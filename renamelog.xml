<?xml version="1.0" encoding="UTF-8"?>
<yguard version="1.5">
<!--
  yGuard Bytecode Obfuscator, v2.7.1, a Product of yWorks GmbH - http://www.yworks.com

  Logfile created on Tue Sep 29 22:23:47 CEST 2020

  Jar file to be obfuscated:           TourMa.jar
  Target Jar file for obfuscated code: TourMa_obf.jar

-->
<!-- WARNING
Methods are called which may break in obfuscated version at runtime.
Please review your source code to ensure that the dangerous methods are not intended
to act on classes which have been obfuscated.
-->
<!--
     Your class com.itextpdf.text.Version calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class com.itextpdf.text.io.ByteBufferRandomAccessSource$1 calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class freemarker.cache.SoftCacheStorage calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class freemarker.cache.TemplateCache calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class freemarker.core.Configurable calls the java.lang.Class method java.lang.reflect.Field getField(java.lang.String)
-->
<!--
     Your class freemarker.core._JavaVersions calls the java.lang.Class method java.lang.reflect.Field getField(java.lang.String)
-->
<!--
     Your class freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression calls the java.lang.Class method java.lang.reflect.Field getField(java.lang.String)
     Your class freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class freemarker.ext.beans.BeansWrapper calls the java.lang.Class method java.lang.reflect.Method getDeclaredMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class freemarker.ext.beans.UnsafeMethods calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class freemarker.ext.jython.JythonVersionAdapterHolder calls the java.lang.Class method java.lang.reflect.Field getField(java.lang.String)
     Your class freemarker.ext.jython.JythonVersionAdapterHolder calls the java.lang.ClassLoader method java.lang.Class loadClass(java.lang.String)
-->
<!--
     Your class freemarker.log.Logger calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class freemarker.template.DefaultObjectWrapper calls the java.lang.Class method java.lang.reflect.Field getField(java.lang.String)
-->
<!--
     Your class freemarker.template.TemplateException calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class javax.xml.parsers.FactoryFinder calls the java.lang.ClassLoader method java.lang.Class loadClass(java.lang.String)
-->
<!--
     Your class javax.xml.transform.FactoryFinder calls the java.lang.ClassLoader method java.lang.Class loadClass(java.lang.String)
-->
<!--
     Your class org.apache.commons.logging.LogFactory calls the java.lang.ClassLoader method java.lang.Class loadClass(java.lang.String)
-->
<!--
     Your class org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$EC calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class org.apache.poi.poifs.crypt.EncryptionInfo calls the java.lang.ClassLoader method java.lang.Class loadClass(java.lang.String)
-->
<!--
     Your class org.apache.poi.poifs.nio.FileBackedDataSource$1 calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class org.apache.poi.ss.usermodel.WorkbookFactory calls the java.lang.ClassLoader method java.lang.Class loadClass(java.lang.String)
     Your class org.apache.poi.ss.usermodel.WorkbookFactory calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class org.apache.xerces.impl.dv.ObjectFactory calls the java.lang.ClassLoader method java.lang.Class loadClass(java.lang.String)
-->
<!--
     Your class org.apache.xerces.parsers.ObjectFactory calls the java.lang.ClassLoader method java.lang.Class loadClass(java.lang.String)
-->
<!--
     Your class org.apache.xerces.xinclude.ObjectFactory calls the java.lang.ClassLoader method java.lang.Class loadClass(java.lang.String)
-->
<!--
     Your class org.apache.xml.security.utils.ClassLoaderUtils calls the java.lang.ClassLoader method java.lang.Class loadClass(java.lang.String)
-->
<!--
     Your class org.bouncycastle.jcajce.provider.symmetric.util.ClassUtil calls the java.lang.ClassLoader method java.lang.Class loadClass(java.lang.String)
-->
<!--
     Your class org.jdom.JDOMException calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
     Your class org.jdom.JDOMException calls the java.lang.Class method java.lang.reflect.Field getField(java.lang.String)
-->
<!--
     Your class org.jdom.input.SAXBuilder calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class org.jdom.output.Format$DefaultEscapeStrategy calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class org.jfree.chart.plot.PiePlot calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class org.jfree.chart.urls.URLUtilities calls the java.lang.Class method java.lang.reflect.Method getDeclaredMethod(java.lang.String, java.lang.Class[])
-->
<!--
     Your class org.jfree.util.ObjectUtilities calls the java.lang.Class method java.lang.reflect.Method getMethod(java.lang.String, java.lang.Class[])
     Your class org.jfree.util.ObjectUtilities calls the java.lang.ClassLoader method java.lang.Class loadClass(java.lang.String)
-->
<!--
     Your class org.xml.sax.helpers.NewInstance calls the java.lang.ClassLoader method java.lang.Class loadClass(java.lang.String)
-->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!--
  Memory in use after class data structure built: 210618104 bytes
  Total memory available                        : 969932800 bytes
-->
<!-- WARNING: Unresolved external dependency: com.itextpdf.text.pdf.OutputStreamEncryption not found! -->
<!-- WARNING: No mapping found: com.itextpdf.text.pdf.OutputStreamEncryption -->
<!-- WARNING: Unresolved external dependency: com.itextpdf.text.pdf.OutputStreamEncryption not found! -->
<!-- WARNING: Unresolved external dependency: com.itextpdf.text.pdf.OutputStreamEncryption not found! -->
<!-- WARNING: Unresolved external dependency: com.itextpdf.text.pdf.PdfPattern not found! -->
<!-- WARNING: Unresolved external dependency: com.itextpdf.text.pdf.OutputStreamEncryption not found! -->
<!-- WARNING: No mapping found: com.itextpdf.text.pdf.OutputStreamEncryption -->
<!-- WARNING: Unresolved external dependency: com.itextpdf.text.pdf.OutputStreamEncryption not found! -->
<!-- WARNING: Unresolved external dependency: com.itextpdf.text.pdf.PdfPattern not found! -->
<!-- WARNING: Unresolved external dependency: com.itextpdf.xmp.XMPException not found! -->
<!-- WARNING: Unresolved external dependency: com.itextpdf.text.pdf.fonts.cmaps.CMapByteCid not found! -->
<!-- WARNING: Unresolved external dependency: com.itextpdf.xmp.XMPException not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: javax.annotation.ParametersAreNonnullByDefault not found! -->
<!-- WARNING: Unresolved external dependency: freemarker.cache.TemplateConfigurationFactoryException not found! -->
<!-- WARNING: Unresolved external dependency: freemarker.cache.TemplateConfigurationFactoryException not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyException not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyException not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.Py not found! -->
<!-- WARNING: No mapping found: org.python.core.Py -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.Py not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyDictionary not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyStringMap not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PySequence not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyInteger not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyLong not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyFloat not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyNone not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyFloat not found! -->
<!-- WARNING: No mapping found: org.python.core.PyFloat -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyException not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.Py not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyFloat not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyException not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PySystemState not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: No mapping found: org.python.core.PyObject -->
<!-- WARNING: No mapping found: org.python.core.PyInteger -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: No mapping found: org.python.core.Py -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyException not found! -->
<!-- WARNING: No mapping found: org.python.core.Py -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyException not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyInteger not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.Py not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: No mapping found: org.python.core.Py -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: No mapping found: org.python.core.PyString -->
<!-- WARNING: No mapping found: org.python.core.PyLong -->
<!-- WARNING: Unresolved external dependency: org.python.core.Py not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyString not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyLong not found! -->
<!-- WARNING: Unresolved external dependency: org.python.core.PyObject not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.poi.ss.usermodel.Sheet not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.poi.ss.usermodel.Sheet not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.poi.ss.usermodel.Sheet not found! -->
<!-- WARNING: No mapping found: org.apache.poi.ss.usermodel.Sheet -->
<!-- WARNING: Unresolved external dependency: org.apache.poi.ss.usermodel.Row not found! -->
<!-- WARNING: No mapping found: org.apache.poi.ss.usermodel.Row -->
<!-- WARNING: Unresolved external dependency: org.apache.poi.ss.usermodel.Cell not found! -->
<!-- WARNING: No mapping found: org.apache.poi.ss.usermodel.Cell -->
<!-- WARNING: Unresolved external dependency: org.apache.poi.ss.usermodel.Sheet not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.poi.ss.usermodel.Row not found! -->
<!-- WARNING: Unresolved external dependency: org.apache.poi.ss.usermodel.Cell not found! -->
<!-- WARNING: No mapping found: org.netbeans.lib.awtextra.AbsoluteLayout -->
<!-- WARNING: No mapping found: org.netbeans.lib.awtextra.AbsoluteConstraints -->
<!-- WARNING: Unresolved external dependency: org.netbeans.lib.awtextra.AbsoluteLayout not found! -->
<!-- WARNING: Unresolved external dependency: org.netbeans.lib.awtextra.AbsoluteConstraints not found! -->
<expose>
  <class name="tourma.MainFrame"/>
  <method class="tourma.MainFrame" name="void main(java.lang.String[])"/>
</expose>
<map>
  <package name="freemarker" map="A"/>
  <package name="freemarker.core" map="A"/>
  <class name="freemarker.core.Items" map="A"/>
  <field class="freemarker.core.Items" name="loopVar2Name" map="&#x00d4;"/>
  <field class="freemarker.core.Items" name="loopVarName" map="&#x00d5;"/>
  <method class="freemarker.core.Items" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.Items" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.Items" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.Items" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.Items" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.Items" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.TemplateNumberFormatFactory" map="B"/>
  <method class="freemarker.core.TemplateNumberFormatFactory" name="freemarker.core.TemplateNumberFormat get(java.lang.String, java.util.Locale, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.ISOLikeTemplateDateFormatFactory" map="C"/>
  <field class="freemarker.core.ISOLikeTemplateDateFormatFactory" name="DATE_TO_CAL_CONVERTER_KEY" map="A"/>
  <field class="freemarker.core.ISOLikeTemplateDateFormatFactory" name="CAL_TO_DATE_CONVERTER_KEY" map="B"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormatFactory" name="freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter getCalendarFieldsToDateCalculator(freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormatFactory" name="freemarker.template.utility.DateUtil$DateToISO8601CalendarFactory getISOBuiltInCalendar(freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core.ArithmeticExpression" map="D"/>
  <field class="freemarker.core.ArithmeticExpression" name="OPERATOR_IMAGES" map="G"/>
  <field class="freemarker.core.ArithmeticExpression" name="operator" map="H"/>
  <field class="freemarker.core.ArithmeticExpression" name="rho" map="I"/>
  <field class="freemarker.core.ArithmeticExpression" name="lho" map="J"/>
  <method class="freemarker.core.ArithmeticExpression" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.ArithmeticExpression" name="char getOperatorSymbol(int)" map="C"/>
  <method class="freemarker.core.ArithmeticExpression" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.ArithmeticExpression" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.ArithmeticExpression" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.ArithmeticExpression" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.ArithmeticExpression" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment, freemarker.core.TemplateObject, java.lang.Number, int, java.lang.Number)" map="A"/>
  <method class="freemarker.core.ArithmeticExpression" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.ArithmeticExpression" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.ArithmeticExpression" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <class name="freemarker.core.BreakInstruction" map="E"/>
  <method class="freemarker.core.BreakInstruction" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.BreakInstruction" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.BreakInstruction" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.BreakInstruction" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.BreakInstruction" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.BreakInstruction" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.ISOLikeTemplateDateFormat" map="F"/>
  <field class="freemarker.core.ISOLikeTemplateDateFormat" name="factory" map="D"/>
  <field class="freemarker.core.ISOLikeTemplateDateFormat" name="timeZone" map="E"/>
  <field class="freemarker.core.ISOLikeTemplateDateFormat" name="dateType" map="F"/>
  <field class="freemarker.core.ISOLikeTemplateDateFormat" name="env" map="G"/>
  <field class="freemarker.core.ISOLikeTemplateDateFormat" name="forceUTC" map="H"/>
  <field class="freemarker.core.ISOLikeTemplateDateFormat" name="accuracy" map="I"/>
  <field class="freemarker.core.ISOLikeTemplateDateFormat" name="zonelessInput" map="J"/>
  <field class="freemarker.core.ISOLikeTemplateDateFormat" name="showZoneOffset" map="K"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormat" name="void checkForceUTCNotSet(java.lang.Boolean)" map="A"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormat" name="java.util.Date parseDateTime(java.lang.String, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="A"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormat" name="java.lang.String getDateTimeDescription()" map="E"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormat" name="boolean isXSMode()" map="F"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormat" name="java.util.Date parseDate(java.lang.String, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="B"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormat" name="java.lang.String getDateDescription()" map="G"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormat" name="java.util.Date parse(java.lang.String, int)" map="C"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormat" name="java.lang.String formatToPlainText(freemarker.template.TemplateDateModel)" map="A"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormat" name="boolean isLocaleBound()" map="C"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormat" name="java.lang.String getDescription()" map="A"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormat" name="boolean isTimeZoneBound()" map="D"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormat" name="java.lang.String getTimeDescription()" map="H"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormat" name="java.lang.Object parse(java.lang.String, int)" map="A"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormat" name="java.lang.String format(java.util.Date, boolean, boolean, boolean, int, java.util.TimeZone, freemarker.template.utility.DateUtil$DateToISO8601CalendarFactory)" map="A"/>
  <method class="freemarker.core.ISOLikeTemplateDateFormat" name="java.util.Date parseTime(java.lang.String, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="C"/>
  <class name="freemarker.core.OrExpression" map="G"/>
  <field class="freemarker.core.OrExpression" name="rho" map="Q"/>
  <field class="freemarker.core.OrExpression" name="lho" map="R"/>
  <method class="freemarker.core.OrExpression" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.OrExpression" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.OrExpression" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.OrExpression" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.OrExpression" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.OrExpression" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <method class="freemarker.core.OrExpression" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.OrExpression" name="boolean evalToBoolean(freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core.StopInstruction" map="H"/>
  <field class="freemarker.core.StopInstruction" name="exp" map="&#x00d6;"/>
  <method class="freemarker.core.StopInstruction" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.StopInstruction" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.StopInstruction" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.StopInstruction" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.StopInstruction" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.StopInstruction" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.XSTemplateDateFormatFactory" map="I"/>
  <field class="freemarker.core.XSTemplateDateFormatFactory" name="INSTANCE" map="C"/>
  <method class="freemarker.core.XSTemplateDateFormatFactory" name="freemarker.core.TemplateDateFormat get(java.lang.String, int, java.util.Locale, java.util.TimeZone, boolean, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.JSONOutputFormat" map="J"/>
  <field class="freemarker.core.JSONOutputFormat" name="INSTANCE" map="L"/>
  <method class="freemarker.core.JSONOutputFormat" name="java.lang.String getMimeType()" map="B"/>
  <method class="freemarker.core.JSONOutputFormat" name="java.lang.String getName()" map="C"/>
  <method class="freemarker.core.JSONOutputFormat" name="boolean isOutputFormatMixingAllowed()" map="D"/>
  <class name="freemarker.core.RegexpHelper$PatternCacheKey" map="_A"/>
  <field class="freemarker.core.RegexpHelper$PatternCacheKey" name="flags" map="A"/>
  <field class="freemarker.core.RegexpHelper$PatternCacheKey" name="hashCode" map="B"/>
  <field class="freemarker.core.RegexpHelper$PatternCacheKey" name="patternString" map="C"/>
  <method class="freemarker.core.RegexpHelper$PatternCacheKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="freemarker.core.RegexpHelper$PatternCacheKey" name="int hashCode()" map="hashCode"/>
  <class name="freemarker.core.RegexpHelper" map="K"/>
  <field class="freemarker.core.RegexpHelper" name="flagWarningsCnt" map="A"/>
  <field class="freemarker.core.RegexpHelper" name="RE_FLAG_COMMENTS" map="B"/>
  <field class="freemarker.core.RegexpHelper" name="RE_FLAG_MULTILINE" map="C"/>
  <field class="freemarker.core.RegexpHelper" name="RE_FLAG_CASE_INSENSITIVE" map="D"/>
  <field class="freemarker.core.RegexpHelper" name="flagWarningsCntSync" map="E"/>
  <field class="freemarker.core.RegexpHelper" name="patternCache" map="F"/>
  <field class="freemarker.core.RegexpHelper" name="flagWarningsEnabled" map="G"/>
  <field class="freemarker.core.RegexpHelper" name="LOG" map="H"/>
  <field class="freemarker.core.RegexpHelper" name="RE_FLAG_DOTALL" map="I"/>
  <method class="freemarker.core.RegexpHelper" name="long intFlagToLong(int)" map="A"/>
  <method class="freemarker.core.RegexpHelper" name="void logFlagWarning(java.lang.String)" map="A"/>
  <method class="freemarker.core.RegexpHelper" name="long parseFlagString(java.lang.String)" map="B"/>
  <method class="freemarker.core.RegexpHelper" name="void checkNonRegexpFlags(java.lang.String, long)" map="A"/>
  <method class="freemarker.core.RegexpHelper" name="void checkOnlyHasNonRegexpFlags(java.lang.String, long, boolean)" map="A"/>
  <method class="freemarker.core.RegexpHelper" name="java.util.regex.Pattern getPattern(java.lang.String, int)" map="A"/>
  <class name="freemarker.core.HTMLOutputFormat" map="L"/>
  <field class="freemarker.core.HTMLOutputFormat" name="INSTANCE" map="E"/>
  <method class="freemarker.core.HTMLOutputFormat" name="freemarker.core.CommonTemplateMarkupOutputModel newTemplateMarkupOutputModel(java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.core.HTMLOutputFormat" name="java.lang.String getMimeType()" map="B"/>
  <method class="freemarker.core.HTMLOutputFormat" name="boolean isLegacyBuiltInBypassed(java.lang.String)" map="B"/>
  <method class="freemarker.core.HTMLOutputFormat" name="void output(java.lang.String, java.io.Writer)" map="A"/>
  <method class="freemarker.core.HTMLOutputFormat" name="java.lang.String getName()" map="C"/>
  <method class="freemarker.core.HTMLOutputFormat" name="java.lang.String escapePlainText(java.lang.String)" map="A"/>
  <method class="freemarker.core.HTMLOutputFormat" name="freemarker.core.TemplateHTMLOutputModel newTemplateMarkupOutputModel(java.lang.String, java.lang.String)" map="B"/>
  <class name="freemarker.core.NonExtendedNodeException" map="M"/>
  <field class="freemarker.core.NonExtendedNodeException" name="EXPECTED_TYPES" map="l"/>
  <class name="freemarker.core.MiscUtil$1" map="1"/>
  <method class="freemarker.core.MiscUtil$1" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="freemarker.core.MiscUtil" map="N"/>
  <method class="freemarker.core.MiscUtil" name="java.util.List sortMapOfExpressions(java.util.Map)" map="A"/>
  <class name="freemarker.core.Interpolation" map="O"/>
  <method class="freemarker.core.Interpolation" name="java.lang.String dump(boolean, boolean)" map="A"/>
  <method class="freemarker.core.Interpolation" name="boolean isShownInStackTrace()" map="d"/>
  <method class="freemarker.core.Interpolation" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.Interpolation" name="java.lang.Object calculateInterpolatedStringOrMarkup(freemarker.core.Environment)" map="L"/>
  <method class="freemarker.core.Interpolation" name="java.lang.String getCanonicalFormInStringLiteral()" map="j"/>
  <class name="freemarker.core._SettingEvaluationEnvironment" map="P"/>
  <field class="freemarker.core._SettingEvaluationEnvironment" name="CURRENT" map="A"/>
  <field class="freemarker.core._SettingEvaluationEnvironment" name="objectWrapper" map="B"/>
  <method class="freemarker.core._SettingEvaluationEnvironment" name="freemarker.core._SettingEvaluationEnvironment getCurrent()" map="A"/>
  <method class="freemarker.core._SettingEvaluationEnvironment" name="freemarker.ext.beans.BeansWrapper getObjectWrapper()" map="B"/>
  <class name="freemarker.core.TemplateCombinedMarkupOutputModel" map="Q"/>
  <field class="freemarker.core.TemplateCombinedMarkupOutputModel" name="outputFormat" map="&#x012b;"/>
  <method class="freemarker.core.TemplateCombinedMarkupOutputModel" name="freemarker.core.MarkupOutputFormat getOutputFormat()" map="x"/>
  <method class="freemarker.core.TemplateCombinedMarkupOutputModel" name="freemarker.core.CombinedMarkupOutputFormat getOutputFormat()" map="&#x00a2;"/>
  <class name="freemarker.core.Dot" map="R"/>
  <field class="freemarker.core.Dot" name="key" map="K"/>
  <field class="freemarker.core.Dot" name="target" map="L"/>
  <method class="freemarker.core.Dot" name="boolean onlyHasIdentifiers()" map="M"/>
  <method class="freemarker.core.Dot" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.Dot" name="java.lang.String getRHO()" map="N"/>
  <method class="freemarker.core.Dot" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.Dot" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.Dot" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.Dot" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.Dot" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.Dot" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.Dot" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <class name="freemarker.core.TemplateRTFOutputModel" map="S"/>
  <method class="freemarker.core.TemplateRTFOutputModel" name="freemarker.core.MarkupOutputFormat getOutputFormat()" map="x"/>
  <method class="freemarker.core.TemplateRTFOutputModel" name="freemarker.core.RTFOutputFormat getOutputFormat()" map="&#x00a3;"/>
  <class name="freemarker.core.ISOTemplateDateFormat" map="T"/>
  <method class="freemarker.core.ISOTemplateDateFormat" name="java.lang.String format(java.util.Date, boolean, boolean, boolean, int, java.util.TimeZone, freemarker.template.utility.DateUtil$DateToISO8601CalendarFactory)" map="A"/>
  <method class="freemarker.core.ISOTemplateDateFormat" name="java.util.Date parseTime(java.lang.String, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="C"/>
  <method class="freemarker.core.ISOTemplateDateFormat" name="java.util.Date parseDate(java.lang.String, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="B"/>
  <method class="freemarker.core.ISOTemplateDateFormat" name="java.lang.String getTimeDescription()" map="H"/>
  <method class="freemarker.core.ISOTemplateDateFormat" name="boolean isXSMode()" map="F"/>
  <method class="freemarker.core.ISOTemplateDateFormat" name="java.lang.String getDateDescription()" map="G"/>
  <method class="freemarker.core.ISOTemplateDateFormat" name="java.util.Date parseDateTime(java.lang.String, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="A"/>
  <method class="freemarker.core.ISOTemplateDateFormat" name="java.lang.String getDateTimeDescription()" map="E"/>
  <class name="freemarker.core.BuiltInForHashEx" map="U"/>
  <method class="freemarker.core.BuiltInForHashEx" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateHashModelEx, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.BuiltInForHashEx" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.BuiltInForHashEx" name="freemarker.core.InvalidReferenceException newNullPropertyException(java.lang.String, freemarker.template.TemplateModel, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core._DelayedAOrAn" map="V"/>
  <method class="freemarker.core._DelayedAOrAn" name="java.lang.String doConversion(java.lang.Object)" map="A"/>
  <class name="freemarker.core.RecoveryBlock" map="W"/>
  <method class="freemarker.core.RecoveryBlock" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.RecoveryBlock" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.RecoveryBlock" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.RecoveryBlock" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.RecoveryBlock" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.RecoveryBlock" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.BuiltinVariable$VarsHash" map="_A"/>
  <field class="freemarker.core.BuiltinVariable$VarsHash" name="env" map="&#x017a;"/>
  <method class="freemarker.core.BuiltinVariable$VarsHash" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.core.BuiltinVariable$VarsHash" name="boolean isEmpty()" map="&#x00c7;"/>
  <class name="freemarker.core.BuiltinVariable" map="X"/>
  <field class="freemarker.core.BuiltinVariable" name="name" map="M"/>
  <field class="freemarker.core.BuiltinVariable" name="SPEC_VAR_NAMES" map="N"/>
  <field class="freemarker.core.BuiltinVariable" name="parseTimeValue" map="O"/>
  <method class="freemarker.core.BuiltinVariable" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.BuiltinVariable" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.BuiltinVariable" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.BuiltinVariable" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.BuiltinVariable" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.BuiltinVariable" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.BuiltinVariable" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.BuiltinVariable" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.core.BuiltinVariable" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <class name="freemarker.core.BreakOrContinueException" map="Y"/>
  <field class="freemarker.core.BreakOrContinueException" name="BREAK_INSTANCE" map="B"/>
  <field class="freemarker.core.BreakOrContinueException" name="CONTINUE_INSTANCE" map="C"/>
  <class name="freemarker.core._DelayedConversionToString" map="Z"/>
  <field class="freemarker.core._DelayedConversionToString" name="stringValue" map="A"/>
  <field class="freemarker.core._DelayedConversionToString" name="object" map="B"/>
  <field class="freemarker.core._DelayedConversionToString" name="NOT_SET" map="C"/>
  <method class="freemarker.core._DelayedConversionToString" name="java.lang.String doConversion(java.lang.Object)" map="A"/>
  <method class="freemarker.core._DelayedConversionToString" name="java.lang.String toString()" map="toString"/>
  <class name="freemarker.core.UnexpectedTypeException" map="_"/>
  <method class="freemarker.core.UnexpectedTypeException" name="java.lang.Object[] unexpectedTypeErrorDescription(java.lang.String, freemarker.core.Expression, java.lang.String, freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.core.UnexpectedTypeException" name="freemarker.core._ErrorDescriptionBuilder newDesciptionBuilder(freemarker.core.Expression, java.lang.String, freemarker.template.TemplateModel, java.lang.String, java.lang.Class[], freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core._CoreStringUtils" map="a"/>
  <method class="freemarker.core._CoreStringUtils" name="boolean isUpperUSASCII(char)" map="A"/>
  <method class="freemarker.core._CoreStringUtils" name="java.lang.String toFTLTopLevelTragetIdentifier(java.lang.String)" map="A"/>
  <method class="freemarker.core._CoreStringUtils" name="java.lang.String backslashEscapeIdentifier(java.lang.String)" map="B"/>
  <method class="freemarker.core._CoreStringUtils" name="java.lang.String toFTLTopLevelIdentifierReference(java.lang.String)" map="C"/>
  <method class="freemarker.core._CoreStringUtils" name="java.lang.String toFTLIdentifierReferenceAfterDot(java.lang.String)" map="D"/>
  <method class="freemarker.core._CoreStringUtils" name="int getIdentifierNamingConvention(java.lang.String)" map="E"/>
  <class name="freemarker.core.FlowControlException" map="b"/>
  <class name="freemarker.core.XHTMLOutputFormat" map="c"/>
  <field class="freemarker.core.XHTMLOutputFormat" name="INSTANCE" map="F"/>
  <method class="freemarker.core.XHTMLOutputFormat" name="freemarker.core.CommonTemplateMarkupOutputModel newTemplateMarkupOutputModel(java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.core.XHTMLOutputFormat" name="java.lang.String getMimeType()" map="B"/>
  <method class="freemarker.core.XHTMLOutputFormat" name="boolean isLegacyBuiltInBypassed(java.lang.String)" map="B"/>
  <method class="freemarker.core.XHTMLOutputFormat" name="void output(java.lang.String, java.io.Writer)" map="A"/>
  <method class="freemarker.core.XHTMLOutputFormat" name="java.lang.String getName()" map="C"/>
  <method class="freemarker.core.XHTMLOutputFormat" name="java.lang.String escapePlainText(java.lang.String)" map="A"/>
  <method class="freemarker.core.XHTMLOutputFormat" name="freemarker.core.TemplateXHTMLOutputModel newTemplateMarkupOutputModel(java.lang.String, java.lang.String)" map="C"/>
  <class name="freemarker.core.MixedContent" map="d"/>
  <method class="freemarker.core.MixedContent" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.MixedContent" name="boolean isIgnorable(boolean)" map="D"/>
  <method class="freemarker.core.MixedContent" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.MixedContent" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.MixedContent" name="freemarker.core.TemplateElement postParseCleanup(boolean)" map="B"/>
  <method class="freemarker.core.MixedContent" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.MixedContent" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.MixedContent" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.Identifier" map="e"/>
  <field class="freemarker.core.Identifier" name="name" map="P"/>
  <method class="freemarker.core.Identifier" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.Identifier" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.Identifier" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.Identifier" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.Identifier" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.Identifier" name="java.lang.String getName()" map="O"/>
  <method class="freemarker.core.Identifier" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.Identifier" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.Identifier" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <class name="freemarker.core.UnregisteredOutputFormatException" map="f"/>
  <class name="freemarker.core.StopException" map="g"/>
  <method class="freemarker.core.StopException" name="void printStackTrace(java.io.PrintWriter)" map="printStackTrace"/>
  <method class="freemarker.core.StopException" name="void printStackTrace(java.io.PrintStream)" map="printStackTrace"/>
  <class name="freemarker.core.NonBooleanException" map="h"/>
  <field class="freemarker.core.NonBooleanException" name="EXPECTED_TYPES" map="Y"/>
  <class name="freemarker.core.BoundedRangeModel" map="i"/>
  <field class="freemarker.core.BoundedRangeModel" name="size" map="&#x0265;"/>
  <field class="freemarker.core.BoundedRangeModel" name="step" map="&#x0266;"/>
  <field class="freemarker.core.BoundedRangeModel" name="affectedByStringSlicingBug" map="&#x0267;"/>
  <field class="freemarker.core.BoundedRangeModel" name="rightAdaptive" map="&#x0268;"/>
  <method class="freemarker.core.BoundedRangeModel" name="int getStep()" map="&#x00fa;"/>
  <method class="freemarker.core.BoundedRangeModel" name="boolean isRightUnbounded()" map="&#x00fc;"/>
  <method class="freemarker.core.BoundedRangeModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.core.BoundedRangeModel" name="boolean isRightAdaptive()" map="&#x00fd;"/>
  <method class="freemarker.core.BoundedRangeModel" name="boolean isAffactedByStringSlicingBug()" map="&#x00fe;"/>
  <class name="freemarker.core.BuiltInsForNumbers$longBI" map="_A"/>
  <method class="freemarker.core.BuiltInsForNumbers$longBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForNumbers$byteBI" map="_B"/>
  <method class="freemarker.core.BuiltInsForNumbers$byteBI" name="freemarker.template.TemplateModel calculateResult(java.lang.Number, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForNumbers$ceilingBI" map="_C"/>
  <method class="freemarker.core.BuiltInsForNumbers$ceilingBI" name="freemarker.template.TemplateModel calculateResult(java.lang.Number, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForNumbers$intBI" map="_D"/>
  <method class="freemarker.core.BuiltInsForNumbers$intBI" name="freemarker.template.TemplateModel calculateResult(java.lang.Number, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForNumbers$doubleBI" map="_E"/>
  <method class="freemarker.core.BuiltInsForNumbers$doubleBI" name="freemarker.template.TemplateModel calculateResult(java.lang.Number, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForNumbers$abcBI" map="_F"/>
  <method class="freemarker.core.BuiltInsForNumbers$abcBI" name="freemarker.template.TemplateModel calculateResult(java.lang.Number, freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.core.BuiltInsForNumbers$abcBI" name="java.lang.String toABC(int)" map="D"/>
  <class name="freemarker.core.BuiltInsForNumbers$floorBI" map="_G"/>
  <method class="freemarker.core.BuiltInsForNumbers$floorBI" name="freemarker.template.TemplateModel calculateResult(java.lang.Number, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForNumbers$floatBI" map="_H"/>
  <method class="freemarker.core.BuiltInsForNumbers$floatBI" name="freemarker.template.TemplateModel calculateResult(java.lang.Number, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForNumbers$number_to_dateBI" map="_I"/>
  <field class="freemarker.core.BuiltInsForNumbers$number_to_dateBI" name="dateType" map="h"/>
  <method class="freemarker.core.BuiltInsForNumbers$number_to_dateBI" name="freemarker.template.TemplateModel calculateResult(java.lang.Number, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForNumbers$roundBI" map="_J"/>
  <field class="freemarker.core.BuiltInsForNumbers$roundBI" name="half" map="i"/>
  <method class="freemarker.core.BuiltInsForNumbers$roundBI" name="freemarker.template.TemplateModel calculateResult(java.lang.Number, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForNumbers$is_nanBI" map="_K"/>
  <method class="freemarker.core.BuiltInsForNumbers$is_nanBI" name="freemarker.template.TemplateModel calculateResult(java.lang.Number, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForNumbers$1" map="1"/>
  <class name="freemarker.core.BuiltInsForNumbers$absBI" map="_L"/>
  <method class="freemarker.core.BuiltInsForNumbers$absBI" name="freemarker.template.TemplateModel calculateResult(java.lang.Number, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForNumbers$shortBI" map="_M"/>
  <method class="freemarker.core.BuiltInsForNumbers$shortBI" name="freemarker.template.TemplateModel calculateResult(java.lang.Number, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForNumbers$is_infiniteBI" map="_N"/>
  <method class="freemarker.core.BuiltInsForNumbers$is_infiniteBI" name="freemarker.template.TemplateModel calculateResult(java.lang.Number, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForNumbers$upper_abcBI" map="_O"/>
  <method class="freemarker.core.BuiltInsForNumbers$upper_abcBI" name="java.lang.String toABC(int)" map="D"/>
  <class name="freemarker.core.BuiltInsForNumbers$lower_abcBI" map="_P"/>
  <method class="freemarker.core.BuiltInsForNumbers$lower_abcBI" name="java.lang.String toABC(int)" map="D"/>
  <class name="freemarker.core.BuiltInsForNumbers" map="j"/>
  <field class="freemarker.core.BuiltInsForNumbers" name="BIG_INTEGER_LONG_MAX" map="A"/>
  <field class="freemarker.core.BuiltInsForNumbers" name="BIG_DECIMAL_LONG_MAX" map="B"/>
  <field class="freemarker.core.BuiltInsForNumbers" name="BIG_INTEGER_LONG_MIN" map="C"/>
  <field class="freemarker.core.BuiltInsForNumbers" name="BIG_DECIMAL_LONG_MIN" map="D"/>
  <field class="freemarker.core.BuiltInsForNumbers" name="BIG_DECIMAL_ONE" map="E"/>
  <method class="freemarker.core.BuiltInsForNumbers" name="java.math.BigDecimal access$100()" map="A"/>
  <method class="freemarker.core.BuiltInsForNumbers" name="long safeToLong(java.lang.Number)" map="A"/>
  <method class="freemarker.core.BuiltInsForNumbers" name="long access$200(java.lang.Number)" map="B"/>
  <class name="freemarker.core.BooleanExpression" map="k"/>
  <method class="freemarker.core.BooleanExpression" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core._MessageUtil" map="l"/>
  <field class="freemarker.core._MessageUtil" name="UNKNOWN_DATE_TO_STRING_TIPS" map="A"/>
  <method class="freemarker.core._MessageUtil" name="freemarker.template.TemplateException newInstantiatingClassNotAllowedException(java.lang.String, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="freemarker.template.TemplateModelException newMethodArgMustBeStringException(java.lang.String, int, freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="freemarker.template.TemplateException newCantFormatNumberException(freemarker.core.TemplateNumberFormat, freemarker.core.Expression, freemarker.core.TemplateValueFormatException, boolean)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="java.lang.String formatPosition(int, int)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="java.lang.String formatLocationForEvaluationError(freemarker.core.Macro, int, int)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="freemarker.template.TemplateModelException newArgCntError(java.lang.String, int, int, int)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="java.lang.String formatLocation(java.lang.String, java.lang.String, java.lang.String, boolean, int, int)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="java.lang.String formatLocation(java.lang.String, java.lang.String, int, int)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="java.lang.String formatLocationForEvaluationError(freemarker.template.Template, int, int)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="freemarker.template.TemplateException newCantFormatDateException(freemarker.core.TemplateDateFormat, freemarker.core.Expression, freemarker.core.TemplateValueFormatException, boolean)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="freemarker.core._TemplateModelException newCantFormatUnknownTypeDateException(freemarker.core.Expression, freemarker.core.UnknownDateTypeFormattingUnsupportedException)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="freemarker.template.TemplateModelException newMethodArgMustBeExtendedHashException(java.lang.String, int, freemarker.template.TemplateModel)" map="B"/>
  <method class="freemarker.core._MessageUtil" name="java.lang.String formatLocationForSimpleParsingError(java.lang.String, int, int)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="freemarker.template.TemplateModelException newMethodArgsInvalidValueException(java.lang.String, java.lang.Object[])" map="A"/>
  <method class="freemarker.core._MessageUtil" name="freemarker.template.TemplateModelException newMethodArgUnexpectedTypeException(java.lang.String, int, java.lang.String, freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="java.lang.String getAOrAn(java.lang.String)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="freemarker.template.TemplateModelException newMethodArgInvalidValueException(java.lang.String, int, java.lang.Object[])" map="A"/>
  <method class="freemarker.core._MessageUtil" name="java.lang.String shorten(java.lang.String, int)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="freemarker.template.TemplateModelException newMethodArgMustBeNumberException(java.lang.String, int, freemarker.template.TemplateModel)" map="C"/>
  <method class="freemarker.core._MessageUtil" name="freemarker.template.TemplateModelException newArgCntError(java.lang.String, int, int)" map="B"/>
  <method class="freemarker.core._MessageUtil" name="java.lang.StringBuilder appendExpressionAsUntearable(java.lang.StringBuilder, freemarker.core.Expression)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="freemarker.template.TemplateModelException newKeyValuePairListingNonStringKeyExceptionMessage(freemarker.template.TemplateModel, freemarker.template.TemplateHashModelEx)" map="A"/>
  <method class="freemarker.core._MessageUtil" name="java.lang.String formatLocation(java.lang.String, freemarker.template.Template, int, int)" map="A"/>
  <class name="freemarker.core.UndefinedOutputFormat" map="m"/>
  <field class="freemarker.core.UndefinedOutputFormat" name="INSTANCE" map="A"/>
  <method class="freemarker.core.UndefinedOutputFormat" name="java.lang.String getMimeType()" map="B"/>
  <method class="freemarker.core.UndefinedOutputFormat" name="java.lang.String getName()" map="C"/>
  <method class="freemarker.core.UndefinedOutputFormat" name="boolean isOutputFormatMixingAllowed()" map="D"/>
  <class name="freemarker.core.NonExtendedHashException" map="n"/>
  <field class="freemarker.core.NonExtendedHashException" name="EXPECTED_TYPES" map="Z"/>
  <class name="freemarker.core.DefaultToExpression$EmptyStringAndSequenceAndHash" map="_A"/>
  <method class="freemarker.core.DefaultToExpression$EmptyStringAndSequenceAndHash" name="freemarker.template.TemplateCollectionModel keys()" map="&#x00c8;"/>
  <method class="freemarker.core.DefaultToExpression$EmptyStringAndSequenceAndHash" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.core.DefaultToExpression$EmptyStringAndSequenceAndHash" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.core.DefaultToExpression$EmptyStringAndSequenceAndHash" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.core.DefaultToExpression$EmptyStringAndSequenceAndHash" name="freemarker.template.TemplateHashModelEx2$KeyValuePairIterator keyValuePairIterator()" map="&#x00cb;"/>
  <method class="freemarker.core.DefaultToExpression$EmptyStringAndSequenceAndHash" name="freemarker.template.TemplateCollectionModel values()" map="&#x00c9;"/>
  <method class="freemarker.core.DefaultToExpression$EmptyStringAndSequenceAndHash" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <method class="freemarker.core.DefaultToExpression$EmptyStringAndSequenceAndHash" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <class name="freemarker.core.DefaultToExpression$1" map="1"/>
  <class name="freemarker.core.DefaultToExpression" map="o"/>
  <field class="freemarker.core.DefaultToExpression" name="EMPTY_STRING_AND_SEQUENCE_AND_HASH" map="Z"/>
  <field class="freemarker.core.DefaultToExpression" name="rho" map="_"/>
  <field class="freemarker.core.DefaultToExpression" name="lho" map="a"/>
  <field class="freemarker.core.DefaultToExpression" name="EMPTY_COLLECTION" map="b"/>
  <method class="freemarker.core.DefaultToExpression" name="freemarker.template.TemplateCollectionModel access$000()" map="P"/>
  <method class="freemarker.core.DefaultToExpression" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.DefaultToExpression" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.DefaultToExpression" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.DefaultToExpression" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.DefaultToExpression" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.DefaultToExpression" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.DefaultToExpression" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.DefaultToExpression" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <class name="freemarker.core.TemplateValueFormatException" map="p"/>
  <class name="freemarker.core.EvalUtil" map="q"/>
  <method class="freemarker.core.EvalUtil" name="boolean compare(freemarker.template.TemplateModel, freemarker.core.Expression, int, java.lang.String, freemarker.template.TemplateModel, freemarker.core.Expression, freemarker.core.Expression, boolean, boolean, boolean, boolean, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.EvalUtil" name="java.lang.Number modelToNumber(freemarker.template.TemplateNumberModel, freemarker.core.Expression)" map="A"/>
  <method class="freemarker.core.EvalUtil" name="java.lang.String cmpOpToString(int, java.lang.String)" map="A"/>
  <method class="freemarker.core.EvalUtil" name="java.lang.Object assertFormatResultNotNull(java.lang.Object)" map="A"/>
  <method class="freemarker.core.EvalUtil" name="freemarker.core.TemplateMarkupOutputModel concatMarkupOutputs(freemarker.core.TemplateObject, freemarker.core.TemplateMarkupOutputModel, freemarker.core.TemplateMarkupOutputModel)" map="A"/>
  <method class="freemarker.core.EvalUtil" name="java.util.Date modelToDate(freemarker.template.TemplateDateModel, freemarker.core.Expression)" map="A"/>
  <method class="freemarker.core.EvalUtil" name="java.lang.String coerceModelToTextualCommon(freemarker.template.TemplateModel, freemarker.core.Expression, java.lang.String, boolean, boolean, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.EvalUtil" name="freemarker.core.ArithmeticEngine getArithmeticEngine(freemarker.core.Environment, freemarker.core.TemplateObject)" map="A"/>
  <method class="freemarker.core.EvalUtil" name="java.lang.Object coerceModelToStringOrMarkup(freemarker.template.TemplateModel, freemarker.core.Expression, java.lang.String, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.EvalUtil" name="java.lang.String coerceModelToStringOrUnsupportedMarkup(freemarker.template.TemplateModel, freemarker.core.Expression, java.lang.String, freemarker.core.Environment)" map="B"/>
  <method class="freemarker.core.EvalUtil" name="boolean compare(freemarker.core.Expression, int, java.lang.String, freemarker.core.Expression, freemarker.core.Expression, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.EvalUtil" name="java.lang.String ensureFormatResultString(java.lang.Object, freemarker.core.Expression, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.EvalUtil" name="boolean shouldWrapUncheckedException(java.lang.Throwable, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.EvalUtil" name="freemarker.template.TemplateModelException newModelHasStoredNullException(java.lang.Class, freemarker.template.TemplateModel, freemarker.core.Expression)" map="A"/>
  <method class="freemarker.core.EvalUtil" name="java.lang.Object coerceModelToStringOrMarkup(freemarker.template.TemplateModel, freemarker.core.Expression, boolean, java.lang.String, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.EvalUtil" name="java.lang.String coerceModelToPlainText(freemarker.template.TemplateModel, freemarker.core.Expression, java.lang.String, freemarker.core.Environment)" map="C"/>
  <method class="freemarker.core.EvalUtil" name="java.lang.String assertFormatResultNotNull(java.lang.String)" map="A"/>
  <method class="freemarker.core.EvalUtil" name="java.lang.String modelToString(freemarker.template.TemplateScalarModel, freemarker.core.Expression, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInForNumber" map="r"/>
  <method class="freemarker.core.BuiltInForNumber" name="freemarker.template.TemplateModel calculateResult(java.lang.Number, freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.core.BuiltInForNumber" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.GetOptionalTemplateMethod$2" map="2"/>
  <field class="freemarker.core.GetOptionalTemplateMethod$2" name="this$0" map="&#x0135;"/>
  <field class="freemarker.core.GetOptionalTemplateMethod$2" name="val$env" map="&#x0136;"/>
  <field class="freemarker.core.GetOptionalTemplateMethod$2" name="val$template" map="&#x0137;"/>
  <method class="freemarker.core.GetOptionalTemplateMethod$2" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.GetOptionalTemplateMethod$1" map="1"/>
  <field class="freemarker.core.GetOptionalTemplateMethod$1" name="this$0" map="&#x027f;"/>
  <field class="freemarker.core.GetOptionalTemplateMethod$1" name="val$template" map="&#x0280;"/>
  <method class="freemarker.core.GetOptionalTemplateMethod$1" name="void execute(freemarker.core.Environment, java.util.Map, freemarker.template.TemplateModel[], freemarker.template.TemplateDirectiveBody)" map="A"/>
  <class name="freemarker.core.GetOptionalTemplateMethod" map="s"/>
  <field class="freemarker.core.GetOptionalTemplateMethod" name="methodName" map="&#x0138;"/>
  <field class="freemarker.core.GetOptionalTemplateMethod" name="INSTANCE" map="&#x0139;"/>
  <field class="freemarker.core.GetOptionalTemplateMethod" name="INSTANCE_CC" map="&#x013a;"/>
  <method class="freemarker.core.GetOptionalTemplateMethod" name="java.lang.String getStringOption(java.lang.String, freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.core.GetOptionalTemplateMethod" name="boolean getBooleanOption(java.lang.String, freemarker.template.TemplateModel)" map="B"/>
  <method class="freemarker.core.GetOptionalTemplateMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.JavaTemplateNumberFormat" map="t"/>
  <field class="freemarker.core.JavaTemplateNumberFormat" name="formatString" map="A"/>
  <field class="freemarker.core.JavaTemplateNumberFormat" name="javaNumberFormat" map="B"/>
  <method class="freemarker.core.JavaTemplateNumberFormat" name="boolean isLocaleBound()" map="B"/>
  <method class="freemarker.core.JavaTemplateNumberFormat" name="java.lang.String getDescription()" map="A"/>
  <method class="freemarker.core.JavaTemplateNumberFormat" name="java.lang.String format(java.lang.Number)" map="A"/>
  <method class="freemarker.core.JavaTemplateNumberFormat" name="java.lang.String formatToPlainText(freemarker.template.TemplateNumberModel)" map="B"/>
  <class name="freemarker.core.NonNamespaceException" map="u"/>
  <field class="freemarker.core.NonNamespaceException" name="EXPECTED_TYPES" map="_"/>
  <class name="freemarker.core.NonNumericalException" map="v"/>
  <field class="freemarker.core.NonNumericalException" name="EXPECTED_TYPES" map="a"/>
  <method class="freemarker.core.NonNumericalException" name="freemarker.core.NonNumericalException newMalformedNumberException(freemarker.core.Expression, java.lang.String, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.InvalidFormatStringException" map="w"/>
  <class name="freemarker.core.AutoEscBlock" map="x"/>
  <method class="freemarker.core.AutoEscBlock" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.AutoEscBlock" name="boolean isIgnorable(boolean)" map="D"/>
  <method class="freemarker.core.AutoEscBlock" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.AutoEscBlock" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.AutoEscBlock" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.AutoEscBlock" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.AutoEscBlock" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.JavaTemplateDateFormatFactory$CacheKey" map="_A"/>
  <field class="freemarker.core.JavaTemplateDateFormatFactory$CacheKey" name="locale" map="A"/>
  <field class="freemarker.core.JavaTemplateDateFormatFactory$CacheKey" name="timeZone" map="B"/>
  <field class="freemarker.core.JavaTemplateDateFormatFactory$CacheKey" name="dateType" map="C"/>
  <field class="freemarker.core.JavaTemplateDateFormatFactory$CacheKey" name="pattern" map="D"/>
  <method class="freemarker.core.JavaTemplateDateFormatFactory$CacheKey" name="java.util.TimeZone access$100(freemarker.core.JavaTemplateDateFormatFactory$CacheKey)" map="A"/>
  <method class="freemarker.core.JavaTemplateDateFormatFactory$CacheKey" name="java.util.Locale access$000(freemarker.core.JavaTemplateDateFormatFactory$CacheKey)" map="B"/>
  <method class="freemarker.core.JavaTemplateDateFormatFactory$CacheKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="freemarker.core.JavaTemplateDateFormatFactory$CacheKey" name="int hashCode()" map="hashCode"/>
  <class name="freemarker.core.JavaTemplateDateFormatFactory" map="y"/>
  <field class="freemarker.core.JavaTemplateDateFormatFactory" name="LOG" map="E"/>
  <field class="freemarker.core.JavaTemplateDateFormatFactory" name="GLOBAL_FORMAT_CACHE" map="F"/>
  <field class="freemarker.core.JavaTemplateDateFormatFactory" name="INSTANCE" map="G"/>
  <method class="freemarker.core.JavaTemplateDateFormatFactory" name="freemarker.core.TemplateDateFormat get(java.lang.String, int, java.util.Locale, java.util.TimeZone, boolean, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.JavaTemplateDateFormatFactory" name="int parseDateStyleToken(java.lang.String)" map="A"/>
  <method class="freemarker.core.JavaTemplateDateFormatFactory" name="java.text.DateFormat getJavaDateFormat(int, java.lang.String, java.util.Locale, java.util.TimeZone)" map="A"/>
  <class name="freemarker.core.TemplateElement" map="z"/>
  <field class="freemarker.core.TemplateElement" name="childBuffer" map="&#x00d0;"/>
  <field class="freemarker.core.TemplateElement" name="childCount" map="&#x00d1;"/>
  <field class="freemarker.core.TemplateElement" name="index" map="&#x00d2;"/>
  <field class="freemarker.core.TemplateElement" name="parent" map="&#x00d3;"/>
  <method class="freemarker.core.TemplateElement" name="java.lang.String getChildrenCanonicalForm(freemarker.core.TemplateElement[])" map="A"/>
  <method class="freemarker.core.TemplateElement" name="void setChildAt(int, freemarker.core.TemplateElement)" map="A"/>
  <method class="freemarker.core.TemplateElement" name="freemarker.core.TemplateElement postParseCleanup(boolean)" map="B"/>
  <method class="freemarker.core.TemplateElement" name="freemarker.core.TemplateElement previousSibling()" map="U"/>
  <method class="freemarker.core.TemplateElement" name="int getChildCount()" map="getChildCount"/>
  <method class="freemarker.core.TemplateElement" name="freemarker.core.TemplateElement nextSibling()" map="V"/>
  <method class="freemarker.core.TemplateElement" name="void addChild(freemarker.core.TemplateElement)" map="A"/>
  <method class="freemarker.core.TemplateElement" name="void addChild(int, freemarker.core.TemplateElement)" map="B"/>
  <method class="freemarker.core.TemplateElement" name="freemarker.core.TemplateElement getFirstLeaf()" map="W"/>
  <method class="freemarker.core.TemplateElement" name="freemarker.core.TemplateElement getFirstChild()" map="X"/>
  <method class="freemarker.core.TemplateElement" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.TemplateElement" name="freemarker.core.TemplateElement getParentElement()" map="Y"/>
  <method class="freemarker.core.TemplateElement" name="freemarker.core.TemplateElement[] getChildBuffer()" map="Z"/>
  <method class="freemarker.core.TemplateElement" name="void setChildBufferCapacity(int)" map="I"/>
  <method class="freemarker.core.TemplateElement" name="freemarker.core.TemplateElement getLastLeaf()" map="_"/>
  <method class="freemarker.core.TemplateElement" name="javax.swing.tree.TreeNode getChildAt(int)" map="getChildAt"/>
  <method class="freemarker.core.TemplateElement" name="int getIndex(javax.swing.tree.TreeNode)" map="getIndex"/>
  <method class="freemarker.core.TemplateElement" name="void setFieldsForRootElement()" map="a"/>
  <method class="freemarker.core.TemplateElement" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.TemplateElement" name="boolean isLeaf()" map="isLeaf"/>
  <method class="freemarker.core.TemplateElement" name="freemarker.core.TemplateElement getLastChild()" map="b"/>
  <method class="freemarker.core.TemplateElement" name="freemarker.core.TemplateElement prevTerminalNode()" map="c"/>
  <method class="freemarker.core.TemplateElement" name="boolean isShownInStackTrace()" map="d"/>
  <method class="freemarker.core.TemplateElement" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.TemplateElement" name="javax.swing.tree.TreeNode getParent()" map="getParent"/>
  <method class="freemarker.core.TemplateElement" name="void setChildren(freemarker.core.TemplateElements)" map="A"/>
  <method class="freemarker.core.TemplateElement" name="boolean isIgnorable(boolean)" map="D"/>
  <method class="freemarker.core.TemplateElement" name="freemarker.core.TemplateElement getChild(int)" map="J"/>
  <method class="freemarker.core.TemplateElement" name="boolean getAllowsChildren()" map="getAllowsChildren"/>
  <method class="freemarker.core.TemplateElement" name="java.lang.String getChildrenCanonicalForm()" map="e"/>
  <method class="freemarker.core.TemplateElement" name="java.lang.String getDescription()" map="f"/>
  <method class="freemarker.core.TemplateElement" name="boolean heedsTrailingWhitespace()" map="g"/>
  <method class="freemarker.core.TemplateElement" name="boolean heedsOpeningWhitespace()" map="h"/>
  <method class="freemarker.core.TemplateElement" name="freemarker.core.TemplateElement nextTerminalNode()" map="i"/>
  <method class="freemarker.core.TemplateElement" name="java.util.Enumeration children()" map="children"/>
  <class name="freemarker.core.BuiltIn" map="$A"/>
  <field class="freemarker.core.BuiltIn" name="BUILT_INS_BY_NAME" map="c"/>
  <field class="freemarker.core.BuiltIn" name="SNAKE_CASE_NAMES" map="d"/>
  <field class="freemarker.core.BuiltIn" name="key" map="e"/>
  <field class="freemarker.core.BuiltIn" name="target" map="f"/>
  <field class="freemarker.core.BuiltIn" name="CAMEL_CASE_NAMES" map="g"/>
  <method class="freemarker.core.BuiltIn" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.BuiltIn" name="void putBI(java.lang.String, freemarker.core.BuiltIn)" map="A"/>
  <method class="freemarker.core.BuiltIn" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.BuiltIn" name="void checkMethodArgCount(java.util.List, int)" map="A"/>
  <method class="freemarker.core.BuiltIn" name="void checkMethodArgCount(int, int)" map="A"/>
  <method class="freemarker.core.BuiltIn" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.BuiltIn" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.BuiltIn" name="java.lang.String getOptStringMethodArg(java.util.List, int)" map="B"/>
  <method class="freemarker.core.BuiltIn" name="freemarker.core.BuiltIn newBuiltIn(int, freemarker.core.Expression, freemarker.core.Token, freemarker.core.FMParserTokenManager)" map="A"/>
  <method class="freemarker.core.BuiltIn" name="java.lang.Number getNumberMethodArg(java.util.List, int)" map="C"/>
  <method class="freemarker.core.BuiltIn" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.BuiltIn" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.BuiltIn" name="java.lang.String getStringMethodArg(java.util.List, int)" map="D"/>
  <method class="freemarker.core.BuiltIn" name="void checkMethodArgCount(java.util.List, int, int)" map="A"/>
  <method class="freemarker.core.BuiltIn" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <method class="freemarker.core.BuiltIn" name="void checkMethodArgCount(int, int, int)" map="A"/>
  <method class="freemarker.core.BuiltIn" name="void putBI(java.lang.String, java.lang.String, freemarker.core.BuiltIn)" map="A"/>
  <class name="freemarker.core.LegacyConstructorParserConfiguration" map="AA"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="freemarker.core.OutputFormat getOutputFormat()" map="B"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="freemarker.core.ArithmeticEngine getArithmeticEngine()" map="A"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="void setRecognizeStandardFileExtensionsIfNotSet(boolean)" map="M"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="int getInterpolationSyntax()" map="C"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="freemarker.template.Version getIncompatibleImprovements()" map="D"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="int getTagSyntax()" map="E"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="void setTabSizeIfNotSet(int)" map="B"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="int getNamingConvention()" map="F"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="boolean getWhitespaceStripping()" map="G"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="void setAutoEscapingPolicyIfNotSet(int)" map="C"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="boolean getStrictSyntaxMode()" map="H"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="void setOutputFormatIfNotSet(freemarker.core.OutputFormat)" map="B"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="void setArithmeticEngineIfNotSet(freemarker.core.ArithmeticEngine)" map="B"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="boolean getRecognizeStandardFileExtensions()" map="I"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="int getAutoEscapingPolicy()" map="J"/>
  <method class="freemarker.core.LegacyConstructorParserConfiguration" name="int getTabSize()" map="K"/>
  <class name="freemarker.core.NonStringOrTemplateOutputException" map="BA"/>
  <field class="freemarker.core.NonStringOrTemplateOutputException" name="STRING_COERCABLE_TYPES_AND_TOM" map="b"/>
  <class name="freemarker.core.UnformattableValueException" map="CA"/>
  <class name="freemarker.core.FallbackInstruction" map="DA"/>
  <method class="freemarker.core.FallbackInstruction" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.FallbackInstruction" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.FallbackInstruction" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.FallbackInstruction" name="boolean isShownInStackTrace()" map="d"/>
  <method class="freemarker.core.FallbackInstruction" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.FallbackInstruction" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.FallbackInstruction" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.SpecialBuiltIn" map="EA"/>
  <class name="freemarker.core._DelayedFTLTypeDescription" map="FA"/>
  <method class="freemarker.core._DelayedFTLTypeDescription" name="java.lang.String doConversion(java.lang.Object)" map="A"/>
  <class name="freemarker.core.BuiltInsForNodes$parentBI" map="_A"/>
  <method class="freemarker.core.BuiltInsForNodes$parentBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateNodeModel, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForNodes$nextSiblingBI" map="_B"/>
  <method class="freemarker.core.BuiltInsForNodes$nextSiblingBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateNodeModelEx, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForNodes$node_typeBI" map="_C"/>
  <method class="freemarker.core.BuiltInsForNodes$node_typeBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateNodeModel, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForNodes$node_nameBI" map="_D"/>
  <method class="freemarker.core.BuiltInsForNodes$node_nameBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateNodeModel, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForNodes$rootBI" map="_E"/>
  <method class="freemarker.core.BuiltInsForNodes$rootBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateNodeModel, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForNodes$AncestorSequence" map="_F"/>
  <field class="freemarker.core.BuiltInsForNodes$AncestorSequence" name="env" map="&#x0208;"/>
  <method class="freemarker.core.BuiltInsForNodes$AncestorSequence" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForNodes$node_namespaceBI" map="_G"/>
  <method class="freemarker.core.BuiltInsForNodes$node_namespaceBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateNodeModel, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForNodes$previousSiblingBI" map="_H"/>
  <method class="freemarker.core.BuiltInsForNodes$previousSiblingBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateNodeModelEx, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForNodes$childrenBI" map="_I"/>
  <method class="freemarker.core.BuiltInsForNodes$childrenBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateNodeModel, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForNodes$ancestorsBI" map="_J"/>
  <method class="freemarker.core.BuiltInsForNodes$ancestorsBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateNodeModel, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForNodes" map="GA"/>
  <class name="freemarker.core.TemplateNumberFormat" map="HA"/>
  <method class="freemarker.core.TemplateNumberFormat" name="boolean isLocaleBound()" map="B"/>
  <method class="freemarker.core.TemplateNumberFormat" name="java.lang.Object format(freemarker.template.TemplateNumberModel)" map="A"/>
  <method class="freemarker.core.TemplateNumberFormat" name="java.lang.String formatToPlainText(freemarker.template.TemplateNumberModel)" map="B"/>
  <class name="freemarker.core.Sep" map="IA"/>
  <method class="freemarker.core.Sep" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.Sep" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.Sep" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.Sep" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.Sep" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.Sep" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.BuiltInForNode" map="JA"/>
  <method class="freemarker.core.BuiltInForNode" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateNodeModel, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.BuiltInForNode" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.Include" map="KA"/>
  <field class="freemarker.core.Include" name="includedTemplateNameExp" map="&#x00e3;"/>
  <field class="freemarker.core.Include" name="ignoreMissingExpPrecalcedValue" map="&#x00e4;"/>
  <field class="freemarker.core.Include" name="encodingExp" map="&#x00e5;"/>
  <field class="freemarker.core.Include" name="ignoreMissingExp" map="&#x00e6;"/>
  <field class="freemarker.core.Include" name="encoding" map="&#x00e7;"/>
  <field class="freemarker.core.Include" name="parseExp" map="&#x00e8;"/>
  <field class="freemarker.core.Include" name="parse" map="&#x00e9;"/>
  <method class="freemarker.core.Include" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.Include" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.Include" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.Include" name="boolean isShownInStackTrace()" map="d"/>
  <method class="freemarker.core.Include" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.Include" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.Include" name="boolean getYesNo(freemarker.core.Expression, java.lang.String)" map="A"/>
  <method class="freemarker.core.Include" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core._UnmodifiableCompositeSet$1" map="1"/>
  <class name="freemarker.core._UnmodifiableCompositeSet$CompositeIterator" map="_A"/>
  <field class="freemarker.core._UnmodifiableCompositeSet$CompositeIterator" name="this$0" map="A"/>
  <field class="freemarker.core._UnmodifiableCompositeSet$CompositeIterator" name="it2" map="B"/>
  <field class="freemarker.core._UnmodifiableCompositeSet$CompositeIterator" name="it1" map="C"/>
  <field class="freemarker.core._UnmodifiableCompositeSet$CompositeIterator" name="it1Deplected" map="D"/>
  <method class="freemarker.core._UnmodifiableCompositeSet$CompositeIterator" name="boolean hasNext()" map="hasNext"/>
  <method class="freemarker.core._UnmodifiableCompositeSet$CompositeIterator" name="void remove()" map="remove"/>
  <method class="freemarker.core._UnmodifiableCompositeSet$CompositeIterator" name="java.lang.Object next()" map="next"/>
  <class name="freemarker.core._UnmodifiableCompositeSet" map="LA"/>
  <field class="freemarker.core._UnmodifiableCompositeSet" name="set2" map="B"/>
  <field class="freemarker.core._UnmodifiableCompositeSet" name="set1" map="C"/>
  <method class="freemarker.core._UnmodifiableCompositeSet" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="freemarker.core._UnmodifiableCompositeSet" name="int size()" map="size"/>
  <method class="freemarker.core._UnmodifiableCompositeSet" name="java.util.Set access$200(freemarker.core._UnmodifiableCompositeSet)" map="A"/>
  <method class="freemarker.core._UnmodifiableCompositeSet" name="java.util.Set access$100(freemarker.core._UnmodifiableCompositeSet)" map="B"/>
  <method class="freemarker.core._UnmodifiableCompositeSet" name="boolean contains(java.lang.Object)" map="contains"/>
  <class name="freemarker.core.HashLiteral$SequenceHash$1$1" map="1"/>
  <field class="freemarker.core.HashLiteral$SequenceHash$1$1" name="key" map="E"/>
  <field class="freemarker.core.HashLiteral$SequenceHash$1$1" name="value" map="F"/>
  <field class="freemarker.core.HashLiteral$SequenceHash$1$1" name="this$2" map="G"/>
  <method class="freemarker.core.HashLiteral$SequenceHash$1$1" name="freemarker.template.TemplateModel getKey()" map="A"/>
  <method class="freemarker.core.HashLiteral$SequenceHash$1$1" name="freemarker.template.TemplateModel getValue()" map="B"/>
  <class name="freemarker.core.HashLiteral$SequenceHash$1" map="1"/>
  <field class="freemarker.core.HashLiteral$SequenceHash$1" name="valueIterator" map="E"/>
  <field class="freemarker.core.HashLiteral$SequenceHash$1" name="keyIterator" map="F"/>
  <field class="freemarker.core.HashLiteral$SequenceHash$1" name="this$1" map="G"/>
  <method class="freemarker.core.HashLiteral$SequenceHash$1" name="boolean hasNext()" map="A"/>
  <method class="freemarker.core.HashLiteral$SequenceHash$1" name="freemarker.template.TemplateModelIterator access$400(freemarker.core.HashLiteral$SequenceHash$1)" map="A"/>
  <method class="freemarker.core.HashLiteral$SequenceHash$1" name="freemarker.template.TemplateHashModelEx2$KeyValuePair next()" map="B"/>
  <method class="freemarker.core.HashLiteral$SequenceHash$1" name="freemarker.template.TemplateModelIterator access$300(freemarker.core.HashLiteral$SequenceHash$1)" map="B"/>
  <class name="freemarker.core.HashLiteral$SequenceHash" map="_A"/>
  <field class="freemarker.core.HashLiteral$SequenceHash" name="this$0" map="&#x018a;"/>
  <field class="freemarker.core.HashLiteral$SequenceHash" name="valueCollection" map="&#x018b;"/>
  <field class="freemarker.core.HashLiteral$SequenceHash" name="keyCollection" map="&#x018c;"/>
  <field class="freemarker.core.HashLiteral$SequenceHash" name="map" map="&#x018d;"/>
  <method class="freemarker.core.HashLiteral$SequenceHash" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.core.HashLiteral$SequenceHash" name="freemarker.template.TemplateCollectionModel keys()" map="&#x00c8;"/>
  <method class="freemarker.core.HashLiteral$SequenceHash" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.core.HashLiteral$SequenceHash" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.core.HashLiteral$SequenceHash" name="freemarker.template.TemplateHashModelEx2$KeyValuePairIterator keyValuePairIterator()" map="&#x00cb;"/>
  <method class="freemarker.core.HashLiteral$SequenceHash" name="freemarker.template.TemplateCollectionModel values()" map="&#x00c9;"/>
  <method class="freemarker.core.HashLiteral$SequenceHash" name="java.lang.String toString()" map="toString"/>
  <class name="freemarker.core.HashLiteral" map="MA"/>
  <field class="freemarker.core.HashLiteral" name="values" map="&#x00c1;"/>
  <field class="freemarker.core.HashLiteral" name="size" map="&#x00c2;"/>
  <field class="freemarker.core.HashLiteral" name="keys" map="&#x00c3;"/>
  <method class="freemarker.core.HashLiteral" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.HashLiteral" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.HashLiteral" name="java.util.ArrayList access$200(freemarker.core.HashLiteral)" map="A"/>
  <method class="freemarker.core.HashLiteral" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.HashLiteral" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.HashLiteral" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.HashLiteral" name="int access$000(freemarker.core.HashLiteral)" map="B"/>
  <method class="freemarker.core.HashLiteral" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.HashLiteral" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.HashLiteral" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <method class="freemarker.core.HashLiteral" name="void checkIndex(int)" map="H"/>
  <method class="freemarker.core.HashLiteral" name="java.util.ArrayList access$100(freemarker.core.HashLiteral)" map="C"/>
  <class name="freemarker.core.OutputFormatBoundBuiltIn" map="NA"/>
  <field class="freemarker.core.OutputFormatBoundBuiltIn" name="autoEscapingPolicy" map="j"/>
  <field class="freemarker.core.OutputFormatBoundBuiltIn" name="outputFormat" map="k"/>
  <method class="freemarker.core.OutputFormatBoundBuiltIn" name="freemarker.template.TemplateModel calculateResult(freemarker.core.Environment)" map="H"/>
  <method class="freemarker.core.OutputFormatBoundBuiltIn" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.OutputFormatBoundBuiltIn" name="void bindToOutputFormat(freemarker.core.OutputFormat, int)" map="A"/>
  <class name="freemarker.core.Range" map="OA"/>
  <field class="freemarker.core.Range" name="rho" map="&#x00c4;"/>
  <field class="freemarker.core.Range" name="lho" map="&#x00c5;"/>
  <field class="freemarker.core.Range" name="endType" map="&#x00c6;"/>
  <method class="freemarker.core.Range" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.Range" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.Range" name="boolean evalToBoolean(freemarker.core.Environment)" map="B"/>
  <method class="freemarker.core.Range" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.Range" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.Range" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.Range" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.Range" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.Range" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <class name="freemarker.core.FMParser$JJCalls" map="_A"/>
  <field class="freemarker.core.FMParser$JJCalls" name="arg" map="A"/>
  <field class="freemarker.core.FMParser$JJCalls" name="next" map="B"/>
  <field class="freemarker.core.FMParser$JJCalls" name="first" map="C"/>
  <field class="freemarker.core.FMParser$JJCalls" name="gen" map="D"/>
  <class name="freemarker.core.FMParser$1" map="1"/>
  <class name="freemarker.core.FMParser$ParserIteratorBlockContext" map="_B"/>
  <field class="freemarker.core.FMParser$ParserIteratorBlockContext" name="loopVar2Name" map="A"/>
  <field class="freemarker.core.FMParser$ParserIteratorBlockContext" name="kind" map="B"/>
  <field class="freemarker.core.FMParser$ParserIteratorBlockContext" name="hashListing" map="C"/>
  <field class="freemarker.core.FMParser$ParserIteratorBlockContext" name="loopVarName" map="D"/>
  <method class="freemarker.core.FMParser$ParserIteratorBlockContext" name="java.lang.String access$200(freemarker.core.FMParser$ParserIteratorBlockContext)" map="A"/>
  <method class="freemarker.core.FMParser$ParserIteratorBlockContext" name="boolean access$400(freemarker.core.FMParser$ParserIteratorBlockContext)" map="B"/>
  <method class="freemarker.core.FMParser$ParserIteratorBlockContext" name="java.lang.String access$202(freemarker.core.FMParser$ParserIteratorBlockContext, java.lang.String)" map="A"/>
  <method class="freemarker.core.FMParser$ParserIteratorBlockContext" name="int access$300(freemarker.core.FMParser$ParserIteratorBlockContext)" map="C"/>
  <method class="freemarker.core.FMParser$ParserIteratorBlockContext" name="int access$302(freemarker.core.FMParser$ParserIteratorBlockContext, int)" map="A"/>
  <method class="freemarker.core.FMParser$ParserIteratorBlockContext" name="java.lang.String access$102(freemarker.core.FMParser$ParserIteratorBlockContext, java.lang.String)" map="B"/>
  <method class="freemarker.core.FMParser$ParserIteratorBlockContext" name="boolean access$402(freemarker.core.FMParser$ParserIteratorBlockContext, boolean)" map="A"/>
  <method class="freemarker.core.FMParser$ParserIteratorBlockContext" name="java.lang.String access$100(freemarker.core.FMParser$ParserIteratorBlockContext)" map="D"/>
  <class name="freemarker.core.FMParser$LookaheadSuccess" map="_C"/>
  <class name="freemarker.core.FMParser" map="PA"/>
  <field class="freemarker.core.FMParser" name="jj_la1" map="&#x00d3;"/>
  <field class="freemarker.core.FMParser" name="jj_ls" map="&#x00d4;"/>
  <field class="freemarker.core.FMParser" name="autoEscapingPolicy" map="&#x00d5;"/>
  <field class="freemarker.core.FMParser" name="template" map="&#x00d6;"/>
  <field class="freemarker.core.FMParser" name="outputFormat" map="&#x00d8;"/>
  <field class="freemarker.core.FMParser" name="iteratorBlockContexts" map="&#x00d9;"/>
  <field class="freemarker.core.FMParser" name="inFunction" map="&#x00da;"/>
  <field class="freemarker.core.FMParser" name="escapes" map="&#x00db;"/>
  <field class="freemarker.core.FMParser" name="jj_scanpos" map="&#x00dc;"/>
  <field class="freemarker.core.FMParser" name="incompatibleImprovements" map="&#x00dd;"/>
  <field class="freemarker.core.FMParser" name="jj_la" map="&#x00de;"/>
  <field class="freemarker.core.FMParser" name="stripWhitespace" map="&#x00df;"/>
  <field class="freemarker.core.FMParser" name="stripText" map="&#x00e0;"/>
  <field class="freemarker.core.FMParser" name="token" map="&#x00e1;"/>
  <field class="freemarker.core.FMParser" name="jj_endpos" map="&#x00e2;"/>
  <field class="freemarker.core.FMParser" name="jj_expentry" map="&#x00e3;"/>
  <field class="freemarker.core.FMParser" name="jj_nt" map="&#x00e4;"/>
  <field class="freemarker.core.FMParser" name="breakableDirectiveNesting" map="&#x00e5;"/>
  <field class="freemarker.core.FMParser" name="token_source" map="&#x00e6;"/>
  <field class="freemarker.core.FMParser" name="jj_expentries" map="&#x00e7;"/>
  <field class="freemarker.core.FMParser" name="mixedContentNesting" map="&#x00e8;"/>
  <field class="freemarker.core.FMParser" name="jj_lasttokens" map="&#x00e9;"/>
  <field class="freemarker.core.FMParser" name="jj_la1_4" map="&#x00ea;"/>
  <field class="freemarker.core.FMParser" name="jj_gen" map="&#x00eb;"/>
  <field class="freemarker.core.FMParser" name="jj_la1_3" map="&#x00ec;"/>
  <field class="freemarker.core.FMParser" name="jj_la1_2" map="&#x00ed;"/>
  <field class="freemarker.core.FMParser" name="jj_la1_1" map="&#x00ee;"/>
  <field class="freemarker.core.FMParser" name="continuableDirectiveNesting" map="&#x00ef;"/>
  <field class="freemarker.core.FMParser" name="jj_la1_0" map="&#x00f0;"/>
  <field class="freemarker.core.FMParser" name="jj_lastpos" map="&#x00f1;"/>
  <field class="freemarker.core.FMParser" name="jj_2_rtns" map="&#x00f2;"/>
  <field class="freemarker.core.FMParser" name="jj_kind" map="&#x00f3;"/>
  <field class="freemarker.core.FMParser" name="autoEscaping" map="&#x00f4;"/>
  <field class="freemarker.core.FMParser" name="jj_rescan" map="&#x00f5;"/>
  <field class="freemarker.core.FMParser" name="jj_gc" map="&#x00f6;"/>
  <field class="freemarker.core.FMParser" name="pCfg" map="&#x00f8;"/>
  <field class="freemarker.core.FMParser" name="preventStrippings" map="&#x00f9;"/>
  <field class="freemarker.core.FMParser" name="inMacro" map="&#x00fa;"/>
  <field class="freemarker.core.FMParser" name="jj_ntk" map="&#x00fb;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.StringLiteral StringLiteral(boolean)" map="A"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_36()" map="R"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3_4()" map="S"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_54()" map="T"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_72()" map="U"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_90()" map="V"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression AndExpression()" map="W"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.TemplateElement Nested()" map="X"/>
  <method class="freemarker.core.FMParser" name="boolean jj_2_12(int)" map="C"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression AdditiveExpression()" map="Y"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Comment Comment()" map="Z"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_88()" map="_"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.NumericalOutput NumericalOutput()" map="a"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3_12()" map="b"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.BuiltinVariable BuiltinVariable()" map="c"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_43()" map="d"/>
  <method class="freemarker.core.FMParser" name="boolean jj_2_1(int)" map="D"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_61()" map="e"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.FallbackInstruction FallBack()" map="f"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3_9()" map="g"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_59()" map="h"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_77()" map="i"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_95()" map="j"/>
  <method class="freemarker.core.FMParser" name="int _getLastTagSyntax()" map="k"/>
  <method class="freemarker.core.FMParser" name="boolean jj_2_8(int)" map="E"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.VisitNode Visit()" map="l"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.ContinueInstruction Continue()" map="m"/>
  <method class="freemarker.core.FMParser" name="int jj_ntk_f()" map="n"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression DynamicKey(freemarker.core.Expression)" map="A"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.BreakInstruction Break()" map="o"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Sep Sep()" map="p"/>
  <method class="freemarker.core.FMParser" name="void jj_la1_init_1()" map="q"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.TemplateElement FreemarkerDirective()" map="r"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_32()" map="s"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_50()" map="t"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression DotVariable(freemarker.core.Expression)" map="B"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.RecoveryBlock Recover()" map="u"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_48()" map="v"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_66()" map="w"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_84()" map="x"/>
  <method class="freemarker.core.FMParser" name="boolean jj_2_15(int)" map="F"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.TemplateElements MixedContentElements()" map="y"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_37()" map="z"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_55()" map="&#x00a2;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3_5()" map="&#x00a3;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_73()" map="&#x00a4;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_2_4(int)" map="G"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.ParseException generateParseException()" map="&#x00a5;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_91()" map="&#x00aa;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.AutoEscBlock AutoEsc()" map="&#x00b5;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_89()" map="&#x00ba;"/>
  <method class="freemarker.core.FMParser" name="void notStringLiteral(freemarker.core.Expression, java.lang.String)" map="A"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.TemplateElement Flush()" map="&#x00c0;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Token LooseDirectiveEnd()" map="&#x00c1;"/>
  <method class="freemarker.core.FMParser" name="void notHashLiteral(freemarker.core.Expression, java.lang.String)" map="B"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3_13()" map="&#x00c2;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.TransformBlock Transform()" map="&#x00c3;"/>
  <method class="freemarker.core.FMParser" name="java.lang.String forEachDirectiveSymbol()" map="&#x00c4;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression RangeExpression()" map="&#x00c5;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_26()" map="&#x00c6;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_44()" map="&#x00c7;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_62()" map="&#x00c8;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.TemplateElement Assign()" map="&#x00c9;"/>
  <method class="freemarker.core.FMParser" name="void checkLoopVariableBuiltInLHO(java.lang.String, freemarker.core.Expression, freemarker.core.Token)" map="A"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_80()" map="&#x00ca;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.TemplateElement Call()" map="&#x00cb;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_2_11(int)" map="H"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.MethodCall MethodArgs(freemarker.core.Expression)" map="C"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_78()" map="&#x00cc;"/>
  <method class="freemarker.core.FMParser" name="int _getLastNamingConvention()" map="&#x00cd;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_96()" map="&#x00ce;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.FMParser$ParserIteratorBlockContext pushIteratorBlockContext()" map="&#x00cf;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.ElseOfList ElseOfList()" map="&#x00d0;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.StopInstruction Stop()" map="&#x00d1;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.OutputFormatBlock OutputFormat()" map="&#x00d2;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.ReturnInstruction Return()" map="&#x00d3;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.MarkupOutputFormat getMarkupOutputFormat()" map="&#x00d4;"/>
  <method class="freemarker.core.FMParser" name="void popIteratorBlockContext()" map="&#x00d5;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.TextBlock WhitespaceText()" map="&#x00d6;"/>
  <method class="freemarker.core.FMParser" name="void jj_la1_init_2()" map="&#x00d8;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_33()" map="&#x00d9;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.TextBlock NoParse()" map="&#x00da;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_51()" map="&#x00db;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3_1()" map="&#x00dc;"/>
  <method class="freemarker.core.FMParser" name="void stringLiteralOnly(freemarker.core.Expression)" map="D"/>
  <method class="freemarker.core.FMParser" name="java.util.List StaticTextAndInterpolations()" map="&#x00dd;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_49()" map="&#x00de;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_67()" map="&#x00df;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_85()" map="&#x00e0;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.ListLiteral ListLiteral()" map="&#x00e1;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_2_7(int)" map="I"/>
  <method class="freemarker.core.FMParser" name="void notBooleanLiteral(freemarker.core.Expression, java.lang.String)" map="C"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.LibraryLoad Import()" map="&#x00e2;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression NotExpression()" map="&#x00e3;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression OrExpression()" map="&#x00e4;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Case Case()" map="&#x00e5;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_100()" map="&#x00e6;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_40()" map="&#x00e7;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_38()" map="&#x00e8;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3_6()" map="&#x00e9;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_56()" map="&#x00ea;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_74()" map="&#x00eb;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_92()" map="&#x00ec;"/>
  <method class="freemarker.core.FMParser" name="void setupStringLiteralMode(freemarker.core.FMParser, freemarker.core.OutputFormat)" map="A"/>
  <method class="freemarker.core.FMParser" name="boolean jj_2_14(int)" map="J"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.MixedContent WhitespaceAndComments()" map="&#x00ed;"/>
  <method class="freemarker.core.FMParser" name="void jj_save(int, int)" map="M"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.TemplateElement Trim()" map="&#x00ee;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3_14()" map="&#x00ef;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Include Include()" map="&#x00f0;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.SwitchBlock Switch()" map="&#x00f1;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_27()" map="&#x00f2;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_45()" map="&#x00f3;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_63()" map="&#x00f4;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_2_3(int)" map="K"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_81()" map="&#x00f5;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.OutputFormat getFormatFromStdFileExt()" map="&#x00f6;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.RecurseNode Recurse()" map="&#x00f8;"/>
  <method class="freemarker.core.FMParser" name="void notNumberLiteral(freemarker.core.Expression, java.lang.String)" map="D"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_79()" map="&#x00f9;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_97()" map="&#x00fa;"/>
  <method class="freemarker.core.FMParser" name="void setPreventStrippings(boolean)" map="B"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression NumberLiteral()" map="&#x00fb;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.TextBlock PCData()" map="&#x00fc;"/>
  <method class="freemarker.core.FMParser" name="void checkCurrentOutputFormatCanEscape(freemarker.core.Token)" map="K"/>
  <method class="freemarker.core.FMParser" name="java.util.ArrayList PositionalArgs()" map="&#x00fd;"/>
  <method class="freemarker.core.FMParser" name="void jj_la1_init_3()" map="&#x00fe;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression UnaryPlusMinusExpression()" map="&#x00ff;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_34()" map="&#x0100;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression BooleanLiteral()" map="&#x0101;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3_2()" map="&#x0102;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_52()" map="&#x0103;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_70()" map="&#x0104;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_2_10(int)" map="L"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.PropertySetting Setting()" map="&#x0105;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_68()" map="&#x0106;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_86()" map="&#x0107;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression UnaryExpression()" map="&#x0108;"/>
  <method class="freemarker.core.FMParser" name="void tearDownStringLiteralMode(freemarker.core.FMParser)" map="B"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression AtomicExpression()" map="&#x0109;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3_10()" map="&#x010a;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_101()" map="&#x010b;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_41()" map="&#x010c;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_39()" map="&#x010d;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3_7()" map="&#x010e;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_57()" map="&#x010f;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_75()" map="&#x0110;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_93()" map="&#x0111;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_2_6(int)" map="M"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Token UnparsedContent(freemarker.core.Token, java.lang.StringBuilder)" map="A"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.AttemptBlock Attempt()" map="&#x0112;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.HashLiteral HashLiteral()" map="&#x0113;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Token jj_consume_token(int)" map="N"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.FMParserTokenManager readerToTokenManager(java.io.Reader, freemarker.core.ParserConfiguration)" map="A"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.EscapeBlock Escape()" map="&#x0114;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression MultiplicativeExpression()" map="&#x0115;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3_15()" map="&#x0116;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_30()" map="&#x0117;"/>
  <method class="freemarker.core.FMParser" name="void numberLiteralOnly(freemarker.core.Expression)" map="E"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression EqualityExpression()" map="&#x0118;"/>
  <method class="freemarker.core.FMParser" name="java.util.HashMap NamedArgs()" map="&#x0119;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_28()" map="&#x011a;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_46()" map="&#x011b;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_64()" map="&#x011c;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression Expression()" map="&#x011d;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_82()" map="&#x011e;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_2_13(int)" map="O"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression escapedExpression(freemarker.core.Expression)" map="F"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_98()" map="&#x011f;"/>
  <method class="freemarker.core.FMParser" name="void notListLiteral(freemarker.core.Expression, java.lang.String)" map="E"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.TemplateElement Root()" map="&#x0120;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.DollarVariable StringOutput()" map="&#x0121;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.TemplateElement UnifiedMacroTransform()" map="&#x0122;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Identifier Identifier()" map="&#x0123;"/>
  <method class="freemarker.core.FMParser" name="void jj_la1_init_4()" map="&#x0124;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_35()" map="&#x0125;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_53()" map="&#x0126;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3_3()" map="&#x0127;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_2_2(int)" map="P"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_71()" map="&#x0128;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.CompressedBlock Compress()" map="&#x0129;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_scan_token(int)" map="Q"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression PrimaryExpression()" map="&#x012a;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_69()" map="&#x012b;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_87()" map="&#x012c;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_2_9(int)" map="R"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.FMParser$ParserIteratorBlockContext peekIteratorBlockContext()" map="&#x012d;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.TemplateElement List()" map="&#x012e;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression RelationalExpression()" map="&#x012f;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3_11()" map="&#x0130;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.NoEscapeBlock NoEscape()" map="&#x0131;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_42()" map="&#x0132;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_60()" map="&#x0133;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression Parenthesis()" map="&#x0134;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.NoAutoEscBlock NoAutoEsc()" map="&#x0135;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3_8()" map="&#x0136;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_58()" map="&#x0137;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_76()" map="&#x0138;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_94()" map="&#x0139;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression DefaultTo(freemarker.core.Expression)" map="G"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression Exists(freemarker.core.Expression)" map="H"/>
  <method class="freemarker.core.FMParser" name="void booleanLiteralOnly(freemarker.core.Expression)" map="I"/>
  <method class="freemarker.core.FMParser" name="void jj_add_error_token(int, int)" map="N"/>
  <method class="freemarker.core.FMParser" name="void jj_la1_init_0()" map="&#x013a;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression IdentifierOrStringLiteral()" map="&#x013b;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.IteratorBlock ForEach()" map="&#x013c;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_31()" map="&#x013d;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Items Items()" map="&#x013e;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Macro Macro()" map="&#x013f;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.TemplateElement If()" map="&#x0140;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_29()" map="&#x0141;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_47()" map="&#x0142;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_65()" map="&#x0143;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_83()" map="&#x0144;"/>
  <method class="freemarker.core.FMParser" name="boolean getBoolean(freemarker.core.Expression, boolean)" map="A"/>
  <method class="freemarker.core.FMParser" name="boolean jj_2_5(int)" map="S"/>
  <method class="freemarker.core.FMParser" name="void recalculateAutoEscapingField()" map="&#x0145;"/>
  <method class="freemarker.core.FMParser" name="freemarker.core.Expression BuiltIn(freemarker.core.Expression)" map="J"/>
  <method class="freemarker.core.FMParser" name="void jj_rescan_token()" map="&#x0146;"/>
  <method class="freemarker.core.FMParser" name="boolean jj_3R_99()" map="&#x0147;"/>
  <method class="freemarker.core.FMParser" name="void HeaderElement()" map="&#x0148;"/>
  <class name="freemarker.core.BuiltInWithParseTimeParameters" map="QA"/>
  <method class="freemarker.core.BuiltInWithParseTimeParameters" name="freemarker.core.Expression getArgumentParameterValue(int)" map="E"/>
  <method class="freemarker.core.BuiltInWithParseTimeParameters" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.BuiltInWithParseTimeParameters" name="int getArgumentsCount()" map="Q"/>
  <method class="freemarker.core.BuiltInWithParseTimeParameters" name="void bindToParameters(java.util.List, freemarker.core.Token, freemarker.core.Token)" map="A"/>
  <method class="freemarker.core.BuiltInWithParseTimeParameters" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.BuiltInWithParseTimeParameters" name="java.util.List getArgumentsAsList()" map="R"/>
  <method class="freemarker.core.BuiltInWithParseTimeParameters" name="freemarker.core.ParseException newArgumentCountException(java.lang.String, freemarker.core.Token, freemarker.core.Token)" map="A"/>
  <method class="freemarker.core.BuiltInWithParseTimeParameters" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.BuiltInWithParseTimeParameters" name="void cloneArguments(freemarker.core.Expression, java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="A"/>
  <method class="freemarker.core.BuiltInWithParseTimeParameters" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.BuiltInWithParseTimeParameters" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.BuiltInWithParseTimeParameters" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <class name="freemarker.core.CompressedBlock" map="RA"/>
  <method class="freemarker.core.CompressedBlock" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.CompressedBlock" name="boolean isIgnorable(boolean)" map="D"/>
  <method class="freemarker.core.CompressedBlock" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.CompressedBlock" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.CompressedBlock" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.CompressedBlock" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.CompressedBlock" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core._ObjectBuilderSettingEvaluationException" map="SA"/>
  <class name="freemarker.core._DelayedOrdinal" map="TA"/>
  <method class="freemarker.core._DelayedOrdinal" name="java.lang.String doConversion(java.lang.Object)" map="A"/>
  <class name="freemarker.core.Environment$NestedElementTemplateDirectiveBody" map="_A"/>
  <field class="freemarker.core.Environment$NestedElementTemplateDirectiveBody" name="this$0" map="A"/>
  <field class="freemarker.core.Environment$NestedElementTemplateDirectiveBody" name="childBuffer" map="B"/>
  <class name="freemarker.core.Environment$Namespace" map="_B"/>
  <field class="freemarker.core.Environment$Namespace" name="this$0" map="&#x01e5;"/>
  <field class="freemarker.core.Environment$Namespace" name="template" map="&#x01e6;"/>
  <method class="freemarker.core.Environment$Namespace" name="void setTemplate(freemarker.template.Template)" map="A"/>
  <method class="freemarker.core.Environment$Namespace" name="freemarker.template.Template getTemplate()" map="&#x00eb;"/>
  <class name="freemarker.core.Environment$LazilyInitializedNamespace" map="_C"/>
  <field class="freemarker.core.Environment$LazilyInitializedNamespace" name="this$0" map="&#x01e5;"/>
  <field class="freemarker.core.Environment$LazilyInitializedNamespace" name="locale" map="&#x01e7;"/>
  <field class="freemarker.core.Environment$LazilyInitializedNamespace" name="status" map="&#x01e8;"/>
  <field class="freemarker.core.Environment$LazilyInitializedNamespace" name="templateName" map="&#x01e9;"/>
  <field class="freemarker.core.Environment$LazilyInitializedNamespace" name="customLookupCondition" map="&#x01ea;"/>
  <field class="freemarker.core.Environment$LazilyInitializedNamespace" name="encoding" map="&#x01eb;"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="void put(java.lang.String, java.lang.Object)" map="A"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="freemarker.template.Template getTemplate()" map="&#x00eb;"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="void ensureInitializedTME()" map="&#x00ec;"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="void put(java.lang.String, boolean)" map="A"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="void access$400(freemarker.core.Environment$LazilyInitializedNamespace)" map="A"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="freemarker.template.TemplateCollectionModel values()" map="&#x00c9;"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="void initialize()" map="&#x00ed;"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="freemarker.template.TemplateCollectionModel keys()" map="&#x00c8;"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="freemarker.template.TemplateHashModelEx2$KeyValuePairIterator keyValuePairIterator()" map="&#x00cb;"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="java.util.Map copyMap(java.util.Map)" map="A"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="boolean containsKey(java.lang.String)" map="J"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="void ensureInitializedRTE()" map="&#x00ee;"/>
  <method class="freemarker.core.Environment$LazilyInitializedNamespace" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <class name="freemarker.core.Environment$InitializationStatus" map="_D"/>
  <field class="freemarker.core.Environment$InitializationStatus" name="$VALUES" map="A"/>
  <field class="freemarker.core.Environment$InitializationStatus" name="INITIALIZED" map="B"/>
  <field class="freemarker.core.Environment$InitializationStatus" name="UNINITIALIZED" map="C"/>
  <field class="freemarker.core.Environment$InitializationStatus" name="FAILED" map="D"/>
  <field class="freemarker.core.Environment$InitializationStatus" name="INITIALIZING" map="E"/>
  <method class="freemarker.core.Environment$InitializationStatus" name="freemarker.core.Environment$InitializationStatus[] values()" map="values"/>
  <method class="freemarker.core.Environment$InitializationStatus" name="freemarker.core.Environment$InitializationStatus valueOf(java.lang.String)" map="valueOf"/>
  <class name="freemarker.core.Environment$5" map="5"/>
  <method class="freemarker.core.Environment$5" name="void write(char[], int, int)" map="write"/>
  <method class="freemarker.core.Environment$5" name="void flush()" map="flush"/>
  <method class="freemarker.core.Environment$5" name="void close()" map="close"/>
  <class name="freemarker.core.Environment$4" map="4"/>
  <field class="freemarker.core.Environment$4" name="this$0" map="&#x017b;"/>
  <method class="freemarker.core.Environment$4" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.core.Environment$4" name="boolean isEmpty()" map="&#x00c7;"/>
  <class name="freemarker.core.Environment$3" map="3"/>
  <field class="freemarker.core.Environment$3" name="this$0" map="&#x017c;"/>
  <method class="freemarker.core.Environment$3" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.core.Environment$3" name="boolean isEmpty()" map="&#x00c7;"/>
  <class name="freemarker.core.Environment$2" map="2"/>
  <field class="freemarker.core.Environment$2" name="this$0" map="&#x017f;"/>
  <method class="freemarker.core.Environment$2" name="freemarker.template.TemplateCollectionModel keys()" map="&#x00c8;"/>
  <method class="freemarker.core.Environment$2" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.core.Environment$2" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.core.Environment$2" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.core.Environment$2" name="freemarker.template.TemplateCollectionModel values()" map="&#x00c9;"/>
  <class name="freemarker.core.Environment$1" map="1"/>
  <field class="freemarker.core.Environment$1" name="this$0" map="V"/>
  <field class="freemarker.core.Environment$1" name="val$bodyParameterNames" map="W"/>
  <field class="freemarker.core.Environment$1" name="val$outArgs" map="X"/>
  <method class="freemarker.core.Environment$1" name="java.util.Collection getLocalVariableNames()" map="A"/>
  <method class="freemarker.core.Environment$1" name="freemarker.template.TemplateModel getLocalVariable(java.lang.String)" map="A"/>
  <class name="freemarker.core.Environment" map="UA"/>
  <field class="freemarker.core.Environment" name="rootDataModel" map="l"/>
  <field class="freemarker.core.Environment" name="currentNodeName" map="m"/>
  <field class="freemarker.core.Environment" name="customStateVariables" map="n"/>
  <field class="freemarker.core.Environment" name="cNumberFormat" map="o"/>
  <field class="freemarker.core.Environment" name="inAttemptBlock" map="p"/>
  <field class="freemarker.core.Environment" name="isoBuiltInCalendarFactory" map="q"/>
  <field class="freemarker.core.Environment" name="loadedLibs" map="r"/>
  <field class="freemarker.core.Environment" name="nodeNamespaceIndex" map="s"/>
  <field class="freemarker.core.Environment" name="cachedCollator" map="t"/>
  <field class="freemarker.core.Environment" name="cachedTemplateNumberFormats" map="u"/>
  <field class="freemarker.core.Environment" name="nodeNamespaces" map="v"/>
  <field class="freemarker.core.Environment" name="C_NUMBER_FORMAT" map="w"/>
  <field class="freemarker.core.Environment" name="globalNamespace" map="x"/>
  <field class="freemarker.core.Environment" name="threadEnv" map="y"/>
  <field class="freemarker.core.Environment" name="lastThrowable" map="z"/>
  <field class="freemarker.core.Environment" name="instructionStack" map="&#x00a2;"/>
  <field class="freemarker.core.Environment" name="cachedTempDateFormatArray" map="&#x00a3;"/>
  <field class="freemarker.core.Environment" name="currentNamespace" map="&#x00a4;"/>
  <field class="freemarker.core.Environment" name="cachedTemplateNumberFormat" map="&#x00a5;"/>
  <field class="freemarker.core.Environment" name="incompatibleImprovementsGE2328" map="&#x00aa;"/>
  <field class="freemarker.core.Environment" name="macroToNamespaceLookup" map="&#x00b5;"/>
  <field class="freemarker.core.Environment" name="mainNamespace" map="&#x00ba;"/>
  <field class="freemarker.core.Environment" name="currentVisitorNode" map="&#x00c0;"/>
  <field class="freemarker.core.Environment" name="cachedURLEscapingCharset" map="&#x00c1;"/>
  <field class="freemarker.core.Environment" name="instructionStackSize" map="&#x00c2;"/>
  <field class="freemarker.core.Environment" name="currentMacroContext" map="&#x00c3;"/>
  <field class="freemarker.core.Environment" name="LOG" map="&#x00c4;"/>
  <field class="freemarker.core.Environment" name="ATTEMPT_LOGGER" map="&#x00c5;"/>
  <field class="freemarker.core.Environment" name="currentNodeNS" map="&#x00c6;"/>
  <field class="freemarker.core.Environment" name="recoveredErrorStack" map="&#x00c7;"/>
  <field class="freemarker.core.Environment" name="out" map="&#x00c8;"/>
  <field class="freemarker.core.Environment" name="legacyParent" map="&#x00c9;"/>
  <field class="freemarker.core.Environment" name="NO_OUT_ARGS" map="&#x00ca;"/>
  <field class="freemarker.core.Environment" name="configuration" map="&#x00cb;"/>
  <field class="freemarker.core.Environment" name="lastReturnValue" map="&#x00cc;"/>
  <field class="freemarker.core.Environment" name="EMPTY_BODY_WRITER" map="&#x00cd;"/>
  <field class="freemarker.core.Environment" name="cachedTempDateFormatsByFmtStrArray" map="&#x00ce;"/>
  <field class="freemarker.core.Environment" name="cachedSQLDateAndTimeTimeZoneSameAsNormal" map="&#x00cf;"/>
  <field class="freemarker.core.Environment" name="fastInvalidReferenceExceptions" map="&#x00d0;"/>
  <field class="freemarker.core.Environment" name="localContextStack" map="&#x00d1;"/>
  <field class="freemarker.core.Environment" name="cachedURLEscapingCharsetSet" map="&#x00d2;"/>
  <method class="freemarker.core.Environment" name="void fallback()" map="s"/>
  <method class="freemarker.core.Environment" name="freemarker.core.Environment$Namespace importLib(freemarker.template.Template, java.lang.String)" map="A"/>
  <method class="freemarker.core.Environment" name="void setDateFormat(java.lang.String)" map="A"/>
  <method class="freemarker.core.Environment" name="void replaceElementStackTop(freemarker.core.TemplateElement)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.template.Template getTemplateForImporting(java.lang.String)" map="Q"/>
  <method class="freemarker.core.Environment" name="java.lang.String getNamespaceForPrefix(java.lang.String)" map="R"/>
  <method class="freemarker.core.Environment" name="void setGlobalVariable(java.lang.String, freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.core.Environment$Namespace access$300(freemarker.core.Environment)" map="B"/>
  <method class="freemarker.core.Environment" name="void visitAndTransform(freemarker.core.TemplateElement[], freemarker.template.TemplateTransformModel, java.util.Map)" map="A"/>
  <method class="freemarker.core.Environment" name="java.lang.String formatNumberToPlainText(freemarker.template.TemplateNumberModel, freemarker.core.Expression, boolean)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.template.Template getTemplateForInclusion(java.lang.String, java.lang.String, boolean, boolean)" map="A"/>
  <method class="freemarker.core.Environment" name="java.lang.Object[] noNodeHandlerDefinedDescription(freemarker.template.TemplateNodeModel, java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.core.Macro$Context getCurrentMacroContext()" map="t"/>
  <method class="freemarker.core.Environment" name="freemarker.template.TemplateModel getGlobalVariable(java.lang.String)" map="S"/>
  <method class="freemarker.core.Environment" name="java.lang.String getEffectiveURLEscapingCharset()" map="u"/>
  <method class="freemarker.core.Environment" name="java.lang.String formatDateToPlainText(freemarker.template.TemplateDateModel, freemarker.core.Expression, boolean)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.template.Template getMainTemplate()" map="v"/>
  <method class="freemarker.core.Environment" name="java.lang.String formatNumberToPlainText(freemarker.template.TemplateNumberModel, freemarker.core.TemplateNumberFormat, freemarker.core.Expression, boolean)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.core.Environment$Namespace getMainNamespace()" map="w"/>
  <method class="freemarker.core.Environment" name="java.util.Set getKnownVariableNames()" map="x"/>
  <method class="freemarker.core.Environment" name="freemarker.template.TemplateModel getNodeProcessor(java.lang.String, java.lang.String, int)" map="A"/>
  <method class="freemarker.core.Environment" name="void setLocale(java.util.Locale)" map="A"/>
  <method class="freemarker.core.Environment" name="boolean isSQLDateAndTimeTimeZoneSameAsNormal()" map="y"/>
  <method class="freemarker.core.Environment" name="freemarker.core.Environment$Namespace importLib(java.lang.String, java.lang.String)" map="D"/>
  <method class="freemarker.core.Environment" name="void setLocalVariable(java.lang.String, freemarker.template.TemplateModel)" map="B"/>
  <method class="freemarker.core.Environment" name="freemarker.core.TemplateDateFormat getTemplateDateFormat(int, boolean, boolean)" map="A"/>
  <method class="freemarker.core.Environment" name="java.lang.String getCurrentRecoveredErrorMessage()" map="z"/>
  <method class="freemarker.core.Environment" name="void pushElement(freemarker.core.TemplateElement)" map="B"/>
  <method class="freemarker.core.Environment" name="freemarker.template.TemplateModel getLocalVariable(java.lang.String)" map="T"/>
  <method class="freemarker.core.Environment" name="freemarker.template.Template getTemplate230()" map="&#x00a2;"/>
  <method class="freemarker.core.Environment" name="void visitAttemptRecover(freemarker.core.AttemptBlock, freemarker.core.TemplateElement, freemarker.core.RecoveryBlock)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.core.TemplateNumberFormat getTemplateNumberFormat()" map="&#x00a3;"/>
  <method class="freemarker.core.Environment" name="freemarker.template.TemplateNodeModel getCurrentVisitorNode()" map="&#x00a4;"/>
  <method class="freemarker.core.Environment" name="freemarker.template.utility.DateUtil$DateToISO8601CalendarFactory getISOBuiltInCalendarFactory()" map="&#x00a5;"/>
  <method class="freemarker.core.Environment" name="void setTimeZone(java.util.TimeZone)" map="A"/>
  <method class="freemarker.core.Environment" name="void clearCachedValues()" map="&#x00aa;"/>
  <method class="freemarker.core.Environment" name="freemarker.template.Configuration getConfiguration()" map="&#x00b5;"/>
  <method class="freemarker.core.Environment" name="freemarker.template.TemplateModel getVariable(java.lang.String)" map="U"/>
  <method class="freemarker.core.Environment" name="void setCurrentEnvironment(freemarker.core.Environment)" map="C"/>
  <method class="freemarker.core.Environment" name="void setMacroContextLocalsFromArguments(freemarker.core.Macro$Context, freemarker.core.Macro, java.util.Map, java.util.List)" map="A"/>
  <method class="freemarker.core.Environment" name="java.lang.String getPrefixForNamespace(java.lang.String)" map="V"/>
  <method class="freemarker.core.Environment" name="void pushLocalContext(freemarker.core.LocalContext)" map="A"/>
  <method class="freemarker.core.Environment" name="java.lang.String formatNumberToPlainText(java.lang.Number, freemarker.core.BackwardCompatibleTemplateNumberFormat, freemarker.core.Expression)" map="A"/>
  <method class="freemarker.core.Environment" name="boolean isBeforeIcI2322()" map="&#x00ba;"/>
  <method class="freemarker.core.Environment" name="freemarker.core.Environment$Namespace getCurrentNamespace()" map="&#x00c0;"/>
  <method class="freemarker.core.Environment" name="java.io.Writer getOut()" map="&#x00c1;"/>
  <method class="freemarker.core.Environment" name="void visit(freemarker.core.TemplateElement[], freemarker.template.TemplateDirectiveModel, java.util.Map, java.util.List)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.core.TemplateNumberFormat getTemplateNumberFormat(java.lang.String, freemarker.core.Expression, boolean)" map="A"/>
  <method class="freemarker.core.Environment" name="boolean nullSafeEquals(java.lang.Object, java.lang.Object)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.core.Environment$Namespace importLib(java.lang.String, java.lang.String, boolean)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.template.TemplateTransformModel getTransform(freemarker.core.Expression)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.core.TemplateNumberFormat getTemplateNumberFormat(java.lang.String, boolean)" map="B"/>
  <method class="freemarker.core.Environment" name="void visitMacroDef(freemarker.core.Macro)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.template.Template getCurrentTemplate()" map="&#x00c2;"/>
  <method class="freemarker.core.Environment" name="java.text.NumberFormat getCNumberFormat()" map="&#x00c3;"/>
  <method class="freemarker.core.Environment" name="freemarker.template.TemplateModel getNodeProcessor(freemarker.template.TemplateNodeModel)" map="A"/>
  <method class="freemarker.core.Environment" name="void access$900(freemarker.core.Environment, freemarker.core.Environment$Namespace, freemarker.template.Template)" map="A"/>
  <method class="freemarker.core.Environment" name="void setURLEscapingCharset(java.lang.String)" map="G"/>
  <method class="freemarker.core.Environment" name="java.lang.String toFullTemplateName(java.lang.String, java.lang.String)" map="E"/>
  <method class="freemarker.core.Environment" name="void include(freemarker.template.Template)" map="A"/>
  <method class="freemarker.core.Environment" name="boolean shouldUseSQLDTTZ(java.lang.Class)" map="A"/>
  <method class="freemarker.core.Environment" name="java.lang.Object getIncludedTemplateCustomLookupCondition()" map="&#x00c4;"/>
  <method class="freemarker.core.Environment" name="freemarker.core.TemplateDateFormat getTemplateDateFormat(int, java.lang.Class, freemarker.core.Expression, boolean)" map="A"/>
  <method class="freemarker.core.Environment" name="void process()" map="&#x00c5;"/>
  <method class="freemarker.core.Environment" name="freemarker.core.Environment$Namespace getGlobalNamespace()" map="&#x00c6;"/>
  <method class="freemarker.core.Environment" name="java.lang.Object getCustomState(java.lang.Object)" map="A"/>
  <method class="freemarker.core.Environment" name="void setOutputEncoding(java.lang.String)" map="H"/>
  <method class="freemarker.core.Environment" name="freemarker.template.TemplateModel getNodeProcessor(freemarker.core.Environment$Namespace, java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.core.Environment" name="int getTemplateDateFormatCacheArrayIndex(int, boolean, boolean)" map="B"/>
  <method class="freemarker.core.Environment" name="void visit(freemarker.core.TemplateElement[], java.io.Writer)" map="A"/>
  <method class="freemarker.core.Environment" name="void invoke(freemarker.core.Macro, java.util.Map, java.util.List, java.util.List, freemarker.core.TemplateObject)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.template.TemplateHashModel access$100(freemarker.core.Environment)" map="D"/>
  <method class="freemarker.core.Environment" name="boolean isSQLDateOrTimeClass(java.lang.Class)" map="B"/>
  <method class="freemarker.core.Environment" name="java.lang.Object setCustomState(java.lang.Object, java.lang.Object)" map="B"/>
  <method class="freemarker.core.Environment" name="void setLastReturnValue(freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.template.Template getTemplateForInclusion(java.lang.String, java.lang.String, boolean)" map="B"/>
  <method class="freemarker.core.Environment" name="freemarker.core.TemplateDateFormat getTemplateDateFormat(java.lang.String, int, java.lang.Class)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.core.Environment getCurrentEnvironment()" map="&#x00c7;"/>
  <method class="freemarker.core.Environment" name="java.lang.String rootBasedToAbsoluteTemplateName(java.lang.String)" map="W"/>
  <method class="freemarker.core.Environment" name="java.lang.String getIncludedTemplateEncoding()" map="&#x00c8;"/>
  <method class="freemarker.core.Environment" name="freemarker.core.Macro getEnclosingMacro(freemarker.core.TemplateElement)" map="C"/>
  <method class="freemarker.core.Environment" name="freemarker.core.TemplateDateFormat getTemplateDateFormat(freemarker.template.TemplateDateModel, freemarker.core.Expression, boolean)" map="B"/>
  <method class="freemarker.core.Environment" name="freemarker.template.Template getTemplate()" map="&#x00c9;"/>
  <method class="freemarker.core.Environment" name="void popElement()" map="&#x00ca;"/>
  <method class="freemarker.core.Environment" name="void visit(freemarker.core.TemplateElement[])" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.core.TemplateElement[] getInstructionStackSnapshot()" map="&#x00cb;"/>
  <method class="freemarker.core.Environment" name="freemarker.template.TemplateModel getLastReturnValue()" map="&#x00cc;"/>
  <method class="freemarker.core.Environment" name="freemarker.template.TemplateHashModel getDataModel()" map="&#x00cd;"/>
  <method class="freemarker.core.Environment" name="freemarker.core.TemplateDateFormat getTemplateDateFormat(java.lang.String, int, boolean, boolean, boolean)" map="A"/>
  <method class="freemarker.core.Environment" name="void visit(freemarker.core.TemplateElement)" map="D"/>
  <method class="freemarker.core.Environment" name="boolean isIcI2324OrLater()" map="&#x00ce;"/>
  <method class="freemarker.core.Environment" name="java.lang.String access$700(freemarker.core.Environment)" map="E"/>
  <method class="freemarker.core.Environment" name="void setNumberFormat(java.lang.String)" map="I"/>
  <method class="freemarker.core.Environment" name="void importMacros(freemarker.template.Template)" map="B"/>
  <method class="freemarker.core.Environment" name="freemarker.core.Environment$Namespace getMacroNamespace(freemarker.core.Macro)" map="B"/>
  <method class="freemarker.core.Environment" name="java.lang.String instructionStackItemToString(freemarker.core.TemplateElement)" map="E"/>
  <method class="freemarker.core.Environment" name="boolean isInAttemptBlock()" map="&#x00cf;"/>
  <method class="freemarker.core.Environment" name="void setTemplateExceptionHandler(freemarker.template.TemplateExceptionHandler)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.core.TemplateDateFormat getTemplateDateFormat(java.lang.String, int, java.lang.Class, freemarker.core.Expression, freemarker.core.Expression, boolean)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.core.TemplateNumberFormat getTemplateNumberFormatWithoutCache(java.lang.String, java.util.Locale)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.template.Configuration access$200(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.Environment" name="java.lang.String getDefaultNS()" map="&#x00d0;"/>
  <method class="freemarker.core.Environment" name="void recurse(freemarker.template.TemplateNodeModel, freemarker.template.TemplateSequenceModel)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.core.TemplateDateFormat getTemplateDateFormat(int, java.lang.Class)" map="A"/>
  <method class="freemarker.core.Environment" name="boolean setFastInvalidReferenceExceptions(boolean)" map="J"/>
  <method class="freemarker.core.Environment" name="freemarker.template.TemplateHashModel getGlobalVariables()" map="&#x00d1;"/>
  <method class="freemarker.core.Environment" name="boolean shouldUseSQLDTTimeZone(boolean)" map="K"/>
  <method class="freemarker.core.Environment" name="void setSQLDateAndTimeTimeZone(java.util.TimeZone)" map="B"/>
  <method class="freemarker.core.Environment" name="void setTimeFormat(java.lang.String)" map="N"/>
  <method class="freemarker.core.Environment" name="void initializeImportLibNamespace(freemarker.core.Environment$Namespace, freemarker.template.Template)" map="A"/>
  <method class="freemarker.core.Environment" name="boolean getFastInvalidReferenceExceptions()" map="&#x00d2;"/>
  <method class="freemarker.core.Environment" name="void setVariable(java.lang.String, freemarker.template.TemplateModel)" map="C"/>
  <method class="freemarker.core.Environment" name="freemarker.core.TemplateNumberFormat getTemplateNumberFormat(freemarker.core.Expression, boolean)" map="A"/>
  <method class="freemarker.core.Environment" name="void appendInstructionStackItem(freemarker.core.TemplateElement, java.lang.StringBuilder)" map="A"/>
  <method class="freemarker.core.Environment" name="void setDateTimeFormat(java.lang.String)" map="O"/>
  <method class="freemarker.core.Environment" name="void invokeNestedContent(freemarker.core.BodyInstruction$Context)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.core.LocalContextStack getLocalContextStack()" map="&#x00d3;"/>
  <method class="freemarker.core.Environment" name="freemarker.core.Environment$Namespace importLib(java.lang.String, freemarker.template.Template, java.lang.String)" map="A"/>
  <method class="freemarker.core.Environment" name="void outputInstructionStack(freemarker.core.TemplateElement[], boolean, java.io.Writer)" map="A"/>
  <method class="freemarker.core.Environment" name="java.text.Collator getCollator()" map="&#x00d4;"/>
  <method class="freemarker.core.Environment" name="freemarker.core.TemplateNumberFormat getTemplateNumberFormat(java.lang.String)" map="X"/>
  <method class="freemarker.core.Environment" name="void invokeNodeHandlerFor(freemarker.template.TemplateNodeModel, freemarker.template.TemplateSequenceModel)" map="B"/>
  <method class="freemarker.core.Environment" name="boolean visitIteratorBlock(freemarker.core.IteratorBlock$IterationContext)" map="A"/>
  <method class="freemarker.core.Environment" name="java.lang.String formatDateToPlainText(freemarker.template.TemplateDateModel, java.lang.String, freemarker.core.Expression, freemarker.core.Expression, boolean)" map="A"/>
  <method class="freemarker.core.Environment" name="void setOut(java.io.Writer)" map="A"/>
  <method class="freemarker.core.Environment" name="void handleTemplateException(freemarker.template.TemplateException)" map="A"/>
  <method class="freemarker.core.Environment" name="freemarker.core.TemplateDateFormat getTemplateDateFormatWithoutCache(java.lang.String, int, java.util.Locale, java.util.TimeZone, boolean)" map="A"/>
  <method class="freemarker.core.Environment" name="java.lang.Object access$800(freemarker.core.Environment)" map="G"/>
  <class name="freemarker.core.FMParserConstants" map="VA"/>
  <field class="freemarker.core.FMParserConstants" name="tokenImage" map="A"/>
  <class name="freemarker.core._ErrorDescriptionBuilder$1" map="1"/>
  <class name="freemarker.core._ErrorDescriptionBuilder$Blaming" map="_A"/>
  <field class="freemarker.core._ErrorDescriptionBuilder$Blaming" name="blamer" map="A"/>
  <field class="freemarker.core._ErrorDescriptionBuilder$Blaming" name="roleOfblamed" map="B"/>
  <class name="freemarker.core._ErrorDescriptionBuilder" map="WA"/>
  <field class="freemarker.core._ErrorDescriptionBuilder" name="tips" map="A"/>
  <field class="freemarker.core._ErrorDescriptionBuilder" name="descriptionParts" map="B"/>
  <field class="freemarker.core._ErrorDescriptionBuilder" name="LOG" map="C"/>
  <field class="freemarker.core._ErrorDescriptionBuilder" name="blamed" map="D"/>
  <field class="freemarker.core._ErrorDescriptionBuilder" name="template" map="E"/>
  <field class="freemarker.core._ErrorDescriptionBuilder" name="description" map="F"/>
  <field class="freemarker.core._ErrorDescriptionBuilder" name="tip" map="G"/>
  <field class="freemarker.core._ErrorDescriptionBuilder" name="showBlamer" map="H"/>
  <method class="freemarker.core._ErrorDescriptionBuilder" name="java.lang.String toString(java.lang.Object)" map="A"/>
  <method class="freemarker.core._ErrorDescriptionBuilder" name="java.lang.String[] splitToLines(java.lang.String)" map="A"/>
  <method class="freemarker.core._ErrorDescriptionBuilder" name="boolean containsSingleInterpolatoinLiteral(freemarker.core.Expression, int)" map="A"/>
  <method class="freemarker.core._ErrorDescriptionBuilder" name="freemarker.core._ErrorDescriptionBuilder showBlamer(boolean)" map="A"/>
  <method class="freemarker.core._ErrorDescriptionBuilder" name="freemarker.core._ErrorDescriptionBuilder tips(java.lang.Object[])" map="A"/>
  <method class="freemarker.core._ErrorDescriptionBuilder" name="freemarker.core._ErrorDescriptionBuilder tip(java.lang.Object)" map="B"/>
  <method class="freemarker.core._ErrorDescriptionBuilder" name="freemarker.core._ErrorDescriptionBuilder$Blaming findBlaming(freemarker.core.TemplateObject, freemarker.core.Expression, int)" map="A"/>
  <method class="freemarker.core._ErrorDescriptionBuilder" name="java.lang.String toString(java.lang.Object, boolean)" map="A"/>
  <method class="freemarker.core._ErrorDescriptionBuilder" name="java.lang.String tryToString(java.lang.Object)" map="C"/>
  <method class="freemarker.core._ErrorDescriptionBuilder" name="freemarker.core._ErrorDescriptionBuilder tip(java.lang.Object[])" map="B"/>
  <method class="freemarker.core._ErrorDescriptionBuilder" name="java.lang.String toString(freemarker.core.TemplateElement, boolean)" map="A"/>
  <method class="freemarker.core._ErrorDescriptionBuilder" name="freemarker.core._ErrorDescriptionBuilder tip(java.lang.String)" map="B"/>
  <method class="freemarker.core._ErrorDescriptionBuilder" name="freemarker.core._ErrorDescriptionBuilder blame(freemarker.core.Expression)" map="A"/>
  <method class="freemarker.core._ErrorDescriptionBuilder" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.core._ErrorDescriptionBuilder" name="void appendParts(java.lang.StringBuilder, java.lang.Object[])" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsEncoding$js_stringBI" map="_A"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$js_stringBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsEncoding$j_stringBI" map="_B"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$j_stringBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsEncoding$urlBI$UrlBIResult" map="_A"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$urlBI$UrlBIResult" name="java.lang.String encodeWithCharset(java.lang.String)" map="F"/>
  <class name="freemarker.core.BuiltInsForStringsEncoding$urlBI" map="_C"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$urlBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsEncoding$xmlBI" map="_D"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$xmlBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core.BuiltInsForStringsEncoding$AbstractUrlBIResult" map="_E"/>
  <field class="freemarker.core.BuiltInsForStringsEncoding$AbstractUrlBIResult" name="cachedResult" map="&#x0131;"/>
  <field class="freemarker.core.BuiltInsForStringsEncoding$AbstractUrlBIResult" name="env" map="&#x0132;"/>
  <field class="freemarker.core.BuiltInsForStringsEncoding$AbstractUrlBIResult" name="parent" map="&#x0133;"/>
  <field class="freemarker.core.BuiltInsForStringsEncoding$AbstractUrlBIResult" name="targetAsString" map="&#x0134;"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$AbstractUrlBIResult" name="java.lang.Object exec(java.util.List)" map="A"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$AbstractUrlBIResult" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$AbstractUrlBIResult" name="java.lang.String encodeWithCharset(java.lang.String)" map="F"/>
  <class name="freemarker.core.BuiltInsForStringsEncoding$json_stringBI" map="_F"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$json_stringBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsEncoding$htmlBI$BIBeforeICI2d3d20" map="_A"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$htmlBI$BIBeforeICI2d3d20" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core.BuiltInsForStringsEncoding$htmlBI" map="_G"/>
  <field class="freemarker.core.BuiltInsForStringsEncoding$htmlBI" name="prevICIObj" map="p"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$htmlBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="B"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$htmlBI" name="java.lang.Object getPreviousICIChainMember()" map="S"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$htmlBI" name="int getMinimumICIVersion()" map="T"/>
  <class name="freemarker.core.BuiltInsForStringsEncoding$rtfBI" map="_H"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$rtfBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core.BuiltInsForStringsEncoding$xhtmlBI" map="_I"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$xhtmlBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core.BuiltInsForStringsEncoding$urlPathBI$UrlPathBIResult" map="_A"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$urlPathBI$UrlPathBIResult" name="java.lang.String encodeWithCharset(java.lang.String)" map="F"/>
  <class name="freemarker.core.BuiltInsForStringsEncoding$urlPathBI" map="_J"/>
  <method class="freemarker.core.BuiltInsForStringsEncoding$urlPathBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsEncoding" map="XA"/>
  <class name="freemarker.core.Comment" map="YA"/>
  <field class="freemarker.core.Comment" name="text" map="&#x00ea;"/>
  <method class="freemarker.core.Comment" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.Comment" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.Comment" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.Comment" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.Comment" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.Comment" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.ParseException" map="ZA"/>
  <field class="freemarker.core.ParseException" name="expectedTokenSequences" map="B"/>
  <field class="freemarker.core.ParseException" name="columnNumber" map="C"/>
  <field class="freemarker.core.ParseException" name="messageAndDescriptionRendered" map="D"/>
  <field class="freemarker.core.ParseException" name="tokenImage" map="A"/>
  <field class="freemarker.core.ParseException" name="lineNumber" map="E"/>
  <field class="freemarker.core.ParseException" name="currentToken" map="F"/>
  <field class="freemarker.core.ParseException" name="endColumnNumber" map="G"/>
  <field class="freemarker.core.ParseException" name="eol" map="H"/>
  <field class="freemarker.core.ParseException" name="specialConstructor" map="I"/>
  <field class="freemarker.core.ParseException" name="description" map="J"/>
  <field class="freemarker.core.ParseException" name="jbossToolsMode" map="K"/>
  <field class="freemarker.core.ParseException" name="templateName" map="L"/>
  <field class="freemarker.core.ParseException" name="endLineNumber" map="M"/>
  <field class="freemarker.core.ParseException" name="message" map="N"/>
  <method class="freemarker.core.ParseException" name="void renderMessageAndDescription()" map="A"/>
  <method class="freemarker.core.ParseException" name="java.lang.String concatWithOrs(java.util.Set)" map="A"/>
  <method class="freemarker.core.ParseException" name="java.lang.String getMessage()" map="getMessage"/>
  <method class="freemarker.core.ParseException" name="java.lang.String getCustomTokenErrorDescription()" map="B"/>
  <method class="freemarker.core.ParseException" name="void setTemplateName(java.lang.String)" map="A"/>
  <method class="freemarker.core.ParseException" name="java.lang.String add_escapes(java.lang.String)" map="B"/>
  <method class="freemarker.core.ParseException" name="boolean isInJBossToolsMode()" map="C"/>
  <method class="freemarker.core.ParseException" name="java.lang.String getOrRenderDescription()" map="D"/>
  <class name="freemarker.core.CSSOutputFormat" map="_A"/>
  <field class="freemarker.core.CSSOutputFormat" name="INSTANCE" map="B"/>
  <method class="freemarker.core.CSSOutputFormat" name="java.lang.String getMimeType()" map="B"/>
  <method class="freemarker.core.CSSOutputFormat" name="java.lang.String getName()" map="C"/>
  <method class="freemarker.core.CSSOutputFormat" name="boolean isOutputFormatMixingAllowed()" map="D"/>
  <class name="freemarker.core.AttemptBlock" map="aA"/>
  <field class="freemarker.core.AttemptBlock" name="recoverySection" map="&#x00eb;"/>
  <field class="freemarker.core.AttemptBlock" name="attemptedSection" map="&#x00ec;"/>
  <method class="freemarker.core.AttemptBlock" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.AttemptBlock" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.AttemptBlock" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.AttemptBlock" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.AttemptBlock" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.AttemptBlock" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.BuiltInsForOutputFormatRelated$escBI" map="_A"/>
  <method class="freemarker.core.BuiltInsForOutputFormatRelated$escBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.MarkupOutputFormat, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForOutputFormatRelated$no_escBI" map="_B"/>
  <method class="freemarker.core.BuiltInsForOutputFormatRelated$no_escBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.MarkupOutputFormat, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForOutputFormatRelated$AbstractConverterBI" map="_C"/>
  <method class="freemarker.core.BuiltInsForOutputFormatRelated$AbstractConverterBI" name="freemarker.template.TemplateModel calculateResult(freemarker.core.Environment)" map="I"/>
  <method class="freemarker.core.BuiltInsForOutputFormatRelated$AbstractConverterBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.MarkupOutputFormat, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForOutputFormatRelated" map="bA"/>
  <class name="freemarker.core.ReturnInstruction$Return" map="_A"/>
  <field class="freemarker.core.ReturnInstruction$Return" name="INSTANCE" map="A"/>
  <class name="freemarker.core.ReturnInstruction" map="cA"/>
  <field class="freemarker.core.ReturnInstruction" name="exp" map="&#x00ed;"/>
  <method class="freemarker.core.ReturnInstruction" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.ReturnInstruction" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.ReturnInstruction" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.ReturnInstruction" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.ReturnInstruction" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.ReturnInstruction" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.InvalidReferenceException" map="dA"/>
  <field class="freemarker.core.InvalidReferenceException" name="FAST_INSTANCE" map="U"/>
  <field class="freemarker.core.InvalidReferenceException" name="TIP" map="V"/>
  <field class="freemarker.core.InvalidReferenceException" name="TIP_MISSING_ASSIGNMENT_TARGET" map="W"/>
  <method class="freemarker.core.InvalidReferenceException" name="freemarker.core.InvalidReferenceException getInstance(int, java.lang.String, java.lang.String, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.InvalidReferenceException" name="boolean endsWithDollarVariable(freemarker.core.Expression)" map="A"/>
  <method class="freemarker.core.InvalidReferenceException" name="freemarker.core.InvalidReferenceException getInstance(freemarker.core.Expression, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInForMarkupOutput" map="eA"/>
  <method class="freemarker.core.BuiltInForMarkupOutput" name="freemarker.template.TemplateModel calculateResult(freemarker.core.TemplateMarkupOutputModel)" map="A"/>
  <method class="freemarker.core.BuiltInForMarkupOutput" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.UnknownDateTypeFormattingUnsupportedException" map="fA"/>
  <class name="freemarker.core.NonMethodException" map="gA"/>
  <field class="freemarker.core.NonMethodException" name="EXPECTED_TYPES" map="c"/>
  <class name="freemarker.core.BuiltInForLegacyEscaping" map="hA"/>
  <method class="freemarker.core.BuiltInForLegacyEscaping" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="B"/>
  <method class="freemarker.core.BuiltInForLegacyEscaping" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.TransformBlock" map="iA"/>
  <field class="freemarker.core.TransformBlock" name="transformExpression" map="&#x00ee;"/>
  <field class="freemarker.core.TransformBlock" name="namedArgs" map="&#x00ef;"/>
  <field class="freemarker.core.TransformBlock" name="sortedNamedArgsCache" map="&#x00f0;"/>
  <method class="freemarker.core.TransformBlock" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.TransformBlock" name="java.util.List getSortedNamedArgs()" map="k"/>
  <method class="freemarker.core.TransformBlock" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.TransformBlock" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.TransformBlock" name="boolean isShownInStackTrace()" map="d"/>
  <method class="freemarker.core.TransformBlock" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.TransformBlock" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.TransformBlock" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.Macro$Context" map="_A"/>
  <field class="freemarker.core.Macro$Context" name="this$0" map="A"/>
  <field class="freemarker.core.Macro$Context" name="prevLocalContextStack" map="B"/>
  <field class="freemarker.core.Macro$Context" name="callPlace" map="C"/>
  <field class="freemarker.core.Macro$Context" name="prevMacroContext" map="D"/>
  <field class="freemarker.core.Macro$Context" name="localVars" map="E"/>
  <field class="freemarker.core.Macro$Context" name="nestedContentParameterNames" map="F"/>
  <field class="freemarker.core.Macro$Context" name="nestedContentNamespace" map="G"/>
  <method class="freemarker.core.Macro$Context" name="freemarker.core.Environment$Namespace getLocals()" map="B"/>
  <method class="freemarker.core.Macro$Context" name="java.util.Collection getLocalVariableNames()" map="A"/>
  <method class="freemarker.core.Macro$Context" name="void setLocalVar(java.lang.String, freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.core.Macro$Context" name="freemarker.core.Macro getMacro()" map="C"/>
  <method class="freemarker.core.Macro$Context" name="freemarker.template.TemplateModel getLocalVariable(java.lang.String)" map="A"/>
  <method class="freemarker.core.Macro$Context" name="void sanityCheck(freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.Macro" map="jA"/>
  <field class="freemarker.core.Macro" name="function" map="&#x0123;"/>
  <field class="freemarker.core.Macro" name="DO_NOTHING_MACRO" map="&#x0124;"/>
  <field class="freemarker.core.Macro" name="name" map="&#x0125;"/>
  <field class="freemarker.core.Macro" name="paramDefaults" map="&#x0126;"/>
  <field class="freemarker.core.Macro" name="catchAllParamName" map="&#x0127;"/>
  <field class="freemarker.core.Macro" name="paramNames" map="&#x0128;"/>
  <method class="freemarker.core.Macro" name="boolean hasArgNamed(java.lang.String)" map="D"/>
  <method class="freemarker.core.Macro" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.Macro" name="boolean isFunction()" map="t"/>
  <method class="freemarker.core.Macro" name="java.lang.String[] getArgumentNamesInternal()" map="u"/>
  <method class="freemarker.core.Macro" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.Macro" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.Macro" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.Macro" name="java.lang.String getCatchAll()" map="v"/>
  <method class="freemarker.core.Macro" name="java.lang.String[] access$000(freemarker.core.Macro)" map="A"/>
  <method class="freemarker.core.Macro" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.Macro" name="java.lang.String getName()" map="w"/>
  <method class="freemarker.core.Macro" name="java.lang.String access$200(freemarker.core.Macro)" map="B"/>
  <method class="freemarker.core.Macro" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.Macro" name="java.util.Map access$100(freemarker.core.Macro)" map="C"/>
  <class name="freemarker.core.ElseOfList" map="kA"/>
  <method class="freemarker.core.ElseOfList" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.ElseOfList" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.ElseOfList" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.ElseOfList" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.ElseOfList" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.ElseOfList" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.NonDateException" map="lA"/>
  <field class="freemarker.core.NonDateException" name="EXPECTED_TYPES" map="d"/>
  <class name="freemarker.core.BodyInstruction$Context" map="_A"/>
  <field class="freemarker.core.BodyInstruction$Context" name="this$0" map="H"/>
  <field class="freemarker.core.BodyInstruction$Context" name="invokingMacroContext" map="I"/>
  <field class="freemarker.core.BodyInstruction$Context" name="bodyVars" map="J"/>
  <method class="freemarker.core.BodyInstruction$Context" name="java.util.Collection getLocalVariableNames()" map="A"/>
  <method class="freemarker.core.BodyInstruction$Context" name="freemarker.template.TemplateModel getLocalVariable(java.lang.String)" map="A"/>
  <class name="freemarker.core.BodyInstruction" map="mA"/>
  <field class="freemarker.core.BodyInstruction" name="bodyParameters" map="&#x00f1;"/>
  <method class="freemarker.core.BodyInstruction" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.BodyInstruction" name="java.util.List access$000(freemarker.core.BodyInstruction)" map="A"/>
  <method class="freemarker.core.BodyInstruction" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.BodyInstruction" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.BodyInstruction" name="boolean isShownInStackTrace()" map="d"/>
  <method class="freemarker.core.BodyInstruction" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.BodyInstruction" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.BodyInstruction" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.BodyInstruction" name="void checkIndex(int)" map="K"/>
  <class name="freemarker.core.VisitNode" map="nA"/>
  <field class="freemarker.core.VisitNode" name="namespaces" map="&#x00f2;"/>
  <field class="freemarker.core.VisitNode" name="targetNode" map="&#x00f3;"/>
  <method class="freemarker.core.VisitNode" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.VisitNode" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.VisitNode" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.VisitNode" name="boolean isShownInStackTrace()" map="d"/>
  <method class="freemarker.core.VisitNode" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.VisitNode" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.VisitNode" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.PropertySetting" map="oA"/>
  <field class="freemarker.core.PropertySetting" name="key" map="&#x00f4;"/>
  <field class="freemarker.core.PropertySetting" name="SETTING_NAMES" map="&#x00f5;"/>
  <field class="freemarker.core.PropertySetting" name="value" map="&#x00f6;"/>
  <method class="freemarker.core.PropertySetting" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.PropertySetting" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.PropertySetting" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.PropertySetting" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.PropertySetting" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.PropertySetting" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.SimpleCharStream" map="pA"/>
  <field class="freemarker.core.SimpleCharStream" name="bufpos" map="A"/>
  <field class="freemarker.core.SimpleCharStream" name="inputStream" map="B"/>
  <field class="freemarker.core.SimpleCharStream" name="tokenBegin" map="C"/>
  <field class="freemarker.core.SimpleCharStream" name="prevCharIsCR" map="D"/>
  <field class="freemarker.core.SimpleCharStream" name="available" map="E"/>
  <field class="freemarker.core.SimpleCharStream" name="bufsize" map="F"/>
  <field class="freemarker.core.SimpleCharStream" name="bufline" map="G"/>
  <field class="freemarker.core.SimpleCharStream" name="column" map="H"/>
  <field class="freemarker.core.SimpleCharStream" name="trackLineColumn" map="I"/>
  <field class="freemarker.core.SimpleCharStream" name="inBuf" map="J"/>
  <field class="freemarker.core.SimpleCharStream" name="maxNextCharInd" map="K"/>
  <field class="freemarker.core.SimpleCharStream" name="buffer" map="L"/>
  <field class="freemarker.core.SimpleCharStream" name="tabSize" map="M"/>
  <field class="freemarker.core.SimpleCharStream" name="prevCharIsLF" map="N"/>
  <field class="freemarker.core.SimpleCharStream" name="bufcolumn" map="O"/>
  <field class="freemarker.core.SimpleCharStream" name="line" map="P"/>
  <method class="freemarker.core.SimpleCharStream" name="void backup(int)" map="A"/>
  <method class="freemarker.core.SimpleCharStream" name="void FillBuff()" map="A"/>
  <method class="freemarker.core.SimpleCharStream" name="char readChar()" map="B"/>
  <method class="freemarker.core.SimpleCharStream" name="java.lang.String GetImage()" map="C"/>
  <method class="freemarker.core.SimpleCharStream" name="void ExpandBuff(boolean)" map="A"/>
  <method class="freemarker.core.SimpleCharStream" name="char[] GetSuffix(int)" map="B"/>
  <method class="freemarker.core.SimpleCharStream" name="char BeginToken()" map="D"/>
  <method class="freemarker.core.SimpleCharStream" name="int getEndLine()" map="E"/>
  <method class="freemarker.core.SimpleCharStream" name="void UpdateLineColumn(char)" map="A"/>
  <method class="freemarker.core.SimpleCharStream" name="void setTabSize(int)" map="C"/>
  <method class="freemarker.core.SimpleCharStream" name="int getBeginColumn()" map="F"/>
  <method class="freemarker.core.SimpleCharStream" name="int getBeginLine()" map="G"/>
  <method class="freemarker.core.SimpleCharStream" name="int getEndColumn()" map="H"/>
  <class name="freemarker.core.RecurseNode" map="qA"/>
  <field class="freemarker.core.RecurseNode" name="namespaces" map="&#x00f8;"/>
  <field class="freemarker.core.RecurseNode" name="targetNode" map="&#x00f9;"/>
  <method class="freemarker.core.RecurseNode" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.RecurseNode" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.RecurseNode" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.RecurseNode" name="boolean isShownInStackTrace()" map="d"/>
  <method class="freemarker.core.RecurseNode" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.RecurseNode" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.RecurseNode" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.Token" map="rA"/>
  <field class="freemarker.core.Token" name="beginLine" map="A"/>
  <field class="freemarker.core.Token" name="next" map="B"/>
  <field class="freemarker.core.Token" name="kind" map="C"/>
  <field class="freemarker.core.Token" name="endLine" map="D"/>
  <field class="freemarker.core.Token" name="beginColumn" map="E"/>
  <field class="freemarker.core.Token" name="image" map="F"/>
  <field class="freemarker.core.Token" name="endColumn" map="G"/>
  <method class="freemarker.core.Token" name="freemarker.core.Token newToken(int, java.lang.String)" map="A"/>
  <method class="freemarker.core.Token" name="java.lang.String toString()" map="toString"/>
  <class name="freemarker.core.TemplateMarkupOutputModel" map="sA"/>
  <method class="freemarker.core.TemplateMarkupOutputModel" name="freemarker.core.MarkupOutputFormat getOutputFormat()" map="x"/>
  <class name="freemarker.core.LibraryLoad" map="tA"/>
  <field class="freemarker.core.LibraryLoad" name="targetNsVarName" map="&#x00fa;"/>
  <field class="freemarker.core.LibraryLoad" name="importedTemplateNameExp" map="&#x00fb;"/>
  <method class="freemarker.core.LibraryLoad" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.LibraryLoad" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.LibraryLoad" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.LibraryLoad" name="boolean isShownInStackTrace()" map="d"/>
  <method class="freemarker.core.LibraryLoad" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.LibraryLoad" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.LibraryLoad" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.ListableRightUnboundedRangeModel$1" map="1"/>
  <field class="freemarker.core.ListableRightUnboundedRangeModel$1" name="this$0" map="&#x019d;"/>
  <field class="freemarker.core.ListableRightUnboundedRangeModel$1" name="nextBigInteger" map="&#x019e;"/>
  <field class="freemarker.core.ListableRightUnboundedRangeModel$1" name="nextLong" map="&#x019f;"/>
  <field class="freemarker.core.ListableRightUnboundedRangeModel$1" name="needInc" map="&#x01a0;"/>
  <field class="freemarker.core.ListableRightUnboundedRangeModel$1" name="nextInt" map="&#x01a1;"/>
  <field class="freemarker.core.ListableRightUnboundedRangeModel$1" name="nextType" map="&#x01a2;"/>
  <method class="freemarker.core.ListableRightUnboundedRangeModel$1" name="boolean hasNext()" map="&#x00d1;"/>
  <method class="freemarker.core.ListableRightUnboundedRangeModel$1" name="freemarker.template.TemplateModel next()" map="&#x00d2;"/>
  <class name="freemarker.core.ListableRightUnboundedRangeModel" map="uA"/>
  <method class="freemarker.core.ListableRightUnboundedRangeModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.core.ListableRightUnboundedRangeModel" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <class name="freemarker.core.JavaScriptOutputFormat" map="vA"/>
  <field class="freemarker.core.JavaScriptOutputFormat" name="INSTANCE" map="C"/>
  <method class="freemarker.core.JavaScriptOutputFormat" name="java.lang.String getMimeType()" map="B"/>
  <method class="freemarker.core.JavaScriptOutputFormat" name="java.lang.String getName()" map="C"/>
  <method class="freemarker.core.JavaScriptOutputFormat" name="boolean isOutputFormatMixingAllowed()" map="D"/>
  <class name="freemarker.core.BuiltInsForMarkupOutputs$markup_stringBI" map="_A"/>
  <method class="freemarker.core.BuiltInsForMarkupOutputs$markup_stringBI" name="freemarker.template.TemplateModel calculateResult(freemarker.core.TemplateMarkupOutputModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForMarkupOutputs" map="wA"/>
  <class name="freemarker.core.PlainTextOutputFormat" map="xA"/>
  <field class="freemarker.core.PlainTextOutputFormat" name="INSTANCE" map="D"/>
  <method class="freemarker.core.PlainTextOutputFormat" name="java.lang.String getMimeType()" map="B"/>
  <method class="freemarker.core.PlainTextOutputFormat" name="java.lang.String getName()" map="C"/>
  <method class="freemarker.core.PlainTextOutputFormat" name="boolean isOutputFormatMixingAllowed()" map="D"/>
  <class name="freemarker.core.RightUnboundedRangeModel" map="yA"/>
  <method class="freemarker.core.RightUnboundedRangeModel" name="int getStep()" map="&#x00fa;"/>
  <method class="freemarker.core.RightUnboundedRangeModel" name="boolean isRightUnbounded()" map="&#x00fc;"/>
  <method class="freemarker.core.RightUnboundedRangeModel" name="boolean isRightAdaptive()" map="&#x00fd;"/>
  <method class="freemarker.core.RightUnboundedRangeModel" name="boolean isAffactedByStringSlicingBug()" map="&#x00fe;"/>
  <class name="freemarker.core._MiscTemplateException" map="zA"/>
  <class name="freemarker.core.TemplateXHTMLOutputModel" map="$B"/>
  <method class="freemarker.core.TemplateXHTMLOutputModel" name="freemarker.core.MarkupOutputFormat getOutputFormat()" map="x"/>
  <method class="freemarker.core.TemplateXHTMLOutputModel" name="freemarker.core.XHTMLOutputFormat getOutputFormat()" map="&#x00a4;"/>
  <class name="freemarker.core.LocalContext" map="AB"/>
  <method class="freemarker.core.LocalContext" name="java.util.Collection getLocalVariableNames()" map="A"/>
  <method class="freemarker.core.LocalContext" name="freemarker.template.TemplateModel getLocalVariable(java.lang.String)" map="A"/>
  <class name="freemarker.core.UnparsableValueException" map="BB"/>
  <class name="freemarker.core._DelayedShortClassName" map="CB"/>
  <method class="freemarker.core._DelayedShortClassName" name="java.lang.String doConversion(java.lang.Object)" map="A"/>
  <class name="freemarker.core.TrimInstruction" map="DB"/>
  <field class="freemarker.core.TrimInstruction" name="right" map="&#x00fc;"/>
  <field class="freemarker.core.TrimInstruction" name="left" map="&#x00fd;"/>
  <method class="freemarker.core.TrimInstruction" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.TrimInstruction" name="boolean isIgnorable(boolean)" map="D"/>
  <method class="freemarker.core.TrimInstruction" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.TrimInstruction" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.TrimInstruction" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.TrimInstruction" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.TrimInstruction" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.RangeModel" map="EB"/>
  <field class="freemarker.core.RangeModel" name="begin" map="&#x0264;"/>
  <method class="freemarker.core.RangeModel" name="int getStep()" map="&#x00fa;"/>
  <method class="freemarker.core.RangeModel" name="int getBegining()" map="&#x00fb;"/>
  <method class="freemarker.core.RangeModel" name="boolean isRightUnbounded()" map="&#x00fc;"/>
  <method class="freemarker.core.RangeModel" name="boolean isRightAdaptive()" map="&#x00fd;"/>
  <method class="freemarker.core.RangeModel" name="boolean isAffactedByStringSlicingBug()" map="&#x00fe;"/>
  <method class="freemarker.core.RangeModel" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <class name="freemarker.core.TemplateElements" map="FB"/>
  <field class="freemarker.core.TemplateElements" name="buffer" map="A"/>
  <field class="freemarker.core.TemplateElements" name="count" map="B"/>
  <field class="freemarker.core.TemplateElements" name="EMPTY" map="C"/>
  <method class="freemarker.core.TemplateElements" name="freemarker.core.TemplateElement asSingleElement()" map="A"/>
  <method class="freemarker.core.TemplateElements" name="int getCount()" map="B"/>
  <method class="freemarker.core.TemplateElements" name="freemarker.core.TemplateElement getLast()" map="C"/>
  <method class="freemarker.core.TemplateElements" name="freemarker.core.TemplateElement[] getBuffer()" map="D"/>
  <class name="freemarker.core.NoEscapeBlock" map="GB"/>
  <method class="freemarker.core.NoEscapeBlock" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.NoEscapeBlock" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.NoEscapeBlock" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.NoEscapeBlock" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.NoEscapeBlock" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.NoEscapeBlock" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.BuiltInBannedWhenAutoEscaping" map="HB"/>
  <class name="freemarker.core.NoAutoEscBlock" map="IB"/>
  <method class="freemarker.core.NoAutoEscBlock" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.NoAutoEscBlock" name="boolean isIgnorable(boolean)" map="D"/>
  <method class="freemarker.core.NoAutoEscBlock" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.NoAutoEscBlock" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.NoAutoEscBlock" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.NoAutoEscBlock" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.NoAutoEscBlock" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$word_listBI" map="_A"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$word_listBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$index_ofBI$BIMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$index_ofBI$BIMethod" name="this$0" map="&#x013b;"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$index_ofBI$BIMethod" name="s" map="&#x013c;"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$index_ofBI$BIMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$index_ofBI" map="_B"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$index_ofBI" name="findLast" map="w"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$index_ofBI" name="boolean access$400(freemarker.core.BuiltInsForStringsBasic$index_ofBI)" map="A"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$index_ofBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$substringBI$1" map="1"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$substringBI$1" name="this$0" map="&#x013d;"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$substringBI$1" name="val$s" map="&#x013e;"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$substringBI$1" name="freemarker.template.TemplateModelException newIndexGreaterThanLengthException(int, int, int)" map="B"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$substringBI$1" name="freemarker.template.TemplateModelException newIndexLessThan0Exception(int, int)" map="C"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$substringBI$1" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$substringBI" map="_C"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$substringBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$uncap_firstBI" map="_D"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$uncap_firstBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$ensure_ends_withBI$BIMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$ensure_ends_withBI$BIMethod" name="this$0" map="&#x013f;"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$ensure_ends_withBI$BIMethod" name="s" map="&#x0140;"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$ensure_ends_withBI$BIMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$ensure_ends_withBI" map="_E"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$ensure_ends_withBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$keep_before_lastBI$KeepUntilMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$keep_before_lastBI$KeepUntilMethod" name="this$0" map="&#x0141;"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$keep_before_lastBI$KeepUntilMethod" name="s" map="&#x0142;"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$keep_before_lastBI$KeepUntilMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$keep_before_lastBI" map="_F"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$keep_before_lastBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$remove_beginningBI$BIMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$remove_beginningBI$BIMethod" name="this$0" map="&#x0143;"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$remove_beginningBI$BIMethod" name="s" map="&#x0144;"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$remove_beginningBI$BIMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$remove_beginningBI" map="_G"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$remove_beginningBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$capitalizeBI" map="_H"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$capitalizeBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$keep_after_lastBI$KeepAfterMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$keep_after_lastBI$KeepAfterMethod" name="this$0" map="&#x0145;"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$keep_after_lastBI$KeepAfterMethod" name="s" map="&#x0146;"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$keep_after_lastBI$KeepAfterMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$keep_after_lastBI" map="_I"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$keep_after_lastBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$chop_linebreakBI" map="_J"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$chop_linebreakBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$cap_firstBI" map="_K"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$cap_firstBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$trimBI" map="_L"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$trimBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$split_BI$SplitMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$split_BI$SplitMethod" name="this$0" map="&#x026c;"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$split_BI$SplitMethod" name="s" map="&#x026d;"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$split_BI$SplitMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$split_BI" map="_M"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$split_BI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$upper_caseBI" map="_N"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$upper_caseBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$ensure_starts_withBI$BIMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$ensure_starts_withBI$BIMethod" name="this$0" map="&#x0147;"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$ensure_starts_withBI$BIMethod" name="s" map="&#x0148;"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$ensure_starts_withBI$BIMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$ensure_starts_withBI" map="_O"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$ensure_starts_withBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$lengthBI" map="_P"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$lengthBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$keep_afterBI$KeepAfterMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$keep_afterBI$KeepAfterMethod" name="this$0" map="&#x0149;"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$keep_afterBI$KeepAfterMethod" name="s" map="&#x014a;"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$keep_afterBI$KeepAfterMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$keep_afterBI" map="_Q"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$keep_afterBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$lower_caseBI" map="_R"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$lower_caseBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$padBI$BIMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$padBI$BIMethod" name="this$0" map="&#x014b;"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$padBI$BIMethod" name="s" map="&#x014c;"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$padBI$BIMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$padBI" map="_S"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$padBI" name="leftPadder" map="x"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$padBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$padBI" name="boolean access$600(freemarker.core.BuiltInsForStringsBasic$padBI)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$containsBI$BIMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$containsBI$BIMethod" name="this$0" map="&#x014d;"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$containsBI$BIMethod" name="s" map="&#x014e;"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$containsBI$BIMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$containsBI" map="_T"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$containsBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$starts_withBI$BIMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$starts_withBI$BIMethod" name="this$0" map="&#x014f;"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$starts_withBI$BIMethod" name="s" map="&#x0150;"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$starts_withBI$BIMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$starts_withBI" map="_U"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$starts_withBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$1" map="1"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$remove_endingBI$BIMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$remove_endingBI$BIMethod" name="this$0" map="&#x0151;"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$remove_endingBI$BIMethod" name="s" map="&#x0152;"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$remove_endingBI$BIMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$remove_endingBI" map="_V"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$remove_endingBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$keep_beforeBI$KeepUntilMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$keep_beforeBI$KeepUntilMethod" name="this$0" map="&#x0153;"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$keep_beforeBI$KeepUntilMethod" name="s" map="&#x0154;"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$keep_beforeBI$KeepUntilMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$keep_beforeBI" map="_W"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$keep_beforeBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$ends_withBI$BIMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$ends_withBI$BIMethod" name="this$0" map="&#x0155;"/>
  <field class="freemarker.core.BuiltInsForStringsBasic$ends_withBI$BIMethod" name="s" map="&#x0156;"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$ends_withBI$BIMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsBasic$ends_withBI" map="_X"/>
  <method class="freemarker.core.BuiltInsForStringsBasic$ends_withBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsBasic" map="JB"/>
  <class name="freemarker.core._UnmodifiableSet" map="KB"/>
  <method class="freemarker.core._UnmodifiableSet" name="void clear()" map="clear"/>
  <method class="freemarker.core._UnmodifiableSet" name="boolean remove(java.lang.Object)" map="remove"/>
  <method class="freemarker.core._UnmodifiableSet" name="boolean add(java.lang.Object)" map="add"/>
  <class name="freemarker.core.ContinueInstruction" map="LB"/>
  <method class="freemarker.core.ContinueInstruction" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.ContinueInstruction" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.ContinueInstruction" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.ContinueInstruction" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.ContinueInstruction" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.ContinueInstruction" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.NonSequenceOrCollectionException" map="MB"/>
  <field class="freemarker.core.NonSequenceOrCollectionException" name="EXPECTED_TYPES" map="e"/>
  <method class="freemarker.core.NonSequenceOrCollectionException" name="boolean isWrappedIterable(freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.core.NonSequenceOrCollectionException" name="java.lang.Object[] extendTipsIfIterable(freemarker.template.TemplateModel, java.lang.Object[])" map="A"/>
  <class name="freemarker.core.DebugBreak" map="NB"/>
  <method class="freemarker.core.DebugBreak" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.DebugBreak" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.DebugBreak" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.DebugBreak" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.DebugBreak" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.DebugBreak" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser$9" map="9"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser$9" name="void handle(freemarker.core.ExtendedDecimalFormatParser, java.lang.String)" map="A"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser$8" map="8"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser$8" name="void handle(freemarker.core.ExtendedDecimalFormatParser, java.lang.String)" map="A"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser$7" map="7"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser$7" name="void handle(freemarker.core.ExtendedDecimalFormatParser, java.lang.String)" map="A"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser$6" map="6"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser$6" name="void handle(freemarker.core.ExtendedDecimalFormatParser, java.lang.String)" map="A"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser$5" map="5"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser$5" name="void handle(freemarker.core.ExtendedDecimalFormatParser, java.lang.String)" map="A"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser$13" map="13"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser$13" name="void handle(freemarker.core.ExtendedDecimalFormatParser, java.lang.String)" map="A"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser$4" map="4"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser$4" name="void handle(freemarker.core.ExtendedDecimalFormatParser, java.lang.String)" map="A"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser$3" map="3"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser$3" name="void handle(freemarker.core.ExtendedDecimalFormatParser, java.lang.String)" map="A"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser$12" map="12"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser$12" name="void handle(freemarker.core.ExtendedDecimalFormatParser, java.lang.String)" map="A"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser$2" map="2"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser$2" name="void handle(freemarker.core.ExtendedDecimalFormatParser, java.lang.String)" map="A"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser$11" map="11"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser$11" name="void handle(freemarker.core.ExtendedDecimalFormatParser, java.lang.String)" map="A"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser$10" map="10"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser$10" name="void handle(freemarker.core.ExtendedDecimalFormatParser, java.lang.String)" map="A"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser$1" map="1"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser$1" name="void handle(freemarker.core.ExtendedDecimalFormatParser, java.lang.String)" map="A"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser$ParameterHandler" map="_A"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser$ParameterHandler" name="void handle(freemarker.core.ExtendedDecimalFormatParser, java.lang.String)" map="A"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser$InvalidParameterValueException" map="_B"/>
  <field class="freemarker.core.ExtendedDecimalFormatParser$InvalidParameterValueException" name="message" map="A"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser$InvalidParameterValueException" name="java.lang.String access$300(freemarker.core.ExtendedDecimalFormatParser$InvalidParameterValueException)" map="A"/>
  <class name="freemarker.core.ExtendedDecimalFormatParser" map="OB"/>
  <field class="freemarker.core.ExtendedDecimalFormatParser" name="multipier" map="A"/>
  <field class="freemarker.core.ExtendedDecimalFormatParser" name="symbols" map="B"/>
  <field class="freemarker.core.ExtendedDecimalFormatParser" name="PARAM_HANDLERS" map="C"/>
  <field class="freemarker.core.ExtendedDecimalFormatParser" name="roundingMode" map="D"/>
  <field class="freemarker.core.ExtendedDecimalFormatParser" name="src" map="E"/>
  <field class="freemarker.core.ExtendedDecimalFormatParser" name="pos" map="F"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="java.text.ParseException newExpectedSgParseException(java.lang.String)" map="A"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="boolean fetchChar(char)" map="A"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="java.text.ParseException newInvalidParameterValueException(java.lang.String, java.lang.String, int, freemarker.core.ExtendedDecimalFormatParser$InvalidParameterValueException)" map="A"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="java.lang.String unescape(java.lang.String, char)" map="A"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="void skipWS()" map="A"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="java.math.RoundingMode access$002(freemarker.core.ExtendedDecimalFormatParser, java.math.RoundingMode)" map="A"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="java.lang.String fetchName()" map="B"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="java.text.DecimalFormat parse()" map="C"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="java.text.DecimalFormatSymbols access$200(freemarker.core.ExtendedDecimalFormatParser)" map="A"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="java.lang.Integer access$102(freemarker.core.ExtendedDecimalFormatParser, java.lang.Integer)" map="A"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="void parseFormatStringExtension()" map="D"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="java.text.DecimalFormat parse(java.lang.String, java.util.Locale)" map="A"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="java.text.ParseException newUnknownParameterException(java.lang.String, int)" map="A"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="java.lang.String fetchStandardPattern()" map="E"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="boolean isWS(char)" map="B"/>
  <method class="freemarker.core.ExtendedDecimalFormatParser" name="java.lang.String fetchValue()" map="F"/>
  <class name="freemarker.core._Java8" map="PB"/>
  <method class="freemarker.core._Java8" name="boolean isDefaultMethod(java.lang.reflect.Method)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsMisc$numberBI" map="_A"/>
  <method class="freemarker.core.BuiltInsForStringsMisc$numberBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsMisc$booleanBI" map="_B"/>
  <method class="freemarker.core.BuiltInsForStringsMisc$booleanBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsMisc$evalBI" map="_C"/>
  <method class="freemarker.core.BuiltInsForStringsMisc$evalBI" name="freemarker.template.TemplateModel calculateResult(freemarker.core.Environment)" map="H"/>
  <method class="freemarker.core.BuiltInsForStringsMisc$evalBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsMisc$absolute_template_nameBI$AbsoluteTemplateNameResult" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsMisc$absolute_template_nameBI$AbsoluteTemplateNameResult" name="this$0" map="&#x0211;"/>
  <field class="freemarker.core.BuiltInsForStringsMisc$absolute_template_nameBI$AbsoluteTemplateNameResult" name="pathToResolve" map="&#x0212;"/>
  <field class="freemarker.core.BuiltInsForStringsMisc$absolute_template_nameBI$AbsoluteTemplateNameResult" name="env" map="&#x0213;"/>
  <method class="freemarker.core.BuiltInsForStringsMisc$absolute_template_nameBI$AbsoluteTemplateNameResult" name="java.lang.String resolvePath(java.lang.String)" map="O"/>
  <method class="freemarker.core.BuiltInsForStringsMisc$absolute_template_nameBI$AbsoluteTemplateNameResult" name="java.lang.Object exec(java.util.List)" map="A"/>
  <method class="freemarker.core.BuiltInsForStringsMisc$absolute_template_nameBI$AbsoluteTemplateNameResult" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <class name="freemarker.core.BuiltInsForStringsMisc$absolute_template_nameBI" map="_D"/>
  <method class="freemarker.core.BuiltInsForStringsMisc$absolute_template_nameBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsMisc" map="QB"/>
  <class name="freemarker.core.NonMarkupOutputException" map="RB"/>
  <field class="freemarker.core.NonMarkupOutputException" name="EXPECTED_TYPES" map="f"/>
  <class name="freemarker.core._Java6" map="SB"/>
  <method class="freemarker.core._Java6" name="void setExponentSeparator(java.text.DecimalFormatSymbols, java.lang.String)" map="A"/>
  <method class="freemarker.core._Java6" name="void setRoundingMode(java.text.DecimalFormat, java.math.RoundingMode)" map="A"/>
  <class name="freemarker.core.Case" map="TB"/>
  <field class="freemarker.core.Case" name="condition" map="&#x00fe;"/>
  <method class="freemarker.core.Case" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.Case" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.Case" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.Case" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.Case" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.Case" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.TemplateConfiguration" map="UB"/>
  <method class="freemarker.core.TemplateConfiguration" name="freemarker.core.OutputFormat getOutputFormat()" map="B"/>
  <method class="freemarker.core.TemplateConfiguration" name="int getInterpolationSyntax()" map="C"/>
  <method class="freemarker.core.TemplateConfiguration" name="freemarker.template.Version getIncompatibleImprovements()" map="D"/>
  <method class="freemarker.core.TemplateConfiguration" name="int getTagSyntax()" map="E"/>
  <method class="freemarker.core.TemplateConfiguration" name="java.lang.String getEncoding()" map="&#x00ff;"/>
  <method class="freemarker.core.TemplateConfiguration" name="int getNamingConvention()" map="F"/>
  <method class="freemarker.core.TemplateConfiguration" name="boolean getWhitespaceStripping()" map="G"/>
  <method class="freemarker.core.TemplateConfiguration" name="boolean getStrictSyntaxMode()" map="H"/>
  <method class="freemarker.core.TemplateConfiguration" name="void apply(freemarker.template.Template)" map="D"/>
  <method class="freemarker.core.TemplateConfiguration" name="boolean getRecognizeStandardFileExtensions()" map="I"/>
  <method class="freemarker.core.TemplateConfiguration" name="int getAutoEscapingPolicy()" map="J"/>
  <method class="freemarker.core.TemplateConfiguration" name="int getTabSize()" map="K"/>
  <method class="freemarker.core.TemplateConfiguration" name="boolean isEncodingSet()" map="&#x0100;"/>
  <class name="freemarker.core.NotExpression" map="VB"/>
  <field class="freemarker.core.NotExpression" name="target" map="S"/>
  <method class="freemarker.core.NotExpression" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.NotExpression" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.NotExpression" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.NotExpression" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.NotExpression" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.NotExpression" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <method class="freemarker.core.NotExpression" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.NotExpression" name="boolean evalToBoolean(freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core.TemplateDateFormat" map="WB"/>
  <method class="freemarker.core.TemplateDateFormat" name="java.lang.String formatToPlainText(freemarker.template.TemplateDateModel)" map="A"/>
  <method class="freemarker.core.TemplateDateFormat" name="boolean isLocaleBound()" map="C"/>
  <method class="freemarker.core.TemplateDateFormat" name="java.lang.Object format(freemarker.template.TemplateDateModel)" map="B"/>
  <method class="freemarker.core.TemplateDateFormat" name="boolean isTimeZoneBound()" map="D"/>
  <method class="freemarker.core.TemplateDateFormat" name="java.lang.Object parse(java.lang.String, int)" map="A"/>
  <class name="freemarker.core.DollarVariable" map="XB"/>
  <field class="freemarker.core.DollarVariable" name="escapedExpression" map="&#x00d8;"/>
  <field class="freemarker.core.DollarVariable" name="markupOutputFormat" map="&#x00d9;"/>
  <field class="freemarker.core.DollarVariable" name="autoEscape" map="&#x00da;"/>
  <field class="freemarker.core.DollarVariable" name="expression" map="&#x00db;"/>
  <field class="freemarker.core.DollarVariable" name="outputFormat" map="&#x00dc;"/>
  <method class="freemarker.core.DollarVariable" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.DollarVariable" name="boolean heedsTrailingWhitespace()" map="g"/>
  <method class="freemarker.core.DollarVariable" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.DollarVariable" name="boolean heedsOpeningWhitespace()" map="h"/>
  <method class="freemarker.core.DollarVariable" name="java.lang.Object calculateInterpolatedStringOrMarkup(freemarker.core.Environment)" map="L"/>
  <method class="freemarker.core.DollarVariable" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.DollarVariable" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.DollarVariable" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.DollarVariable" name="java.lang.String dump(boolean, boolean)" map="A"/>
  <class name="freemarker.core.BuiltInForString" map="YB"/>
  <method class="freemarker.core.BuiltInForString" name="java.lang.String getTargetString(freemarker.core.Expression, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.BuiltInForString" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <method class="freemarker.core.BuiltInForString" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core._UnexpectedTypeErrorExplainerTemplateModel" map="ZB"/>
  <method class="freemarker.core._UnexpectedTypeErrorExplainerTemplateModel" name="java.lang.Object[] explainTypeError(java.lang.Class[])" map="A"/>
  <class name="freemarker.core.BuiltInForLoopVariable" map="_B"/>
  <field class="freemarker.core.BuiltInForLoopVariable" name="loopVarName" map="q"/>
  <method class="freemarker.core.BuiltInForLoopVariable" name="freemarker.template.TemplateModel calculateResult(freemarker.core.IteratorBlock$IterationContext, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.BuiltInForLoopVariable" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.BuiltInForLoopVariable" name="void bindToLoopVariable(java.lang.String)" map="A"/>
  <class name="freemarker.core.JavaTemplateNumberFormatFactory$CacheKey" map="_A"/>
  <field class="freemarker.core.JavaTemplateNumberFormatFactory$CacheKey" name="locale" map="A"/>
  <field class="freemarker.core.JavaTemplateNumberFormatFactory$CacheKey" name="pattern" map="B"/>
  <method class="freemarker.core.JavaTemplateNumberFormatFactory$CacheKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="freemarker.core.JavaTemplateNumberFormatFactory$CacheKey" name="int hashCode()" map="hashCode"/>
  <class name="freemarker.core.JavaTemplateNumberFormatFactory" map="aB"/>
  <field class="freemarker.core.JavaTemplateNumberFormatFactory" name="LOG" map="H"/>
  <field class="freemarker.core.JavaTemplateNumberFormatFactory" name="GLOBAL_FORMAT_CACHE" map="I"/>
  <field class="freemarker.core.JavaTemplateNumberFormatFactory" name="INSTANCE" map="J"/>
  <method class="freemarker.core.JavaTemplateNumberFormatFactory" name="freemarker.core.TemplateNumberFormat get(java.lang.String, java.util.Locale, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.XMLOutputFormat" map="bB"/>
  <field class="freemarker.core.XMLOutputFormat" name="INSTANCE" map="G"/>
  <method class="freemarker.core.XMLOutputFormat" name="freemarker.core.CommonTemplateMarkupOutputModel newTemplateMarkupOutputModel(java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.core.XMLOutputFormat" name="freemarker.core.TemplateXMLOutputModel newTemplateMarkupOutputModel(java.lang.String, java.lang.String)" map="D"/>
  <method class="freemarker.core.XMLOutputFormat" name="java.lang.String getMimeType()" map="B"/>
  <method class="freemarker.core.XMLOutputFormat" name="boolean isLegacyBuiltInBypassed(java.lang.String)" map="B"/>
  <method class="freemarker.core.XMLOutputFormat" name="void output(java.lang.String, java.io.Writer)" map="A"/>
  <method class="freemarker.core.XMLOutputFormat" name="java.lang.String getName()" map="C"/>
  <method class="freemarker.core.XMLOutputFormat" name="java.lang.String escapePlainText(java.lang.String)" map="A"/>
  <class name="freemarker.core.OutputFormatBlock" map="cB"/>
  <field class="freemarker.core.OutputFormatBlock" name="paramExp" map="&#x00ff;"/>
  <method class="freemarker.core.OutputFormatBlock" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.OutputFormatBlock" name="boolean isIgnorable(boolean)" map="D"/>
  <method class="freemarker.core.OutputFormatBlock" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.OutputFormatBlock" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.OutputFormatBlock" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.OutputFormatBlock" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.OutputFormatBlock" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.BuiltInsForHashes$valuesBI" map="_A"/>
  <method class="freemarker.core.BuiltInsForHashes$valuesBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateHashModelEx, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForHashes$keysBI" map="_B"/>
  <method class="freemarker.core.BuiltInsForHashes$keysBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateHashModelEx, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForHashes" map="dB"/>
  <class name="freemarker.core.ICIChainMember" map="eB"/>
  <method class="freemarker.core.ICIChainMember" name="java.lang.Object getPreviousICIChainMember()" map="S"/>
  <method class="freemarker.core.ICIChainMember" name="int getMinimumICIVersion()" map="T"/>
  <class name="freemarker.core._DelayedJQuote" map="fB"/>
  <method class="freemarker.core._DelayedJQuote" name="java.lang.String doConversion(java.lang.Object)" map="A"/>
  <class name="freemarker.core.BuiltInsForLoopVariables$is_lastBI" map="_A"/>
  <method class="freemarker.core.BuiltInsForLoopVariables$is_lastBI" name="boolean calculateBooleanResult(freemarker.core.IteratorBlock$IterationContext, freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core.BuiltInsForLoopVariables$BooleanBuiltInForLoopVariable" map="_B"/>
  <method class="freemarker.core.BuiltInsForLoopVariables$BooleanBuiltInForLoopVariable" name="boolean calculateBooleanResult(freemarker.core.IteratorBlock$IterationContext, freemarker.core.Environment)" map="B"/>
  <method class="freemarker.core.BuiltInsForLoopVariables$BooleanBuiltInForLoopVariable" name="freemarker.template.TemplateModel calculateResult(freemarker.core.IteratorBlock$IterationContext, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForLoopVariables$is_odd_itemBI" map="_C"/>
  <method class="freemarker.core.BuiltInsForLoopVariables$is_odd_itemBI" name="boolean calculateBooleanResult(freemarker.core.IteratorBlock$IterationContext, freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core.BuiltInsForLoopVariables$has_nextBI" map="_D"/>
  <method class="freemarker.core.BuiltInsForLoopVariables$has_nextBI" name="boolean calculateBooleanResult(freemarker.core.IteratorBlock$IterationContext, freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core.BuiltInsForLoopVariables$counterBI" map="_E"/>
  <method class="freemarker.core.BuiltInsForLoopVariables$counterBI" name="freemarker.template.TemplateModel calculateResult(freemarker.core.IteratorBlock$IterationContext, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForLoopVariables$is_even_itemBI" map="_F"/>
  <method class="freemarker.core.BuiltInsForLoopVariables$is_even_itemBI" name="boolean calculateBooleanResult(freemarker.core.IteratorBlock$IterationContext, freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core.BuiltInsForLoopVariables$indexBI" map="_G"/>
  <method class="freemarker.core.BuiltInsForLoopVariables$indexBI" name="freemarker.template.TemplateModel calculateResult(freemarker.core.IteratorBlock$IterationContext, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForLoopVariables$is_firstBI" map="_H"/>
  <method class="freemarker.core.BuiltInsForLoopVariables$is_firstBI" name="boolean calculateBooleanResult(freemarker.core.IteratorBlock$IterationContext, freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core.BuiltInsForLoopVariables$item_parity_capBI" map="_I"/>
  <field class="freemarker.core.BuiltInsForLoopVariables$item_parity_capBI" name="EVEN" map="r"/>
  <field class="freemarker.core.BuiltInsForLoopVariables$item_parity_capBI" name="ODD" map="s"/>
  <method class="freemarker.core.BuiltInsForLoopVariables$item_parity_capBI" name="freemarker.template.TemplateModel calculateResult(freemarker.core.IteratorBlock$IterationContext, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForLoopVariables$item_parityBI" map="_J"/>
  <field class="freemarker.core.BuiltInsForLoopVariables$item_parityBI" name="EVEN" map="t"/>
  <field class="freemarker.core.BuiltInsForLoopVariables$item_parityBI" name="ODD" map="u"/>
  <method class="freemarker.core.BuiltInsForLoopVariables$item_parityBI" name="freemarker.template.TemplateModel calculateResult(freemarker.core.IteratorBlock$IterationContext, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForLoopVariables$1" map="1"/>
  <class name="freemarker.core.BuiltInsForLoopVariables$item_cycleBI$BIMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForLoopVariables$item_cycleBI$BIMethod" name="this$0" map="&#x0157;"/>
  <field class="freemarker.core.BuiltInsForLoopVariables$item_cycleBI$BIMethod" name="iterCtx" map="&#x0158;"/>
  <method class="freemarker.core.BuiltInsForLoopVariables$item_cycleBI$BIMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForLoopVariables$item_cycleBI" map="_K"/>
  <method class="freemarker.core.BuiltInsForLoopVariables$item_cycleBI" name="freemarker.template.TemplateModel calculateResult(freemarker.core.IteratorBlock$IterationContext, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForLoopVariables" map="gB"/>
  <class name="freemarker.core.CommonMarkupOutputFormat" map="hB"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="boolean isEmpty(freemarker.core.TemplateMarkupOutputModel)" map="C"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="freemarker.core.CommonTemplateMarkupOutputModel fromPlainTextByEscaping(java.lang.String)" map="E"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="freemarker.core.TemplateMarkupOutputModel fromPlainTextByEscaping(java.lang.String)" map="C"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="java.lang.String getSourcePlainText(freemarker.core.TemplateMarkupOutputModel)" map="A"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="java.lang.String getSourcePlainText(freemarker.core.CommonTemplateMarkupOutputModel)" map="A"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="freemarker.core.TemplateMarkupOutputModel fromMarkup(java.lang.String)" map="D"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="void output(freemarker.core.TemplateMarkupOutputModel, java.io.Writer)" map="A"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="java.lang.String getMarkupString(freemarker.core.TemplateMarkupOutputModel)" map="B"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="void output(freemarker.core.CommonTemplateMarkupOutputModel, java.io.Writer)" map="A"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="freemarker.core.CommonTemplateMarkupOutputModel fromMarkup(java.lang.String)" map="F"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="boolean isOutputFormatMixingAllowed()" map="D"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="boolean isAutoEscapedByDefault()" map="E"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="freemarker.core.TemplateMarkupOutputModel concat(freemarker.core.TemplateMarkupOutputModel, freemarker.core.TemplateMarkupOutputModel)" map="A"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="void output(java.lang.String, java.io.Writer)" map="A"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="boolean isEmpty(freemarker.core.CommonTemplateMarkupOutputModel)" map="B"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="freemarker.core.CommonTemplateMarkupOutputModel concat(freemarker.core.CommonTemplateMarkupOutputModel, freemarker.core.CommonTemplateMarkupOutputModel)" map="A"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="java.lang.String getMarkupString(freemarker.core.CommonTemplateMarkupOutputModel)" map="C"/>
  <method class="freemarker.core.CommonMarkupOutputFormat" name="freemarker.core.CommonTemplateMarkupOutputModel newTemplateMarkupOutputModel(java.lang.String, java.lang.String)" map="A"/>
  <class name="freemarker.core.APINotSupportedTemplateException" map="iB"/>
  <method class="freemarker.core.APINotSupportedTemplateException" name="freemarker.core._ErrorDescriptionBuilder buildDescription(freemarker.core.Environment, freemarker.core.Expression, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.MethodCall" map="jB"/>
  <field class="freemarker.core.MethodCall" name="arguments" map="&#x00c7;"/>
  <field class="freemarker.core.MethodCall" name="target" map="&#x00c8;"/>
  <method class="freemarker.core.MethodCall" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.MethodCall" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.MethodCall" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.MethodCall" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.MethodCall" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.MethodCall" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <method class="freemarker.core.MethodCall" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.MethodCall" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core._ArrayIterator" map="kB"/>
  <field class="freemarker.core._ArrayIterator" name="nextIndex" map="A"/>
  <field class="freemarker.core._ArrayIterator" name="array" map="B"/>
  <method class="freemarker.core._ArrayIterator" name="boolean hasNext()" map="hasNext"/>
  <method class="freemarker.core._ArrayIterator" name="void remove()" map="remove"/>
  <method class="freemarker.core._ArrayIterator" name="java.lang.Object next()" map="next"/>
  <class name="freemarker.core.TemplateFormatUtil" map="lB"/>
  <method class="freemarker.core.TemplateFormatUtil" name="java.util.Date getNonNullDate(freemarker.template.TemplateDateModel)" map="A"/>
  <method class="freemarker.core.TemplateFormatUtil" name="java.lang.Number getNonNullNumber(freemarker.template.TemplateNumberModel)" map="A"/>
  <class name="freemarker.core.JavaTemplateDateFormat" map="mB"/>
  <field class="freemarker.core.JavaTemplateDateFormat" name="javaDateFormat" map="C"/>
  <method class="freemarker.core.JavaTemplateDateFormat" name="java.lang.String formatToPlainText(freemarker.template.TemplateDateModel)" map="A"/>
  <method class="freemarker.core.JavaTemplateDateFormat" name="boolean isLocaleBound()" map="C"/>
  <method class="freemarker.core.JavaTemplateDateFormat" name="java.lang.String getDescription()" map="A"/>
  <method class="freemarker.core.JavaTemplateDateFormat" name="java.util.Date parse(java.lang.String, int)" map="B"/>
  <method class="freemarker.core.JavaTemplateDateFormat" name="java.lang.Object parse(java.lang.String, int)" map="A"/>
  <method class="freemarker.core.JavaTemplateDateFormat" name="boolean isTimeZoneBound()" map="D"/>
  <class name="freemarker.core.AddConcatExpression$ConcatenatedHash" map="_A"/>
  <field class="freemarker.core.AddConcatExpression$ConcatenatedHash" name="right" map="&#x017d;"/>
  <field class="freemarker.core.AddConcatExpression$ConcatenatedHash" name="left" map="&#x017e;"/>
  <method class="freemarker.core.AddConcatExpression$ConcatenatedHash" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.core.AddConcatExpression$ConcatenatedHash" name="boolean isEmpty()" map="&#x00c7;"/>
  <class name="freemarker.core.AddConcatExpression$ConcatenatedSequence" map="_B"/>
  <field class="freemarker.core.AddConcatExpression$ConcatenatedSequence" name="right" map="&#x0254;"/>
  <field class="freemarker.core.AddConcatExpression$ConcatenatedSequence" name="left" map="&#x0255;"/>
  <method class="freemarker.core.AddConcatExpression$ConcatenatedSequence" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.core.AddConcatExpression$ConcatenatedSequence" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <class name="freemarker.core.AddConcatExpression$ConcatenatedHashEx" map="_C"/>
  <field class="freemarker.core.AddConcatExpression$ConcatenatedHashEx" name="values" map="&#x01f1;"/>
  <field class="freemarker.core.AddConcatExpression$ConcatenatedHashEx" name="size" map="&#x01f2;"/>
  <field class="freemarker.core.AddConcatExpression$ConcatenatedHashEx" name="keys" map="&#x01f3;"/>
  <method class="freemarker.core.AddConcatExpression$ConcatenatedHashEx" name="void initValues()" map="&#x00f1;"/>
  <method class="freemarker.core.AddConcatExpression$ConcatenatedHashEx" name="freemarker.template.TemplateCollectionModel keys()" map="&#x00c8;"/>
  <method class="freemarker.core.AddConcatExpression$ConcatenatedHashEx" name="void addKeys(java.util.Set, freemarker.template.SimpleSequence, freemarker.template.TemplateHashModelEx)" map="A"/>
  <method class="freemarker.core.AddConcatExpression$ConcatenatedHashEx" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.core.AddConcatExpression$ConcatenatedHashEx" name="void initKeys()" map="&#x00f2;"/>
  <method class="freemarker.core.AddConcatExpression$ConcatenatedHashEx" name="freemarker.template.TemplateCollectionModel values()" map="&#x00c9;"/>
  <class name="freemarker.core.AddConcatExpression" map="nB"/>
  <field class="freemarker.core.AddConcatExpression" name="right" map="&#x00c9;"/>
  <field class="freemarker.core.AddConcatExpression" name="left" map="&#x00ca;"/>
  <method class="freemarker.core.AddConcatExpression" name="freemarker.template.TemplateModel _evalOnNumbers(freemarker.core.Environment, freemarker.core.TemplateObject, java.lang.Number, java.lang.Number)" map="A"/>
  <method class="freemarker.core.AddConcatExpression" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.AddConcatExpression" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.AddConcatExpression" name="freemarker.template.TemplateModel _eval_concatenateHashes(freemarker.template.TemplateModel, freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.core.AddConcatExpression" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.AddConcatExpression" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.AddConcatExpression" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.AddConcatExpression" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment, freemarker.core.TemplateObject, freemarker.core.Expression, freemarker.template.TemplateModel, freemarker.core.Expression, freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.core.AddConcatExpression" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.AddConcatExpression" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.AddConcatExpression" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <class name="freemarker.core.IfBlock" map="oB"/>
  <method class="freemarker.core.IfBlock" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.IfBlock" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.IfBlock" name="freemarker.core.TemplateElement postParseCleanup(boolean)" map="B"/>
  <method class="freemarker.core.IfBlock" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.IfBlock" name="void addBlock(freemarker.core.ConditionalBlock)" map="A"/>
  <method class="freemarker.core.IfBlock" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.IfBlock" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.IfBlock" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core._CoreAPI" map="pB"/>
  <field class="freemarker.core._CoreAPI" name="ALL_BUILT_IN_DIRECTIVE_NAMES" map="A"/>
  <field class="freemarker.core._CoreAPI" name="CAMEL_CASE_BUILT_IN_DIRECTIVE_NAMES" map="B"/>
  <field class="freemarker.core._CoreAPI" name="LEGACY_BUILT_IN_DIRECTIVE_NAMES" map="C"/>
  <method class="freemarker.core._CoreAPI" name="void addName(java.util.Set, java.util.Set, java.util.Set, java.lang.String)" map="A"/>
  <method class="freemarker.core._CoreAPI" name="void setPreventStrippings(freemarker.core.FMParser, boolean)" map="A"/>
  <method class="freemarker.core._CoreAPI" name="void addName(java.util.Set, java.util.Set, java.util.Set, java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.core._CoreAPI" name="void replaceText(freemarker.core.TextBlock, java.lang.String)" map="A"/>
  <method class="freemarker.core._CoreAPI" name="void outputInstructionStack(freemarker.core.TemplateElement[], boolean, java.io.Writer)" map="A"/>
  <method class="freemarker.core._CoreAPI" name="freemarker.core.TemplateElement getParentElement(freemarker.core.TemplateElement)" map="A"/>
  <method class="freemarker.core._CoreAPI" name="freemarker.template.TemplateModelException ensureIsTemplateModelException(java.lang.String, freemarker.template.TemplateException)" map="A"/>
  <method class="freemarker.core._CoreAPI" name="freemarker.core.TemplateElement[] getInstructionStackSnapshot(freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core._CoreAPI" name="void checkSettingValueItemsType(java.lang.String, java.lang.Class, java.util.Collection)" map="A"/>
  <class name="freemarker.core.BugException" map="qB"/>
  <class name="freemarker.core.Assignment" map="rB"/>
  <field class="freemarker.core.Assignment" name="valueExp" map="&#x0100;"/>
  <field class="freemarker.core.Assignment" name="ONE" map="&#x0101;"/>
  <field class="freemarker.core.Assignment" name="namespaceExp" map="&#x0102;"/>
  <field class="freemarker.core.Assignment" name="scope" map="&#x0103;"/>
  <field class="freemarker.core.Assignment" name="operatorType" map="&#x0104;"/>
  <field class="freemarker.core.Assignment" name="variableName" map="&#x0105;"/>
  <method class="freemarker.core.Assignment" name="java.lang.String scopeAsString(int)" map="L"/>
  <method class="freemarker.core.Assignment" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.Assignment" name="java.lang.String getOperatorTypeAsString()" map="l"/>
  <method class="freemarker.core.Assignment" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.Assignment" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.Assignment" name="java.lang.String getDirectiveName(int)" map="M"/>
  <method class="freemarker.core.Assignment" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.Assignment" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.Assignment" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.Assignment" name="void setNamespaceExp(freemarker.core.Expression)" map="A"/>
  <class name="freemarker.core.UndefinedCustomFormatException" map="sB"/>
  <class name="freemarker.core.CommonTemplateMarkupOutputModel" map="tB"/>
  <field class="freemarker.core.CommonTemplateMarkupOutputModel" name="plainTextContent" map="&#x0129;"/>
  <field class="freemarker.core.CommonTemplateMarkupOutputModel" name="markupContet" map="&#x012a;"/>
  <method class="freemarker.core.CommonTemplateMarkupOutputModel" name="freemarker.core.MarkupOutputFormat getOutputFormat()" map="x"/>
  <method class="freemarker.core.CommonTemplateMarkupOutputModel" name="void setMarkupContet(java.lang.String)" map="E"/>
  <method class="freemarker.core.CommonTemplateMarkupOutputModel" name="java.lang.String getMarkupContent()" map="y"/>
  <method class="freemarker.core.CommonTemplateMarkupOutputModel" name="java.lang.String getPlainTextContent()" map="z"/>
  <class name="freemarker.core.TemplateValueFormatFactory" map="uB"/>
  <class name="freemarker.core.DynamicKeyName" map="vB"/>
  <field class="freemarker.core.DynamicKeyName" name="keyExpression" map="&#x00cb;"/>
  <field class="freemarker.core.DynamicKeyName" name="NUMERICAL_KEY_LHO_EXPECTED_TYPES" map="&#x00cc;"/>
  <field class="freemarker.core.DynamicKeyName" name="target" map="&#x00cd;"/>
  <method class="freemarker.core.DynamicKeyName" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.DynamicKeyName" name="freemarker.template.TemplateModel dealWithStringKey(freemarker.template.TemplateModel, java.lang.String, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.DynamicKeyName" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.DynamicKeyName" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.DynamicKeyName" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.DynamicKeyName" name="freemarker.template.TemplateModel dealWithNumericalKey(freemarker.template.TemplateModel, int, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.DynamicKeyName" name="freemarker.template.TemplateModel dealWithRangeKey(freemarker.template.TemplateModel, freemarker.core.RangeModel, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.DynamicKeyName" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.DynamicKeyName" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.DynamicKeyName" name="freemarker.template.TemplateModel emptyResult(boolean)" map="A"/>
  <method class="freemarker.core.DynamicKeyName" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.DynamicKeyName" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <class name="freemarker.core.BooleanLiteral" map="wB"/>
  <field class="freemarker.core.BooleanLiteral" name="val" map="&#x00ce;"/>
  <method class="freemarker.core.BooleanLiteral" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.BooleanLiteral" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.BooleanLiteral" name="boolean evalToBoolean(freemarker.core.Environment)" map="B"/>
  <method class="freemarker.core.BooleanLiteral" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.BooleanLiteral" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.BooleanLiteral" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.BooleanLiteral" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.BooleanLiteral" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.BooleanLiteral" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.core.BooleanLiteral" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <class name="freemarker.core.ParameterRole" map="xB"/>
  <field class="freemarker.core.ParameterRole" name="NAMESPACE" map="A"/>
  <field class="freemarker.core.ParameterRole" name="IGNORE_MISSING_PARAMETER" map="B"/>
  <field class="freemarker.core.ParameterRole" name="TARGET_LOOP_VARIABLE" map="C"/>
  <field class="freemarker.core.ParameterRole" name="EMBEDDED_TEMPLATE" map="D"/>
  <field class="freemarker.core.ParameterRole" name="TEMPLATE_NAME" map="E"/>
  <field class="freemarker.core.ParameterRole" name="LEFT_HAND_OPERAND" map="F"/>
  <field class="freemarker.core.ParameterRole" name="ERROR_HANDLER" map="G"/>
  <field class="freemarker.core.ParameterRole" name="ENCLOSED_OPERAND" map="H"/>
  <field class="freemarker.core.ParameterRole" name="MINIMUM_DECIMALS" map="I"/>
  <field class="freemarker.core.ParameterRole" name="name" map="J"/>
  <field class="freemarker.core.ParameterRole" name="ITEM_KEY" map="K"/>
  <field class="freemarker.core.ParameterRole" name="ASSIGNMENT_TARGET" map="L"/>
  <field class="freemarker.core.ParameterRole" name="PARAMETER_DEFAULT" map="M"/>
  <field class="freemarker.core.ParameterRole" name="ITEM_VALUE" map="N"/>
  <field class="freemarker.core.ParameterRole" name="CONDITION" map="O"/>
  <field class="freemarker.core.ParameterRole" name="PARSE_PARAMETER" map="P"/>
  <field class="freemarker.core.ParameterRole" name="PLACEHOLDER_VARIABLE" map="Q"/>
  <field class="freemarker.core.ParameterRole" name="LIST_SOURCE" map="R"/>
  <field class="freemarker.core.ParameterRole" name="PARAMETER_NAME" map="S"/>
  <field class="freemarker.core.ParameterRole" name="PASSED_VALUE" map="T"/>
  <field class="freemarker.core.ParameterRole" name="UNKNOWN" map="U"/>
  <field class="freemarker.core.ParameterRole" name="MAXIMUM_DECIMALS" map="V"/>
  <field class="freemarker.core.ParameterRole" name="MESSAGE" map="W"/>
  <field class="freemarker.core.ParameterRole" name="CONTENT" map="X"/>
  <field class="freemarker.core.ParameterRole" name="ASSIGNMENT_OPERATOR" map="Y"/>
  <field class="freemarker.core.ParameterRole" name="EXPRESSION_TEMPLATE" map="Z"/>
  <field class="freemarker.core.ParameterRole" name="ARGUMENT_NAME" map="_"/>
  <field class="freemarker.core.ParameterRole" name="ASSIGNMENT_SOURCE" map="a"/>
  <field class="freemarker.core.ParameterRole" name="ARGUMENT_VALUE" map="b"/>
  <field class="freemarker.core.ParameterRole" name="VALUE" map="c"/>
  <field class="freemarker.core.ParameterRole" name="CATCH_ALL_PARAMETER_NAME" map="d"/>
  <field class="freemarker.core.ParameterRole" name="AST_NODE_SUBTYPE" map="e"/>
  <field class="freemarker.core.ParameterRole" name="VARIABLE_SCOPE" map="f"/>
  <field class="freemarker.core.ParameterRole" name="CALLEE" map="g"/>
  <field class="freemarker.core.ParameterRole" name="RIGHT_HAND_OPERAND" map="h"/>
  <field class="freemarker.core.ParameterRole" name="NODE" map="i"/>
  <field class="freemarker.core.ParameterRole" name="VALUE_PART" map="j"/>
  <field class="freemarker.core.ParameterRole" name="ENCODING_PARAMETER" map="k"/>
  <method class="freemarker.core.ParameterRole" name="freemarker.core.ParameterRole forBinaryOperatorOperand(int)" map="A"/>
  <method class="freemarker.core.ParameterRole" name="java.lang.String toString()" map="toString"/>
  <class name="freemarker.core.BlockAssignment" map="yB"/>
  <field class="freemarker.core.BlockAssignment" name="markupOutputFormat" map="&#x0106;"/>
  <field class="freemarker.core.BlockAssignment" name="scope" map="&#x0107;"/>
  <field class="freemarker.core.BlockAssignment" name="namespaceExp" map="&#x0108;"/>
  <field class="freemarker.core.BlockAssignment" name="varName" map="&#x0109;"/>
  <method class="freemarker.core.BlockAssignment" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.BlockAssignment" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.BlockAssignment" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.BlockAssignment" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.BlockAssignment" name="freemarker.template.TemplateModel capturedStringToModel(java.lang.String)" map="B"/>
  <method class="freemarker.core.BlockAssignment" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.BlockAssignment" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.BuiltInsForExistenceHandling$ExistenceBuiltIn" map="_A"/>
  <method class="freemarker.core.BuiltInsForExistenceHandling$ExistenceBuiltIn" name="freemarker.template.TemplateModel evalMaybeNonexistentTarget(freemarker.core.Environment)" map="J"/>
  <class name="freemarker.core.BuiltInsForExistenceHandling$defaultBI$ConstantMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForExistenceHandling$defaultBI$ConstantMethod" name="constant" map="&#x0159;"/>
  <method class="freemarker.core.BuiltInsForExistenceHandling$defaultBI$ConstantMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForExistenceHandling$defaultBI$1" map="1"/>
  <method class="freemarker.core.BuiltInsForExistenceHandling$defaultBI$1" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForExistenceHandling$defaultBI" map="_B"/>
  <field class="freemarker.core.BuiltInsForExistenceHandling$defaultBI" name="FIRST_NON_NULL_METHOD" map="y"/>
  <method class="freemarker.core.BuiltInsForExistenceHandling$defaultBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForExistenceHandling$1" map="1"/>
  <class name="freemarker.core.BuiltInsForExistenceHandling$existsBI" map="_C"/>
  <method class="freemarker.core.BuiltInsForExistenceHandling$existsBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.BuiltInsForExistenceHandling$existsBI" name="boolean evalToBoolean(freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core.BuiltInsForExistenceHandling$has_contentBI" map="_D"/>
  <method class="freemarker.core.BuiltInsForExistenceHandling$has_contentBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.BuiltInsForExistenceHandling$has_contentBI" name="boolean evalToBoolean(freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core.BuiltInsForExistenceHandling$if_existsBI" map="_E"/>
  <method class="freemarker.core.BuiltInsForExistenceHandling$if_existsBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForExistenceHandling" map="zB"/>
  <class name="freemarker.core.ConditionalBlock" map="$C"/>
  <field class="freemarker.core.ConditionalBlock" name="type" map="&#x010a;"/>
  <field class="freemarker.core.ConditionalBlock" name="condition" map="&#x010b;"/>
  <method class="freemarker.core.ConditionalBlock" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.ConditionalBlock" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.ConditionalBlock" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.ConditionalBlock" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.ConditionalBlock" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.ConditionalBlock" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.StringLiteral" map="AC"/>
  <field class="freemarker.core.StringLiteral" name="value" map="&#x0214;"/>
  <field class="freemarker.core.StringLiteral" name="dynamicValue" map="&#x0215;"/>
  <method class="freemarker.core.StringLiteral" name="boolean isSingleInterpolationLiteral()" map="&#x00f8;"/>
  <method class="freemarker.core.StringLiteral" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.StringLiteral" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <method class="freemarker.core.StringLiteral" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.StringLiteral" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.StringLiteral" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.StringLiteral" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.StringLiteral" name="void parseValue(freemarker.core.FMParser, freemarker.core.OutputFormat)" map="A"/>
  <method class="freemarker.core.StringLiteral" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.StringLiteral" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.StringLiteral" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <method class="freemarker.core.StringLiteral" name="void checkIndex(int)" map="O"/>
  <class name="freemarker.core._JavaVersions" map="BC"/>
  <field class="freemarker.core._JavaVersions" name="JAVA_6" map="A"/>
  <field class="freemarker.core._JavaVersions" name="IS_AT_LEAST_8" map="B"/>
  <field class="freemarker.core._JavaVersions" name="IS_AT_LEAST_6" map="C"/>
  <field class="freemarker.core._JavaVersions" name="JAVA_8" map="D"/>
  <class name="freemarker.core.EscapeBlock" map="CC"/>
  <field class="freemarker.core.EscapeBlock" name="variable" map="&#x010c;"/>
  <field class="freemarker.core.EscapeBlock" name="escapedExpr" map="&#x010d;"/>
  <field class="freemarker.core.EscapeBlock" name="expr" map="&#x010e;"/>
  <method class="freemarker.core.EscapeBlock" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.EscapeBlock" name="freemarker.core.Expression doEscape(freemarker.core.Expression)" map="B"/>
  <method class="freemarker.core.EscapeBlock" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.EscapeBlock" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.EscapeBlock" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.EscapeBlock" name="void setContent(freemarker.core.TemplateElements)" map="B"/>
  <method class="freemarker.core.EscapeBlock" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.EscapeBlock" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.TemplateObject" map="DC"/>
  <field class="freemarker.core.TemplateObject" name="beginLine" map="A"/>
  <field class="freemarker.core.TemplateObject" name="template" map="B"/>
  <field class="freemarker.core.TemplateObject" name="endLine" map="C"/>
  <field class="freemarker.core.TemplateObject" name="beginColumn" map="D"/>
  <field class="freemarker.core.TemplateObject" name="endColumn" map="E"/>
  <method class="freemarker.core.TemplateObject" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.TemplateObject" name="int getEndLine()" map="B"/>
  <method class="freemarker.core.TemplateObject" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.core.TemplateObject" name="void setLocation(freemarker.template.Template, freemarker.core.TemplateObject, freemarker.core.Token)" map="A"/>
  <method class="freemarker.core.TemplateObject" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.TemplateObject" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.TemplateObject" name="void setLocation(freemarker.template.Template, freemarker.core.Token, freemarker.core.TemplateObject)" map="A"/>
  <method class="freemarker.core.TemplateObject" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.TemplateObject" name="int getEndColumn()" map="E"/>
  <method class="freemarker.core.TemplateObject" name="freemarker.core.TemplateObject copyLocationFrom(freemarker.core.TemplateObject)" map="A"/>
  <method class="freemarker.core.TemplateObject" name="void setLocation(freemarker.template.Template, freemarker.core.Token, freemarker.core.Token, freemarker.core.TemplateElements)" map="A"/>
  <method class="freemarker.core.TemplateObject" name="void setLocation(freemarker.template.Template, freemarker.core.TemplateObject, freemarker.core.TemplateObject)" map="A"/>
  <method class="freemarker.core.TemplateObject" name="void setLocation(freemarker.template.Template, int, int, int, int)" map="A"/>
  <method class="freemarker.core.TemplateObject" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.TemplateObject" name="java.lang.String getStartLocation()" map="F"/>
  <method class="freemarker.core.TemplateObject" name="freemarker.template.Template getTemplate()" map="G"/>
  <method class="freemarker.core.TemplateObject" name="int getBeginLine()" map="H"/>
  <method class="freemarker.core.TemplateObject" name="java.lang.String getStartLocationQuoted()" map="I"/>
  <method class="freemarker.core.TemplateObject" name="int getBeginColumn()" map="J"/>
  <method class="freemarker.core.TemplateObject" name="java.lang.String getSource()" map="K"/>
  <method class="freemarker.core.TemplateObject" name="void setLocation(freemarker.template.Template, freemarker.core.Token, freemarker.core.Token)" map="A"/>
  <class name="freemarker.core.TemplateDateFormatFactory" map="EC"/>
  <method class="freemarker.core.TemplateDateFormatFactory" name="freemarker.core.TemplateDateFormat get(java.lang.String, int, java.util.Locale, java.util.TimeZone, boolean, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.Configurable$SettingStringParser" map="_A"/>
  <field class="freemarker.core.Configurable$SettingStringParser" name="ln" map="A"/>
  <field class="freemarker.core.Configurable$SettingStringParser" name="p" map="B"/>
  <field class="freemarker.core.Configurable$SettingStringParser" name="text" map="C"/>
  <method class="freemarker.core.Configurable$SettingStringParser" name="java.lang.String fetchWord()" map="A"/>
  <method class="freemarker.core.Configurable$SettingStringParser" name="java.lang.String fetchStringValue()" map="B"/>
  <method class="freemarker.core.Configurable$SettingStringParser" name="java.util.HashMap parseAsImportList()" map="C"/>
  <method class="freemarker.core.Configurable$SettingStringParser" name="java.util.ArrayList parseAsList()" map="D"/>
  <method class="freemarker.core.Configurable$SettingStringParser" name="java.util.ArrayList parseAsSegmentedList()" map="E"/>
  <method class="freemarker.core.Configurable$SettingStringParser" name="char skipWS()" map="F"/>
  <method class="freemarker.core.Configurable$SettingStringParser" name="java.lang.String fetchKeyword()" map="G"/>
  <class name="freemarker.core.Configurable$UnknownSettingException" map="_B"/>
  <class name="freemarker.core.Configurable$SettingValueAssignmentException" map="_C"/>
  <class name="freemarker.core.Configurable$1" map="1"/>
  <class name="freemarker.core.Configurable$KeyValuePair" map="_D"/>
  <field class="freemarker.core.Configurable$KeyValuePair" name="key" map="A"/>
  <field class="freemarker.core.Configurable$KeyValuePair" name="value" map="B"/>
  <method class="freemarker.core.Configurable$KeyValuePair" name="java.lang.Object getKey()" map="A"/>
  <method class="freemarker.core.Configurable$KeyValuePair" name="java.lang.Object getValue()" map="B"/>
  <class name="freemarker.core.Configurable" map="FC"/>
  <field class="freemarker.core.Configurable" name="properties" map="A"/>
  <field class="freemarker.core.Configurable" name="SETTING_NAMES_SNAKE_CASE" map="B"/>
  <field class="freemarker.core.Configurable" name="autoFlush" map="C"/>
  <field class="freemarker.core.Configurable" name="showErrorTips" map="D"/>
  <field class="freemarker.core.Configurable" name="timeZone" map="E"/>
  <field class="freemarker.core.Configurable" name="wrapUncheckedExceptions" map="F"/>
  <field class="freemarker.core.Configurable" name="falseStringValue" map="G"/>
  <field class="freemarker.core.Configurable" name="logTemplateExceptions" map="H"/>
  <field class="freemarker.core.Configurable" name="customNumberFormats" map="I"/>
  <field class="freemarker.core.Configurable" name="parent" map="J"/>
  <field class="freemarker.core.Configurable" name="classicCompatible" map="K"/>
  <field class="freemarker.core.Configurable" name="booleanFormat" map="L"/>
  <field class="freemarker.core.Configurable" name="customAttributes" map="M"/>
  <field class="freemarker.core.Configurable" name="lazyAutoImports" map="N"/>
  <field class="freemarker.core.Configurable" name="outputEncoding" map="O"/>
  <field class="freemarker.core.Configurable" name="locale" map="P"/>
  <field class="freemarker.core.Configurable" name="sqlDataAndTimeTimeZone" map="Q"/>
  <field class="freemarker.core.Configurable" name="dateFormat" map="R"/>
  <field class="freemarker.core.Configurable" name="objectWrapper" map="S"/>
  <field class="freemarker.core.Configurable" name="sqlDataAndTimeTimeZoneSet" map="T"/>
  <field class="freemarker.core.Configurable" name="autoIncludes" map="U"/>
  <field class="freemarker.core.Configurable" name="dateTimeFormat" map="V"/>
  <field class="freemarker.core.Configurable" name="lazyAutoImportsSet" map="W"/>
  <field class="freemarker.core.Configurable" name="urlEscapingCharsetSet" map="X"/>
  <field class="freemarker.core.Configurable" name="trueStringValue" map="Y"/>
  <field class="freemarker.core.Configurable" name="timeFormat" map="Z"/>
  <field class="freemarker.core.Configurable" name="newBuiltinClassResolver" map="_"/>
  <field class="freemarker.core.Configurable" name="attemptExceptionReporter" map="a"/>
  <field class="freemarker.core.Configurable" name="apiBuiltinEnabled" map="b"/>
  <field class="freemarker.core.Configurable" name="outputEncodingSet" map="c"/>
  <field class="freemarker.core.Configurable" name="SETTING_NAMES_CAMEL_CASE" map="d"/>
  <field class="freemarker.core.Configurable" name="templateExceptionHandler" map="e"/>
  <field class="freemarker.core.Configurable" name="lazyImports" map="f"/>
  <field class="freemarker.core.Configurable" name="customDateFormats" map="g"/>
  <field class="freemarker.core.Configurable" name="autoImports" map="h"/>
  <field class="freemarker.core.Configurable" name="urlEscapingCharset" map="i"/>
  <field class="freemarker.core.Configurable" name="numberFormat" map="j"/>
  <field class="freemarker.core.Configurable" name="arithmeticEngine" map="k"/>
  <method class="freemarker.core.Configurable" name="void addAutoInclude(java.lang.String, boolean)" map="A"/>
  <method class="freemarker.core.Configurable" name="void setDateFormat(java.lang.String)" map="A"/>
  <method class="freemarker.core.Configurable" name="void setAutoIncludes(java.util.List)" map="A"/>
  <method class="freemarker.core.Configurable" name="int getClassicCompatibleAsInt()" map="L"/>
  <method class="freemarker.core.Configurable" name="java.lang.String getBooleanFormat()" map="M"/>
  <method class="freemarker.core.Configurable" name="java.lang.String getSetting(java.lang.String)" map="B"/>
  <method class="freemarker.core.Configurable" name="void setAutoFlush(boolean)" map="A"/>
  <method class="freemarker.core.Configurable" name="freemarker.core.Environment getEnvironment()" map="N"/>
  <method class="freemarker.core.Configurable" name="java.util.Locale getLocale()" map="O"/>
  <method class="freemarker.core.Configurable" name="java.lang.Boolean getLazyAutoImports()" map="P"/>
  <method class="freemarker.core.Configurable" name="boolean getAutoFlush()" map="Q"/>
  <method class="freemarker.core.Configurable" name="boolean getWrapUncheckedExceptions()" map="R"/>
  <method class="freemarker.core.Configurable" name="void initAutoImportsMap()" map="S"/>
  <method class="freemarker.core.Configurable" name="void setShowErrorTips(boolean)" map="B"/>
  <method class="freemarker.core.Configurable" name="void setLocale(java.util.Locale)" map="A"/>
  <method class="freemarker.core.Configurable" name="java.lang.String getFalseStringValue()" map="T"/>
  <method class="freemarker.core.Configurable" name="java.lang.String classicCompatibilityIntToString(java.lang.Integer)" map="A"/>
  <method class="freemarker.core.Configurable" name="void doAutoImportsAndIncludes(freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.Configurable" name="void setBooleanFormat(java.lang.String)" map="C"/>
  <method class="freemarker.core.Configurable" name="void setTimeZone(java.util.TimeZone)" map="A"/>
  <method class="freemarker.core.Configurable" name="void validateFormatNames(java.util.Set)" map="A"/>
  <method class="freemarker.core.Configurable" name="void setSetting(java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.core.Configurable" name="freemarker.template.TemplateException settingValueAssignmentException(java.lang.String, java.lang.String, java.lang.Throwable)" map="A"/>
  <method class="freemarker.core.Configurable" name="java.util.List getAutoIncludesWithoutFallback()" map="U"/>
  <method class="freemarker.core.Configurable" name="void setArithmeticEngine(freemarker.core.ArithmeticEngine)" map="A"/>
  <method class="freemarker.core.Configurable" name="freemarker.core.ArithmeticEngine getArithmeticEngine()" map="A"/>
  <method class="freemarker.core.Configurable" name="java.lang.Object clone()" map="clone"/>
  <method class="freemarker.core.Configurable" name="freemarker.core.TemplateDateFormatFactory getCustomDateFormat(java.lang.String)" map="D"/>
  <method class="freemarker.core.Configurable" name="void setLogTemplateExceptions(boolean)" map="C"/>
  <method class="freemarker.core.Configurable" name="void initAutoIncludesList()" map="V"/>
  <method class="freemarker.core.Configurable" name="void setCustomNumberFormats(java.util.Map)" map="A"/>
  <method class="freemarker.core.Configurable" name="freemarker.template.ObjectWrapper getObjectWrapper()" map="W"/>
  <method class="freemarker.core.Configurable" name="java.util.HashMap parseAsImportList(java.lang.String)" map="E"/>
  <method class="freemarker.core.Configurable" name="freemarker.template.AttemptExceptionReporter getAttemptExceptionReporter()" map="X"/>
  <method class="freemarker.core.Configurable" name="java.util.ArrayList parseAsSegmentedList(java.lang.String)" map="F"/>
  <method class="freemarker.core.Configurable" name="java.util.TimeZone getTimeZone()" map="Y"/>
  <method class="freemarker.core.Configurable" name="void setURLEscapingCharset(java.lang.String)" map="G"/>
  <method class="freemarker.core.Configurable" name="void setObjectWrapper(freemarker.template.ObjectWrapper)" map="A"/>
  <method class="freemarker.core.Configurable" name="void setLazyImports(boolean)" map="D"/>
  <method class="freemarker.core.Configurable" name="java.lang.String getURLEscapingCharset()" map="Z"/>
  <method class="freemarker.core.Configurable" name="void setWrapUncheckedExceptions(boolean)" map="E"/>
  <method class="freemarker.core.Configurable" name="boolean getShowErrorTips()" map="_"/>
  <method class="freemarker.core.Configurable" name="boolean hasCustomFormats()" map="a"/>
  <method class="freemarker.core.Configurable" name="void setOutputEncoding(java.lang.String)" map="H"/>
  <method class="freemarker.core.Configurable" name="java.lang.String formatBoolean(boolean, boolean)" map="A"/>
  <method class="freemarker.core.Configurable" name="boolean getLogTemplateExceptions()" map="b"/>
  <method class="freemarker.core.Configurable" name="java.util.Map getAutoImportsWithoutFallback()" map="c"/>
  <method class="freemarker.core.Configurable" name="freemarker.template.TemplateException invalidSettingValueException(java.lang.String, java.lang.String)" map="B"/>
  <method class="freemarker.core.Configurable" name="freemarker.core._ErrorDescriptionBuilder getNullBooleanFormatErrorDescription()" map="d"/>
  <method class="freemarker.core.Configurable" name="boolean getLazyImports()" map="e"/>
  <method class="freemarker.core.Configurable" name="java.lang.String getOutputEncoding()" map="f"/>
  <method class="freemarker.core.Configurable" name="void setParent(freemarker.core.Configurable)" map="A"/>
  <method class="freemarker.core.Configurable" name="void setAttemptExceptionReporter(freemarker.template.AttemptExceptionReporter)" map="A"/>
  <method class="freemarker.core.Configurable" name="java.lang.String getDateTimeFormat()" map="g"/>
  <method class="freemarker.core.Configurable" name="void setNumberFormat(java.lang.String)" map="I"/>
  <method class="freemarker.core.Configurable" name="java.lang.String getCorrectedNameForUnknownSetting(java.lang.String)" map="J"/>
  <method class="freemarker.core.Configurable" name="boolean isLocaleSet()" map="h"/>
  <method class="freemarker.core.Configurable" name="void setLazyAutoImports(java.lang.Boolean)" map="A"/>
  <method class="freemarker.core.Configurable" name="java.util.ArrayList parseAsList(java.lang.String)" map="K"/>
  <method class="freemarker.core.Configurable" name="void setStrictBeanModels(boolean)" map="F"/>
  <method class="freemarker.core.Configurable" name="void setNewBuiltinClassResolver(freemarker.core.TemplateClassResolver)" map="A"/>
  <method class="freemarker.core.Configurable" name="freemarker.core.Configurable getParent()" map="i"/>
  <method class="freemarker.core.Configurable" name="void setAPIBuiltinEnabled(boolean)" map="G"/>
  <method class="freemarker.core.Configurable" name="void setClassicCompatibleAsInt(int)" map="A"/>
  <method class="freemarker.core.Configurable" name="void setTemplateExceptionHandler(freemarker.template.TemplateExceptionHandler)" map="A"/>
  <method class="freemarker.core.Configurable" name="freemarker.core.TemplateNumberFormatFactory getCustomNumberFormat(java.lang.String)" map="L"/>
  <method class="freemarker.core.Configurable" name="freemarker.template.TemplateException unknownSettingException(java.lang.String)" map="M"/>
  <method class="freemarker.core.Configurable" name="java.lang.String getTimeFormat()" map="j"/>
  <method class="freemarker.core.Configurable" name="void setSQLDateAndTimeTimeZone(java.util.TimeZone)" map="B"/>
  <method class="freemarker.core.Configurable" name="void setTimeFormat(java.lang.String)" map="N"/>
  <method class="freemarker.core.Configurable" name="java.lang.String getDateFormat()" map="k"/>
  <method class="freemarker.core.Configurable" name="void setClassicCompatible(boolean)" map="H"/>
  <method class="freemarker.core.Configurable" name="freemarker.template.TemplateExceptionHandler getTemplateExceptionHandler()" map="l"/>
  <method class="freemarker.core.Configurable" name="void setCustomAttribute(java.lang.String, java.lang.Object)" map="A"/>
  <method class="freemarker.core.Configurable" name="boolean isClassicCompatible()" map="m"/>
  <method class="freemarker.core.Configurable" name="void setAutoImports(java.util.Map)" map="B"/>
  <method class="freemarker.core.Configurable" name="freemarker.core.TemplateClassResolver getNewBuiltinClassResolver()" map="n"/>
  <method class="freemarker.core.Configurable" name="void setCustomDateFormats(java.util.Map)" map="C"/>
  <method class="freemarker.core.Configurable" name="void setDateTimeFormat(java.lang.String)" map="O"/>
  <method class="freemarker.core.Configurable" name="java.lang.String getNumberFormat()" map="o"/>
  <method class="freemarker.core.Configurable" name="void addAutoImport(java.lang.String, java.lang.String)" map="C"/>
  <method class="freemarker.core.Configurable" name="java.util.Set getSettingNames(boolean)" map="I"/>
  <method class="freemarker.core.Configurable" name="java.util.TimeZone getSQLDateAndTimeTimeZone()" map="p"/>
  <method class="freemarker.core.Configurable" name="java.lang.String getTrueStringValue()" map="q"/>
  <method class="freemarker.core.Configurable" name="boolean isAPIBuiltinEnabled()" map="r"/>
  <method class="freemarker.core.Configurable" name="java.util.TimeZone parseTimeZoneSettingValue(java.lang.String)" map="P"/>
  <class name="freemarker.core.LocalContextStack" map="GC"/>
  <field class="freemarker.core.LocalContextStack" name="buffer" map="A"/>
  <field class="freemarker.core.LocalContextStack" name="size" map="B"/>
  <method class="freemarker.core.LocalContextStack" name="void pop()" map="A"/>
  <method class="freemarker.core.LocalContextStack" name="int size()" map="B"/>
  <method class="freemarker.core.LocalContextStack" name="void push(freemarker.core.LocalContext)" map="A"/>
  <method class="freemarker.core.LocalContextStack" name="freemarker.core.LocalContext get(int)" map="A"/>
  <class name="freemarker.core._DelayedGetCanonicalForm" map="HC"/>
  <method class="freemarker.core._DelayedGetCanonicalForm" name="java.lang.String doConversion(java.lang.Object)" map="A"/>
  <class name="freemarker.core.CombinedMarkupOutputFormat" map="IC"/>
  <field class="freemarker.core.CombinedMarkupOutputFormat" name="inner" map="H"/>
  <field class="freemarker.core.CombinedMarkupOutputFormat" name="name" map="I"/>
  <field class="freemarker.core.CombinedMarkupOutputFormat" name="outer" map="J"/>
  <method class="freemarker.core.CombinedMarkupOutputFormat" name="freemarker.core.CommonTemplateMarkupOutputModel newTemplateMarkupOutputModel(java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.core.CombinedMarkupOutputFormat" name="java.lang.String getMimeType()" map="B"/>
  <method class="freemarker.core.CombinedMarkupOutputFormat" name="java.lang.String escapePlainText(java.lang.String)" map="A"/>
  <method class="freemarker.core.CombinedMarkupOutputFormat" name="boolean isLegacyBuiltInBypassed(java.lang.String)" map="B"/>
  <method class="freemarker.core.CombinedMarkupOutputFormat" name="java.lang.String getName()" map="C"/>
  <method class="freemarker.core.CombinedMarkupOutputFormat" name="boolean isOutputFormatMixingAllowed()" map="D"/>
  <method class="freemarker.core.CombinedMarkupOutputFormat" name="void output(java.lang.String, java.io.Writer)" map="A"/>
  <method class="freemarker.core.CombinedMarkupOutputFormat" name="freemarker.core.TemplateCombinedMarkupOutputModel newTemplateMarkupOutputModel(java.lang.String, java.lang.String)" map="E"/>
  <method class="freemarker.core.CombinedMarkupOutputFormat" name="boolean isAutoEscapedByDefault()" map="E"/>
  <class name="freemarker.core.ListElseContainer" map="JC"/>
  <field class="freemarker.core.ListElseContainer" name="elsePart" map="&#x010f;"/>
  <field class="freemarker.core.ListElseContainer" name="listPart" map="&#x0110;"/>
  <method class="freemarker.core.ListElseContainer" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.ListElseContainer" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.ListElseContainer" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.ListElseContainer" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.ListElseContainer" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.ListElseContainer" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.AssignmentInstruction" map="KC"/>
  <field class="freemarker.core.AssignmentInstruction" name="namespaceExp" map="&#x0111;"/>
  <field class="freemarker.core.AssignmentInstruction" name="scope" map="&#x0112;"/>
  <method class="freemarker.core.AssignmentInstruction" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.AssignmentInstruction" name="void setNamespaceExp(freemarker.core.Expression)" map="C"/>
  <method class="freemarker.core.AssignmentInstruction" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.AssignmentInstruction" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.AssignmentInstruction" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.AssignmentInstruction" name="void addAssignment(freemarker.core.Assignment)" map="A"/>
  <method class="freemarker.core.AssignmentInstruction" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.AssignmentInstruction" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core._DelayedGetMessageWithoutStackTop" map="LC"/>
  <method class="freemarker.core._DelayedGetMessageWithoutStackTop" name="java.lang.String doConversion(java.lang.Object)" map="A"/>
  <class name="freemarker.core._TemplateModelException" map="MC"/>
  <method class="freemarker.core._TemplateModelException" name="java.lang.Object[] modelHasStoredNullDescription(java.lang.Class, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.ParentheticalExpression" map="NC"/>
  <field class="freemarker.core.ParentheticalExpression" name="nested" map="&#x0281;"/>
  <method class="freemarker.core.ParentheticalExpression" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.ParentheticalExpression" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.ParentheticalExpression" name="boolean evalToBoolean(freemarker.core.Environment)" map="B"/>
  <method class="freemarker.core.ParentheticalExpression" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.ParentheticalExpression" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.ParentheticalExpression" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.ParentheticalExpression" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.ParentheticalExpression" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.ParentheticalExpression" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <class name="freemarker.core.NonNodeException" map="OC"/>
  <field class="freemarker.core.NonNodeException" name="EXPECTED_TYPES" map="g"/>
  <class name="freemarker.core.TemplateClassResolver$3" map="3"/>
  <method class="freemarker.core.TemplateClassResolver$3" name="java.lang.Class resolve(java.lang.String, freemarker.core.Environment, freemarker.template.Template)" map="A"/>
  <class name="freemarker.core.TemplateClassResolver$2" map="2"/>
  <method class="freemarker.core.TemplateClassResolver$2" name="java.lang.Class resolve(java.lang.String, freemarker.core.Environment, freemarker.template.Template)" map="A"/>
  <class name="freemarker.core.TemplateClassResolver$1" map="1"/>
  <method class="freemarker.core.TemplateClassResolver$1" name="java.lang.Class resolve(java.lang.String, freemarker.core.Environment, freemarker.template.Template)" map="A"/>
  <class name="freemarker.core.TemplateClassResolver" map="PC"/>
  <field class="freemarker.core.TemplateClassResolver" name="SAFER_RESOLVER" map="A"/>
  <field class="freemarker.core.TemplateClassResolver" name="UNRESTRICTED_RESOLVER" map="B"/>
  <field class="freemarker.core.TemplateClassResolver" name="ALLOWS_NOTHING_RESOLVER" map="C"/>
  <method class="freemarker.core.TemplateClassResolver" name="java.lang.Class resolve(java.lang.String, freemarker.core.Environment, freemarker.template.Template)" map="A"/>
  <class name="freemarker.core._SortedArraySet" map="QC"/>
  <field class="freemarker.core._SortedArraySet" name="array" map="A"/>
  <method class="freemarker.core._SortedArraySet" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="freemarker.core._SortedArraySet" name="void clear()" map="clear"/>
  <method class="freemarker.core._SortedArraySet" name="boolean removeAll(java.util.Collection)" map="removeAll"/>
  <method class="freemarker.core._SortedArraySet" name="boolean contains(java.lang.Object)" map="contains"/>
  <method class="freemarker.core._SortedArraySet" name="boolean add(java.lang.Object)" map="add"/>
  <method class="freemarker.core._SortedArraySet" name="boolean retainAll(java.util.Collection)" map="retainAll"/>
  <method class="freemarker.core._SortedArraySet" name="boolean addAll(java.util.Collection)" map="addAll"/>
  <method class="freemarker.core._SortedArraySet" name="int size()" map="size"/>
  <method class="freemarker.core._SortedArraySet" name="boolean remove(java.lang.Object)" map="remove"/>
  <class name="freemarker.core.TemplateHTMLOutputModel" map="RC"/>
  <method class="freemarker.core.TemplateHTMLOutputModel" name="freemarker.core.MarkupOutputFormat getOutputFormat()" map="x"/>
  <method class="freemarker.core.TemplateHTMLOutputModel" name="freemarker.core.HTMLOutputFormat getOutputFormat()" map="&#x00a5;"/>
  <class name="freemarker.core.NonUserDefinedDirectiveLikeException" map="SC"/>
  <field class="freemarker.core.NonUserDefinedDirectiveLikeException" name="EXPECTED_TYPES" map="h"/>
  <class name="freemarker.core.RTFOutputFormat" map="TC"/>
  <field class="freemarker.core.RTFOutputFormat" name="INSTANCE" map="K"/>
  <method class="freemarker.core.RTFOutputFormat" name="freemarker.core.CommonTemplateMarkupOutputModel newTemplateMarkupOutputModel(java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.core.RTFOutputFormat" name="freemarker.core.TemplateRTFOutputModel newTemplateMarkupOutputModel(java.lang.String, java.lang.String)" map="F"/>
  <method class="freemarker.core.RTFOutputFormat" name="java.lang.String getMimeType()" map="B"/>
  <method class="freemarker.core.RTFOutputFormat" name="boolean isLegacyBuiltInBypassed(java.lang.String)" map="B"/>
  <method class="freemarker.core.RTFOutputFormat" name="void output(java.lang.String, java.io.Writer)" map="A"/>
  <method class="freemarker.core.RTFOutputFormat" name="java.lang.String getName()" map="C"/>
  <method class="freemarker.core.RTFOutputFormat" name="java.lang.String escapePlainText(java.lang.String)" map="A"/>
  <class name="freemarker.core.NumericalOutput$FormatHolder" map="_A"/>
  <field class="freemarker.core.NumericalOutput$FormatHolder" name="locale" map="A"/>
  <field class="freemarker.core.NumericalOutput$FormatHolder" name="format" map="B"/>
  <class name="freemarker.core.NumericalOutput" map="UC"/>
  <field class="freemarker.core.NumericalOutput" name="hasFormat" map="&#x00dd;"/>
  <field class="freemarker.core.NumericalOutput" name="autoEscapeOutputFormat" map="&#x00de;"/>
  <field class="freemarker.core.NumericalOutput" name="formatCache" map="&#x00df;"/>
  <field class="freemarker.core.NumericalOutput" name="expression" map="&#x00e0;"/>
  <field class="freemarker.core.NumericalOutput" name="maxFracDigits" map="&#x00e1;"/>
  <field class="freemarker.core.NumericalOutput" name="minFracDigits" map="&#x00e2;"/>
  <method class="freemarker.core.NumericalOutput" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.NumericalOutput" name="boolean heedsTrailingWhitespace()" map="g"/>
  <method class="freemarker.core.NumericalOutput" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.NumericalOutput" name="boolean heedsOpeningWhitespace()" map="h"/>
  <method class="freemarker.core.NumericalOutput" name="java.lang.String calculateInterpolatedStringOrMarkup(freemarker.core.Environment)" map="M"/>
  <method class="freemarker.core.NumericalOutput" name="java.lang.Object calculateInterpolatedStringOrMarkup(freemarker.core.Environment)" map="L"/>
  <method class="freemarker.core.NumericalOutput" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.NumericalOutput" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.NumericalOutput" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.NumericalOutput" name="java.lang.String dump(boolean, boolean)" map="A"/>
  <class name="freemarker.core.NewBI$ConstructorFunction" map="_A"/>
  <field class="freemarker.core.NewBI$ConstructorFunction" name="this$0" map="&#x015a;"/>
  <field class="freemarker.core.NewBI$ConstructorFunction" name="cl" map="&#x015b;"/>
  <field class="freemarker.core.NewBI$ConstructorFunction" name="env" map="&#x015c;"/>
  <method class="freemarker.core.NewBI$ConstructorFunction" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.NewBI" map="VC"/>
  <field class="freemarker.core.NewBI" name="JYTHON_MODEL_CLASS" map="z"/>
  <method class="freemarker.core.NewBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.IteratorBlock$IterationContext" map="_A"/>
  <field class="freemarker.core.IteratorBlock$IterationContext" name="hasNext" map="K"/>
  <field class="freemarker.core.IteratorBlock$IterationContext" name="loopVarName" map="L"/>
  <field class="freemarker.core.IteratorBlock$IterationContext" name="loopVar2" map="M"/>
  <field class="freemarker.core.IteratorBlock$IterationContext" name="openedIterator" map="N"/>
  <field class="freemarker.core.IteratorBlock$IterationContext" name="localVarNames" map="O"/>
  <field class="freemarker.core.IteratorBlock$IterationContext" name="this$0" map="P"/>
  <field class="freemarker.core.IteratorBlock$IterationContext" name="index" map="Q"/>
  <field class="freemarker.core.IteratorBlock$IterationContext" name="alreadyEntered" map="R"/>
  <field class="freemarker.core.IteratorBlock$IterationContext" name="loopVar2Name" map="S"/>
  <field class="freemarker.core.IteratorBlock$IterationContext" name="listedValue" map="T"/>
  <field class="freemarker.core.IteratorBlock$IterationContext" name="loopVar" map="U"/>
  <method class="freemarker.core.IteratorBlock$IterationContext" name="boolean hasNext()" map="D"/>
  <method class="freemarker.core.IteratorBlock$IterationContext" name="int getIndex()" map="E"/>
  <method class="freemarker.core.IteratorBlock$IterationContext" name="boolean executeNestedContent(freemarker.core.Environment, freemarker.core.TemplateElement[])" map="A"/>
  <method class="freemarker.core.IteratorBlock$IterationContext" name="java.lang.String getLoopVariable2Name()" map="F"/>
  <method class="freemarker.core.IteratorBlock$IterationContext" name="freemarker.template.TemplateModel getLocalVariable(java.lang.String)" map="A"/>
  <method class="freemarker.core.IteratorBlock$IterationContext" name="void loopForItemsElement(freemarker.core.Environment, freemarker.core.TemplateElement[], java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.core.IteratorBlock$IterationContext" name="java.lang.String getLoopVariableName()" map="G"/>
  <method class="freemarker.core.IteratorBlock$IterationContext" name="java.util.Collection getLocalVariableNames()" map="A"/>
  <method class="freemarker.core.IteratorBlock$IterationContext" name="boolean executedNestedContentForHashListing(freemarker.core.Environment, freemarker.core.TemplateElement[])" map="B"/>
  <method class="freemarker.core.IteratorBlock$IterationContext" name="boolean accept(freemarker.core.Environment)" map="B"/>
  <method class="freemarker.core.IteratorBlock$IterationContext" name="boolean executedNestedContentForCollOrSeqListing(freemarker.core.Environment, freemarker.core.TemplateElement[])" map="C"/>
  <class name="freemarker.core.IteratorBlock" map="WC"/>
  <field class="freemarker.core.IteratorBlock" name="listedExp" map="&#x0113;"/>
  <field class="freemarker.core.IteratorBlock" name="loopVar2Name" map="&#x0114;"/>
  <field class="freemarker.core.IteratorBlock" name="hashListing" map="&#x0115;"/>
  <field class="freemarker.core.IteratorBlock" name="loopVarName" map="&#x0116;"/>
  <field class="freemarker.core.IteratorBlock" name="forEach" map="&#x0117;"/>
  <method class="freemarker.core.IteratorBlock" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.IteratorBlock" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.IteratorBlock" name="boolean access$000(freemarker.core.IteratorBlock)" map="A"/>
  <method class="freemarker.core.IteratorBlock" name="freemarker.core.IteratorBlock$IterationContext findEnclosingIterationContext(freemarker.core.Environment, java.lang.String)" map="B"/>
  <method class="freemarker.core.IteratorBlock" name="boolean acceptWithResult(freemarker.core.Environment)" map="N"/>
  <method class="freemarker.core.IteratorBlock" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.IteratorBlock" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.IteratorBlock" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.IteratorBlock" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.IteratorBlock" name="freemarker.core.Expression access$100(freemarker.core.IteratorBlock)" map="B"/>
  <class name="freemarker.core.XSTemplateDateFormat" map="XC"/>
  <method class="freemarker.core.XSTemplateDateFormat" name="java.lang.String format(java.util.Date, boolean, boolean, boolean, int, java.util.TimeZone, freemarker.template.utility.DateUtil$DateToISO8601CalendarFactory)" map="A"/>
  <method class="freemarker.core.XSTemplateDateFormat" name="java.util.Date parseTime(java.lang.String, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="C"/>
  <method class="freemarker.core.XSTemplateDateFormat" name="java.util.Date parseDate(java.lang.String, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="B"/>
  <method class="freemarker.core.XSTemplateDateFormat" name="java.lang.String getTimeDescription()" map="H"/>
  <method class="freemarker.core.XSTemplateDateFormat" name="boolean isXSMode()" map="F"/>
  <method class="freemarker.core.XSTemplateDateFormat" name="java.lang.String getDateDescription()" map="G"/>
  <method class="freemarker.core.XSTemplateDateFormat" name="java.util.Date parseDateTime(java.lang.String, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="A"/>
  <method class="freemarker.core.XSTemplateDateFormat" name="java.lang.String getDateTimeDescription()" map="E"/>
  <class name="freemarker.core.ExistsExpression" map="YC"/>
  <field class="freemarker.core.ExistsExpression" name="exp" map="&#x0282;"/>
  <method class="freemarker.core.ExistsExpression" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.ExistsExpression" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.ExistsExpression" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.ExistsExpression" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.ExistsExpression" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.ExistsExpression" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <method class="freemarker.core.ExistsExpression" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.ExistsExpression" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.NonStringException" map="ZC"/>
  <field class="freemarker.core.NonStringException" name="STRING_COERCABLE_TYPES" map="i"/>
  <class name="freemarker.core.Expression$ReplacemenetState" map="_A"/>
  <field class="freemarker.core.Expression$ReplacemenetState" name="replacementAlreadyInUse" map="A"/>
  <class name="freemarker.core.Expression" map="_C"/>
  <field class="freemarker.core.Expression" name="constantValue" map="F"/>
  <method class="freemarker.core.Expression" name="boolean evalToBoolean(freemarker.core.Environment, freemarker.template.Configuration)" map="A"/>
  <method class="freemarker.core.Expression" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.Expression" name="java.lang.String evalAndCoerceToPlainText(freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.Expression" name="boolean isEmpty(freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.core.Expression" name="boolean evalToBoolean(freemarker.core.Environment)" map="B"/>
  <method class="freemarker.core.Expression" name="freemarker.template.TemplateModel evalToNonMissing(freemarker.core.Environment)" map="C"/>
  <method class="freemarker.core.Expression" name="freemarker.core.Expression deepCloneWithIdentifierReplaced(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="A"/>
  <method class="freemarker.core.Expression" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <method class="freemarker.core.Expression" name="java.lang.String evalAndCoerceToStringOrUnsupportedMarkup(freemarker.core.Environment, java.lang.String)" map="A"/>
  <method class="freemarker.core.Expression" name="void setLocation(freemarker.template.Template, int, int, int, int)" map="A"/>
  <method class="freemarker.core.Expression" name="boolean evalToBoolean(freemarker.template.Configuration)" map="A"/>
  <method class="freemarker.core.Expression" name="java.lang.Number evalToNumber(freemarker.core.Environment)" map="D"/>
  <method class="freemarker.core.Expression" name="boolean modelToBoolean(freemarker.template.TemplateModel, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.Expression" name="freemarker.template.TemplateModel eval(freemarker.core.Environment)" map="E"/>
  <method class="freemarker.core.Expression" name="java.lang.Number modelToNumber(freemarker.template.TemplateModel, freemarker.core.Environment)" map="B"/>
  <method class="freemarker.core.Expression" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.Expression" name="void assertNonNull(freemarker.template.TemplateModel, freemarker.core.Environment)" map="C"/>
  <method class="freemarker.core.Expression" name="boolean modelToBoolean(freemarker.template.TemplateModel, freemarker.core.Environment, freemarker.template.Configuration)" map="A"/>
  <method class="freemarker.core.Expression" name="java.lang.String evalAndCoerceToStringOrUnsupportedMarkup(freemarker.core.Environment)" map="G"/>
  <class name="freemarker.core.OutputFormat" map="aC"/>
  <method class="freemarker.core.OutputFormat" name="java.lang.String toStringExtraProperties()" map="A"/>
  <method class="freemarker.core.OutputFormat" name="java.lang.String getMimeType()" map="B"/>
  <method class="freemarker.core.OutputFormat" name="java.lang.String getName()" map="C"/>
  <method class="freemarker.core.OutputFormat" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.core.OutputFormat" name="boolean isOutputFormatMixingAllowed()" map="D"/>
  <class name="freemarker.core._DelayedGetMessage" map="bC"/>
  <method class="freemarker.core._DelayedGetMessage" name="java.lang.String doConversion(java.lang.Object)" map="A"/>
  <class name="freemarker.core.FlushInstruction" map="cC"/>
  <method class="freemarker.core.FlushInstruction" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.FlushInstruction" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.FlushInstruction" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.FlushInstruction" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.FlushInstruction" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.FlushInstruction" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.MarkupOutputFormat" map="dC"/>
  <method class="freemarker.core.MarkupOutputFormat" name="java.lang.String getSourcePlainText(freemarker.core.TemplateMarkupOutputModel)" map="A"/>
  <method class="freemarker.core.MarkupOutputFormat" name="java.lang.String getMarkupString(freemarker.core.TemplateMarkupOutputModel)" map="B"/>
  <method class="freemarker.core.MarkupOutputFormat" name="java.lang.String escapePlainText(java.lang.String)" map="A"/>
  <method class="freemarker.core.MarkupOutputFormat" name="boolean isLegacyBuiltInBypassed(java.lang.String)" map="B"/>
  <method class="freemarker.core.MarkupOutputFormat" name="freemarker.core.TemplateMarkupOutputModel concat(freemarker.core.TemplateMarkupOutputModel, freemarker.core.TemplateMarkupOutputModel)" map="A"/>
  <method class="freemarker.core.MarkupOutputFormat" name="freemarker.core.TemplateMarkupOutputModel fromPlainTextByEscaping(java.lang.String)" map="C"/>
  <method class="freemarker.core.MarkupOutputFormat" name="boolean isEmpty(freemarker.core.TemplateMarkupOutputModel)" map="C"/>
  <method class="freemarker.core.MarkupOutputFormat" name="freemarker.core.TemplateMarkupOutputModel fromMarkup(java.lang.String)" map="D"/>
  <method class="freemarker.core.MarkupOutputFormat" name="void output(java.lang.String, java.io.Writer)" map="A"/>
  <method class="freemarker.core.MarkupOutputFormat" name="void output(freemarker.core.TemplateMarkupOutputModel, java.io.Writer)" map="A"/>
  <method class="freemarker.core.MarkupOutputFormat" name="boolean isAutoEscapedByDefault()" map="E"/>
  <class name="freemarker.core.NonHashException" map="eC"/>
  <field class="freemarker.core.NonHashException" name="EXPECTED_TYPES" map="j"/>
  <class name="freemarker.core.ParserConfiguration" map="fC"/>
  <method class="freemarker.core.ParserConfiguration" name="freemarker.core.ArithmeticEngine getArithmeticEngine()" map="A"/>
  <method class="freemarker.core.ParserConfiguration" name="freemarker.core.OutputFormat getOutputFormat()" map="B"/>
  <method class="freemarker.core.ParserConfiguration" name="int getInterpolationSyntax()" map="C"/>
  <method class="freemarker.core.ParserConfiguration" name="freemarker.template.Version getIncompatibleImprovements()" map="D"/>
  <method class="freemarker.core.ParserConfiguration" name="int getTagSyntax()" map="E"/>
  <method class="freemarker.core.ParserConfiguration" name="int getNamingConvention()" map="F"/>
  <method class="freemarker.core.ParserConfiguration" name="boolean getWhitespaceStripping()" map="G"/>
  <method class="freemarker.core.ParserConfiguration" name="boolean getStrictSyntaxMode()" map="H"/>
  <method class="freemarker.core.ParserConfiguration" name="boolean getRecognizeStandardFileExtensions()" map="I"/>
  <method class="freemarker.core.ParserConfiguration" name="int getAutoEscapingPolicy()" map="J"/>
  <method class="freemarker.core.ParserConfiguration" name="int getTabSize()" map="K"/>
  <class name="freemarker.core.ComparisonExpression" map="gC"/>
  <field class="freemarker.core.ComparisonExpression" name="opString" map="T"/>
  <field class="freemarker.core.ComparisonExpression" name="operation" map="U"/>
  <field class="freemarker.core.ComparisonExpression" name="right" map="V"/>
  <field class="freemarker.core.ComparisonExpression" name="left" map="W"/>
  <method class="freemarker.core.ComparisonExpression" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.ComparisonExpression" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.ComparisonExpression" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.ComparisonExpression" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.ComparisonExpression" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.ComparisonExpression" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <method class="freemarker.core.ComparisonExpression" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.ComparisonExpression" name="boolean evalToBoolean(freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core._DelayedToString" map="hC"/>
  <method class="freemarker.core._DelayedToString" name="java.lang.String doConversion(java.lang.Object)" map="A"/>
  <class name="freemarker.core.FMParserTokenManager" map="iC"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjnewLexState" map="Q"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjmatchedKind" map="R"/>
  <field class="freemarker.core.FMParserTokenManager" name="curChar" map="S"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjstrLiteralImages" map="T"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjimageLen" map="U"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjmatchedPos" map="V"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjimage" map="W"/>
  <field class="freemarker.core.FMParserTokenManager" name="namingConventionEstabilisher" map="X"/>
  <field class="freemarker.core.FMParserTokenManager" name="image" map="Y"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjtoToken" map="Z"/>
  <field class="freemarker.core.FMParserTokenManager" name="strictSyntaxMode" map="_"/>
  <field class="freemarker.core.FMParserTokenManager" name="debugStream" map="a"/>
  <field class="freemarker.core.FMParserTokenManager" name="curlyBracketNesting" map="b"/>
  <field class="freemarker.core.FMParserTokenManager" name="incompatibleImprovements" map="c"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjnextStates" map="d"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjtoSkip" map="e"/>
  <field class="freemarker.core.FMParserTokenManager" name="interpolationSyntax" map="f"/>
  <field class="freemarker.core.FMParserTokenManager" name="autodetectTagSyntax" map="g"/>
  <field class="freemarker.core.FMParserTokenManager" name="defaultLexState" map="h"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjstateSet" map="i"/>
  <field class="freemarker.core.FMParserTokenManager" name="parenthesisNesting" map="j"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjrounds" map="k"/>
  <field class="freemarker.core.FMParserTokenManager" name="noparseTag" map="l"/>
  <field class="freemarker.core.FMParserTokenManager" name="bracketNesting" map="m"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec25" map="n"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec24" map="o"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec23" map="p"/>
  <field class="freemarker.core.FMParserTokenManager" name="parser" map="q"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec22" map="r"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec21" map="s"/>
  <field class="freemarker.core.FMParserTokenManager" name="namingConvention" map="t"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec20" map="u"/>
  <field class="freemarker.core.FMParserTokenManager" name="squBracTagSyntax" map="v"/>
  <field class="freemarker.core.FMParserTokenManager" name="postInterpolationLexState" map="w"/>
  <field class="freemarker.core.FMParserTokenManager" name="inInvocation" map="x"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjnewStateCnt" map="y"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec19" map="z"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec9" map="&#x00a2;"/>
  <field class="freemarker.core.FMParserTokenManager" name="lengthOfMatch" map="&#x00a3;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjround" map="&#x00a4;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec18" map="&#x00a5;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec8" map="&#x00aa;"/>
  <field class="freemarker.core.FMParserTokenManager" name="tagSyntaxEstablished" map="&#x00b5;"/>
  <field class="freemarker.core.FMParserTokenManager" name="lexStateNames" map="&#x00ba;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec7" map="&#x00c0;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec17" map="&#x00c1;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec6" map="&#x00c2;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec16" map="&#x00c3;"/>
  <field class="freemarker.core.FMParserTokenManager" name="inFTLHeader" map="&#x00c4;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec5" map="&#x00c5;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec15" map="&#x00c6;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec4" map="&#x00c7;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec14" map="&#x00c8;"/>
  <field class="freemarker.core.FMParserTokenManager" name="initialNamingConvention" map="&#x00c9;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec3" map="&#x00ca;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec13" map="&#x00cb;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec2" map="&#x00cc;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec12" map="&#x00cd;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec11" map="&#x00ce;"/>
  <field class="freemarker.core.FMParserTokenManager" name="input_stream" map="&#x00cf;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec0" map="&#x00d0;"/>
  <field class="freemarker.core.FMParserTokenManager" name="jjbitVec10" map="&#x00d1;"/>
  <field class="freemarker.core.FMParserTokenManager" name="curLexState" map="&#x00d2;"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa1_3(long, long)" map="A"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStopStringLiteralDfa_3(int, long, long, long)" map="A"/>
  <method class="freemarker.core.FMParserTokenManager" name="void jjCheckNAddTwoStates(int, int)" map="A"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa3_6(long, long, long, long)" map="A"/>
  <method class="freemarker.core.FMParserTokenManager" name="char getTagNameCharAt(freemarker.core.Token, int)" map="A"/>
  <method class="freemarker.core.FMParserTokenManager" name="void handleTagSyntaxAndSwitch(freemarker.core.Token, int)" map="B"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa2_3(long, long, long, long)" map="B"/>
  <method class="freemarker.core.FMParserTokenManager" name="void checkNamingConvention(freemarker.core.Token)" map="A"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveNfa_2(int, int)" map="B"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa4_3(long, long, long, long)" map="C"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStartNfaWithStates_2(int, int, int)" map="A"/>
  <method class="freemarker.core.FMParserTokenManager" name="freemarker.core.Token jjFillToken()" map="F"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa3_2(long, long, long, long)" map="D"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa3_4(long, long, long, long)" map="E"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStopStringLiteralDfa_1(int, long, long)" map="A"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa1_4(long, long)" map="B"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa1_0(long)" map="A"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa0_0()" map="G"/>
  <method class="freemarker.core.FMParserTokenManager" name="void setParser(freemarker.core.FMParser)" map="A"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa0_1()" map="H"/>
  <method class="freemarker.core.FMParserTokenManager" name="void SwitchTo(int)" map="A"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa0_2()" map="I"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveNfa_3(int, int)" map="C"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa0_3()" map="J"/>
  <method class="freemarker.core.FMParserTokenManager" name="boolean jjCanMove_0(int, int, int, long, long)" map="A"/>
  <method class="freemarker.core.FMParserTokenManager" name="void handleTagSyntaxAndSwitch(freemarker.core.Token, int, int)" map="A"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa0_4()" map="K"/>
  <method class="freemarker.core.FMParserTokenManager" name="void unifiedCallEnd(freemarker.core.Token)" map="B"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa0_5()" map="L"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa0_6()" map="M"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStartNfaWithStates_6(int, int, int)" map="B"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStopStringLiteralDfa_6(int, long, long, long)" map="B"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStartNfa_3(int, long, long, long)" map="C"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa0_7()" map="N"/>
  <method class="freemarker.core.FMParserTokenManager" name="boolean isStrictTag(java.lang.String)" map="C"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStopStringLiteralDfa_0(int, long, long)" map="B"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveNfa_4(int, int)" map="D"/>
  <method class="freemarker.core.FMParserTokenManager" name="void jjCheckNAddStates(int, int)" map="E"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStopStringLiteralDfa_4(int, long, long, long)" map="D"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa1_6(long, long)" map="C"/>
  <method class="freemarker.core.FMParserTokenManager" name="void checkNamingConvention(freemarker.core.Token, int)" map="C"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStartNfaWithStates_5(int, int, int)" map="C"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa2_4(long, long, long, long)" map="F"/>
  <method class="freemarker.core.FMParserTokenManager" name="void SkipLexicalActions(freemarker.core.Token)" map="C"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa2_6(long, long, long, long)" map="G"/>
  <method class="freemarker.core.FMParserTokenManager" name="void ftlHeader(freemarker.core.Token)" map="D"/>
  <method class="freemarker.core.FMParserTokenManager" name="void jjCheckNAdd(int)" map="B"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa4_6(long, long, long, long)" map="H"/>
  <method class="freemarker.core.FMParserTokenManager" name="void eatNewline()" map="O"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveNfa_5(int, int)" map="F"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStopStringLiteralDfa_2(int, long, long, long)" map="E"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa3_3(long, long, long, long)" map="I"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa2_2(long, long, long, long)" map="J"/>
  <method class="freemarker.core.FMParserTokenManager" name="void TokenLexicalActions(freemarker.core.Token)" map="E"/>
  <method class="freemarker.core.FMParserTokenManager" name="freemarker.core.TokenMgrError newNameConventionMismatchException(freemarker.core.Token)" map="F"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa4_2(long, long, long, long)" map="K"/>
  <method class="freemarker.core.FMParserTokenManager" name="void ReInitRounds()" map="P"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa4_4(long, long, long, long)" map="L"/>
  <method class="freemarker.core.FMParserTokenManager" name="void startInterpolation(freemarker.core.Token)" map="G"/>
  <method class="freemarker.core.FMParserTokenManager" name="void endInterpolation(freemarker.core.Token)" map="H"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStartNfa_1(int, long, long)" map="C"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStartNfa_6(int, long, long, long)" map="F"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveNfa_6(int, int)" map="G"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStartNfaWithStates_4(int, int, int)" map="D"/>
  <method class="freemarker.core.FMParserTokenManager" name="boolean jjCanMove_1(int, int, int, long, long)" map="B"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveNfa_0(int, int)" map="H"/>
  <method class="freemarker.core.FMParserTokenManager" name="freemarker.core.TokenMgrError newUnexpectedClosingTokenException(freemarker.core.Token)" map="I"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStartNfa_4(int, long, long, long)" map="G"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStopAtPos(int, int)" map="I"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStartNfa_0(int, long, long)" map="D"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa1_2(long, long)" map="D"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStartNfaWithStates_3(int, int, int)" map="E"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveNfa_7(int, int)" map="J"/>
  <method class="freemarker.core.FMParserTokenManager" name="void unifiedCall(freemarker.core.Token)" map="J"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjStartNfa_2(int, long, long, long)" map="H"/>
  <method class="freemarker.core.FMParserTokenManager" name="freemarker.core.Token getNextToken()" map="Q"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveNfa_1(int, int)" map="K"/>
  <method class="freemarker.core.FMParserTokenManager" name="void jjAddStates(int, int)" map="L"/>
  <method class="freemarker.core.FMParserTokenManager" name="int getTagNamingConvention(freemarker.core.Token, int)" map="D"/>
  <method class="freemarker.core.FMParserTokenManager" name="int jjMoveStringLiteralDfa1_1(long)" map="B"/>
  <class name="freemarker.core.CollectionAndSequence$SequenceIterator" map="_A"/>
  <field class="freemarker.core.CollectionAndSequence$SequenceIterator" name="index" map="&#x01a3;"/>
  <field class="freemarker.core.CollectionAndSequence$SequenceIterator" name="size" map="&#x01a4;"/>
  <field class="freemarker.core.CollectionAndSequence$SequenceIterator" name="sequence" map="&#x01a5;"/>
  <method class="freemarker.core.CollectionAndSequence$SequenceIterator" name="boolean hasNext()" map="&#x00d1;"/>
  <method class="freemarker.core.CollectionAndSequence$SequenceIterator" name="freemarker.template.TemplateModel next()" map="&#x00d2;"/>
  <class name="freemarker.core.CollectionAndSequence" map="jC"/>
  <field class="freemarker.core.CollectionAndSequence" name="data" map="&#x0256;"/>
  <field class="freemarker.core.CollectionAndSequence" name="collection" map="&#x0257;"/>
  <field class="freemarker.core.CollectionAndSequence" name="sequence" map="&#x0258;"/>
  <method class="freemarker.core.CollectionAndSequence" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.core.CollectionAndSequence" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.core.CollectionAndSequence" name="void initSequence()" map="&#x00f9;"/>
  <method class="freemarker.core.CollectionAndSequence" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <class name="freemarker.core.UnaryPlusMinusExpression" map="kC"/>
  <field class="freemarker.core.UnaryPlusMinusExpression" name="MINUS_ONE" map="&#x0283;"/>
  <field class="freemarker.core.UnaryPlusMinusExpression" name="isMinus" map="&#x0284;"/>
  <field class="freemarker.core.UnaryPlusMinusExpression" name="target" map="&#x0285;"/>
  <method class="freemarker.core.UnaryPlusMinusExpression" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.UnaryPlusMinusExpression" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.UnaryPlusMinusExpression" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.UnaryPlusMinusExpression" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.UnaryPlusMinusExpression" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.UnaryPlusMinusExpression" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <method class="freemarker.core.UnaryPlusMinusExpression" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.UnaryPlusMinusExpression" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.Interpret$TemplateProcessorModel$1" map="1"/>
  <field class="freemarker.core.Interpret$TemplateProcessorModel$1" name="val$out" map="A"/>
  <field class="freemarker.core.Interpret$TemplateProcessorModel$1" name="this$1" map="B"/>
  <method class="freemarker.core.Interpret$TemplateProcessorModel$1" name="void write(char[], int, int)" map="write"/>
  <method class="freemarker.core.Interpret$TemplateProcessorModel$1" name="void flush()" map="flush"/>
  <method class="freemarker.core.Interpret$TemplateProcessorModel$1" name="void close()" map="close"/>
  <class name="freemarker.core.Interpret$TemplateProcessorModel" map="_A"/>
  <field class="freemarker.core.Interpret$TemplateProcessorModel" name="this$0" map="&#x0272;"/>
  <field class="freemarker.core.Interpret$TemplateProcessorModel" name="template" map="&#x0273;"/>
  <method class="freemarker.core.Interpret$TemplateProcessorModel" name="java.io.Writer getWriter(java.io.Writer, java.util.Map)" map="A"/>
  <class name="freemarker.core.Interpret" map="lC"/>
  <method class="freemarker.core.Interpret" name="freemarker.template.TemplateModel calculateResult(freemarker.core.Environment)" map="H"/>
  <class name="freemarker.core._ArrayEnumeration" map="mC"/>
  <field class="freemarker.core._ArrayEnumeration" name="nextIndex" map="A"/>
  <field class="freemarker.core._ArrayEnumeration" name="size" map="B"/>
  <field class="freemarker.core._ArrayEnumeration" name="array" map="C"/>
  <method class="freemarker.core._ArrayEnumeration" name="boolean hasMoreElements()" map="hasMoreElements"/>
  <method class="freemarker.core._ArrayEnumeration" name="java.lang.Object nextElement()" map="nextElement"/>
  <class name="freemarker.core.BuiltInsForStringsRegexp$replace_reBI$ReplaceMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$replace_reBI$ReplaceMethod" name="this$0" map="&#x026e;"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$replace_reBI$ReplaceMethod" name="s" map="&#x026f;"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$replace_reBI$ReplaceMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsRegexp$replace_reBI" map="_A"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$replace_reBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsRegexp$matchesBI$MatcherBuilder" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$matchesBI$MatcherBuilder" name="this$0" map="&#x0270;"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$matchesBI$MatcherBuilder" name="matchString" map="&#x0271;"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$matchesBI$MatcherBuilder" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForStringsRegexp$matchesBI" map="_B"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$matchesBI" name="freemarker.template.TemplateModel calculateResult(java.lang.String, freemarker.core.Environment)" map="C"/>
  <class name="freemarker.core.BuiltInsForStringsRegexp$groupsBI" map="_C"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$groupsBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$3" map="3"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$3" name="this$0" map="&#x01a6;"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$3" name="val$matchingInputParts" map="&#x01a7;"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$3" name="nextIdx" map="&#x01a8;"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$3" name="boolean hasNext()" map="&#x00d1;"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$3" name="freemarker.template.TemplateModel next()" map="&#x00d2;"/>
  <class name="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$2" map="2"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$2" name="this$0" map="&#x01a9;"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$2" name="hasFindInfo" map="&#x01aa;"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$2" name="nextIdx" map="&#x01ab;"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$2" name="val$matcher" map="&#x01ac;"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$2" name="boolean hasNext()" map="&#x00d1;"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$2" name="freemarker.template.TemplateModel next()" map="&#x00d2;"/>
  <class name="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$1" map="1"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$1" name="this$0" map="&#x0259;"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$1" name="val$firedEntireInputMatcher" map="&#x025a;"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$1" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$1" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <class name="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$MatchWithGroups" map="_A"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$MatchWithGroups" name="groupsSeq" map="&#x0216;"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$MatchWithGroups" name="matchedInputPart" map="&#x0217;"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel$MatchWithGroups" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <class name="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel" map="_D"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel" name="firedEntireInputMatcher" map="&#x0174;"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel" name="matchingInputParts" map="&#x0175;"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel" name="input" map="&#x0176;"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel" name="entireInputMatchGroups" map="&#x0177;"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel" name="pattern" map="&#x0178;"/>
  <field class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel" name="entireInputMatched" map="&#x0179;"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel" name="freemarker.template.TemplateModel getGroups()" map="&#x00c4;"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel" name="java.util.ArrayList access$000(freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel)" map="A"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel" name="boolean isEntrieInputMatchesAndStoreResults()" map="&#x00c5;"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel" name="boolean getAsBoolean()" map="&#x00c3;"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <method class="freemarker.core.BuiltInsForStringsRegexp$RegexMatchModel" name="java.util.ArrayList getMatchingInputPartsAndStoreResults()" map="&#x00c6;"/>
  <class name="freemarker.core.BuiltInsForStringsRegexp" map="nC"/>
  <class name="freemarker.core.NumberLiteral" map="oC"/>
  <field class="freemarker.core.NumberLiteral" name="value" map="&#x01bc;"/>
  <method class="freemarker.core.NumberLiteral" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.NumberLiteral" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.NumberLiteral" name="java.lang.String evalAndCoerceToPlainText(freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.NumberLiteral" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.NumberLiteral" name="java.lang.Number getAsNumber()" map="&#x00d8;"/>
  <method class="freemarker.core.NumberLiteral" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.NumberLiteral" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.NumberLiteral" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.NumberLiteral" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.NumberLiteral" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <class name="freemarker.core.NonSequenceException" map="pC"/>
  <field class="freemarker.core.NonSequenceException" name="EXPECTED_TYPES" map="k"/>
  <class name="freemarker.core.TokenMgrError" map="qC"/>
  <field class="freemarker.core.TokenMgrError" name="lineNumber" map="A"/>
  <field class="freemarker.core.TokenMgrError" name="columnNumber" map="B"/>
  <field class="freemarker.core.TokenMgrError" name="detail" map="C"/>
  <field class="freemarker.core.TokenMgrError" name="errorCode" map="D"/>
  <field class="freemarker.core.TokenMgrError" name="endColumnNumber" map="E"/>
  <field class="freemarker.core.TokenMgrError" name="endLineNumber" map="F"/>
  <method class="freemarker.core.TokenMgrError" name="java.lang.Integer getEndColumnNumber()" map="A"/>
  <method class="freemarker.core.TokenMgrError" name="java.lang.String LexicalError(boolean, int, int, int, java.lang.String, char)" map="A"/>
  <method class="freemarker.core.TokenMgrError" name="java.lang.Integer getLineNumber()" map="B"/>
  <method class="freemarker.core.TokenMgrError" name="java.lang.String getMessage()" map="getMessage"/>
  <method class="freemarker.core.TokenMgrError" name="freemarker.core.ParseException toParseException(freemarker.template.Template)" map="A"/>
  <method class="freemarker.core.TokenMgrError" name="java.lang.Integer getEndLineNumber()" map="C"/>
  <method class="freemarker.core.TokenMgrError" name="java.lang.String addEscapes(java.lang.String)" map="A"/>
  <method class="freemarker.core.TokenMgrError" name="java.lang.String getDetail()" map="D"/>
  <method class="freemarker.core.TokenMgrError" name="java.lang.Integer getColumnNumber()" map="E"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$stringBI$DateFormatter" map="_A"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$stringBI$DateFormatter" name="this$0" map="&#x01f4;"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$stringBI$DateFormatter" name="dateModel" map="&#x01f5;"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$stringBI$DateFormatter" name="defaultFormat" map="&#x01fa;"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$stringBI$DateFormatter" name="env" map="&#x01fb;"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$stringBI$DateFormatter" name="cachedValue" map="&#x01fc;"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$stringBI$DateFormatter" name="freemarker.template.TemplateModel formatWith(java.lang.String)" map="K"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$stringBI$DateFormatter" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$stringBI$DateFormatter" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$stringBI$DateFormatter" name="java.lang.Object exec(java.util.List)" map="A"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$stringBI$DateFormatter" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$stringBI$NumberFormatter" map="_B"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$stringBI$NumberFormatter" name="this$0" map="&#x01fd;"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$stringBI$NumberFormatter" name="defaultFormat" map="&#x01fe;"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$stringBI$NumberFormatter" name="env" map="&#x01ff;"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$stringBI$NumberFormatter" name="numberModel" map="&#x0200;"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$stringBI$NumberFormatter" name="number" map="&#x0201;"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$stringBI$NumberFormatter" name="cachedValue" map="&#x0202;"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$stringBI$NumberFormatter" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$stringBI$NumberFormatter" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$stringBI$NumberFormatter" name="java.lang.Object exec(java.util.List)" map="A"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$stringBI$NumberFormatter" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$stringBI$BooleanFormatter" map="_C"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$stringBI$BooleanFormatter" name="this$0" map="&#x0250;"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$stringBI$BooleanFormatter" name="bool" map="&#x0251;"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$stringBI$BooleanFormatter" name="env" map="&#x0252;"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$stringBI$BooleanFormatter" name="java.lang.Object exec(java.util.List)" map="A"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$stringBI$BooleanFormatter" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$stringBI" map="_A"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$stringBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_collectionBI" map="_B"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_collectionBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_booleanBI" map="_C"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_booleanBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_markup_outputBI" map="_D"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_markup_outputBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_transformBI" map="_E"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_transformBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$dateBI$DateParser" map="_A"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$dateBI$DateParser" name="this$0" map="&#x01c4;"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$dateBI$DateParser" name="defaultFormat" map="&#x01c5;"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$dateBI$DateParser" name="env" map="&#x01c6;"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$dateBI$DateParser" name="cachedValue" map="&#x01c7;"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$dateBI$DateParser" name="text" map="&#x01c8;"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$dateBI$DateParser" name="freemarker.template.TemplateDateModel getAsDateModel()" map="&#x00dc;"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$dateBI$DateParser" name="java.util.Date getAsDate()" map="&#x00da;"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$dateBI$DateParser" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$dateBI$DateParser" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$dateBI$DateParser" name="java.lang.Object exec(java.util.List)" map="A"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$dateBI$DateParser" name="int getDateType()" map="&#x00db;"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$dateBI$DateParser" name="freemarker.template.TemplateDateModel toTemplateDateModel(java.lang.Object)" map="C"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$dateBI$DateParser" name="java.lang.Object parse(freemarker.core.TemplateDateFormat)" map="A"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$dateBI" map="_F"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$dateBI" name="dateType" map="&#x00a2;"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$dateBI" name="int access$000(freemarker.core.BuiltInsForMultipleTypes$dateBI)" map="A"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$dateBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$has_apiBI" map="_G"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$has_apiBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_hash_exBI" map="_H"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_hash_exBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_nodeBI" map="_I"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_nodeBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_sequenceBI" map="_J"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_sequenceBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_directiveBI" map="_K"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_directiveBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_methodBI" map="_L"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_methodBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$AbstractCBI" map="_M"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$AbstractCBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$AbstractCBI" name="freemarker.template.TemplateModel formatNumber(freemarker.core.Environment, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$apiBI" map="_N"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$apiBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_indexableBI" map="_O"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_indexableBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_numberBI" map="_P"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_numberBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$cBI$BIBeforeICE2d3d21" map="_A"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$cBI$BIBeforeICE2d3d21" name="freemarker.template.TemplateModel formatNumber(freemarker.core.Environment, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$cBI" map="_Q"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$cBI" name="prevICIObj" map="o"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$cBI" name="java.lang.Object getPreviousICIChainMember()" map="S"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$cBI" name="int getMinimumICIVersion()" map="T"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$cBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$cBI" name="freemarker.template.TemplateModel formatNumber(freemarker.core.Environment, freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_enumerableBI" map="_R"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_enumerableBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$namespaceBI" map="_S"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$namespaceBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_dateOfTypeBI" map="_T"/>
  <field class="freemarker.core.BuiltInsForMultipleTypes$is_dateOfTypeBI" name="dateType" map="&#x00a3;"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_dateOfTypeBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_dateLikeBI" map="_U"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_dateLikeBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$sizeBI" map="_V"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$sizeBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_macroBI" map="_W"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_macroBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_stringBI" map="_X"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_stringBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_hashBI" map="_Y"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_hashBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes$is_collection_exBI" map="_Z"/>
  <method class="freemarker.core.BuiltInsForMultipleTypes$is_collection_exBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForMultipleTypes" map="rC"/>
  <class name="freemarker.core.NonListableRightUnboundedRangeModel" map="sC"/>
  <method class="freemarker.core.NonListableRightUnboundedRangeModel" name="int size()" map="&#x00c1;"/>
  <class name="freemarker.core.BuiltInForSequence" map="tC"/>
  <method class="freemarker.core.BuiltInForSequence" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.BuiltInForSequence" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateSequenceModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForDates$iso_utc_or_local_BI" map="_A"/>
  <field class="freemarker.core.BuiltInsForDates$iso_utc_or_local_BI" name="useUTC" map="&#x00c0;"/>
  <method class="freemarker.core.BuiltInsForDates$iso_utc_or_local_BI" name="freemarker.template.TemplateModel calculateResult(java.util.Date, int, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForDates$AbstractISOBI" map="_B"/>
  <field class="freemarker.core.BuiltInsForDates$AbstractISOBI" name="showOffset" map="&#x00b5;"/>
  <field class="freemarker.core.BuiltInsForDates$AbstractISOBI" name="accuracy" map="&#x00ba;"/>
  <method class="freemarker.core.BuiltInsForDates$AbstractISOBI" name="boolean shouldShowOffset(java.util.Date, int, freemarker.core.Environment)" map="B"/>
  <method class="freemarker.core.BuiltInsForDates$AbstractISOBI" name="void checkDateTypeNotUnknown(int)" map="G"/>
  <class name="freemarker.core.BuiltInsForDates$dateType_if_unknownBI" map="_C"/>
  <field class="freemarker.core.BuiltInsForDates$dateType_if_unknownBI" name="dateType" map="&#x00a4;"/>
  <method class="freemarker.core.BuiltInsForDates$dateType_if_unknownBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForDates$iso_BI$Result" map="_A"/>
  <field class="freemarker.core.BuiltInsForDates$iso_BI$Result" name="this$0" map="&#x015d;"/>
  <field class="freemarker.core.BuiltInsForDates$iso_BI$Result" name="date" map="&#x015e;"/>
  <field class="freemarker.core.BuiltInsForDates$iso_BI$Result" name="dateType" map="&#x015f;"/>
  <field class="freemarker.core.BuiltInsForDates$iso_BI$Result" name="env" map="&#x0160;"/>
  <method class="freemarker.core.BuiltInsForDates$iso_BI$Result" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForDates$iso_BI" map="_D"/>
  <method class="freemarker.core.BuiltInsForDates$iso_BI" name="freemarker.template.TemplateModel calculateResult(java.util.Date, int, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.BuiltInsForDates" map="uC"/>
  <class name="freemarker.core.BuiltInsForSequences$maxBI" map="_A"/>
  <class name="freemarker.core.BuiltInsForSequences$reverseBI$ReverseSequence" map="_A"/>
  <field class="freemarker.core.BuiltInsForSequences$reverseBI$ReverseSequence" name="seq" map="&#x025b;"/>
  <method class="freemarker.core.BuiltInsForSequences$reverseBI$ReverseSequence" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.core.BuiltInsForSequences$reverseBI$ReverseSequence" name="freemarker.template.TemplateSequenceModel access$800(freemarker.core.BuiltInsForSequences$reverseBI$ReverseSequence)" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences$reverseBI$ReverseSequence" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <class name="freemarker.core.BuiltInsForSequences$reverseBI" map="_B"/>
  <method class="freemarker.core.BuiltInsForSequences$reverseBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateSequenceModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForSequences$MinOrMaxBI" map="_C"/>
  <field class="freemarker.core.BuiltInsForSequences$MinOrMaxBI" name="comparatorOperator" map="&#x00a5;"/>
  <method class="freemarker.core.BuiltInsForSequences$MinOrMaxBI" name="freemarker.template.TemplateModel calculateResultForSequence(freemarker.template.TemplateSequenceModel, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences$MinOrMaxBI" name="freemarker.template.TemplateModel calculateResultForColletion(freemarker.template.TemplateCollectionModel, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences$MinOrMaxBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForSequences$joinBI$BIMethodForCollection" map="_A"/>
  <field class="freemarker.core.BuiltInsForSequences$joinBI$BIMethodForCollection" name="this$0" map="&#x0161;"/>
  <field class="freemarker.core.BuiltInsForSequences$joinBI$BIMethodForCollection" name="coll" map="&#x0162;"/>
  <field class="freemarker.core.BuiltInsForSequences$joinBI$BIMethodForCollection" name="env" map="&#x0163;"/>
  <method class="freemarker.core.BuiltInsForSequences$joinBI$BIMethodForCollection" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForSequences$joinBI" map="_D"/>
  <method class="freemarker.core.BuiltInsForSequences$joinBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForSequences$sequenceBI" map="_E"/>
  <method class="freemarker.core.BuiltInsForSequences$sequenceBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForSequences$seq_containsBI$BIMethodForSequence" map="_A"/>
  <field class="freemarker.core.BuiltInsForSequences$seq_containsBI$BIMethodForSequence" name="this$0" map="&#x0164;"/>
  <field class="freemarker.core.BuiltInsForSequences$seq_containsBI$BIMethodForSequence" name="m_env" map="&#x0165;"/>
  <field class="freemarker.core.BuiltInsForSequences$seq_containsBI$BIMethodForSequence" name="m_seq" map="&#x0166;"/>
  <method class="freemarker.core.BuiltInsForSequences$seq_containsBI$BIMethodForSequence" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForSequences$seq_containsBI$BIMethodForCollection" map="_B"/>
  <field class="freemarker.core.BuiltInsForSequences$seq_containsBI$BIMethodForCollection" name="this$0" map="&#x0167;"/>
  <field class="freemarker.core.BuiltInsForSequences$seq_containsBI$BIMethodForCollection" name="m_env" map="&#x0168;"/>
  <field class="freemarker.core.BuiltInsForSequences$seq_containsBI$BIMethodForCollection" name="m_coll" map="&#x0169;"/>
  <method class="freemarker.core.BuiltInsForSequences$seq_containsBI$BIMethodForCollection" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForSequences$seq_containsBI" map="_F"/>
  <method class="freemarker.core.BuiltInsForSequences$seq_containsBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForSequences$sort_byBI$BIMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForSequences$sort_byBI$BIMethod" name="this$0" map="&#x016a;"/>
  <field class="freemarker.core.BuiltInsForSequences$sort_byBI$BIMethod" name="seq" map="&#x016b;"/>
  <method class="freemarker.core.BuiltInsForSequences$sort_byBI$BIMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForSequences$sort_byBI" map="_G"/>
  <method class="freemarker.core.BuiltInsForSequences$sort_byBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateSequenceModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForSequences$firstBI" map="_H"/>
  <method class="freemarker.core.BuiltInsForSequences$firstBI" name="freemarker.template.TemplateModel calculateResultForColletion(freemarker.template.TemplateCollectionModel)" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences$firstBI" name="freemarker.template.TemplateModel calculateResultForSequence(freemarker.template.TemplateSequenceModel)" map="B"/>
  <method class="freemarker.core.BuiltInsForSequences$firstBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForSequences$lastBI" map="_I"/>
  <method class="freemarker.core.BuiltInsForSequences$lastBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateSequenceModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForSequences$1" map="1"/>
  <class name="freemarker.core.BuiltInsForSequences$minBI" map="_J"/>
  <class name="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence$1" map="1"/>
  <field class="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence$1" name="this$0" map="&#x025c;"/>
  <field class="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence$1" name="val$chunkIndex" map="&#x025d;"/>
  <field class="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence$1" name="baseIndex" map="&#x025e;"/>
  <method class="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence$1" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence$1" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <class name="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence" map="_A"/>
  <field class="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence" name="wrappedTsm" map="&#x025f;"/>
  <field class="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence" name="fillerItem" map="&#x0260;"/>
  <field class="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence" name="numberOfChunks" map="&#x0261;"/>
  <field class="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence" name="chunkSize" map="&#x0262;"/>
  <method class="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence" name="int access$100(freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence)" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence" name="freemarker.template.TemplateSequenceModel access$200(freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence)" map="B"/>
  <method class="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence" name="freemarker.template.TemplateModel access$400(freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence)" map="C"/>
  <method class="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence" name="int access$300(freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence)" map="D"/>
  <method class="freemarker.core.BuiltInsForSequences$chunkBI$ChunkedSequence" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <class name="freemarker.core.BuiltInsForSequences$chunkBI$BIMethod" map="_B"/>
  <field class="freemarker.core.BuiltInsForSequences$chunkBI$BIMethod" name="this$0" map="&#x016c;"/>
  <field class="freemarker.core.BuiltInsForSequences$chunkBI$BIMethod" name="tsm" map="&#x016d;"/>
  <method class="freemarker.core.BuiltInsForSequences$chunkBI$BIMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.core.BuiltInsForSequences$chunkBI" map="_K"/>
  <method class="freemarker.core.BuiltInsForSequences$chunkBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateSequenceModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForSequences$seq_index_ofBI$BIMethod" map="_A"/>
  <field class="freemarker.core.BuiltInsForSequences$seq_index_ofBI$BIMethod" name="this$0" map="&#x016e;"/>
  <field class="freemarker.core.BuiltInsForSequences$seq_index_ofBI$BIMethod" name="m_env" map="&#x016f;"/>
  <field class="freemarker.core.BuiltInsForSequences$seq_index_ofBI$BIMethod" name="m_seq" map="&#x0170;"/>
  <field class="freemarker.core.BuiltInsForSequences$seq_index_ofBI$BIMethod" name="m_col" map="&#x0171;"/>
  <method class="freemarker.core.BuiltInsForSequences$seq_index_ofBI$BIMethod" name="java.lang.Object exec(java.util.List)" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences$seq_index_ofBI$BIMethod" name="int findInCol(freemarker.template.TemplateModel, int, int)" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences$seq_index_ofBI$BIMethod" name="int findInCol(freemarker.template.TemplateModel)" map="B"/>
  <method class="freemarker.core.BuiltInsForSequences$seq_index_ofBI$BIMethod" name="int findInSeq(freemarker.template.TemplateModel, int, int)" map="B"/>
  <method class="freemarker.core.BuiltInsForSequences$seq_index_ofBI$BIMethod" name="int findInCol(freemarker.template.TemplateModel, int)" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences$seq_index_ofBI$BIMethod" name="int findInSeq(freemarker.template.TemplateModel, int)" map="B"/>
  <method class="freemarker.core.BuiltInsForSequences$seq_index_ofBI$BIMethod" name="int findInSeq(freemarker.template.TemplateModel)" map="C"/>
  <class name="freemarker.core.BuiltInsForSequences$seq_index_ofBI" map="_L"/>
  <field class="freemarker.core.BuiltInsForSequences$seq_index_ofBI" name="findFirst" map="&#x00aa;"/>
  <method class="freemarker.core.BuiltInsForSequences$seq_index_ofBI" name="boolean access$1200(freemarker.core.BuiltInsForSequences$seq_index_ofBI)" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences$seq_index_ofBI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsForSequences$sortBI$KVP" map="_A"/>
  <field class="freemarker.core.BuiltInsForSequences$sortBI$KVP" name="key" map="A"/>
  <field class="freemarker.core.BuiltInsForSequences$sortBI$KVP" name="value" map="B"/>
  <method class="freemarker.core.BuiltInsForSequences$sortBI$KVP" name="java.lang.Object access$1900(freemarker.core.BuiltInsForSequences$sortBI$KVP)" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences$sortBI$KVP" name="java.lang.Object access$1400(freemarker.core.BuiltInsForSequences$sortBI$KVP)" map="B"/>
  <class name="freemarker.core.BuiltInsForSequences$sortBI$LexicalKVPComparator" map="_B"/>
  <field class="freemarker.core.BuiltInsForSequences$sortBI$LexicalKVPComparator" name="collator" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences$sortBI$LexicalKVPComparator" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="freemarker.core.BuiltInsForSequences$sortBI$BooleanKVPComparator" map="_C"/>
  <method class="freemarker.core.BuiltInsForSequences$sortBI$BooleanKVPComparator" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="freemarker.core.BuiltInsForSequences$sortBI$DateKVPComparator" map="_D"/>
  <method class="freemarker.core.BuiltInsForSequences$sortBI$DateKVPComparator" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="freemarker.core.BuiltInsForSequences$sortBI$NumericalKVPComparator" map="_E"/>
  <field class="freemarker.core.BuiltInsForSequences$sortBI$NumericalKVPComparator" name="ae" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences$sortBI$NumericalKVPComparator" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="freemarker.core.BuiltInsForSequences$sortBI" map="_M"/>
  <method class="freemarker.core.BuiltInsForSequences$sortBI" name="java.lang.Object[] startErrorMessage(int)" map="F"/>
  <method class="freemarker.core.BuiltInsForSequences$sortBI" name="java.lang.Object[] startErrorMessage(int, int)" map="B"/>
  <method class="freemarker.core.BuiltInsForSequences$sortBI" name="freemarker.template.TemplateSequenceModel sort(freemarker.template.TemplateSequenceModel, java.lang.String[])" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences$sortBI" name="freemarker.template.TemplateModelException newInconsistentSortKeyTypeException(int, java.lang.String, java.lang.String, int, freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences$sortBI" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateSequenceModel)" map="A"/>
  <class name="freemarker.core.BuiltInsForSequences" map="vC"/>
  <method class="freemarker.core.BuiltInsForSequences" name="boolean access$600(freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences" name="boolean modelsEqual(int, freemarker.template.TemplateModel, freemarker.template.TemplateModel, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.BuiltInsForSequences" name="boolean access$900(int, freemarker.template.TemplateModel, freemarker.template.TemplateModel, freemarker.core.Environment)" map="B"/>
  <method class="freemarker.core.BuiltInsForSequences" name="boolean isBuggySeqButGoodCollection(freemarker.template.TemplateModel)" map="B"/>
  <class name="freemarker.core.SwitchBlock" map="wC"/>
  <field class="freemarker.core.SwitchBlock" name="firstCaseIndex" map="&#x0118;"/>
  <field class="freemarker.core.SwitchBlock" name="defaultCase" map="&#x0119;"/>
  <field class="freemarker.core.SwitchBlock" name="searched" map="&#x011a;"/>
  <method class="freemarker.core.SwitchBlock" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.SwitchBlock" name="freemarker.core.TemplateElement postParseCleanup(boolean)" map="B"/>
  <method class="freemarker.core.SwitchBlock" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.SwitchBlock" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.SwitchBlock" name="void addCase(freemarker.core.Case)" map="A"/>
  <method class="freemarker.core.SwitchBlock" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.SwitchBlock" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.SwitchBlock" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <class name="freemarker.core.TextBlock" map="xC"/>
  <field class="freemarker.core.TextBlock" name="unparsed" map="&#x011b;"/>
  <field class="freemarker.core.TextBlock" name="text" map="&#x011c;"/>
  <method class="freemarker.core.TextBlock" name="int openingCharsToStrip()" map="m"/>
  <method class="freemarker.core.TextBlock" name="char[] substring(char[], int)" map="A"/>
  <method class="freemarker.core.TextBlock" name="int lastNewLineIndex()" map="n"/>
  <method class="freemarker.core.TextBlock" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.TextBlock" name="freemarker.core.TemplateElement postParseCleanup(boolean)" map="B"/>
  <method class="freemarker.core.TextBlock" name="int firstNewLineIndex()" map="o"/>
  <method class="freemarker.core.TextBlock" name="boolean isTopLevelTextIfParentIs(freemarker.core.TemplateElement)" map="B"/>
  <method class="freemarker.core.TextBlock" name="char[] concat(char[], char[])" map="A"/>
  <method class="freemarker.core.TextBlock" name="char[] substring(char[], int, int)" map="A"/>
  <method class="freemarker.core.TextBlock" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.TextBlock" name="boolean deliberateRightTrim()" map="p"/>
  <method class="freemarker.core.TextBlock" name="void replaceText(java.lang.String)" map="C"/>
  <method class="freemarker.core.TextBlock" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.TextBlock" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.TextBlock" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.TextBlock" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.TextBlock" name="boolean isIgnorable(boolean)" map="D"/>
  <method class="freemarker.core.TextBlock" name="int trailingCharsToStrip()" map="q"/>
  <method class="freemarker.core.TextBlock" name="boolean nonOutputtingType(freemarker.core.TemplateElement)" map="C"/>
  <method class="freemarker.core.TextBlock" name="boolean deliberateLeftTrim()" map="r"/>
  <class name="freemarker.core.TemplateXMLOutputModel" map="yC"/>
  <method class="freemarker.core.TemplateXMLOutputModel" name="freemarker.core.MarkupOutputFormat getOutputFormat()" map="x"/>
  <method class="freemarker.core.TemplateXMLOutputModel" name="freemarker.core.XMLOutputFormat getOutputFormat()" map="&#x00aa;"/>
  <class name="freemarker.core._ParserConfigurationWithInheritedFormat" map="zC"/>
  <field class="freemarker.core._ParserConfigurationWithInheritedFormat" name="autoEscapingPolicy" map="&#x0117;"/>
  <field class="freemarker.core._ParserConfigurationWithInheritedFormat" name="wrappedPCfg" map="&#x0118;"/>
  <field class="freemarker.core._ParserConfigurationWithInheritedFormat" name="outputFormat" map="&#x0119;"/>
  <method class="freemarker.core._ParserConfigurationWithInheritedFormat" name="freemarker.core.ArithmeticEngine getArithmeticEngine()" map="A"/>
  <method class="freemarker.core._ParserConfigurationWithInheritedFormat" name="freemarker.core.OutputFormat getOutputFormat()" map="B"/>
  <method class="freemarker.core._ParserConfigurationWithInheritedFormat" name="int getInterpolationSyntax()" map="C"/>
  <method class="freemarker.core._ParserConfigurationWithInheritedFormat" name="freemarker.template.Version getIncompatibleImprovements()" map="D"/>
  <method class="freemarker.core._ParserConfigurationWithInheritedFormat" name="int getTagSyntax()" map="E"/>
  <method class="freemarker.core._ParserConfigurationWithInheritedFormat" name="int getNamingConvention()" map="F"/>
  <method class="freemarker.core._ParserConfigurationWithInheritedFormat" name="boolean getWhitespaceStripping()" map="G"/>
  <method class="freemarker.core._ParserConfigurationWithInheritedFormat" name="boolean getStrictSyntaxMode()" map="H"/>
  <method class="freemarker.core._ParserConfigurationWithInheritedFormat" name="boolean getRecognizeStandardFileExtensions()" map="I"/>
  <method class="freemarker.core._ParserConfigurationWithInheritedFormat" name="int getAutoEscapingPolicy()" map="J"/>
  <method class="freemarker.core._ParserConfigurationWithInheritedFormat" name="int getTabSize()" map="K"/>
  <class name="freemarker.core.OptInTemplateClassResolver" map="$D"/>
  <field class="freemarker.core.OptInTemplateClassResolver" name="allowedClasses" map="D"/>
  <field class="freemarker.core.OptInTemplateClassResolver" name="trustedTemplatePrefixes" map="E"/>
  <field class="freemarker.core.OptInTemplateClassResolver" name="trustedTemplateNames" map="F"/>
  <method class="freemarker.core.OptInTemplateClassResolver" name="boolean hasMatchingPrefix(java.lang.String)" map="A"/>
  <method class="freemarker.core.OptInTemplateClassResolver" name="java.lang.String safeGetTemplateName(freemarker.template.Template)" map="A"/>
  <method class="freemarker.core.OptInTemplateClassResolver" name="java.lang.Class resolve(java.lang.String, freemarker.core.Environment, freemarker.template.Template)" map="A"/>
  <class name="freemarker.core.TemplateValueFormat" map="AD"/>
  <method class="freemarker.core.TemplateValueFormat" name="java.lang.String getDescription()" map="A"/>
  <class name="freemarker.core.BuiltInForDate" map="BD"/>
  <method class="freemarker.core.BuiltInForDate" name="freemarker.template.TemplateModel calculateResult(java.util.Date, int, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.BuiltInForDate" name="freemarker.template.TemplateException newNonDateException(freemarker.core.Environment, freemarker.template.TemplateModel, freemarker.core.Expression)" map="A"/>
  <method class="freemarker.core.BuiltInForDate" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.ArithmeticEngine$BigDecimalEngine" map="_A"/>
  <method class="freemarker.core.ArithmeticEngine$BigDecimalEngine" name="java.lang.Number divide(java.lang.Number, java.lang.Number)" map="A"/>
  <method class="freemarker.core.ArithmeticEngine$BigDecimalEngine" name="java.math.BigDecimal divide(java.math.BigDecimal, java.math.BigDecimal)" map="A"/>
  <method class="freemarker.core.ArithmeticEngine$BigDecimalEngine" name="java.lang.Number toNumber(java.lang.String)" map="A"/>
  <method class="freemarker.core.ArithmeticEngine$BigDecimalEngine" name="java.lang.Number multiply(java.lang.Number, java.lang.Number)" map="F"/>
  <method class="freemarker.core.ArithmeticEngine$BigDecimalEngine" name="java.lang.Number subtract(java.lang.Number, java.lang.Number)" map="C"/>
  <method class="freemarker.core.ArithmeticEngine$BigDecimalEngine" name="int compareNumbers(java.lang.Number, java.lang.Number)" map="E"/>
  <method class="freemarker.core.ArithmeticEngine$BigDecimalEngine" name="java.lang.Number modulus(java.lang.Number, java.lang.Number)" map="D"/>
  <method class="freemarker.core.ArithmeticEngine$BigDecimalEngine" name="java.lang.Number add(java.lang.Number, java.lang.Number)" map="B"/>
  <class name="freemarker.core.ArithmeticEngine$ConservativeEngine" map="_B"/>
  <field class="freemarker.core.ArithmeticEngine$ConservativeEngine" name="classCodes" map="F"/>
  <method class="freemarker.core.ArithmeticEngine$ConservativeEngine" name="int getClassCode(java.lang.Number)" map="C"/>
  <method class="freemarker.core.ArithmeticEngine$ConservativeEngine" name="java.lang.Number divide(java.lang.Number, java.lang.Number)" map="A"/>
  <method class="freemarker.core.ArithmeticEngine$ConservativeEngine" name="java.lang.Number toNumber(java.lang.String)" map="A"/>
  <method class="freemarker.core.ArithmeticEngine$ConservativeEngine" name="java.lang.Number add(java.lang.Number, java.lang.Number)" map="B"/>
  <method class="freemarker.core.ArithmeticEngine$ConservativeEngine" name="java.util.Map createClassCodesMap()" map="A"/>
  <method class="freemarker.core.ArithmeticEngine$ConservativeEngine" name="java.lang.Number subtract(java.lang.Number, java.lang.Number)" map="C"/>
  <method class="freemarker.core.ArithmeticEngine$ConservativeEngine" name="java.math.BigInteger toBigInteger(java.lang.Number)" map="D"/>
  <method class="freemarker.core.ArithmeticEngine$ConservativeEngine" name="java.lang.Number modulus(java.lang.Number, java.lang.Number)" map="D"/>
  <method class="freemarker.core.ArithmeticEngine$ConservativeEngine" name="int compareNumbers(java.lang.Number, java.lang.Number)" map="E"/>
  <method class="freemarker.core.ArithmeticEngine$ConservativeEngine" name="int getCommonClassCode(java.lang.Number, java.lang.Number)" map="G"/>
  <method class="freemarker.core.ArithmeticEngine$ConservativeEngine" name="java.lang.Number multiply(java.lang.Number, java.lang.Number)" map="F"/>
  <class name="freemarker.core.ArithmeticEngine" map="CD"/>
  <field class="freemarker.core.ArithmeticEngine" name="CONSERVATIVE_ENGINE" map="A"/>
  <field class="freemarker.core.ArithmeticEngine" name="roundingPolicy" map="B"/>
  <field class="freemarker.core.ArithmeticEngine" name="BIGDECIMAL_ENGINE" map="C"/>
  <field class="freemarker.core.ArithmeticEngine" name="minScale" map="D"/>
  <field class="freemarker.core.ArithmeticEngine" name="maxScale" map="E"/>
  <method class="freemarker.core.ArithmeticEngine" name="java.lang.Number divide(java.lang.Number, java.lang.Number)" map="A"/>
  <method class="freemarker.core.ArithmeticEngine" name="java.lang.Number toNumber(java.lang.String)" map="A"/>
  <method class="freemarker.core.ArithmeticEngine" name="java.lang.Number add(java.lang.Number, java.lang.Number)" map="B"/>
  <method class="freemarker.core.ArithmeticEngine" name="java.lang.Number subtract(java.lang.Number, java.lang.Number)" map="C"/>
  <method class="freemarker.core.ArithmeticEngine" name="java.lang.Number modulus(java.lang.Number, java.lang.Number)" map="D"/>
  <method class="freemarker.core.ArithmeticEngine" name="java.lang.Number access$100(java.lang.String)" map="B"/>
  <method class="freemarker.core.ArithmeticEngine" name="java.math.BigDecimal access$000(java.lang.Number)" map="A"/>
  <method class="freemarker.core.ArithmeticEngine" name="int compareNumbers(java.lang.Number, java.lang.Number)" map="E"/>
  <method class="freemarker.core.ArithmeticEngine" name="java.math.BigDecimal toBigDecimal(java.lang.Number)" map="B"/>
  <method class="freemarker.core.ArithmeticEngine" name="java.lang.Number toBigDecimalOrDouble(java.lang.String)" map="C"/>
  <method class="freemarker.core.ArithmeticEngine" name="java.lang.Number multiply(java.lang.Number, java.lang.Number)" map="F"/>
  <class name="freemarker.core.MarkupOutputFormatBoundBuiltIn" map="DD"/>
  <field class="freemarker.core.MarkupOutputFormatBoundBuiltIn" name="outputFormat" map="v"/>
  <method class="freemarker.core.MarkupOutputFormatBoundBuiltIn" name="freemarker.template.TemplateModel calculateResult(freemarker.core.Environment)" map="I"/>
  <method class="freemarker.core.MarkupOutputFormatBoundBuiltIn" name="void bindToMarkupOutputFormat(freemarker.core.MarkupOutputFormat)" map="A"/>
  <method class="freemarker.core.MarkupOutputFormatBoundBuiltIn" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.BuiltInsWithParseTimeParameters$then_BI" map="_A"/>
  <field class="freemarker.core.BuiltInsWithParseTimeParameters$then_BI" name="whenFalseExp" map="l"/>
  <field class="freemarker.core.BuiltInsWithParseTimeParameters$then_BI" name="whenTrueExp" map="m"/>
  <method class="freemarker.core.BuiltInsWithParseTimeParameters$then_BI" name="void cloneArguments(freemarker.core.Expression, java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="A"/>
  <method class="freemarker.core.BuiltInsWithParseTimeParameters$then_BI" name="int getArgumentsCount()" map="Q"/>
  <method class="freemarker.core.BuiltInsWithParseTimeParameters$then_BI" name="void bindToParameters(java.util.List, freemarker.core.Token, freemarker.core.Token)" map="A"/>
  <method class="freemarker.core.BuiltInsWithParseTimeParameters$then_BI" name="freemarker.core.Expression getArgumentParameterValue(int)" map="E"/>
  <method class="freemarker.core.BuiltInsWithParseTimeParameters$then_BI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.BuiltInsWithParseTimeParameters$then_BI" name="java.util.List getArgumentsAsList()" map="R"/>
  <class name="freemarker.core.BuiltInsWithParseTimeParameters$switch_BI" map="_B"/>
  <field class="freemarker.core.BuiltInsWithParseTimeParameters$switch_BI" name="parameters" map="n"/>
  <method class="freemarker.core.BuiltInsWithParseTimeParameters$switch_BI" name="void cloneArguments(freemarker.core.Expression, java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="A"/>
  <method class="freemarker.core.BuiltInsWithParseTimeParameters$switch_BI" name="int getArgumentsCount()" map="Q"/>
  <method class="freemarker.core.BuiltInsWithParseTimeParameters$switch_BI" name="void bindToParameters(java.util.List, freemarker.core.Token, freemarker.core.Token)" map="A"/>
  <method class="freemarker.core.BuiltInsWithParseTimeParameters$switch_BI" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.BuiltInsWithParseTimeParameters$switch_BI" name="freemarker.core.Expression getArgumentParameterValue(int)" map="E"/>
  <method class="freemarker.core.BuiltInsWithParseTimeParameters$switch_BI" name="java.util.List getArgumentsAsList()" map="R"/>
  <class name="freemarker.core.BuiltInsWithParseTimeParameters" map="ED"/>
  <class name="freemarker.core.ISOTemplateDateFormatFactory" map="FD"/>
  <field class="freemarker.core.ISOTemplateDateFormatFactory" name="INSTANCE" map="D"/>
  <method class="freemarker.core.ISOTemplateDateFormatFactory" name="freemarker.core.TemplateDateFormat get(java.lang.String, int, java.util.Locale, java.util.TimeZone, boolean, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.core.InvalidFormatParametersException" map="GD"/>
  <class name="freemarker.core.BackwardCompatibleTemplateNumberFormat" map="HD"/>
  <method class="freemarker.core.BackwardCompatibleTemplateNumberFormat" name="java.lang.String format(java.lang.Number)" map="A"/>
  <class name="freemarker.core.ListLiteral" map="ID"/>
  <field class="freemarker.core.ListLiteral" name="items" map="&#x0286;"/>
  <method class="freemarker.core.ListLiteral" name="java.util.List getValueList(freemarker.core.Environment)" map="O"/>
  <method class="freemarker.core.ListLiteral" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.ListLiteral" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.ListLiteral" name="java.util.List getModelList(freemarker.core.Environment)" map="P"/>
  <method class="freemarker.core.ListLiteral" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <method class="freemarker.core.ListLiteral" name="freemarker.template.TemplateSequenceModel evaluateStringsToNamespaces(freemarker.core.Environment)" map="Q"/>
  <method class="freemarker.core.ListLiteral" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.ListLiteral" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.ListLiteral" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.ListLiteral" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.ListLiteral" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <method class="freemarker.core.ListLiteral" name="void checkIndex(int)" map="P"/>
  <class name="freemarker.core._ObjectBuilderSettingEvaluator$ListExpression" map="_A"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator$ListExpression" name="this$0" map="J"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator$ListExpression" name="items" map="K"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$ListExpression" name="int itemCount()" map="E"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$ListExpression" name="java.lang.Object eval()" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$ListExpression" name="void addItem(java.lang.Object)" map="B"/>
  <class name="freemarker.core._ObjectBuilderSettingEvaluator$LegacyExceptionWrapperSettingEvaluationExpression" map="_B"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$LegacyExceptionWrapperSettingEvaluationExpression" name="void rethrowLegacy()" map="A"/>
  <class name="freemarker.core._ObjectBuilderSettingEvaluator$SettingExpression" map="_C"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$SettingExpression" name="java.lang.Object eval()" map="A"/>
  <class name="freemarker.core._ObjectBuilderSettingEvaluator$Name" map="_D"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator$Name" name="name" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$Name" name="java.lang.String access$400(freemarker.core._ObjectBuilderSettingEvaluator$Name)" map="A"/>
  <class name="freemarker.core._ObjectBuilderSettingEvaluator$ExpressionWithParameters" map="_E"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator$ExpressionWithParameters" name="this$0" map="A"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator$ExpressionWithParameters" name="namedParamValues" map="B"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator$ExpressionWithParameters" name="namedParamNames" map="C"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator$ExpressionWithParameters" name="positionalParamValues" map="D"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$ExpressionWithParameters" name="boolean getAllowPositionalParameters()" map="B"/>
  <class name="freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression" map="_F"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression" name="this$0" map="A"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression" name="className" map="E"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression" name="canBeStaticField" map="F"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression" name="mustBeStaticField" map="G"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression" name="java.lang.Object eval()" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression" name="boolean access$102(freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression, boolean)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression" name="boolean hasNoParameters()" map="C"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression" name="java.lang.Object callConstructor(java.lang.Class)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression" name="java.lang.Object getStaticFieldValue(java.lang.String)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression" name="java.lang.Object callBuild(java.lang.Object)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression" name="boolean access$302(freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression, boolean)" map="B"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression" name="java.lang.String access$200(freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression" name="java.lang.String access$202(freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression, java.lang.String)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$BuilderCallExpression" name="boolean getAllowPositionalParameters()" map="B"/>
  <class name="freemarker.core._ObjectBuilderSettingEvaluator$1" map="1"/>
  <class name="freemarker.core._ObjectBuilderSettingEvaluator$KeyValuePair" map="_G"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator$KeyValuePair" name="key" map="A"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator$KeyValuePair" name="value" map="B"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$KeyValuePair" name="java.lang.Object access$900(freemarker.core._ObjectBuilderSettingEvaluator$KeyValuePair)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$KeyValuePair" name="java.lang.Object access$1000(freemarker.core._ObjectBuilderSettingEvaluator$KeyValuePair)" map="B"/>
  <class name="freemarker.core._ObjectBuilderSettingEvaluator$MapExpression" map="_H"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator$MapExpression" name="this$0" map="H"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator$MapExpression" name="items" map="I"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$MapExpression" name="void addItem(freemarker.core._ObjectBuilderSettingEvaluator$KeyValuePair)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$MapExpression" name="int itemCount()" map="D"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator$MapExpression" name="java.lang.Object eval()" map="A"/>
  <class name="freemarker.core._ObjectBuilderSettingEvaluator" map="JD"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator" name="allowNull" map="A"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator" name="modernMode" map="B"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator" name="expectedClass" map="C"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator" name="SHORTHANDS" map="D"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator" name="env" map="E"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator" name="src" map="F"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator" name="VOID" map="G"/>
  <field class="freemarker.core._ObjectBuilderSettingEvaluator" name="pos" map="H"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="java.lang.Object fetchValue(boolean, boolean, boolean, boolean)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="void access$1300(freemarker.core._ObjectBuilderSettingEvaluator, java.lang.Object, java.util.List, java.util.List)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="void setJavaBeanProperties(java.lang.Object, java.util.List, java.util.List)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="boolean isIdentifierStart(char)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="java.lang.Object eval()" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="char fetchOptionalChar(java.lang.String)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="java.lang.Object fetchListLiteral(boolean)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="freemarker.core._SettingEvaluationEnvironment access$1500(freemarker.core._ObjectBuilderSettingEvaluator)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="java.lang.Object eval(java.lang.String, java.lang.Class, boolean, freemarker.core._SettingEvaluationEnvironment)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="java.lang.String access$1400(java.lang.String)" map="B"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="char fetchChar(java.lang.String, boolean)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="boolean isKeyword(java.lang.String)" map="C"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="boolean access$1200(freemarker.core._ObjectBuilderSettingEvaluator)" map="B"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="java.lang.Object fetchBuilderCall(boolean, boolean)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="java.lang.String shorthandToFullQualified(java.lang.String)" map="D"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="java.lang.Object fetchStringLiteral(boolean)" map="B"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="java.lang.Object fetchNumberLike(boolean, boolean)" map="B"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="void skipWS()" map="B"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="boolean isASCIIDigit(char)" map="B"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="java.lang.Object fetchMapLiteral(boolean)" map="C"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="void fetchParameterListInto(freemarker.core._ObjectBuilderSettingEvaluator$ExpressionWithParameters)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="void addWithSimpleName(java.util.Map, java.lang.Class)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="java.lang.String fetchSimpleName(boolean)" map="D"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="java.lang.Object keywordToValueOrVoid(java.lang.String)" map="E"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="char fetchRequiredChar(java.lang.String)" map="F"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="boolean isIdentifierMiddle(char)" map="C"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="java.lang.Object ensureEvaled(java.lang.Object)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="java.lang.Object access$800(freemarker.core._ObjectBuilderSettingEvaluator, java.lang.Object)" map="A"/>
  <method class="freemarker.core._ObjectBuilderSettingEvaluator" name="java.lang.String fetchClassName(boolean)" map="E"/>
  <class name="freemarker.core.DirectiveCallPlace" map="KD"/>
  <class name="freemarker.core.BuiltInForNodeEx" map="LD"/>
  <method class="freemarker.core.BuiltInForNodeEx" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.BuiltInForNodeEx" name="freemarker.template.TemplateModel calculateResult(freemarker.template.TemplateNodeModelEx, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.core.BuiltInForNodeEx" name="freemarker.template.TemplateModel _eval(freemarker.core.Environment)" map="F"/>
  <class name="freemarker.core.AndExpression" map="MD"/>
  <field class="freemarker.core.AndExpression" name="rho" map="X"/>
  <field class="freemarker.core.AndExpression" name="lho" map="Y"/>
  <method class="freemarker.core.AndExpression" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.AndExpression" name="boolean isLiteral()" map="L"/>
  <method class="freemarker.core.AndExpression" name="java.lang.String getCanonicalForm()" map="C"/>
  <method class="freemarker.core.AndExpression" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.AndExpression" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.AndExpression" name="freemarker.core.Expression deepCloneWithIdentifierReplaced_inner(java.lang.String, freemarker.core.Expression, freemarker.core.Expression$ReplacemenetState)" map="B"/>
  <method class="freemarker.core.AndExpression" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <method class="freemarker.core.AndExpression" name="boolean evalToBoolean(freemarker.core.Environment)" map="B"/>
  <class name="freemarker.core.UnifiedCall" map="ND"/>
  <field class="freemarker.core.UnifiedCall" name="legacySyntax" map="&#x011d;"/>
  <field class="freemarker.core.UnifiedCall" name="namedArgs" map="&#x011e;"/>
  <field class="freemarker.core.UnifiedCall" name="sortedNamedArgsCache" map="&#x011f;"/>
  <field class="freemarker.core.UnifiedCall" name="positionalArgs" map="&#x0120;"/>
  <field class="freemarker.core.UnifiedCall" name="bodyParameterNames" map="&#x0121;"/>
  <field class="freemarker.core.UnifiedCall" name="nameExp" map="&#x0122;"/>
  <method class="freemarker.core.UnifiedCall" name="freemarker.core.ParameterRole getParameterRole(int)" map="A"/>
  <method class="freemarker.core.UnifiedCall" name="java.util.List getSortedNamedArgs()" map="s"/>
  <method class="freemarker.core.UnifiedCall" name="java.lang.Object getParameterValue(int)" map="B"/>
  <method class="freemarker.core.UnifiedCall" name="freemarker.core.TemplateElement[] accept(freemarker.core.Environment)" map="K"/>
  <method class="freemarker.core.UnifiedCall" name="boolean isShownInStackTrace()" map="d"/>
  <method class="freemarker.core.UnifiedCall" name="int getParameterCount()" map="A"/>
  <method class="freemarker.core.UnifiedCall" name="java.lang.String dump(boolean)" map="C"/>
  <method class="freemarker.core.UnifiedCall" name="java.lang.String getNodeTypeSymbol()" map="D"/>
  <package name="freemarker.debug" map="B"/>
  <package name="freemarker.debug.impl" map="A"/>
  <class name="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugConfigurationModel$1" map="1"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugConfigurationModel$1" name="this$0" map="&#x0180;"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugConfigurationModel$1" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugConfigurationModel$1" name="java.util.Collection keySet()" map="&#x00ca;"/>
  <class name="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugConfigurationModel" map="_A"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugConfigurationModel" name="sharedVariables" map="&#x0184;"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugConfigurationModel" name="KEYS" map="&#x0185;"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugConfigurationModel" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugConfigurationModel" name="java.util.Collection keySet()" map="&#x00ca;"/>
  <class name="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugEnvironmentModel$1" map="1"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugEnvironmentModel$1" name="this$0" map="&#x0181;"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugEnvironmentModel$1" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugEnvironmentModel$1" name="java.util.Collection keySet()" map="&#x00ca;"/>
  <class name="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugEnvironmentModel" map="_B"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugEnvironmentModel" name="KEYS" map="&#x0186;"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugEnvironmentModel" name="knownVariables" map="&#x0187;"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugEnvironmentModel" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugEnvironmentModel" name="java.util.Collection keySet()" map="&#x00ca;"/>
  <class name="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$1" map="1"/>
  <class name="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugMapModel" map="_C"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugMapModel" name="freemarker.template.TemplateCollectionModel keys()" map="&#x00c8;"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugMapModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugMapModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugMapModel" name="freemarker.template.TemplateCollectionModel values()" map="&#x00c9;"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugMapModel" name="java.util.List composeList(java.util.Collection, java.util.Collection)" map="A"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugMapModel" name="java.util.Collection keySet()" map="&#x00ca;"/>
  <class name="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugConfigurableModel" map="_D"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugConfigurableModel" name="KEYS" map="&#x0182;"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugConfigurableModel" name="configurable" map="&#x0183;"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugConfigurableModel" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <class name="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugTemplateModel" map="_E"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugTemplateModel" name="KEYS" map="&#x0188;"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugTemplateModel" name="name" map="&#x0189;"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugTemplateModel" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl$DebugTemplateModel" name="java.util.Collection keySet()" map="&#x00ca;"/>
  <class name="freemarker.debug.impl.RmiDebuggedEnvironmentImpl" map="A"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl" name="remotes" map="C"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl" name="idLock" map="D"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl" name="nextId" map="E"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl" name="stopped" map="F"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl" name="id" map="G"/>
  <field class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl" name="storage" map="H"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl" name="boolean isStopped()" map="A"/>
  <method class="freemarker.debug.impl.RmiDebuggedEnvironmentImpl" name="java.lang.Object getCachedWrapperFor(java.lang.Object)" map="A"/>
  <class name="freemarker.debug.impl.RmiDebuggerService$TemplateDebugInfo" map="_A"/>
  <field class="freemarker.debug.impl.RmiDebuggerService$TemplateDebugInfo" name="templates" map="A"/>
  <field class="freemarker.debug.impl.RmiDebuggerService$TemplateDebugInfo" name="breakpoints" map="B"/>
  <method class="freemarker.debug.impl.RmiDebuggerService$TemplateDebugInfo" name="boolean isEmpty()" map="A"/>
  <class name="freemarker.debug.impl.RmiDebuggerService$1" map="1"/>
  <class name="freemarker.debug.impl.RmiDebuggerService$TemplateReference" map="_B"/>
  <field class="freemarker.debug.impl.RmiDebuggerService$TemplateReference" name="templateName" map="A"/>
  <class name="freemarker.debug.impl.RmiDebuggerService" map="B"/>
  <field class="freemarker.debug.impl.RmiDebuggerService" name="debugger" map="B"/>
  <field class="freemarker.debug.impl.RmiDebuggerService" name="refQueue" map="C"/>
  <field class="freemarker.debug.impl.RmiDebuggerService" name="listeners" map="D"/>
  <field class="freemarker.debug.impl.RmiDebuggerService" name="templateDebugInfos" map="E"/>
  <field class="freemarker.debug.impl.RmiDebuggerService" name="server" map="F"/>
  <field class="freemarker.debug.impl.RmiDebuggerService" name="suspendedEnvironments" map="G"/>
  <method class="freemarker.debug.impl.RmiDebuggerService" name="freemarker.core.TemplateElement findTemplateElement(freemarker.core.TemplateElement, int)" map="A"/>
  <method class="freemarker.debug.impl.RmiDebuggerService" name="void processRefQueue()" map="B"/>
  <method class="freemarker.debug.impl.RmiDebuggerService" name="void insertDebugBreak(freemarker.template.Template, freemarker.debug.Breakpoint)" map="A"/>
  <method class="freemarker.debug.impl.RmiDebuggerService" name="freemarker.debug.impl.RmiDebuggerService$TemplateDebugInfo findTemplateDebugInfo(java.lang.String)" map="A"/>
  <method class="freemarker.debug.impl.RmiDebuggerService" name="boolean suspendEnvironmentSpi(freemarker.core.Environment, java.lang.String, int)" map="B"/>
  <method class="freemarker.debug.impl.RmiDebuggerService" name="freemarker.debug.impl.RmiDebuggerService$TemplateDebugInfo createTemplateDebugInfo(java.lang.String)" map="B"/>
  <method class="freemarker.debug.impl.RmiDebuggerService" name="void registerTemplateSpi(freemarker.template.Template)" map="B"/>
  <class name="freemarker.debug.impl.RmiDebugModelImpl" map="C"/>
  <field class="freemarker.debug.impl.RmiDebugModelImpl" name="model" map="A"/>
  <field class="freemarker.debug.impl.RmiDebugModelImpl" name="type" map="B"/>
  <method class="freemarker.debug.impl.RmiDebugModelImpl" name="int calculateType(freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.debug.impl.DebuggerServer$1" map="1"/>
  <field class="freemarker.debug.impl.DebuggerServer$1" name="this$0" map="A"/>
  <method class="freemarker.debug.impl.DebuggerServer$1" name="void run()" map="run"/>
  <class name="freemarker.debug.impl.DebuggerServer$DebuggerAuthProtocol" map="_A"/>
  <field class="freemarker.debug.impl.DebuggerServer$DebuggerAuthProtocol" name="this$0" map="A"/>
  <field class="freemarker.debug.impl.DebuggerServer$DebuggerAuthProtocol" name="s" map="B"/>
  <method class="freemarker.debug.impl.DebuggerServer$DebuggerAuthProtocol" name="void run()" map="run"/>
  <class name="freemarker.debug.impl.DebuggerServer" map="D"/>
  <field class="freemarker.debug.impl.DebuggerServer" name="port" map="A"/>
  <field class="freemarker.debug.impl.DebuggerServer" name="LOG" map="B"/>
  <field class="freemarker.debug.impl.DebuggerServer" name="password" map="C"/>
  <field class="freemarker.debug.impl.DebuggerServer" name="stop" map="D"/>
  <field class="freemarker.debug.impl.DebuggerServer" name="serverSocket" map="E"/>
  <field class="freemarker.debug.impl.DebuggerServer" name="R" map="F"/>
  <field class="freemarker.debug.impl.DebuggerServer" name="debuggerStub" map="G"/>
  <method class="freemarker.debug.impl.DebuggerServer" name="void startInternal()" map="A"/>
  <method class="freemarker.debug.impl.DebuggerServer" name="java.util.Random access$100()" map="B"/>
  <method class="freemarker.debug.impl.DebuggerServer" name="void access$000(freemarker.debug.impl.DebuggerServer)" map="A"/>
  <method class="freemarker.debug.impl.DebuggerServer" name="java.io.Serializable access$300(freemarker.debug.impl.DebuggerServer)" map="B"/>
  <method class="freemarker.debug.impl.DebuggerServer" name="freemarker.log.Logger access$400()" map="C"/>
  <method class="freemarker.debug.impl.DebuggerServer" name="byte[] access$200(freemarker.debug.impl.DebuggerServer)" map="C"/>
  <method class="freemarker.debug.impl.DebuggerServer" name="void start()" map="D"/>
  <class name="freemarker.debug.impl.DebuggerService$1" map="1"/>
  <class name="freemarker.debug.impl.DebuggerService$NoOpDebuggerService" map="_A"/>
  <method class="freemarker.debug.impl.DebuggerService$NoOpDebuggerService" name="boolean suspendEnvironmentSpi(freemarker.core.Environment, java.lang.String, int)" map="B"/>
  <method class="freemarker.debug.impl.DebuggerService$NoOpDebuggerService" name="void registerTemplateSpi(freemarker.template.Template)" map="B"/>
  <class name="freemarker.debug.impl.DebuggerService" map="E"/>
  <field class="freemarker.debug.impl.DebuggerService" name="instance" map="A"/>
  <method class="freemarker.debug.impl.DebuggerService" name="void registerTemplate(freemarker.template.Template)" map="A"/>
  <method class="freemarker.debug.impl.DebuggerService" name="boolean suspendEnvironment(freemarker.core.Environment, java.lang.String, int)" map="A"/>
  <method class="freemarker.debug.impl.DebuggerService" name="freemarker.debug.impl.DebuggerService createInstance()" map="A"/>
  <method class="freemarker.debug.impl.DebuggerService" name="boolean suspendEnvironmentSpi(freemarker.core.Environment, java.lang.String, int)" map="B"/>
  <method class="freemarker.debug.impl.DebuggerService" name="void registerTemplateSpi(freemarker.template.Template)" map="B"/>
  <class name="freemarker.debug.impl.RmiDebuggerImpl" map="F"/>
  <field class="freemarker.debug.impl.RmiDebuggerImpl" name="service" map="A"/>
  <class name="freemarker.debug.EnvironmentSuspendedEvent" map="A"/>
  <field class="freemarker.debug.EnvironmentSuspendedEvent" name="line" map="A"/>
  <field class="freemarker.debug.EnvironmentSuspendedEvent" name="name" map="B"/>
  <field class="freemarker.debug.EnvironmentSuspendedEvent" name="env" map="C"/>
  <class name="freemarker.debug.Debugger" map="B"/>
  <class name="freemarker.debug.DebuggerListener" map="C"/>
  <method class="freemarker.debug.DebuggerListener" name="void environmentSuspended(freemarker.debug.EnvironmentSuspendedEvent)" map="A"/>
  <class name="freemarker.debug.DebugModel" map="D"/>
  <class name="freemarker.debug.DebuggedEnvironment" map="E"/>
  <class name="freemarker.debug.Breakpoint" map="F"/>
  <method class="freemarker.debug.Breakpoint" name="int getLine()" map="A"/>
  <package name="freemarker.cache" map="C"/>
  <class name="freemarker.cache.TemplateCache$TemplateKey" map="_A"/>
  <field class="freemarker.cache.TemplateCache$TemplateKey" name="locale" map="A"/>
  <field class="freemarker.cache.TemplateCache$TemplateKey" name="name" map="B"/>
  <field class="freemarker.cache.TemplateCache$TemplateKey" name="encoding" map="C"/>
  <field class="freemarker.cache.TemplateCache$TemplateKey" name="customLookupCondition" map="D"/>
  <field class="freemarker.cache.TemplateCache$TemplateKey" name="parse" map="E"/>
  <method class="freemarker.cache.TemplateCache$TemplateKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="freemarker.cache.TemplateCache$TemplateKey" name="int hashCode()" map="hashCode"/>
  <method class="freemarker.cache.TemplateCache$TemplateKey" name="boolean nullSafeEquals(java.lang.Object, java.lang.Object)" map="A"/>
  <class name="freemarker.cache.TemplateCache$TemplateCacheTemplateLookupContext" map="_B"/>
  <field class="freemarker.cache.TemplateCache$TemplateCacheTemplateLookupContext" name="this$0" map="D"/>
  <method class="freemarker.cache.TemplateCache$TemplateCacheTemplateLookupContext" name="freemarker.cache.TemplateLookupResult lookupWithAcquisitionStrategy(java.lang.String)" map="A"/>
  <method class="freemarker.cache.TemplateCache$TemplateCacheTemplateLookupContext" name="freemarker.cache.TemplateLookupResult lookupWithLocalizedThenAcquisitionStrategy(java.lang.String, java.util.Locale)" map="A"/>
  <class name="freemarker.cache.TemplateCache$1" map="1"/>
  <class name="freemarker.cache.TemplateCache$CachedTemplate" map="_C"/>
  <field class="freemarker.cache.TemplateCache$CachedTemplate" name="lastChecked" map="A"/>
  <field class="freemarker.cache.TemplateCache$CachedTemplate" name="lastModified" map="B"/>
  <field class="freemarker.cache.TemplateCache$CachedTemplate" name="source" map="C"/>
  <field class="freemarker.cache.TemplateCache$CachedTemplate" name="templateOrException" map="D"/>
  <method class="freemarker.cache.TemplateCache$CachedTemplate" name="freemarker.cache.TemplateCache$CachedTemplate cloneCachedTemplate()" map="A"/>
  <class name="freemarker.cache.TemplateCache$MaybeMissingTemplate" map="_D"/>
  <field class="freemarker.cache.TemplateCache$MaybeMissingTemplate" name="missingTemplateCauseException" map="A"/>
  <field class="freemarker.cache.TemplateCache$MaybeMissingTemplate" name="missingTemplateNormalizedName" map="B"/>
  <field class="freemarker.cache.TemplateCache$MaybeMissingTemplate" name="missingTemplateReason" map="C"/>
  <field class="freemarker.cache.TemplateCache$MaybeMissingTemplate" name="template" map="D"/>
  <method class="freemarker.cache.TemplateCache$MaybeMissingTemplate" name="java.lang.String getMissingTemplateNormalizedName()" map="A"/>
  <method class="freemarker.cache.TemplateCache$MaybeMissingTemplate" name="java.lang.String getMissingTemplateReason()" map="B"/>
  <method class="freemarker.cache.TemplateCache$MaybeMissingTemplate" name="freemarker.template.Template getTemplate()" map="C"/>
  <class name="freemarker.cache.TemplateCache" map="A"/>
  <field class="freemarker.cache.TemplateCache" name="INIT_CAUSE" map="A"/>
  <field class="freemarker.cache.TemplateCache" name="isStorageConcurrent" map="B"/>
  <field class="freemarker.cache.TemplateCache" name="config" map="C"/>
  <field class="freemarker.cache.TemplateCache" name="updateDelay" map="D"/>
  <field class="freemarker.cache.TemplateCache" name="templateConfigurations" map="E"/>
  <field class="freemarker.cache.TemplateCache" name="localizedLookup" map="F"/>
  <field class="freemarker.cache.TemplateCache" name="storage" map="G"/>
  <field class="freemarker.cache.TemplateCache" name="templateLookupStrategy" map="H"/>
  <field class="freemarker.cache.TemplateCache" name="templateNameFormat" map="I"/>
  <field class="freemarker.cache.TemplateCache" name="templateLoader" map="J"/>
  <field class="freemarker.cache.TemplateCache" name="LOG" map="K"/>
  <method class="freemarker.cache.TemplateCache" name="void storeNegativeLookup(freemarker.cache.TemplateCache$TemplateKey, freemarker.cache.TemplateCache$CachedTemplate, java.lang.Exception)" map="A"/>
  <method class="freemarker.cache.TemplateCache" name="java.lang.String buildDebugName(java.lang.String, java.util.Locale, java.lang.Object, java.lang.String, boolean)" map="A"/>
  <method class="freemarker.cache.TemplateCache" name="freemarker.cache.TemplateLookupStrategy getTemplateLookupStrategy()" map="A"/>
  <method class="freemarker.cache.TemplateCache" name="freemarker.cache.TemplateConfigurationFactory getTemplateConfigurations()" map="B"/>
  <method class="freemarker.cache.TemplateCache" name="freemarker.cache.CacheStorage getCacheStorage()" map="C"/>
  <method class="freemarker.cache.TemplateCache" name="java.lang.String concatPath(java.util.List, int, int)" map="A"/>
  <method class="freemarker.cache.TemplateCache" name="freemarker.cache.TemplateLookupResult lookupTemplateWithAcquisitionStrategy(java.lang.String)" map="A"/>
  <method class="freemarker.cache.TemplateCache" name="boolean access$400(freemarker.cache.TemplateCache)" map="A"/>
  <method class="freemarker.cache.TemplateCache" name="java.lang.Object modifyForConfIcI(java.lang.Object)" map="A"/>
  <method class="freemarker.cache.TemplateCache" name="freemarker.cache.TemplateNameFormat getTemplateNameFormat()" map="D"/>
  <method class="freemarker.cache.TemplateCache" name="void setDelay(long)" map="A"/>
  <method class="freemarker.cache.TemplateCache" name="freemarker.cache.TemplateLoader getTemplateLoader()" map="E"/>
  <method class="freemarker.cache.TemplateCache" name="java.io.IOException newIOException(java.lang.String, java.lang.Throwable)" map="A"/>
  <method class="freemarker.cache.TemplateCache" name="void setLocalizedLookup(boolean)" map="A"/>
  <method class="freemarker.cache.TemplateCache" name="long getDelay()" map="F"/>
  <method class="freemarker.cache.TemplateCache" name="freemarker.template.Template loadTemplate(freemarker.cache.TemplateLoader, java.lang.Object, java.lang.String, java.lang.String, java.util.Locale, java.lang.Object, java.lang.String, boolean)" map="A"/>
  <method class="freemarker.cache.TemplateCache" name="void throwLoadFailedException(java.lang.Throwable)" map="A"/>
  <method class="freemarker.cache.TemplateCache" name="freemarker.cache.TemplateCache$MaybeMissingTemplate getTemplate(java.lang.String, java.util.Locale, java.lang.Object, java.lang.String, boolean)" map="B"/>
  <method class="freemarker.cache.TemplateCache" name="java.lang.reflect.Method getInitCauseMethod()" map="G"/>
  <method class="freemarker.cache.TemplateCache" name="void storeCached(freemarker.cache.TemplateCache$TemplateKey, freemarker.cache.TemplateCache$CachedTemplate)" map="A"/>
  <method class="freemarker.cache.TemplateCache" name="java.lang.Object findTemplateSource(java.lang.String)" map="B"/>
  <method class="freemarker.cache.TemplateCache" name="void clear()" map="H"/>
  <method class="freemarker.cache.TemplateCache" name="freemarker.template.Template getTemplateInternal(java.lang.String, java.util.Locale, java.lang.Object, java.lang.String, boolean)" map="C"/>
  <method class="freemarker.cache.TemplateCache" name="freemarker.cache.TemplateLookupResult access$500(freemarker.cache.TemplateCache, java.lang.String)" map="A"/>
  <method class="freemarker.cache.TemplateCache" name="freemarker.cache.TemplateLookupResult lookupTemplate(java.lang.String, java.util.Locale, java.lang.Object)" map="A"/>
  <class name="freemarker.cache.OrMatcher" map="B"/>
  <class name="freemarker.cache.FileTemplateLoader$4" map="4"/>
  <field class="freemarker.cache.FileTemplateLoader$4" name="this$0" map="A"/>
  <field class="freemarker.cache.FileTemplateLoader$4" name="val$encoding" map="B"/>
  <field class="freemarker.cache.FileTemplateLoader$4" name="val$templateSource" map="C"/>
  <method class="freemarker.cache.FileTemplateLoader$4" name="java.lang.Object run()" map="run"/>
  <method class="freemarker.cache.FileTemplateLoader$4" name="java.io.Reader run()" map="A"/>
  <class name="freemarker.cache.FileTemplateLoader$3" map="3"/>
  <field class="freemarker.cache.FileTemplateLoader$3" name="this$0" map="A"/>
  <field class="freemarker.cache.FileTemplateLoader$3" name="val$templateSource" map="B"/>
  <method class="freemarker.cache.FileTemplateLoader$3" name="java.lang.Long run()" map="A"/>
  <method class="freemarker.cache.FileTemplateLoader$3" name="java.lang.Object run()" map="run"/>
  <class name="freemarker.cache.FileTemplateLoader$2" map="2"/>
  <field class="freemarker.cache.FileTemplateLoader$2" name="this$0" map="A"/>
  <field class="freemarker.cache.FileTemplateLoader$2" name="val$name" map="B"/>
  <method class="freemarker.cache.FileTemplateLoader$2" name="java.io.File run()" map="A"/>
  <method class="freemarker.cache.FileTemplateLoader$2" name="java.lang.Object run()" map="run"/>
  <class name="freemarker.cache.FileTemplateLoader$1" map="1"/>
  <field class="freemarker.cache.FileTemplateLoader$1" name="this$0" map="A"/>
  <field class="freemarker.cache.FileTemplateLoader$1" name="val$disableCanonicalPathCheck" map="B"/>
  <field class="freemarker.cache.FileTemplateLoader$1" name="val$baseDir" map="C"/>
  <method class="freemarker.cache.FileTemplateLoader$1" name="java.lang.Object run()" map="run"/>
  <method class="freemarker.cache.FileTemplateLoader$1" name="java.lang.Object[] run()" map="A"/>
  <class name="freemarker.cache.FileTemplateLoader" map="C"/>
  <field class="freemarker.cache.FileTemplateLoader" name="correctCasePaths" map="E"/>
  <field class="freemarker.cache.FileTemplateLoader" name="LOG" map="F"/>
  <field class="freemarker.cache.FileTemplateLoader" name="emulateCaseSensitiveFileSystem" map="G"/>
  <field class="freemarker.cache.FileTemplateLoader" name="EMULATE_CASE_SENSITIVE_FILE_SYSTEM_DEFAULT" map="H"/>
  <field class="freemarker.cache.FileTemplateLoader" name="SYSTEM_PROPERTY_NAME_EMULATE_CASE_SENSITIVE_FILE_SYSTEM" map="I"/>
  <field class="freemarker.cache.FileTemplateLoader" name="baseDir" map="J"/>
  <field class="freemarker.cache.FileTemplateLoader" name="canonicalBasePath" map="K"/>
  <field class="freemarker.cache.FileTemplateLoader" name="SEP_IS_SLASH" map="L"/>
  <method class="freemarker.cache.FileTemplateLoader" name="long getLastModified(java.lang.Object)" map="A"/>
  <method class="freemarker.cache.FileTemplateLoader" name="boolean access$000()" map="C"/>
  <method class="freemarker.cache.FileTemplateLoader" name="void setEmulateCaseSensitiveFileSystem(boolean)" map="A"/>
  <method class="freemarker.cache.FileTemplateLoader" name="java.lang.String access$100(freemarker.cache.FileTemplateLoader)" map="A"/>
  <method class="freemarker.cache.FileTemplateLoader" name="boolean isNameCaseCorrect(java.io.File)" map="A"/>
  <method class="freemarker.cache.FileTemplateLoader" name="java.io.Reader getReader(java.lang.Object, java.lang.String)" map="A"/>
  <method class="freemarker.cache.FileTemplateLoader" name="boolean access$300(freemarker.cache.FileTemplateLoader, java.io.File)" map="A"/>
  <method class="freemarker.cache.FileTemplateLoader" name="void closeTemplateSource(java.lang.Object)" map="B"/>
  <method class="freemarker.cache.FileTemplateLoader" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.cache.FileTemplateLoader" name="java.lang.Object findTemplateSource(java.lang.String)" map="A"/>
  <method class="freemarker.cache.FileTemplateLoader" name="boolean getEmulateCaseSensitiveFileSystemDefault()" map="D"/>
  <method class="freemarker.cache.FileTemplateLoader" name="boolean access$200(freemarker.cache.FileTemplateLoader)" map="B"/>
  <class name="freemarker.cache.AndMatcher" map="D"/>
  <class name="freemarker.cache.TemplateLookupContext" map="E"/>
  <field class="freemarker.cache.TemplateLookupContext" name="templateName" map="A"/>
  <field class="freemarker.cache.TemplateLookupContext" name="templateLocale" map="B"/>
  <field class="freemarker.cache.TemplateLookupContext" name="customLookupCondition" map="C"/>
  <method class="freemarker.cache.TemplateLookupContext" name="java.util.Locale getTemplateLocale()" map="A"/>
  <method class="freemarker.cache.TemplateLookupContext" name="freemarker.cache.TemplateLookupResult createNegativeLookupResult()" map="B"/>
  <method class="freemarker.cache.TemplateLookupContext" name="java.lang.String getTemplateName()" map="C"/>
  <method class="freemarker.cache.TemplateLookupContext" name="freemarker.cache.TemplateLookupResult lookupWithLocalizedThenAcquisitionStrategy(java.lang.String, java.util.Locale)" map="A"/>
  <class name="freemarker.cache.ConcurrentCacheStorage" map="F"/>
  <method class="freemarker.cache.ConcurrentCacheStorage" name="boolean isConcurrent()" map="C"/>
  <class name="freemarker.cache.TemplateSourceMatcher" map="G"/>
  <class name="freemarker.cache.TemplateConfigurationFactory" map="H"/>
  <method class="freemarker.cache.TemplateConfigurationFactory" name="freemarker.core.TemplateConfiguration get(java.lang.String, java.lang.Object)" map="A"/>
  <class name="freemarker.cache.FirstMatchTemplateConfigurationFactory" map="I"/>
  <class name="freemarker.cache.CacheStorage" map="J"/>
  <method class="freemarker.cache.CacheStorage" name="void clear()" map="A"/>
  <method class="freemarker.cache.CacheStorage" name="java.lang.Object get(java.lang.Object)" map="A"/>
  <method class="freemarker.cache.CacheStorage" name="void put(java.lang.Object, java.lang.Object)" map="A"/>
  <class name="freemarker.cache.ConditionalTemplateConfigurationFactory" map="K"/>
  <class name="freemarker.cache.TemplateLoader" map="L"/>
  <method class="freemarker.cache.TemplateLoader" name="long getLastModified(java.lang.Object)" map="A"/>
  <method class="freemarker.cache.TemplateLoader" name="void closeTemplateSource(java.lang.Object)" map="B"/>
  <method class="freemarker.cache.TemplateLoader" name="java.lang.Object findTemplateSource(java.lang.String)" map="A"/>
  <method class="freemarker.cache.TemplateLoader" name="java.io.Reader getReader(java.lang.Object, java.lang.String)" map="A"/>
  <class name="freemarker.cache.MultiTemplateLoader$MultiSource" map="_A"/>
  <method class="freemarker.cache.MultiTemplateLoader$MultiSource" name="java.lang.Object getWrappedSource()" map="A"/>
  <class name="freemarker.cache.MultiTemplateLoader" map="M"/>
  <class name="freemarker.cache.URLTemplateLoader" map="N"/>
  <field class="freemarker.cache.URLTemplateLoader" name="urlConnectionUsesCaches" map="A"/>
  <method class="freemarker.cache.URLTemplateLoader" name="java.lang.String canonicalizePrefix(java.lang.String)" map="B"/>
  <method class="freemarker.cache.URLTemplateLoader" name="java.net.URL getURL(java.lang.String)" map="C"/>
  <method class="freemarker.cache.URLTemplateLoader" name="java.lang.Boolean getURLConnectionUsesCaches()" map="A"/>
  <method class="freemarker.cache.URLTemplateLoader" name="long getLastModified(java.lang.Object)" map="A"/>
  <method class="freemarker.cache.URLTemplateLoader" name="void closeTemplateSource(java.lang.Object)" map="B"/>
  <method class="freemarker.cache.URLTemplateLoader" name="java.lang.Object findTemplateSource(java.lang.String)" map="A"/>
  <method class="freemarker.cache.URLTemplateLoader" name="java.io.Reader getReader(java.lang.Object, java.lang.String)" map="A"/>
  <class name="freemarker.cache.FileExtensionMatcher" map="O"/>
  <class name="freemarker.cache.PathGlobMatcher" map="P"/>
  <class name="freemarker.cache.CacheStorageWithGetSize" map="Q"/>
  <class name="freemarker.cache.FileNameGlobMatcher" map="R"/>
  <class name="freemarker.cache.PathRegexMatcher" map="S"/>
  <class name="freemarker.cache.URLTemplateSource" map="T"/>
  <field class="freemarker.cache.URLTemplateSource" name="url" map="A"/>
  <field class="freemarker.cache.URLTemplateSource" name="inputStream" map="B"/>
  <field class="freemarker.cache.URLTemplateSource" name="conn" map="C"/>
  <field class="freemarker.cache.URLTemplateSource" name="useCaches" map="D"/>
  <method class="freemarker.cache.URLTemplateSource" name="void setUseCaches(boolean)" map="A"/>
  <method class="freemarker.cache.URLTemplateSource" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="freemarker.cache.URLTemplateSource" name="int hashCode()" map="hashCode"/>
  <method class="freemarker.cache.URLTemplateSource" name="java.lang.Boolean getUseCaches()" map="A"/>
  <method class="freemarker.cache.URLTemplateSource" name="java.io.InputStream getInputStream()" map="B"/>
  <method class="freemarker.cache.URLTemplateSource" name="void close()" map="C"/>
  <method class="freemarker.cache.URLTemplateSource" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.cache.URLTemplateSource" name="long lastModified()" map="D"/>
  <class name="freemarker.cache.TemplateLoaderUtils" map="U"/>
  <method class="freemarker.cache.TemplateLoaderUtils" name="java.lang.String getClassNameForToString(freemarker.cache.TemplateLoader)" map="A"/>
  <class name="freemarker.cache.MruCacheStorage$MruReference" map="_A"/>
  <field class="freemarker.cache.MruCacheStorage$MruReference" name="key" map="A"/>
  <method class="freemarker.cache.MruCacheStorage$MruReference" name="java.lang.Object getKey()" map="A"/>
  <class name="freemarker.cache.MruCacheStorage$MruEntry" map="_B"/>
  <field class="freemarker.cache.MruCacheStorage$MruEntry" name="key" map="A"/>
  <field class="freemarker.cache.MruCacheStorage$MruEntry" name="next" map="B"/>
  <field class="freemarker.cache.MruCacheStorage$MruEntry" name="prev" map="C"/>
  <field class="freemarker.cache.MruCacheStorage$MruEntry" name="value" map="D"/>
  <method class="freemarker.cache.MruCacheStorage$MruEntry" name="void setValue(java.lang.Object)" map="A"/>
  <method class="freemarker.cache.MruCacheStorage$MruEntry" name="void makeHead()" map="A"/>
  <method class="freemarker.cache.MruCacheStorage$MruEntry" name="void unlink()" map="B"/>
  <method class="freemarker.cache.MruCacheStorage$MruEntry" name="java.lang.Object getKey()" map="C"/>
  <method class="freemarker.cache.MruCacheStorage$MruEntry" name="java.lang.Object getValue()" map="D"/>
  <method class="freemarker.cache.MruCacheStorage$MruEntry" name="void linkAfter(freemarker.cache.MruCacheStorage$MruEntry)" map="A"/>
  <method class="freemarker.cache.MruCacheStorage$MruEntry" name="freemarker.cache.MruCacheStorage$MruEntry getPrevious()" map="E"/>
  <class name="freemarker.cache.MruCacheStorage" map="V"/>
  <field class="freemarker.cache.MruCacheStorage" name="strongSize" map="A"/>
  <field class="freemarker.cache.MruCacheStorage" name="strongHead" map="B"/>
  <field class="freemarker.cache.MruCacheStorage" name="refQueue" map="C"/>
  <field class="freemarker.cache.MruCacheStorage" name="softSizeLimit" map="D"/>
  <field class="freemarker.cache.MruCacheStorage" name="map" map="E"/>
  <field class="freemarker.cache.MruCacheStorage" name="softSize" map="F"/>
  <field class="freemarker.cache.MruCacheStorage" name="softHead" map="G"/>
  <field class="freemarker.cache.MruCacheStorage" name="strongSizeLimit" map="H"/>
  <method class="freemarker.cache.MruCacheStorage" name="void removeClearedReferences()" map="B"/>
  <method class="freemarker.cache.MruCacheStorage" name="void clear()" map="A"/>
  <method class="freemarker.cache.MruCacheStorage" name="void removeInternal(java.lang.Object)" map="B"/>
  <method class="freemarker.cache.MruCacheStorage" name="boolean unlinkEntryAndInspectIfSoft(freemarker.cache.MruCacheStorage$MruEntry)" map="A"/>
  <method class="freemarker.cache.MruCacheStorage" name="void linkAfterStrongHead(freemarker.cache.MruCacheStorage$MruEntry)" map="B"/>
  <method class="freemarker.cache.MruCacheStorage" name="void relinkEntryAfterStrongHead(freemarker.cache.MruCacheStorage$MruEntry, java.lang.Object)" map="A"/>
  <method class="freemarker.cache.MruCacheStorage" name="java.lang.Object get(java.lang.Object)" map="A"/>
  <method class="freemarker.cache.MruCacheStorage" name="void put(java.lang.Object, java.lang.Object)" map="A"/>
  <class name="freemarker.cache.TemplateNameFormat$1" map="1"/>
  <class name="freemarker.cache.TemplateNameFormat$Default020400" map="_A"/>
  <method class="freemarker.cache.TemplateNameFormat$Default020400" name="java.lang.String resolveDotDotSteps(java.lang.String, java.lang.String)" map="B"/>
  <method class="freemarker.cache.TemplateNameFormat$Default020400" name="java.lang.String removeDotSteps(java.lang.String)" map="G"/>
  <method class="freemarker.cache.TemplateNameFormat$Default020400" name="java.lang.String rootBasedNameToAbsoluteName(java.lang.String)" map="F"/>
  <method class="freemarker.cache.TemplateNameFormat$Default020400" name="java.lang.String removeRedundantStarSteps(java.lang.String)" map="H"/>
  <method class="freemarker.cache.TemplateNameFormat$Default020400" name="java.lang.String toRootBasedName(java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.cache.TemplateNameFormat$Default020400" name="int findSchemeSectionEnd(java.lang.String)" map="I"/>
  <method class="freemarker.cache.TemplateNameFormat$Default020400" name="java.lang.String removeRedundantSlashes(java.lang.String)" map="J"/>
  <method class="freemarker.cache.TemplateNameFormat$Default020400" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.cache.TemplateNameFormat$Default020400" name="java.lang.String normalizeRootBasedName(java.lang.String)" map="B"/>
  <class name="freemarker.cache.TemplateNameFormat$Default020300" map="_B"/>
  <method class="freemarker.cache.TemplateNameFormat$Default020300" name="java.lang.String toRootBasedName(java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.cache.TemplateNameFormat$Default020300" name="java.lang.String normalizeRootBasedName(java.lang.String)" map="B"/>
  <method class="freemarker.cache.TemplateNameFormat$Default020300" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.cache.TemplateNameFormat$Default020300" name="java.lang.String rootBasedNameToAbsoluteName(java.lang.String)" map="F"/>
  <class name="freemarker.cache.TemplateNameFormat" map="W"/>
  <field class="freemarker.cache.TemplateNameFormat" name="DEFAULT_2_3_0" map="A"/>
  <field class="freemarker.cache.TemplateNameFormat" name="DEFAULT_2_4_0" map="B"/>
  <method class="freemarker.cache.TemplateNameFormat" name="java.lang.String toRootBasedName(java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.cache.TemplateNameFormat" name="freemarker.template.MalformedTemplateNameException access$400(java.lang.String)" map="A"/>
  <method class="freemarker.cache.TemplateNameFormat" name="java.lang.String normalizeRootBasedName(java.lang.String)" map="B"/>
  <method class="freemarker.cache.TemplateNameFormat" name="freemarker.template.MalformedTemplateNameException newRootLeavingException(java.lang.String)" map="C"/>
  <method class="freemarker.cache.TemplateNameFormat" name="void access$300(java.lang.String)" map="D"/>
  <method class="freemarker.cache.TemplateNameFormat" name="void checkNameHasNoNullCharacter(java.lang.String)" map="E"/>
  <method class="freemarker.cache.TemplateNameFormat" name="java.lang.String rootBasedNameToAbsoluteName(java.lang.String)" map="F"/>
  <class name="freemarker.cache.ClassTemplateLoader" map="X"/>
  <field class="freemarker.cache.ClassTemplateLoader" name="resourceLoaderClass" map="B"/>
  <field class="freemarker.cache.ClassTemplateLoader" name="classLoader" map="C"/>
  <field class="freemarker.cache.ClassTemplateLoader" name="basePackagePath" map="D"/>
  <method class="freemarker.cache.ClassTemplateLoader" name="java.net.URL getURL(java.lang.String)" map="C"/>
  <method class="freemarker.cache.ClassTemplateLoader" name="boolean isSchemeless(java.lang.String)" map="D"/>
  <method class="freemarker.cache.ClassTemplateLoader" name="java.lang.String toString()" map="toString"/>
  <class name="freemarker.cache._CacheAPI" map="Y"/>
  <method class="freemarker.cache._CacheAPI" name="java.lang.String rootBasedNameToAbsoluteName(freemarker.cache.TemplateNameFormat, java.lang.String)" map="A"/>
  <method class="freemarker.cache._CacheAPI" name="java.lang.String toRootBasedName(freemarker.cache.TemplateNameFormat, java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.cache._CacheAPI" name="java.lang.String normalizeRootBasedName(freemarker.cache.TemplateNameFormat, java.lang.String)" map="B"/>
  <class name="freemarker.cache.TemplateLookupStrategy$1" map="1"/>
  <class name="freemarker.cache.TemplateLookupStrategy$Default020300" map="_A"/>
  <method class="freemarker.cache.TemplateLookupStrategy$Default020300" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.cache.TemplateLookupStrategy$Default020300" name="freemarker.cache.TemplateLookupResult lookup(freemarker.cache.TemplateLookupContext)" map="A"/>
  <class name="freemarker.cache.TemplateLookupStrategy" map="Z"/>
  <field class="freemarker.cache.TemplateLookupStrategy" name="DEFAULT_2_3_0" map="A"/>
  <method class="freemarker.cache.TemplateLookupStrategy" name="freemarker.cache.TemplateLookupResult lookup(freemarker.cache.TemplateLookupContext)" map="A"/>
  <class name="freemarker.cache.SoftCacheStorage$SoftValueReference" map="_A"/>
  <field class="freemarker.cache.SoftCacheStorage$SoftValueReference" name="key" map="A"/>
  <method class="freemarker.cache.SoftCacheStorage$SoftValueReference" name="java.lang.Object getKey()" map="A"/>
  <class name="freemarker.cache.SoftCacheStorage" map="_"/>
  <field class="freemarker.cache.SoftCacheStorage" name="queue" map="I"/>
  <field class="freemarker.cache.SoftCacheStorage" name="concurrent" map="J"/>
  <field class="freemarker.cache.SoftCacheStorage" name="atomicRemove" map="K"/>
  <field class="freemarker.cache.SoftCacheStorage" name="map" map="L"/>
  <method class="freemarker.cache.SoftCacheStorage" name="java.lang.reflect.Method getAtomicRemoveMethod()" map="D"/>
  <method class="freemarker.cache.SoftCacheStorage" name="void processQueue()" map="E"/>
  <method class="freemarker.cache.SoftCacheStorage" name="boolean isConcurrent()" map="C"/>
  <method class="freemarker.cache.SoftCacheStorage" name="void clear()" map="A"/>
  <method class="freemarker.cache.SoftCacheStorage" name="java.lang.Object get(java.lang.Object)" map="A"/>
  <method class="freemarker.cache.SoftCacheStorage" name="void put(java.lang.Object, java.lang.Object)" map="A"/>
  <class name="freemarker.cache.StatefulTemplateLoader" map="a"/>
  <method class="freemarker.cache.StatefulTemplateLoader" name="void resetState()" map="B"/>
  <class name="freemarker.cache.NotMatcher" map="b"/>
  <class name="freemarker.cache.MergingTemplateConfigurationFactory" map="c"/>
  <class name="freemarker.cache.TemplateLookupResult$NegativeTemplateLookupResult" map="_A"/>
  <field class="freemarker.cache.TemplateLookupResult$NegativeTemplateLookupResult" name="INSTANCE" map="C"/>
  <method class="freemarker.cache.TemplateLookupResult$NegativeTemplateLookupResult" name="java.lang.Object getTemplateSource()" map="A"/>
  <method class="freemarker.cache.TemplateLookupResult$NegativeTemplateLookupResult" name="java.lang.String getTemplateSourceName()" map="B"/>
  <method class="freemarker.cache.TemplateLookupResult$NegativeTemplateLookupResult" name="freemarker.cache.TemplateLookupResult$NegativeTemplateLookupResult access$000()" map="E"/>
  <method class="freemarker.cache.TemplateLookupResult$NegativeTemplateLookupResult" name="boolean isPositive()" map="D"/>
  <class name="freemarker.cache.TemplateLookupResult$1" map="1"/>
  <class name="freemarker.cache.TemplateLookupResult$PositiveTemplateLookupResult" map="_B"/>
  <field class="freemarker.cache.TemplateLookupResult$PositiveTemplateLookupResult" name="templateSource" map="A"/>
  <field class="freemarker.cache.TemplateLookupResult$PositiveTemplateLookupResult" name="templateSourceName" map="B"/>
  <method class="freemarker.cache.TemplateLookupResult$PositiveTemplateLookupResult" name="java.lang.Object getTemplateSource()" map="A"/>
  <method class="freemarker.cache.TemplateLookupResult$PositiveTemplateLookupResult" name="java.lang.String getTemplateSourceName()" map="B"/>
  <method class="freemarker.cache.TemplateLookupResult$PositiveTemplateLookupResult" name="boolean isPositive()" map="D"/>
  <class name="freemarker.cache.TemplateLookupResult" map="d"/>
  <method class="freemarker.cache.TemplateLookupResult" name="java.lang.Object getTemplateSource()" map="A"/>
  <method class="freemarker.cache.TemplateLookupResult" name="freemarker.cache.TemplateLookupResult from(java.lang.String, java.lang.Object)" map="A"/>
  <method class="freemarker.cache.TemplateLookupResult" name="java.lang.String getTemplateSourceName()" map="B"/>
  <method class="freemarker.cache.TemplateLookupResult" name="freemarker.cache.TemplateLookupResult createNegativeResult()" map="C"/>
  <method class="freemarker.cache.TemplateLookupResult" name="boolean isPositive()" map="D"/>
  <package name="freemarker.template" map="D"/>
  <package name="freemarker.template.utility" map="A"/>
  <class name="freemarker.template.utility.DateUtil$TrivialDateToISO8601CalendarFactory" map="_A"/>
  <field class="freemarker.template.utility.DateUtil$TrivialDateToISO8601CalendarFactory" name="lastlySetTimeZone" map="A"/>
  <field class="freemarker.template.utility.DateUtil$TrivialDateToISO8601CalendarFactory" name="calendar" map="B"/>
  <method class="freemarker.template.utility.DateUtil$TrivialDateToISO8601CalendarFactory" name="java.util.GregorianCalendar get(java.util.TimeZone, java.util.Date)" map="A"/>
  <class name="freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter" map="_B"/>
  <method class="freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter" name="java.util.Date calculate(int, int, int, int, int, int, int, int, boolean, java.util.TimeZone)" map="A"/>
  <class name="freemarker.template.utility.DateUtil$DateToISO8601CalendarFactory" map="_C"/>
  <method class="freemarker.template.utility.DateUtil$DateToISO8601CalendarFactory" name="java.util.GregorianCalendar get(java.util.TimeZone, java.util.Date)" map="A"/>
  <class name="freemarker.template.utility.DateUtil$TrivialCalendarFieldsToDateConverter" map="_D"/>
  <field class="freemarker.template.utility.DateUtil$TrivialCalendarFieldsToDateConverter" name="lastlySetTimeZone" map="A"/>
  <field class="freemarker.template.utility.DateUtil$TrivialCalendarFieldsToDateConverter" name="calendar" map="B"/>
  <method class="freemarker.template.utility.DateUtil$TrivialCalendarFieldsToDateConverter" name="java.util.Date calculate(int, int, int, int, int, int, int, int, boolean, java.util.TimeZone)" map="A"/>
  <class name="freemarker.template.utility.DateUtil$DateParseException" map="_E"/>
  <class name="freemarker.template.utility.DateUtil" map="A"/>
  <field class="freemarker.template.utility.DateUtil" name="UTC" map="A"/>
  <field class="freemarker.template.utility.DateUtil" name="PATTERN_XS_DATE_TIME" map="B"/>
  <field class="freemarker.template.utility.DateUtil" name="PATTERN_XS_TIME_ZONE" map="C"/>
  <field class="freemarker.template.utility.DateUtil" name="PATTERN_XS_DATE" map="D"/>
  <field class="freemarker.template.utility.DateUtil" name="PATTERN_XS_TIME" map="E"/>
  <field class="freemarker.template.utility.DateUtil" name="PATTERN_ISO8601_EXTENDED_DATE_TIME" map="F"/>
  <field class="freemarker.template.utility.DateUtil" name="PATTERN_ISO8601_BASIC_DATE" map="G"/>
  <field class="freemarker.template.utility.DateUtil" name="PATTERN_ISO8601_BASIC_TIME" map="H"/>
  <field class="freemarker.template.utility.DateUtil" name="PATTERN_ISO8601_BASIC_DATE_TIME" map="I"/>
  <field class="freemarker.template.utility.DateUtil" name="PATTERN_ISO8601_EXTENDED_DATE" map="J"/>
  <field class="freemarker.template.utility.DateUtil" name="PATTERN_ISO8601_EXTENDED_TIME" map="K"/>
  <method class="freemarker.template.utility.DateUtil" name="java.lang.String dateToISO8601String(java.util.Date, boolean, boolean, boolean, int, java.util.TimeZone, freemarker.template.utility.DateUtil$DateToISO8601CalendarFactory)" map="A"/>
  <method class="freemarker.template.utility.DateUtil" name="java.lang.String dateToXSString(java.util.Date, boolean, boolean, boolean, int, java.util.TimeZone, freemarker.template.utility.DateUtil$DateToISO8601CalendarFactory)" map="B"/>
  <method class="freemarker.template.utility.DateUtil" name="java.util.Date parseDateTime_parseMatcher(java.util.regex.Matcher, java.util.TimeZone, boolean, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="A"/>
  <method class="freemarker.template.utility.DateUtil" name="java.util.Date parseISO8601Time(java.lang.String, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="A"/>
  <method class="freemarker.template.utility.DateUtil" name="java.util.Date parseDate_parseMatcher(java.util.regex.Matcher, java.util.TimeZone, boolean, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="B"/>
  <method class="freemarker.template.utility.DateUtil" name="java.util.Date parseXSDateTime(java.lang.String, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="B"/>
  <method class="freemarker.template.utility.DateUtil" name="int groupToMillisecond(java.lang.String)" map="A"/>
  <method class="freemarker.template.utility.DateUtil" name="java.util.Date parseXSDate(java.lang.String, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="C"/>
  <method class="freemarker.template.utility.DateUtil" name="java.lang.String dateToString(java.util.Date, boolean, boolean, boolean, int, java.util.TimeZone, boolean, freemarker.template.utility.DateUtil$DateToISO8601CalendarFactory)" map="A"/>
  <method class="freemarker.template.utility.DateUtil" name="java.util.Date parseTime_parseMatcher(java.util.regex.Matcher, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="A"/>
  <method class="freemarker.template.utility.DateUtil" name="java.util.Date parseISO8601Date(java.lang.String, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="D"/>
  <method class="freemarker.template.utility.DateUtil" name="java.util.TimeZone getTimeZone(java.lang.String)" map="B"/>
  <method class="freemarker.template.utility.DateUtil" name="int append00(char[], int, int)" map="A"/>
  <method class="freemarker.template.utility.DateUtil" name="java.util.Date parseXSTime(java.lang.String, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="E"/>
  <method class="freemarker.template.utility.DateUtil" name="boolean isGMTish(java.lang.String)" map="C"/>
  <method class="freemarker.template.utility.DateUtil" name="java.util.TimeZone parseMatchingTimeZone(java.lang.String, java.util.TimeZone)" map="A"/>
  <method class="freemarker.template.utility.DateUtil" name="int groupToInt(java.lang.String, java.lang.String, int, int)" map="A"/>
  <method class="freemarker.template.utility.DateUtil" name="java.util.Date parseISO8601DateTime(java.lang.String, java.util.TimeZone, freemarker.template.utility.DateUtil$CalendarFieldsToDateConverter)" map="F"/>
  <class name="freemarker.template.utility.Constants$EmptyHashModel" map="_A"/>
  <method class="freemarker.template.utility.Constants$EmptyHashModel" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.template.utility.Constants$EmptyHashModel" name="freemarker.template.TemplateCollectionModel keys()" map="&#x00c8;"/>
  <method class="freemarker.template.utility.Constants$EmptyHashModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.template.utility.Constants$EmptyHashModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.utility.Constants$EmptyHashModel" name="freemarker.template.TemplateHashModelEx2$KeyValuePairIterator keyValuePairIterator()" map="&#x00cb;"/>
  <method class="freemarker.template.utility.Constants$EmptyHashModel" name="freemarker.template.TemplateCollectionModel values()" map="&#x00c9;"/>
  <class name="freemarker.template.utility.Constants$EmptySequenceModel" map="_B"/>
  <method class="freemarker.template.utility.Constants$EmptySequenceModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.utility.Constants$EmptySequenceModel" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <class name="freemarker.template.utility.Constants$1" map="1"/>
  <class name="freemarker.template.utility.Constants$EmptyCollectionModel" map="_C"/>
  <method class="freemarker.template.utility.Constants$EmptyCollectionModel" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <class name="freemarker.template.utility.Constants$EmptyKeyValuePairIterator" map="_D"/>
  <method class="freemarker.template.utility.Constants$EmptyKeyValuePairIterator" name="boolean hasNext()" map="A"/>
  <method class="freemarker.template.utility.Constants$EmptyKeyValuePairIterator" name="freemarker.template.TemplateHashModelEx2$KeyValuePair next()" map="B"/>
  <class name="freemarker.template.utility.Constants$EmptyIteratorModel" map="_E"/>
  <method class="freemarker.template.utility.Constants$EmptyIteratorModel" name="boolean hasNext()" map="&#x00d1;"/>
  <method class="freemarker.template.utility.Constants$EmptyIteratorModel" name="freemarker.template.TemplateModel next()" map="&#x00d2;"/>
  <class name="freemarker.template.utility.Constants" map="B"/>
  <field class="freemarker.template.utility.Constants" name="EMPTY_ITERATOR" map="A"/>
  <field class="freemarker.template.utility.Constants" name="ONE" map="B"/>
  <field class="freemarker.template.utility.Constants" name="EMPTY_STRING" map="C"/>
  <field class="freemarker.template.utility.Constants" name="EMPTY_HASH" map="D"/>
  <field class="freemarker.template.utility.Constants" name="TRUE" map="E"/>
  <field class="freemarker.template.utility.Constants" name="EMPTY_KEY_VALUE_PAIR_ITERATOR" map="F"/>
  <field class="freemarker.template.utility.Constants" name="MINUS_ONE" map="G"/>
  <field class="freemarker.template.utility.Constants" name="ZERO" map="H"/>
  <field class="freemarker.template.utility.Constants" name="FALSE" map="I"/>
  <field class="freemarker.template.utility.Constants" name="EMPTY_COLLECTION" map="J"/>
  <field class="freemarker.template.utility.Constants" name="EMPTY_SEQUENCE" map="K"/>
  <class name="freemarker.template.utility.SecurityUtilities$3" map="3"/>
  <field class="freemarker.template.utility.SecurityUtilities$3" name="val$defValue" map="A"/>
  <field class="freemarker.template.utility.SecurityUtilities$3" name="val$key" map="B"/>
  <method class="freemarker.template.utility.SecurityUtilities$3" name="java.lang.Object run()" map="run"/>
  <class name="freemarker.template.utility.SecurityUtilities$2" map="2"/>
  <field class="freemarker.template.utility.SecurityUtilities$2" name="val$defValue" map="A"/>
  <field class="freemarker.template.utility.SecurityUtilities$2" name="val$key" map="B"/>
  <method class="freemarker.template.utility.SecurityUtilities$2" name="java.lang.Object run()" map="run"/>
  <class name="freemarker.template.utility.SecurityUtilities$1" map="1"/>
  <field class="freemarker.template.utility.SecurityUtilities$1" name="val$key" map="A"/>
  <method class="freemarker.template.utility.SecurityUtilities$1" name="java.lang.Object run()" map="run"/>
  <class name="freemarker.template.utility.SecurityUtilities" map="C"/>
  <field class="freemarker.template.utility.SecurityUtilities" name="LOG" map="A"/>
  <method class="freemarker.template.utility.SecurityUtilities" name="java.lang.String getSystemProperty(java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.template.utility.SecurityUtilities" name="java.lang.Integer getSystemProperty(java.lang.String, int)" map="A"/>
  <method class="freemarker.template.utility.SecurityUtilities" name="java.lang.String getSystemProperty(java.lang.String)" map="A"/>
  <class name="freemarker.template.utility.UnrecognizedTimeZoneException" map="D"/>
  <field class="freemarker.template.utility.UnrecognizedTimeZoneException" name="timeZoneName" map="A"/>
  <class name="freemarker.template.utility.ObjectConstructor" map="E"/>
  <method class="freemarker.template.utility.ObjectConstructor" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.template.utility.StandardCompress$StandardCompressWriter" map="_A"/>
  <field class="freemarker.template.utility.StandardCompress$StandardCompressWriter" name="singleLine" map="A"/>
  <field class="freemarker.template.utility.StandardCompress$StandardCompressWriter" name="lineBreakState" map="B"/>
  <field class="freemarker.template.utility.StandardCompress$StandardCompressWriter" name="buf" map="C"/>
  <field class="freemarker.template.utility.StandardCompress$StandardCompressWriter" name="out" map="D"/>
  <field class="freemarker.template.utility.StandardCompress$StandardCompressWriter" name="inWhitespace" map="E"/>
  <field class="freemarker.template.utility.StandardCompress$StandardCompressWriter" name="pos" map="F"/>
  <method class="freemarker.template.utility.StandardCompress$StandardCompressWriter" name="void write(char[], int, int)" map="write"/>
  <method class="freemarker.template.utility.StandardCompress$StandardCompressWriter" name="void flush()" map="flush"/>
  <method class="freemarker.template.utility.StandardCompress$StandardCompressWriter" name="void writeLineBreakOrSpace()" map="A"/>
  <method class="freemarker.template.utility.StandardCompress$StandardCompressWriter" name="void close()" map="close"/>
  <method class="freemarker.template.utility.StandardCompress$StandardCompressWriter" name="void updateLineBreakState(char)" map="A"/>
  <method class="freemarker.template.utility.StandardCompress$StandardCompressWriter" name="void writeHelper(char[], int, int)" map="A"/>
  <method class="freemarker.template.utility.StandardCompress$StandardCompressWriter" name="void flushInternal()" map="B"/>
  <class name="freemarker.template.utility.StandardCompress" map="F"/>
  <field class="freemarker.template.utility.StandardCompress" name="INSTANCE" map="&#x0274;"/>
  <field class="freemarker.template.utility.StandardCompress" name="defaultBufferSize" map="&#x0275;"/>
  <method class="freemarker.template.utility.StandardCompress" name="java.io.Writer getWriter(java.io.Writer, java.util.Map)" map="A"/>
  <class name="freemarker.template.utility.ClassUtil$1" map="1"/>
  <class name="freemarker.template.utility.ClassUtil$MaybeZipFileClosedException" map="_A"/>
  <class name="freemarker.template.utility.ClassUtil" map="G"/>
  <method class="freemarker.template.utility.ClassUtil" name="java.lang.Class getUnwrappedClass(freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.template.utility.ClassUtil" name="java.lang.Class forName(java.lang.String)" map="A"/>
  <method class="freemarker.template.utility.ClassUtil" name="java.lang.Class getPrimaryTemplateModelInterface(freemarker.template.TemplateModel)" map="B"/>
  <method class="freemarker.template.utility.ClassUtil" name="java.lang.String getFTLTypeDescription(freemarker.template.TemplateModel)" map="C"/>
  <method class="freemarker.template.utility.ClassUtil" name="java.lang.String getShortClassName(java.lang.Class, boolean)" map="A"/>
  <method class="freemarker.template.utility.ClassUtil" name="boolean isNumerical(java.lang.Class)" map="A"/>
  <method class="freemarker.template.utility.ClassUtil" name="void checkInputStreamNotNull(java.io.InputStream, java.lang.Class, java.lang.String)" map="A"/>
  <method class="freemarker.template.utility.ClassUtil" name="java.lang.String getShortClassNameOfObject(java.lang.Object)" map="A"/>
  <method class="freemarker.template.utility.ClassUtil" name="void appendTemplateModelTypeName(java.lang.StringBuilder, java.util.Set, java.lang.Class)" map="A"/>
  <method class="freemarker.template.utility.ClassUtil" name="java.lang.Class primitiveClassToBoxingClass(java.lang.Class)" map="B"/>
  <method class="freemarker.template.utility.ClassUtil" name="void appendTypeName(java.lang.StringBuilder, java.util.Set, java.lang.String)" map="A"/>
  <method class="freemarker.template.utility.ClassUtil" name="java.lang.String getShortClassName(java.lang.Class)" map="C"/>
  <method class="freemarker.template.utility.ClassUtil" name="java.lang.String getShortClassNameOfObject(java.lang.Object, boolean)" map="A"/>
  <method class="freemarker.template.utility.ClassUtil" name="java.util.Properties loadProperties(java.lang.Class, java.lang.String)" map="A"/>
  <class name="freemarker.template.utility.WriteProtectable" map="H"/>
  <method class="freemarker.template.utility.WriteProtectable" name="void writeProtect()" map="A"/>
  <class name="freemarker.template.utility.NullWriter" map="I"/>
  <field class="freemarker.template.utility.NullWriter" name="INSTANCE" map="A"/>
  <method class="freemarker.template.utility.NullWriter" name="java.io.Writer append(java.lang.CharSequence)" map="append"/>
  <method class="freemarker.template.utility.NullWriter" name="void close()" map="close"/>
  <method class="freemarker.template.utility.NullWriter" name="void write(int)" map="write"/>
  <method class="freemarker.template.utility.NullWriter" name="void write(char[], int, int)" map="write"/>
  <method class="freemarker.template.utility.NullWriter" name="java.lang.Appendable append(java.lang.CharSequence, int, int)" map="append"/>
  <method class="freemarker.template.utility.NullWriter" name="java.lang.Appendable append(java.lang.CharSequence)" map="append"/>
  <method class="freemarker.template.utility.NullWriter" name="java.io.Writer append(char)" map="append"/>
  <method class="freemarker.template.utility.NullWriter" name="void write(char[])" map="write"/>
  <method class="freemarker.template.utility.NullWriter" name="java.io.Writer append(java.lang.CharSequence, int, int)" map="append"/>
  <method class="freemarker.template.utility.NullWriter" name="void write(java.lang.String, int, int)" map="write"/>
  <method class="freemarker.template.utility.NullWriter" name="void write(java.lang.String)" map="write"/>
  <method class="freemarker.template.utility.NullWriter" name="java.lang.Appendable append(char)" map="append"/>
  <method class="freemarker.template.utility.NullWriter" name="void flush()" map="flush"/>
  <class name="freemarker.template.utility.OptimizerUtil" map="J"/>
  <field class="freemarker.template.utility.OptimizerUtil" name="LONG_MAX" map="A"/>
  <field class="freemarker.template.utility.OptimizerUtil" name="INTEGER_MIN" map="B"/>
  <field class="freemarker.template.utility.OptimizerUtil" name="LONG_MIN" map="C"/>
  <field class="freemarker.template.utility.OptimizerUtil" name="INTEGER_MAX" map="D"/>
  <method class="freemarker.template.utility.OptimizerUtil" name="java.lang.Number optimizeNumberRepresentation(java.lang.Number)" map="A"/>
  <class name="freemarker.template.utility.RichObjectWrapper" map="K"/>
  <class name="freemarker.template.utility.CollectionUtils" map="L"/>
  <field class="freemarker.template.utility.CollectionUtils" name="EMPTY_OBJECT_ARRAY" map="A"/>
  <field class="freemarker.template.utility.CollectionUtils" name="EMPTY_CHAR_ARRAY" map="B"/>
  <field class="freemarker.template.utility.CollectionUtils" name="EMPTY_CLASS_ARRAY" map="C"/>
  <class name="freemarker.template.utility.UndeclaredThrowableException" map="M"/>
  <class name="freemarker.template.utility.CaptureOutput$1" map="1"/>
  <field class="freemarker.template.utility.CaptureOutput$1" name="this$0" map="A"/>
  <field class="freemarker.template.utility.CaptureOutput$1" name="val$out" map="B"/>
  <field class="freemarker.template.utility.CaptureOutput$1" name="val$buf" map="C"/>
  <field class="freemarker.template.utility.CaptureOutput$1" name="val$env" map="D"/>
  <field class="freemarker.template.utility.CaptureOutput$1" name="val$localVar" map="E"/>
  <field class="freemarker.template.utility.CaptureOutput$1" name="val$nsModel" map="F"/>
  <field class="freemarker.template.utility.CaptureOutput$1" name="val$varName" map="G"/>
  <field class="freemarker.template.utility.CaptureOutput$1" name="val$globalVar" map="H"/>
  <method class="freemarker.template.utility.CaptureOutput$1" name="void write(char[], int, int)" map="write"/>
  <method class="freemarker.template.utility.CaptureOutput$1" name="void flush()" map="flush"/>
  <method class="freemarker.template.utility.CaptureOutput$1" name="void close()" map="close"/>
  <class name="freemarker.template.utility.CaptureOutput" map="N"/>
  <method class="freemarker.template.utility.CaptureOutput" name="java.io.Writer getWriter(java.io.Writer, java.util.Map)" map="A"/>
  <class name="freemarker.template.utility.StringUtil" map="O"/>
  <field class="freemarker.template.utility.StringUtil" name="AMP" map="A"/>
  <field class="freemarker.template.utility.StringUtil" name="LT" map="B"/>
  <field class="freemarker.template.utility.StringUtil" name="GT" map="C"/>
  <field class="freemarker.template.utility.StringUtil" name="HTML_APOS" map="D"/>
  <field class="freemarker.template.utility.StringUtil" name="QUOT" map="E"/>
  <field class="freemarker.template.utility.StringUtil" name="XML_APOS" map="F"/>
  <field class="freemarker.template.utility.StringUtil" name="ESCAPES" map="G"/>
  <method class="freemarker.template.utility.StringUtil" name="int versionStringToInt(java.lang.String)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="char toHexDigit(int)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String jQuoteNoXSS(java.lang.Object)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String RTFEnc(java.lang.String)" map="B"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String tryToString(java.lang.Object)" map="B"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String[] split(java.lang.String, char)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String XHTMLEnc(java.lang.String)" map="C"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String ftlQuote(java.lang.String)" map="D"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String jsonStringEnc(java.lang.String)" map="E"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String chomp(java.lang.String)" map="F"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String leftPad(java.lang.String, int, java.lang.String)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String XMLEnc(java.lang.String)" map="G"/>
  <method class="freemarker.template.utility.StringUtil" name="boolean isTrimmableToEmpty(char[])" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String failedToStringSubstitute(java.lang.Object, java.lang.Throwable)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String javaStringEnc(java.lang.String)" map="H"/>
  <method class="freemarker.template.utility.StringUtil" name="void XMLOrHTMLEnc(java.lang.String, char[], java.io.Writer)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="void XHTMLEnc(java.lang.String, java.io.Writer)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String XMLEncNQG(java.lang.String)" map="I"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String XMLEncNA(java.lang.String)" map="J"/>
  <method class="freemarker.template.utility.StringUtil" name="boolean isFTLIdentifierStart(char)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String toABC(int, char)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String jQuote(java.lang.String)" map="K"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String[] split(java.lang.String, java.lang.String, boolean)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="int shortArrayCopy(char[], char[], int)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String rightPad(java.lang.String, int, char)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String URLEnc(java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String jQuote(java.lang.Object)" map="C"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String capitalize(java.lang.String)" map="L"/>
  <method class="freemarker.template.utility.StringUtil" name="boolean isTrimmableToEmpty(char[], int, int)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String FTLStringLiteralEnc(java.lang.String, char, boolean)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="void XMLEnc(java.lang.String, java.io.Writer)" map="B"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String FTLStringLiteralDec(java.lang.String)" map="M"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String rightPad(java.lang.String, int, java.lang.String)" map="B"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String javaScriptStringEnc(java.lang.String)" map="N"/>
  <method class="freemarker.template.utility.StringUtil" name="boolean maybeCDataEndGT(java.lang.String, int)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String XMLEncQAttr(java.lang.String)" map="O"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String URLEnc(java.lang.String, java.lang.String, boolean)" map="B"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String XMLOrHTMLEnc(java.lang.String, boolean, boolean, char[])" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="boolean getYesNo(java.lang.String)" map="P"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String replace(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="void RTFEnc(java.lang.String, java.io.Writer)" map="C"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String leftPad(java.lang.String, int)" map="B"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String leftPad(java.lang.String, int, char)" map="B"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String jsStringEnc(java.lang.String, boolean)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="boolean isTrimmableToEmpty(char[], int)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String toUpperABC(int)" map="B"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String toLowerABC(int)" map="C"/>
  <method class="freemarker.template.utility.StringUtil" name="char[] createEscapes()" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="boolean safeInURL(char, boolean)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String replace(java.lang.String, java.lang.String, java.lang.String, boolean, boolean)" map="A"/>
  <method class="freemarker.template.utility.StringUtil" name="boolean isInterpolationStart(char)" map="B"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String rightPad(java.lang.String, int)" map="C"/>
  <method class="freemarker.template.utility.StringUtil" name="java.util.Locale deduceLocale(java.lang.String)" map="Q"/>
  <method class="freemarker.template.utility.StringUtil" name="boolean isFTLIdentifierPart(char)" map="C"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String jQuoteNoXSS(java.lang.String)" map="R"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String HTMLEnc(java.lang.String)" map="S"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String URLPathEnc(java.lang.String, java.lang.String)" map="B"/>
  <method class="freemarker.template.utility.StringUtil" name="java.lang.String FTLStringLiteralEnc(java.lang.String, char)" map="B"/>
  <class name="freemarker.template.utility.DeepUnwrap" map="P"/>
  <field class="freemarker.template.utility.DeepUnwrap" name="OBJECT_CLASS" map="A"/>
  <method class="freemarker.template.utility.DeepUnwrap" name="java.lang.Object unwrap(freemarker.template.TemplateModel, freemarker.template.TemplateModel, boolean)" map="A"/>
  <method class="freemarker.template.utility.DeepUnwrap" name="java.lang.Object unwrap(freemarker.template.TemplateModel, boolean)" map="A"/>
  <method class="freemarker.template.utility.DeepUnwrap" name="java.lang.Object unwrap(freemarker.template.TemplateModel)" map="A"/>
  <class name="freemarker.template.utility.NormalizeNewlines$1" map="1"/>
  <field class="freemarker.template.utility.NormalizeNewlines$1" name="this$0" map="A"/>
  <field class="freemarker.template.utility.NormalizeNewlines$1" name="val$out" map="B"/>
  <field class="freemarker.template.utility.NormalizeNewlines$1" name="val$buf" map="C"/>
  <method class="freemarker.template.utility.NormalizeNewlines$1" name="void write(char[], int, int)" map="write"/>
  <method class="freemarker.template.utility.NormalizeNewlines$1" name="void flush()" map="flush"/>
  <method class="freemarker.template.utility.NormalizeNewlines$1" name="void close()" map="close"/>
  <class name="freemarker.template.utility.NormalizeNewlines" map="Q"/>
  <method class="freemarker.template.utility.NormalizeNewlines" name="void transform(java.io.Reader, java.io.Writer)" map="A"/>
  <method class="freemarker.template.utility.NormalizeNewlines" name="java.io.Writer getWriter(java.io.Writer, java.util.Map)" map="A"/>
  <class name="freemarker.template.utility.TemplateModelUtils$TemplateHashModelExKeyValuePairIterator$1" map="1"/>
  <field class="freemarker.template.utility.TemplateModelUtils$TemplateHashModelExKeyValuePairIterator$1" name="this$0" map="A"/>
  <field class="freemarker.template.utility.TemplateModelUtils$TemplateHashModelExKeyValuePairIterator$1" name="val$key" map="B"/>
  <method class="freemarker.template.utility.TemplateModelUtils$TemplateHashModelExKeyValuePairIterator$1" name="freemarker.template.TemplateModel getKey()" map="A"/>
  <method class="freemarker.template.utility.TemplateModelUtils$TemplateHashModelExKeyValuePairIterator$1" name="freemarker.template.TemplateModel getValue()" map="B"/>
  <class name="freemarker.template.utility.TemplateModelUtils$TemplateHashModelExKeyValuePairIterator" map="_A"/>
  <field class="freemarker.template.utility.TemplateModelUtils$TemplateHashModelExKeyValuePairIterator" name="keyIter" map="A"/>
  <field class="freemarker.template.utility.TemplateModelUtils$TemplateHashModelExKeyValuePairIterator" name="hash" map="B"/>
  <method class="freemarker.template.utility.TemplateModelUtils$TemplateHashModelExKeyValuePairIterator" name="boolean hasNext()" map="A"/>
  <method class="freemarker.template.utility.TemplateModelUtils$TemplateHashModelExKeyValuePairIterator" name="freemarker.template.TemplateHashModelEx access$100(freemarker.template.utility.TemplateModelUtils$TemplateHashModelExKeyValuePairIterator)" map="A"/>
  <method class="freemarker.template.utility.TemplateModelUtils$TemplateHashModelExKeyValuePairIterator" name="freemarker.template.TemplateHashModelEx2$KeyValuePair next()" map="B"/>
  <class name="freemarker.template.utility.TemplateModelUtils$1" map="1"/>
  <class name="freemarker.template.utility.TemplateModelUtils" map="R"/>
  <method class="freemarker.template.utility.TemplateModelUtils" name="freemarker.template.TemplateHashModelEx2$KeyValuePairIterator getKeyValuePairIterator(freemarker.template.TemplateHashModelEx)" map="A"/>
  <class name="freemarker.template.utility.NumberUtil" map="S"/>
  <field class="freemarker.template.utility.NumberUtil" name="BIG_INTEGER_INT_MAX" map="A"/>
  <field class="freemarker.template.utility.NumberUtil" name="BIG_DECIMAL_INT_MAX" map="B"/>
  <field class="freemarker.template.utility.NumberUtil" name="BIG_INTEGER_INT_MIN" map="C"/>
  <field class="freemarker.template.utility.NumberUtil" name="BIG_DECIMAL_INT_MIN" map="D"/>
  <method class="freemarker.template.utility.NumberUtil" name="int toIntExact(java.lang.Number)" map="A"/>
  <method class="freemarker.template.utility.NumberUtil" name="boolean isIntegerBigDecimal(java.math.BigDecimal)" map="A"/>
  <method class="freemarker.template.utility.NumberUtil" name="boolean hasTypeThatIsKnownToNotSupportInfiniteAndNaN(java.lang.Number)" map="B"/>
  <method class="freemarker.template.utility.NumberUtil" name="int getSignum(java.lang.Number)" map="C"/>
  <method class="freemarker.template.utility.NumberUtil" name="java.lang.ArithmeticException newLossyConverionException(java.lang.Number, java.lang.Class)" map="A"/>
  <method class="freemarker.template.utility.NumberUtil" name="boolean isInfinite(java.lang.Number)" map="D"/>
  <method class="freemarker.template.utility.NumberUtil" name="boolean isNaN(java.lang.Number)" map="E"/>
  <class name="freemarker.template.utility.ObjectWrapperWithAPISupport" map="T"/>
  <method class="freemarker.template.utility.ObjectWrapperWithAPISupport" name="freemarker.template.TemplateHashModel wrapAsAPI(java.lang.Object)" map="B"/>
  <class name="freemarker.template.utility.UnsupportedNumberClassException" map="U"/>
  <field class="freemarker.template.utility.UnsupportedNumberClassException" name="fClass" map="A"/>
  <class name="freemarker.template.utility.HtmlEscape$1" map="1"/>
  <field class="freemarker.template.utility.HtmlEscape$1" name="this$0" map="A"/>
  <field class="freemarker.template.utility.HtmlEscape$1" name="val$out" map="B"/>
  <method class="freemarker.template.utility.HtmlEscape$1" name="void write(char[], int, int)" map="write"/>
  <method class="freemarker.template.utility.HtmlEscape$1" name="void flush()" map="flush"/>
  <method class="freemarker.template.utility.HtmlEscape$1" name="void write(int)" map="write"/>
  <method class="freemarker.template.utility.HtmlEscape$1" name="void close()" map="close"/>
  <class name="freemarker.template.utility.HtmlEscape" map="V"/>
  <field class="freemarker.template.utility.HtmlEscape" name="AMP" map="&#x0276;"/>
  <field class="freemarker.template.utility.HtmlEscape" name="LT" map="&#x0277;"/>
  <field class="freemarker.template.utility.HtmlEscape" name="GT" map="&#x0278;"/>
  <field class="freemarker.template.utility.HtmlEscape" name="QUOT" map="&#x0279;"/>
  <method class="freemarker.template.utility.HtmlEscape" name="char[] access$100()" map="&#x00ff;"/>
  <method class="freemarker.template.utility.HtmlEscape" name="char[] access$200()" map="&#x0100;"/>
  <method class="freemarker.template.utility.HtmlEscape" name="char[] access$300()" map="&#x0101;"/>
  <method class="freemarker.template.utility.HtmlEscape" name="java.io.Writer getWriter(java.io.Writer, java.util.Map)" map="A"/>
  <method class="freemarker.template.utility.HtmlEscape" name="char[] access$000()" map="&#x0102;"/>
  <class name="freemarker.template.utility.NullArgumentException" map="W"/>
  <method class="freemarker.template.utility.NullArgumentException" name="void check(java.lang.Object)" map="A"/>
  <method class="freemarker.template.utility.NullArgumentException" name="void check(java.lang.String, java.lang.Object)" map="A"/>
  <class name="freemarker.template.utility.Execute" map="X"/>
  <method class="freemarker.template.utility.Execute" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.template.utility.XmlEscape$1" map="1"/>
  <field class="freemarker.template.utility.XmlEscape$1" name="this$0" map="A"/>
  <field class="freemarker.template.utility.XmlEscape$1" name="val$out" map="B"/>
  <method class="freemarker.template.utility.XmlEscape$1" name="void write(char[], int, int)" map="write"/>
  <method class="freemarker.template.utility.XmlEscape$1" name="void flush()" map="flush"/>
  <method class="freemarker.template.utility.XmlEscape$1" name="void write(int)" map="write"/>
  <method class="freemarker.template.utility.XmlEscape$1" name="void close()" map="close"/>
  <class name="freemarker.template.utility.XmlEscape" map="Y"/>
  <field class="freemarker.template.utility.XmlEscape" name="AMP" map="&#x027a;"/>
  <field class="freemarker.template.utility.XmlEscape" name="LT" map="&#x027b;"/>
  <field class="freemarker.template.utility.XmlEscape" name="GT" map="&#x027c;"/>
  <field class="freemarker.template.utility.XmlEscape" name="QUOT" map="&#x027d;"/>
  <field class="freemarker.template.utility.XmlEscape" name="APOS" map="&#x027e;"/>
  <method class="freemarker.template.utility.XmlEscape" name="char[] access$400()" map="&#x0103;"/>
  <method class="freemarker.template.utility.XmlEscape" name="char[] access$100()" map="&#x0104;"/>
  <method class="freemarker.template.utility.XmlEscape" name="char[] access$200()" map="&#x0105;"/>
  <method class="freemarker.template.utility.XmlEscape" name="char[] access$300()" map="&#x0106;"/>
  <method class="freemarker.template.utility.XmlEscape" name="java.io.Writer getWriter(java.io.Writer, java.util.Map)" map="A"/>
  <method class="freemarker.template.utility.XmlEscape" name="char[] access$000()" map="&#x0107;"/>
  <class name="freemarker.template.DefaultObjectWrapper$2" map="2"/>
  <field class="freemarker.template.DefaultObjectWrapper$2" name="this$0" map="N"/>
  <class name="freemarker.template.DefaultObjectWrapper$1" map="1"/>
  <class name="freemarker.template.DefaultObjectWrapper" map="A"/>
  <field class="freemarker.template.DefaultObjectWrapper" name="useAdapterForEnumerations" map="_"/>
  <field class="freemarker.template.DefaultObjectWrapper" name="instance" map="a"/>
  <field class="freemarker.template.DefaultObjectWrapper" name="useAdaptersForContainers" map="b"/>
  <field class="freemarker.template.DefaultObjectWrapper" name="JYTHON_OBJ_CLASS" map="c"/>
  <field class="freemarker.template.DefaultObjectWrapper" name="iterableSupport" map="d"/>
  <field class="freemarker.template.DefaultObjectWrapper" name="forceLegacyNonListCollections" map="e"/>
  <field class="freemarker.template.DefaultObjectWrapper" name="JYTHON_WRAPPER" map="f"/>
  <method class="freemarker.template.DefaultObjectWrapper" name="java.lang.Object convertArray(java.lang.Object)" map="D"/>
  <method class="freemarker.template.DefaultObjectWrapper" name="boolean getForceLegacyNonListCollections()" map="R"/>
  <method class="freemarker.template.DefaultObjectWrapper" name="freemarker.template.Version normalizeIncompatibleImprovementsVersion(freemarker.template.Version)" map="C"/>
  <method class="freemarker.template.DefaultObjectWrapper" name="freemarker.template.TemplateModel wrap(java.lang.Object)" map="A"/>
  <method class="freemarker.template.DefaultObjectWrapper" name="boolean getUseAdaptersForContainers()" map="S"/>
  <method class="freemarker.template.DefaultObjectWrapper" name="java.lang.String toPropertiesString()" map="L"/>
  <method class="freemarker.template.DefaultObjectWrapper" name="freemarker.template.TemplateModel handleUnknownType(java.lang.Object)" map="E"/>
  <method class="freemarker.template.DefaultObjectWrapper" name="freemarker.template.TemplateModel wrapDomNode(java.lang.Object)" map="F"/>
  <class name="freemarker.template.TemplateDateModel" map="B"/>
  <field class="freemarker.template.TemplateDateModel" name="TYPE_NAMES" map="&#x01c3;"/>
  <method class="freemarker.template.TemplateDateModel" name="java.util.Date getAsDate()" map="&#x00da;"/>
  <method class="freemarker.template.TemplateDateModel" name="int getDateType()" map="&#x00db;"/>
  <class name="freemarker.template.TemplateCollectionModel" map="C"/>
  <method class="freemarker.template.TemplateCollectionModel" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <class name="freemarker.template.TemplateDirectiveBody" map="D"/>
  <class name="freemarker.template.ObjectWrapper" map="E"/>
  <field class="freemarker.template.ObjectWrapper" name="DEFAULT_WRAPPER" map="A"/>
  <field class="freemarker.template.ObjectWrapper" name="BEANS_WRAPPER" map="B"/>
  <field class="freemarker.template.ObjectWrapper" name="SIMPLE_WRAPPER" map="C"/>
  <method class="freemarker.template.ObjectWrapper" name="freemarker.template.TemplateModel wrap(java.lang.Object)" map="A"/>
  <class name="freemarker.template.DefaultNonListCollectionAdapter" map="F"/>
  <field class="freemarker.template.DefaultNonListCollectionAdapter" name="collection" map="&#x018e;"/>
  <method class="freemarker.template.DefaultNonListCollectionAdapter" name="java.lang.Object getAdaptedObject(java.lang.Class)" map="A"/>
  <method class="freemarker.template.DefaultNonListCollectionAdapter" name="freemarker.template.DefaultNonListCollectionAdapter adapt(java.util.Collection, freemarker.template.utility.ObjectWrapperWithAPISupport)" map="A"/>
  <method class="freemarker.template.DefaultNonListCollectionAdapter" name="int size()" map="&#x00cc;"/>
  <method class="freemarker.template.DefaultNonListCollectionAdapter" name="freemarker.template.TemplateModel getAPI()" map="&#x00ce;"/>
  <method class="freemarker.template.DefaultNonListCollectionAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <method class="freemarker.template.DefaultNonListCollectionAdapter" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <class name="freemarker.template.TemplateExceptionHandler$4" map="4"/>
  <method class="freemarker.template.TemplateExceptionHandler$4" name="void handleTemplateException(freemarker.template.TemplateException, freemarker.core.Environment, java.io.Writer)" map="A"/>
  <class name="freemarker.template.TemplateExceptionHandler$3" map="3"/>
  <method class="freemarker.template.TemplateExceptionHandler$3" name="void handleTemplateException(freemarker.template.TemplateException, freemarker.core.Environment, java.io.Writer)" map="A"/>
  <class name="freemarker.template.TemplateExceptionHandler$2" map="2"/>
  <method class="freemarker.template.TemplateExceptionHandler$2" name="void handleTemplateException(freemarker.template.TemplateException, freemarker.core.Environment, java.io.Writer)" map="A"/>
  <class name="freemarker.template.TemplateExceptionHandler$1" map="1"/>
  <method class="freemarker.template.TemplateExceptionHandler$1" name="void handleTemplateException(freemarker.template.TemplateException, freemarker.core.Environment, java.io.Writer)" map="A"/>
  <class name="freemarker.template.TemplateExceptionHandler" map="G"/>
  <field class="freemarker.template.TemplateExceptionHandler" name="DEBUG_HANDLER" map="A"/>
  <field class="freemarker.template.TemplateExceptionHandler" name="RETHROW_HANDLER" map="B"/>
  <field class="freemarker.template.TemplateExceptionHandler" name="HTML_DEBUG_HANDLER" map="C"/>
  <field class="freemarker.template.TemplateExceptionHandler" name="IGNORE_HANDLER" map="D"/>
  <method class="freemarker.template.TemplateExceptionHandler" name="void handleTemplateException(freemarker.template.TemplateException, freemarker.core.Environment, java.io.Writer)" map="A"/>
  <class name="freemarker.template.SimpleNumber" map="H"/>
  <field class="freemarker.template.SimpleNumber" name="value" map="&#x01bd;"/>
  <method class="freemarker.template.SimpleNumber" name="java.lang.Number getAsNumber()" map="&#x00d8;"/>
  <method class="freemarker.template.SimpleNumber" name="java.lang.String toString()" map="toString"/>
  <class name="freemarker.template.TemplateNumberModel" map="I"/>
  <method class="freemarker.template.TemplateNumberModel" name="java.lang.Number getAsNumber()" map="&#x00d8;"/>
  <class name="freemarker.template.DefaultIterableAdapter" map="J"/>
  <field class="freemarker.template.DefaultIterableAdapter" name="iterable" map="&#x01cd;"/>
  <method class="freemarker.template.DefaultIterableAdapter" name="java.lang.Object getAdaptedObject(java.lang.Class)" map="A"/>
  <method class="freemarker.template.DefaultIterableAdapter" name="freemarker.template.DefaultIterableAdapter adapt(java.lang.Iterable, freemarker.template.utility.ObjectWrapperWithAPISupport)" map="A"/>
  <method class="freemarker.template.DefaultIterableAdapter" name="freemarker.template.TemplateModel getAPI()" map="&#x00ce;"/>
  <method class="freemarker.template.DefaultIterableAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <method class="freemarker.template.DefaultIterableAdapter" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <class name="freemarker.template.DefaultIteratorAdapter$SimpleTemplateModelIterator" map="_A"/>
  <field class="freemarker.template.DefaultIteratorAdapter$SimpleTemplateModelIterator" name="this$0" map="&#x01ad;"/>
  <field class="freemarker.template.DefaultIteratorAdapter$SimpleTemplateModelIterator" name="iteratorOwnedByMe" map="&#x01ae;"/>
  <method class="freemarker.template.DefaultIteratorAdapter$SimpleTemplateModelIterator" name="boolean hasNext()" map="&#x00d1;"/>
  <method class="freemarker.template.DefaultIteratorAdapter$SimpleTemplateModelIterator" name="void checkNotOwner()" map="&#x00d3;"/>
  <method class="freemarker.template.DefaultIteratorAdapter$SimpleTemplateModelIterator" name="freemarker.template.TemplateModel next()" map="&#x00d2;"/>
  <class name="freemarker.template.DefaultIteratorAdapter$1" map="1"/>
  <class name="freemarker.template.DefaultIteratorAdapter" map="K"/>
  <field class="freemarker.template.DefaultIteratorAdapter" name="iteratorOwnedBySomeone" map="&#x018f;"/>
  <field class="freemarker.template.DefaultIteratorAdapter" name="iterator" map="&#x0190;"/>
  <method class="freemarker.template.DefaultIteratorAdapter" name="java.lang.Object getAdaptedObject(java.lang.Class)" map="A"/>
  <method class="freemarker.template.DefaultIteratorAdapter" name="java.util.Iterator access$200(freemarker.template.DefaultIteratorAdapter)" map="A"/>
  <method class="freemarker.template.DefaultIteratorAdapter" name="boolean access$102(freemarker.template.DefaultIteratorAdapter, boolean)" map="A"/>
  <method class="freemarker.template.DefaultIteratorAdapter" name="freemarker.template.TemplateModel getAPI()" map="&#x00ce;"/>
  <method class="freemarker.template.DefaultIteratorAdapter" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <method class="freemarker.template.DefaultIteratorAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <method class="freemarker.template.DefaultIteratorAdapter" name="freemarker.template.DefaultIteratorAdapter adapt(java.util.Iterator, freemarker.template.ObjectWrapper)" map="A"/>
  <method class="freemarker.template.DefaultIteratorAdapter" name="boolean access$100(freemarker.template.DefaultIteratorAdapter)" map="B"/>
  <class name="freemarker.template.SimpleObjectWrapper" map="L"/>
  <field class="freemarker.template.SimpleObjectWrapper" name="instance" map="a"/>
  <method class="freemarker.template.SimpleObjectWrapper" name="freemarker.template.TemplateHashModel wrapAsAPI(java.lang.Object)" map="B"/>
  <method class="freemarker.template.SimpleObjectWrapper" name="freemarker.template.TemplateModel handleUnknownType(java.lang.Object)" map="E"/>
  <class name="freemarker.template.TemplateModelIterator" map="M"/>
  <method class="freemarker.template.TemplateModelIterator" name="boolean hasNext()" map="&#x00d1;"/>
  <method class="freemarker.template.TemplateModelIterator" name="freemarker.template.TemplateModel next()" map="&#x00d2;"/>
  <class name="freemarker.template.TemplateHashModel" map="N"/>
  <method class="freemarker.template.TemplateHashModel" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.template.TemplateHashModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <class name="freemarker.template.MalformedTemplateNameException" map="O"/>
  <field class="freemarker.template.MalformedTemplateNameException" name="templateName" map="A"/>
  <field class="freemarker.template.MalformedTemplateNameException" name="malformednessDescription" map="B"/>
  <method class="freemarker.template.MalformedTemplateNameException" name="java.lang.String getMalformednessDescription()" map="A"/>
  <method class="freemarker.template.MalformedTemplateNameException" name="java.lang.String getTemplateName()" map="B"/>
  <class name="freemarker.template.TemplateScalarModel" map="P"/>
  <field class="freemarker.template.TemplateScalarModel" name="EMPTY_STRING" map="&#x0130;"/>
  <method class="freemarker.template.TemplateScalarModel" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <class name="freemarker.template.TemplateCollectionModelEx" map="Q"/>
  <method class="freemarker.template.TemplateCollectionModelEx" name="int size()" map="&#x00cc;"/>
  <class name="freemarker.template.TemplateModelAdapter" map="R"/>
  <method class="freemarker.template.TemplateModelAdapter" name="freemarker.template.TemplateModel getTemplateModel()" map="getTemplateModel"/>
  <class name="freemarker.template.TemplateNodeModel" map="S"/>
  <method class="freemarker.template.TemplateNodeModel" name="java.lang.String getNodeType()" map="&#x00dd;"/>
  <method class="freemarker.template.TemplateNodeModel" name="java.lang.String getNodeName()" map="&#x00de;"/>
  <method class="freemarker.template.TemplateNodeModel" name="freemarker.template.TemplateSequenceModel getChildNodes()" map="&#x00df;"/>
  <method class="freemarker.template.TemplateNodeModel" name="java.lang.String getNodeNamespace()" map="&#x00e0;"/>
  <method class="freemarker.template.TemplateNodeModel" name="freemarker.template.TemplateNodeModel getParentNode()" map="&#x00e1;"/>
  <class name="freemarker.template.TemplateBooleanModel" map="T"/>
  <field class="freemarker.template.TemplateBooleanModel" name="TRUE" map="&#x0172;"/>
  <field class="freemarker.template.TemplateBooleanModel" name="FALSE" map="&#x0173;"/>
  <method class="freemarker.template.TemplateBooleanModel" name="boolean getAsBoolean()" map="&#x00c3;"/>
  <class name="freemarker.template.LoggingAttemptExceptionReporter" map="U"/>
  <field class="freemarker.template.LoggingAttemptExceptionReporter" name="LOG" map="C"/>
  <field class="freemarker.template.LoggingAttemptExceptionReporter" name="logAsWarn" map="D"/>
  <method class="freemarker.template.LoggingAttemptExceptionReporter" name="void report(freemarker.template.TemplateException, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.template.SimpleCollection$SimpleTemplateModelIterator" map="_A"/>
  <field class="freemarker.template.SimpleCollection$SimpleTemplateModelIterator" name="this$0" map="&#x01af;"/>
  <field class="freemarker.template.SimpleCollection$SimpleTemplateModelIterator" name="iteratorOwnedByMe" map="&#x01b0;"/>
  <field class="freemarker.template.SimpleCollection$SimpleTemplateModelIterator" name="iterator" map="&#x01b1;"/>
  <method class="freemarker.template.SimpleCollection$SimpleTemplateModelIterator" name="void checkIteratorOwned()" map="&#x00d4;"/>
  <method class="freemarker.template.SimpleCollection$SimpleTemplateModelIterator" name="boolean hasNext()" map="&#x00d1;"/>
  <method class="freemarker.template.SimpleCollection$SimpleTemplateModelIterator" name="freemarker.template.TemplateModel next()" map="&#x00d2;"/>
  <class name="freemarker.template.SimpleCollection" map="V"/>
  <field class="freemarker.template.SimpleCollection" name="iterator" map="&#x0269;"/>
  <field class="freemarker.template.SimpleCollection" name="iterable" map="&#x026a;"/>
  <field class="freemarker.template.SimpleCollection" name="iteratorOwned" map="&#x026b;"/>
  <method class="freemarker.template.SimpleCollection" name="boolean access$000(freemarker.template.SimpleCollection)" map="A"/>
  <method class="freemarker.template.SimpleCollection" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <method class="freemarker.template.SimpleCollection" name="boolean access$002(freemarker.template.SimpleCollection, boolean)" map="A"/>
  <class name="freemarker.template.DefaultMapAdapter" map="W"/>
  <field class="freemarker.template.DefaultMapAdapter" name="map" map="&#x0191;"/>
  <method class="freemarker.template.DefaultMapAdapter" name="java.lang.Object getAdaptedObject(java.lang.Class)" map="A"/>
  <method class="freemarker.template.DefaultMapAdapter" name="freemarker.template.DefaultMapAdapter adapt(java.util.Map, freemarker.template.utility.ObjectWrapperWithAPISupport)" map="A"/>
  <method class="freemarker.template.DefaultMapAdapter" name="freemarker.template.TemplateCollectionModel values()" map="&#x00c9;"/>
  <method class="freemarker.template.DefaultMapAdapter" name="freemarker.template.TemplateCollectionModel keys()" map="&#x00c8;"/>
  <method class="freemarker.template.DefaultMapAdapter" name="freemarker.template.TemplateModel getAPI()" map="&#x00ce;"/>
  <method class="freemarker.template.DefaultMapAdapter" name="freemarker.template.TemplateHashModelEx2$KeyValuePairIterator keyValuePairIterator()" map="&#x00cb;"/>
  <method class="freemarker.template.DefaultMapAdapter" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.DefaultMapAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <method class="freemarker.template.DefaultMapAdapter" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.template.DefaultMapAdapter" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <class name="freemarker.template.TransformControl" map="X"/>
  <method class="freemarker.template.TransformControl" name="int onStart()" map="A"/>
  <method class="freemarker.template.TransformControl" name="int afterBody()" map="B"/>
  <method class="freemarker.template.TransformControl" name="void onError(java.lang.Throwable)" map="A"/>
  <class name="freemarker.template.MapKeyValuePairIterator$1" map="1"/>
  <field class="freemarker.template.MapKeyValuePairIterator$1" name="this$0" map="C"/>
  <field class="freemarker.template.MapKeyValuePairIterator$1" name="val$entry" map="D"/>
  <method class="freemarker.template.MapKeyValuePairIterator$1" name="freemarker.template.TemplateModel getKey()" map="A"/>
  <method class="freemarker.template.MapKeyValuePairIterator$1" name="freemarker.template.TemplateModel getValue()" map="B"/>
  <class name="freemarker.template.MapKeyValuePairIterator" map="Y"/>
  <field class="freemarker.template.MapKeyValuePairIterator" name="entrySetIterator" map="C"/>
  <field class="freemarker.template.MapKeyValuePairIterator" name="objectWrapper" map="D"/>
  <method class="freemarker.template.MapKeyValuePairIterator" name="boolean hasNext()" map="A"/>
  <method class="freemarker.template.MapKeyValuePairIterator" name="freemarker.template.TemplateHashModelEx2$KeyValuePair next()" map="B"/>
  <method class="freemarker.template.MapKeyValuePairIterator" name="freemarker.template.TemplateModel wrap(java.lang.Object)" map="A"/>
  <method class="freemarker.template.MapKeyValuePairIterator" name="freemarker.template.TemplateModel access$000(freemarker.template.MapKeyValuePairIterator, java.lang.Object)" map="A"/>
  <class name="freemarker.template.TemplateTransformModel" map="Z"/>
  <method class="freemarker.template.TemplateTransformModel" name="java.io.Writer getWriter(java.io.Writer, java.util.Map)" map="A"/>
  <class name="freemarker.template.Configuration$DefaultSoftCacheStorage" map="_A"/>
  <class name="freemarker.template.Configuration$1" map="1"/>
  <class name="freemarker.template.Configuration$LegacyDefaultFileTemplateLoader" map="_B"/>
  <class name="freemarker.template.Configuration" map="_"/>
  <field class="freemarker.template.Configuration" name="registeredCustomOutputFormats" map="&#x00d3;"/>
  <field class="freemarker.template.Configuration" name="SETTING_NAMES_SNAKE_CASE" map="&#x00d4;"/>
  <field class="freemarker.template.Configuration" name="autoEscapingPolicy" map="&#x00d5;"/>
  <field class="freemarker.template.Configuration" name="DEFAULT_INCOMPATIBLE_IMPROVEMENTS" map="&#x00d6;"/>
  <field class="freemarker.template.Configuration" name="timeZoneExplicitlySet" map="&#x00d8;"/>
  <field class="freemarker.template.Configuration" name="outputFormat" map="&#x00d9;"/>
  <field class="freemarker.template.Configuration" name="whitespaceStripping" map="&#x00da;"/>
  <field class="freemarker.template.Configuration" name="sharedVariables" map="&#x00db;"/>
  <field class="freemarker.template.Configuration" name="localeExplicitlySet" map="&#x00dc;"/>
  <field class="freemarker.template.Configuration" name="incompatibleImprovements" map="&#x00dd;"/>
  <field class="freemarker.template.Configuration" name="localeToCharsetMap" map="&#x00de;"/>
  <field class="freemarker.template.Configuration" name="cache" map="&#x00df;"/>
  <field class="freemarker.template.Configuration" name="rewrappableSharedVariables" map="&#x00e0;"/>
  <field class="freemarker.template.Configuration" name="interpolationSyntax" map="&#x00e1;"/>
  <field class="freemarker.template.Configuration" name="objectWrapperExplicitlySet" map="&#x00e2;"/>
  <field class="freemarker.template.Configuration" name="DEFAULT_INCOMPATIBLE_ENHANCEMENTS" map="&#x00e3;"/>
  <field class="freemarker.template.Configuration" name="wrapUncheckedExceptionsExplicitlySet" map="&#x00e4;"/>
  <field class="freemarker.template.Configuration" name="templateExceptionHandlerExplicitlySet" map="&#x00e5;"/>
  <field class="freemarker.template.Configuration" name="VERSION" map="&#x00e6;"/>
  <field class="freemarker.template.Configuration" name="localizedLookup" map="&#x00e7;"/>
  <field class="freemarker.template.Configuration" name="VERSION_2_3_28" map="&#x00e8;"/>
  <field class="freemarker.template.Configuration" name="VERSION_2_3_27" map="&#x00e9;"/>
  <field class="freemarker.template.Configuration" name="VERSION_2_3_26" map="&#x00ea;"/>
  <field class="freemarker.template.Configuration" name="VERSION_2_3_25" map="&#x00eb;"/>
  <field class="freemarker.template.Configuration" name="attemptExceptionReporterExplicitlySet" map="&#x00ec;"/>
  <field class="freemarker.template.Configuration" name="VERSION_2_3_24" map="&#x00ed;"/>
  <field class="freemarker.template.Configuration" name="VERSION_2_3_23" map="&#x00ee;"/>
  <field class="freemarker.template.Configuration" name="STANDARD_OUTPUT_FORMATS" map="&#x00ef;"/>
  <field class="freemarker.template.Configuration" name="VERSION_2_3_22" map="&#x00f0;"/>
  <field class="freemarker.template.Configuration" name="VERSION_2_3_21" map="&#x00f1;"/>
  <field class="freemarker.template.Configuration" name="tabSize" map="&#x00f2;"/>
  <field class="freemarker.template.Configuration" name="VERSION_2_3_20" map="&#x00f3;"/>
  <field class="freemarker.template.Configuration" name="PARSED_DEFAULT_INCOMPATIBLE_ENHANCEMENTS" map="&#x00f4;"/>
  <field class="freemarker.template.Configuration" name="strictSyntax" map="&#x00f5;"/>
  <field class="freemarker.template.Configuration" name="namingConvention" map="&#x00f6;"/>
  <field class="freemarker.template.Configuration" name="recognizeStandardFileExtensions" map="&#x00f8;"/>
  <field class="freemarker.template.Configuration" name="templateLoaderExplicitlySet" map="&#x00f9;"/>
  <field class="freemarker.template.Configuration" name="SETTING_NAMES_CAMEL_CASE" map="&#x00fa;"/>
  <field class="freemarker.template.Configuration" name="CACHE_LOG" map="&#x00fb;"/>
  <field class="freemarker.template.Configuration" name="tagSyntax" map="&#x00fc;"/>
  <field class="freemarker.template.Configuration" name="VERSION_2_3_19" map="&#x00fd;"/>
  <field class="freemarker.template.Configuration" name="defaultEncoding" map="&#x00fe;"/>
  <field class="freemarker.template.Configuration" name="FM_24_DETECTED" map="&#x00ff;"/>
  <field class="freemarker.template.Configuration" name="defaultConfigLock" map="&#x0100;"/>
  <field class="freemarker.template.Configuration" name="logTemplateExceptionsExplicitlySet" map="&#x0101;"/>
  <field class="freemarker.template.Configuration" name="VERSION_2_3_0" map="&#x0102;"/>
  <field class="freemarker.template.Configuration" name="preventStrippings" map="&#x0103;"/>
  <field class="freemarker.template.Configuration" name="defaultConfig" map="&#x0104;"/>
  <method class="freemarker.template.Configuration" name="freemarker.cache.TemplateLookupStrategy getDefaultTemplateLookupStrategy()" map="&#x00d5;"/>
  <method class="freemarker.template.Configuration" name="int getInterpolationSyntax()" map="C"/>
  <method class="freemarker.template.Configuration" name="java.util.Locale getDefaultLocale()" map="&#x00d6;"/>
  <method class="freemarker.template.Configuration" name="java.util.Set getSharedVariableNames()" map="&#x00d8;"/>
  <method class="freemarker.template.Configuration" name="boolean getPreventStrippings()" map="&#x00d9;"/>
  <method class="freemarker.template.Configuration" name="freemarker.template.Template getTemplate(java.lang.String)" map="Y"/>
  <method class="freemarker.template.Configuration" name="freemarker.cache.TemplateLookupStrategy getDefaultTemplateLookupStrategy(freemarker.template.Version)" map="A"/>
  <method class="freemarker.template.Configuration" name="java.lang.String getEncoding(java.util.Locale)" map="B"/>
  <method class="freemarker.template.Configuration" name="freemarker.template.ObjectWrapper getDefaultObjectWrapper()" map="&#x00da;"/>
  <method class="freemarker.template.Configuration" name="boolean isKnownNonConfusingLookupStrategy(freemarker.cache.TemplateLookupStrategy)" map="A"/>
  <method class="freemarker.template.Configuration" name="int getTabSize()" map="K"/>
  <method class="freemarker.template.Configuration" name="void loadBuiltInSharedVariables()" map="&#x00db;"/>
  <method class="freemarker.template.Configuration" name="boolean getRecognizeStandardFileExtensions()" map="I"/>
  <method class="freemarker.template.Configuration" name="void doAutoImports(freemarker.core.Environment, freemarker.template.Template)" map="A"/>
  <method class="freemarker.template.Configuration" name="void setLocale(java.util.Locale)" map="A"/>
  <method class="freemarker.template.Configuration" name="boolean getDefaultWrapUncheckedExceptions(freemarker.template.Version)" map="B"/>
  <method class="freemarker.template.Configuration" name="void recreateTemplateCacheWith(freemarker.cache.TemplateLoader, freemarker.cache.CacheStorage, freemarker.cache.TemplateLookupStrategy, freemarker.cache.TemplateNameFormat, freemarker.cache.TemplateConfigurationFactory)" map="A"/>
  <method class="freemarker.template.Configuration" name="freemarker.cache.TemplateNameFormat getTemplateNameFormat()" map="&#x00dc;"/>
  <method class="freemarker.template.Configuration" name="void setClassForTemplateLoading(java.lang.Class, java.lang.String)" map="A"/>
  <method class="freemarker.template.Configuration" name="int getAutoEscapingPolicy()" map="J"/>
  <method class="freemarker.template.Configuration" name="freemarker.template.ObjectWrapper getDefaultObjectWrapper(freemarker.template.Version)" map="C"/>
  <method class="freemarker.template.Configuration" name="void setTimeZone(java.util.TimeZone)" map="A"/>
  <method class="freemarker.template.Configuration" name="void doAutoImportsAndIncludes(freemarker.core.Environment)" map="A"/>
  <method class="freemarker.template.Configuration" name="freemarker.template.Version getIncompatibleImprovements()" map="D"/>
  <method class="freemarker.template.Configuration" name="boolean getDefaultLogTemplateExceptions(freemarker.template.Version)" map="D"/>
  <method class="freemarker.template.Configuration" name="void unsetObjectWrapper()" map="&#x00dd;"/>
  <method class="freemarker.template.Configuration" name="java.lang.String getDefaultDefaultEncoding()" map="&#x00de;"/>
  <method class="freemarker.template.Configuration" name="java.lang.Object clone()" map="clone"/>
  <method class="freemarker.template.Configuration" name="java.util.TimeZone getDefaultTimeZone()" map="&#x00df;"/>
  <method class="freemarker.template.Configuration" name="void setLogTemplateExceptions(boolean)" map="C"/>
  <method class="freemarker.template.Configuration" name="freemarker.cache.TemplateLoader createDefaultTemplateLoader(freemarker.template.Version, freemarker.cache.TemplateLoader)" map="A"/>
  <method class="freemarker.template.Configuration" name="freemarker.cache.CacheStorage getDefaultCacheStorage()" map="&#x00e0;"/>
  <method class="freemarker.template.Configuration" name="void doAutoIncludes(freemarker.core.Environment, freemarker.template.Template)" map="B"/>
  <method class="freemarker.template.Configuration" name="void createTemplateCache()" map="&#x00e1;"/>
  <method class="freemarker.template.Configuration" name="freemarker.template.TemplateExceptionHandler getDefaultTemplateExceptionHandler()" map="&#x00e2;"/>
  <method class="freemarker.template.Configuration" name="boolean getWhitespaceStripping()" map="G"/>
  <method class="freemarker.template.Configuration" name="void setObjectWrapper(freemarker.template.ObjectWrapper)" map="A"/>
  <method class="freemarker.template.Configuration" name="freemarker.template.Template getTemplate(java.lang.String, java.util.Locale, java.lang.Object, java.lang.String, boolean, boolean)" map="A"/>
  <method class="freemarker.template.Configuration" name="freemarker.cache.TemplateLookupStrategy getTemplateLookupStrategy()" map="&#x00e3;"/>
  <method class="freemarker.template.Configuration" name="void setWrapUncheckedExceptions(boolean)" map="E"/>
  <method class="freemarker.template.Configuration" name="int getNamingConvention()" map="F"/>
  <method class="freemarker.template.Configuration" name="java.lang.String removeInitialSlash(java.lang.String)" map="Z"/>
  <method class="freemarker.template.Configuration" name="void unsetAttemptExceptionReporter()" map="&#x00e4;"/>
  <method class="freemarker.template.Configuration" name="freemarker.cache.TemplateLoader getTemplateLoader()" map="&#x00e5;"/>
  <method class="freemarker.template.Configuration" name="java.lang.String getRequiredVersionProperty(java.util.Properties, java.lang.String)" map="A"/>
  <method class="freemarker.template.Configuration" name="void setDirectoryForTemplateLoading(java.io.File)" map="A"/>
  <method class="freemarker.template.Configuration" name="java.lang.String ensureSentenceIsClosed(java.lang.String)" map="_"/>
  <method class="freemarker.template.Configuration" name="freemarker.template.AttemptExceptionReporter getDefaultAttemptExceptionReporter(freemarker.template.Version)" map="E"/>
  <method class="freemarker.template.Configuration" name="void setSharedVariablesFromRewrappableSharedVariables()" map="&#x00e6;"/>
  <method class="freemarker.template.Configuration" name="freemarker.template.TemplateExceptionHandler getDefaultTemplateExceptionHandler(freemarker.template.Version)" map="F"/>
  <method class="freemarker.template.Configuration" name="void setTemplateLoader(freemarker.cache.TemplateLoader)" map="A"/>
  <method class="freemarker.template.Configuration" name="freemarker.core.OutputFormat getOutputFormat()" map="B"/>
  <method class="freemarker.template.Configuration" name="void setAttemptExceptionReporter(freemarker.template.AttemptExceptionReporter)" map="A"/>
  <method class="freemarker.template.Configuration" name="java.lang.String getCorrectedNameForUnknownSetting(java.lang.String)" map="J"/>
  <method class="freemarker.template.Configuration" name="freemarker.cache.CacheStorage createDefaultCacheStorage(freemarker.template.Version, freemarker.cache.CacheStorage)" map="A"/>
  <method class="freemarker.template.Configuration" name="boolean getStrictSyntaxMode()" map="H"/>
  <method class="freemarker.template.Configuration" name="freemarker.cache.TemplateNameFormat getDefaultTemplateNameFormat(freemarker.template.Version)" map="G"/>
  <method class="freemarker.template.Configuration" name="void setTemplateExceptionHandler(freemarker.template.TemplateExceptionHandler)" map="A"/>
  <method class="freemarker.template.Configuration" name="java.lang.String getVersionNumber()" map="&#x00e7;"/>
  <method class="freemarker.template.Configuration" name="freemarker.cache.CacheStorage getCacheStorage()" map="&#x00e8;"/>
  <method class="freemarker.template.Configuration" name="freemarker.template.Template getTemplate(java.lang.String, java.util.Locale)" map="B"/>
  <method class="freemarker.template.Configuration" name="void checkFreeMarkerVersionClash()" map="&#x00e9;"/>
  <method class="freemarker.template.Configuration" name="freemarker.core.MarkupOutputFormat getMarkupOutputFormatForCombined(java.lang.String)" map="a"/>
  <method class="freemarker.template.Configuration" name="void unsetTemplateExceptionHandler()" map="&#x00ea;"/>
  <method class="freemarker.template.Configuration" name="freemarker.template.Configuration getDefaultConfiguration()" map="&#x00eb;"/>
  <method class="freemarker.template.Configuration" name="java.util.Set getSettingNames(boolean)" map="I"/>
  <method class="freemarker.template.Configuration" name="freemarker.cache.TemplateNameFormat getDefaultTemplateNameFormat()" map="&#x00ec;"/>
  <method class="freemarker.template.Configuration" name="freemarker.core.OutputFormat getOutputFormat(java.lang.String)" map="b"/>
  <method class="freemarker.template.Configuration" name="freemarker.template.TemplateModel getSharedVariable(java.lang.String)" map="c"/>
  <method class="freemarker.template.Configuration" name="freemarker.template.Version getVersion()" map="&#x00ed;"/>
  <method class="freemarker.template.Configuration" name="java.lang.String getJVMDefaultEncoding()" map="&#x00ee;"/>
  <method class="freemarker.template.Configuration" name="int getTagSyntax()" map="E"/>
  <method class="freemarker.template.Configuration" name="freemarker.cache.TemplateLoader getDefaultTemplateLoader()" map="&#x00ef;"/>
  <method class="freemarker.template.Configuration" name="freemarker.template.AttemptExceptionReporter getDefaultAttemptExceptionReporter()" map="&#x00f0;"/>
  <class name="freemarker.template.ObjectWrapperAndUnwrapper" map="a"/>
  <field class="freemarker.template.ObjectWrapperAndUnwrapper" name="CANT_UNWRAP_TO_TARGET_CLASS" map="D"/>
  <class name="freemarker.template.IteratorToTemplateModelIteratorAdapter" map="b"/>
  <field class="freemarker.template.IteratorToTemplateModelIteratorAdapter" name="it" map="&#x01b2;"/>
  <field class="freemarker.template.IteratorToTemplateModelIteratorAdapter" name="wrapper" map="&#x01b3;"/>
  <method class="freemarker.template.IteratorToTemplateModelIteratorAdapter" name="boolean hasNext()" map="&#x00d1;"/>
  <method class="freemarker.template.IteratorToTemplateModelIteratorAdapter" name="freemarker.template.TemplateModel next()" map="&#x00d2;"/>
  <class name="freemarker.template.DefaultObjectWrapperConfiguration" map="c"/>
  <field class="freemarker.template.DefaultObjectWrapperConfiguration" name="useAdaptersForContainers" map="I"/>
  <field class="freemarker.template.DefaultObjectWrapperConfiguration" name="iterableSupport" map="J"/>
  <field class="freemarker.template.DefaultObjectWrapperConfiguration" name="forceLegacyNonListCollections" map="K"/>
  <method class="freemarker.template.DefaultObjectWrapperConfiguration" name="boolean getIterableSupport()" map="J"/>
  <method class="freemarker.template.DefaultObjectWrapperConfiguration" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="freemarker.template.DefaultObjectWrapperConfiguration" name="int hashCode()" map="hashCode"/>
  <method class="freemarker.template.DefaultObjectWrapperConfiguration" name="boolean getForceLegacyNonListCollections()" map="K"/>
  <method class="freemarker.template.DefaultObjectWrapperConfiguration" name="boolean getUseAdaptersForContainers()" map="L"/>
  <class name="freemarker.template.TemplateModelException" map="d"/>
  <field class="freemarker.template.TemplateModelException" name="replaceWithCause" map="X"/>
  <method class="freemarker.template.TemplateModelException" name="boolean getReplaceWithCause()" map="L"/>
  <class name="freemarker.template.TemplateNotFoundException" map="e"/>
  <field class="freemarker.template.TemplateNotFoundException" name="templateName" map="A"/>
  <field class="freemarker.template.TemplateNotFoundException" name="customLookupCondition" map="B"/>
  <class name="freemarker.template.TemplateModelListSequence" map="f"/>
  <field class="freemarker.template.TemplateModelListSequence" name="list" map="&#x0263;"/>
  <method class="freemarker.template.TemplateModelListSequence" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.TemplateModelListSequence" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <class name="freemarker.template.SimpleHash" map="g"/>
  <field class="freemarker.template.SimpleHash" name="unwrappedMap" map="&#x01e2;"/>
  <field class="freemarker.template.SimpleHash" name="putFailed" map="&#x01e3;"/>
  <field class="freemarker.template.SimpleHash" name="map" map="&#x01e4;"/>
  <method class="freemarker.template.SimpleHash" name="void put(java.lang.String, java.lang.Object)" map="A"/>
  <method class="freemarker.template.SimpleHash" name="void put(java.lang.String, boolean)" map="A"/>
  <method class="freemarker.template.SimpleHash" name="freemarker.template.TemplateCollectionModel values()" map="&#x00c9;"/>
  <method class="freemarker.template.SimpleHash" name="freemarker.template.TemplateCollectionModel keys()" map="&#x00c8;"/>
  <method class="freemarker.template.SimpleHash" name="freemarker.template.TemplateHashModelEx2$KeyValuePairIterator keyValuePairIterator()" map="&#x00cb;"/>
  <method class="freemarker.template.SimpleHash" name="java.util.Map copyMap(java.util.Map)" map="A"/>
  <method class="freemarker.template.SimpleHash" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.SimpleHash" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.template.SimpleHash" name="boolean containsKey(java.lang.String)" map="J"/>
  <method class="freemarker.template.SimpleHash" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.template.SimpleHash" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <class name="freemarker.template.Template$WrongEncodingException" map="_A"/>
  <field class="freemarker.template.Template$WrongEncodingException" name="constructorSpecifiedEncoding" map="O"/>
  <field class="freemarker.template.Template$WrongEncodingException" name="specifiedEncoding" map="P"/>
  <method class="freemarker.template.Template$WrongEncodingException" name="java.lang.String getMessage()" map="getMessage"/>
  <method class="freemarker.template.Template$WrongEncodingException" name="java.lang.String getTemplateSpecifiedEncoding()" map="E"/>
  <class name="freemarker.template.Template$LineTableBuilder" map="_B"/>
  <field class="freemarker.template.Template$LineTableBuilder" name="this$0" map="A"/>
  <field class="freemarker.template.Template$LineTableBuilder" name="closed" map="B"/>
  <field class="freemarker.template.Template$LineTableBuilder" name="failure" map="C"/>
  <field class="freemarker.template.Template$LineTableBuilder" name="lastChar" map="D"/>
  <field class="freemarker.template.Template$LineTableBuilder" name="tabSize" map="E"/>
  <field class="freemarker.template.Template$LineTableBuilder" name="lineBuf" map="F"/>
  <method class="freemarker.template.Template$LineTableBuilder" name="int read()" map="read"/>
  <method class="freemarker.template.Template$LineTableBuilder" name="void handleChar(int)" map="A"/>
  <method class="freemarker.template.Template$LineTableBuilder" name="void throwFailure()" map="A"/>
  <method class="freemarker.template.Template$LineTableBuilder" name="int read(char[], int, int)" map="read"/>
  <method class="freemarker.template.Template$LineTableBuilder" name="java.io.IOException rememberException(java.lang.Exception)" map="A"/>
  <method class="freemarker.template.Template$LineTableBuilder" name="void close()" map="close"/>
  <method class="freemarker.template.Template$LineTableBuilder" name="boolean hasFailure()" map="B"/>
  <class name="freemarker.template.Template" map="h"/>
  <field class="freemarker.template.Template" name="lines" map="&#x0105;"/>
  <field class="freemarker.template.Template" name="sourceName" map="&#x0106;"/>
  <field class="freemarker.template.Template" name="interpolationSyntax" map="&#x0107;"/>
  <field class="freemarker.template.Template" name="encoding" map="&#x0108;"/>
  <field class="freemarker.template.Template" name="rootElement" map="&#x0109;"/>
  <field class="freemarker.template.Template" name="templateLanguageVersion" map="&#x010a;"/>
  <field class="freemarker.template.Template" name="namespaceURIToPrefixLookup" map="&#x010b;"/>
  <field class="freemarker.template.Template" name="actualTagSyntax" map="&#x010c;"/>
  <field class="freemarker.template.Template" name="macros" map="&#x010d;"/>
  <field class="freemarker.template.Template" name="actualNamingConvention" map="&#x010e;"/>
  <field class="freemarker.template.Template" name="customLookupCondition" map="&#x010f;"/>
  <field class="freemarker.template.Template" name="autoEscaping" map="&#x0110;"/>
  <field class="freemarker.template.Template" name="defaultNS" map="&#x0111;"/>
  <field class="freemarker.template.Template" name="parserConfiguration" map="&#x0112;"/>
  <field class="freemarker.template.Template" name="prefixToNamespaceURILookup" map="&#x0113;"/>
  <field class="freemarker.template.Template" name="imports" map="&#x0114;"/>
  <field class="freemarker.template.Template" name="outputFormat" map="&#x0115;"/>
  <field class="freemarker.template.Template" name="name" map="&#x0116;"/>
  <method class="freemarker.template.Template" name="java.util.Map getMacros()" map="&#x00f1;"/>
  <method class="freemarker.template.Template" name="freemarker.template.Configuration getConfiguration()" map="&#x00f2;"/>
  <method class="freemarker.template.Template" name="freemarker.template.Version normalizeTemplateLanguageVersion(freemarker.template.Version)" map="H"/>
  <method class="freemarker.template.Template" name="java.lang.String getPrefixForNamespace(java.lang.String)" map="d"/>
  <method class="freemarker.template.Template" name="void setCustomLookupCondition(java.lang.Object)" map="B"/>
  <method class="freemarker.template.Template" name="java.util.ArrayList access$000(freemarker.template.Template)" map="C"/>
  <method class="freemarker.template.Template" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.template.Template" name="java.lang.String getEncoding()" map="&#x00f3;"/>
  <method class="freemarker.template.Template" name="java.lang.String getDefaultNS()" map="&#x00f4;"/>
  <method class="freemarker.template.Template" name="void setOutputFormat(freemarker.core.OutputFormat)" map="A"/>
  <method class="freemarker.template.Template" name="freemarker.core.ParserConfiguration getParserConfiguration()" map="&#x00f5;"/>
  <method class="freemarker.template.Template" name="java.lang.String getSource(int, int, int, int)" map="A"/>
  <method class="freemarker.template.Template" name="java.lang.Object getCustomLookupCondition()" map="&#x00f6;"/>
  <method class="freemarker.template.Template" name="freemarker.template.Version getTemplateLanguageVersion()" map="&#x00f8;"/>
  <method class="freemarker.template.Template" name="java.lang.String getNamespaceForPrefix(java.lang.String)" map="e"/>
  <method class="freemarker.template.Template" name="void dump(java.io.Writer)" map="B"/>
  <method class="freemarker.template.Template" name="java.lang.String getName()" map="&#x00f9;"/>
  <method class="freemarker.template.Template" name="freemarker.core.TemplateElement getRootTreeNode()" map="&#x00fa;"/>
  <method class="freemarker.template.Template" name="freemarker.core.OutputFormat getOutputFormat()" map="&#x00fb;"/>
  <method class="freemarker.template.Template" name="freemarker.template.Configuration toNonNull(freemarker.template.Configuration)" map="A"/>
  <method class="freemarker.template.Template" name="freemarker.template.Template getPlainTextTemplate(java.lang.String, java.lang.String, java.lang.String, freemarker.template.Configuration)" map="A"/>
  <method class="freemarker.template.Template" name="int getActualTagSyntax()" map="&#x00fc;"/>
  <method class="freemarker.template.Template" name="void addPrefixNSMapping(java.lang.String, java.lang.String)" map="F"/>
  <method class="freemarker.template.Template" name="void addMacro(freemarker.core.Macro)" map="C"/>
  <method class="freemarker.template.Template" name="void setAutoEscaping(boolean)" map="L"/>
  <method class="freemarker.template.Template" name="java.lang.String getSourceName()" map="&#x00fd;"/>
  <method class="freemarker.template.Template" name="void process(java.lang.Object, java.io.Writer)" map="A"/>
  <method class="freemarker.template.Template" name="void setEncoding(java.lang.String)" map="f"/>
  <method class="freemarker.template.Template" name="int getInterpolationSyntax()" map="&#x00fe;"/>
  <method class="freemarker.template.Template" name="void addImport(freemarker.core.LibraryLoad)" map="A"/>
  <method class="freemarker.template.Template" name="freemarker.core.Environment createProcessingEnvironment(java.lang.Object, java.io.Writer, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.template.TrueTemplateBooleanModel" map="i"/>
  <method class="freemarker.template.TrueTemplateBooleanModel" name="boolean getAsBoolean()" map="&#x00c3;"/>
  <class name="freemarker.template.DefaultArrayAdapter$BooleanArrayAdapter" map="_A"/>
  <field class="freemarker.template.DefaultArrayAdapter$BooleanArrayAdapter" name="array" map="&#x01ce;"/>
  <method class="freemarker.template.DefaultArrayAdapter$BooleanArrayAdapter" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.DefaultArrayAdapter$BooleanArrayAdapter" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.template.DefaultArrayAdapter$BooleanArrayAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <class name="freemarker.template.DefaultArrayAdapter$ObjectArrayAdapter" map="_B"/>
  <field class="freemarker.template.DefaultArrayAdapter$ObjectArrayAdapter" name="array" map="&#x01cf;"/>
  <method class="freemarker.template.DefaultArrayAdapter$ObjectArrayAdapter" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.DefaultArrayAdapter$ObjectArrayAdapter" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.template.DefaultArrayAdapter$ObjectArrayAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <class name="freemarker.template.DefaultArrayAdapter$DoubleArrayAdapter" map="_C"/>
  <field class="freemarker.template.DefaultArrayAdapter$DoubleArrayAdapter" name="array" map="&#x01d0;"/>
  <method class="freemarker.template.DefaultArrayAdapter$DoubleArrayAdapter" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.DefaultArrayAdapter$DoubleArrayAdapter" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.template.DefaultArrayAdapter$DoubleArrayAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <class name="freemarker.template.DefaultArrayAdapter$GenericPrimitiveArrayAdapter" map="_D"/>
  <field class="freemarker.template.DefaultArrayAdapter$GenericPrimitiveArrayAdapter" name="length" map="&#x01d1;"/>
  <field class="freemarker.template.DefaultArrayAdapter$GenericPrimitiveArrayAdapter" name="array" map="&#x01d2;"/>
  <method class="freemarker.template.DefaultArrayAdapter$GenericPrimitiveArrayAdapter" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.DefaultArrayAdapter$GenericPrimitiveArrayAdapter" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.template.DefaultArrayAdapter$GenericPrimitiveArrayAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <class name="freemarker.template.DefaultArrayAdapter$CharArrayAdapter" map="_E"/>
  <field class="freemarker.template.DefaultArrayAdapter$CharArrayAdapter" name="array" map="&#x01d3;"/>
  <method class="freemarker.template.DefaultArrayAdapter$CharArrayAdapter" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.DefaultArrayAdapter$CharArrayAdapter" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.template.DefaultArrayAdapter$CharArrayAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <class name="freemarker.template.DefaultArrayAdapter$ByteArrayAdapter" map="_F"/>
  <field class="freemarker.template.DefaultArrayAdapter$ByteArrayAdapter" name="array" map="&#x01d4;"/>
  <method class="freemarker.template.DefaultArrayAdapter$ByteArrayAdapter" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.DefaultArrayAdapter$ByteArrayAdapter" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.template.DefaultArrayAdapter$ByteArrayAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <class name="freemarker.template.DefaultArrayAdapter$ShortArrayAdapter" map="_G"/>
  <field class="freemarker.template.DefaultArrayAdapter$ShortArrayAdapter" name="array" map="&#x01d5;"/>
  <method class="freemarker.template.DefaultArrayAdapter$ShortArrayAdapter" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.DefaultArrayAdapter$ShortArrayAdapter" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.template.DefaultArrayAdapter$ShortArrayAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <class name="freemarker.template.DefaultArrayAdapter$1" map="1"/>
  <class name="freemarker.template.DefaultArrayAdapter$LongArrayAdapter" map="_H"/>
  <field class="freemarker.template.DefaultArrayAdapter$LongArrayAdapter" name="array" map="&#x01d6;"/>
  <method class="freemarker.template.DefaultArrayAdapter$LongArrayAdapter" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.DefaultArrayAdapter$LongArrayAdapter" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.template.DefaultArrayAdapter$LongArrayAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <class name="freemarker.template.DefaultArrayAdapter$IntArrayAdapter" map="_I"/>
  <field class="freemarker.template.DefaultArrayAdapter$IntArrayAdapter" name="array" map="&#x01d7;"/>
  <method class="freemarker.template.DefaultArrayAdapter$IntArrayAdapter" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.DefaultArrayAdapter$IntArrayAdapter" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.template.DefaultArrayAdapter$IntArrayAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <class name="freemarker.template.DefaultArrayAdapter$FloatArrayAdapter" map="_J"/>
  <field class="freemarker.template.DefaultArrayAdapter$FloatArrayAdapter" name="array" map="&#x01d8;"/>
  <method class="freemarker.template.DefaultArrayAdapter$FloatArrayAdapter" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.DefaultArrayAdapter$FloatArrayAdapter" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.template.DefaultArrayAdapter$FloatArrayAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <class name="freemarker.template.DefaultArrayAdapter" map="j"/>
  <method class="freemarker.template.DefaultArrayAdapter" name="java.lang.Object getAdaptedObject(java.lang.Class)" map="A"/>
  <method class="freemarker.template.DefaultArrayAdapter" name="freemarker.template.DefaultArrayAdapter adapt(java.lang.Object, freemarker.template.ObjectWrapperAndUnwrapper)" map="A"/>
  <class name="freemarker.template.SimpleSequence" map="k"/>
  <field class="freemarker.template.SimpleSequence" name="unwrappedList" map="&#x0206;"/>
  <field class="freemarker.template.SimpleSequence" name="list" map="&#x0207;"/>
  <method class="freemarker.template.SimpleSequence" name="void add(java.lang.Object)" map="D"/>
  <method class="freemarker.template.SimpleSequence" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.SimpleSequence" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.template.SimpleSequence" name="java.lang.String toString()" map="toString"/>
  <class name="freemarker.template.AdapterTemplateModel" map="l"/>
  <method class="freemarker.template.AdapterTemplateModel" name="java.lang.Object getAdaptedObject(java.lang.Class)" map="A"/>
  <class name="freemarker.template.GeneralPurposeNothing" map="m"/>
  <field class="freemarker.template.GeneralPurposeNothing" name="instance" map="&#x01ec;"/>
  <method class="freemarker.template.GeneralPurposeNothing" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <method class="freemarker.template.GeneralPurposeNothing" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.template.GeneralPurposeNothing" name="freemarker.template.TemplateModel getInstance()" map="&#x00ef;"/>
  <method class="freemarker.template.GeneralPurposeNothing" name="freemarker.template.TemplateCollectionModel values()" map="&#x00c9;"/>
  <method class="freemarker.template.GeneralPurposeNothing" name="freemarker.template.TemplateCollectionModel keys()" map="&#x00c8;"/>
  <method class="freemarker.template.GeneralPurposeNothing" name="boolean getAsBoolean()" map="&#x00c3;"/>
  <method class="freemarker.template.GeneralPurposeNothing" name="freemarker.template.TemplateHashModelEx2$KeyValuePairIterator keyValuePairIterator()" map="&#x00cb;"/>
  <method class="freemarker.template.GeneralPurposeNothing" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.GeneralPurposeNothing" name="java.lang.Object exec(java.util.List)" map="A"/>
  <method class="freemarker.template.GeneralPurposeNothing" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.template.GeneralPurposeNothing" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <class name="freemarker.template.TemplateMethodModel" map="n"/>
  <method class="freemarker.template.TemplateMethodModel" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.template.EmptyMap" map="o"/>
  <field class="freemarker.template.EmptyMap" name="instance" map="A"/>
  <method class="freemarker.template.EmptyMap" name="java.lang.Object remove(java.lang.Object)" map="remove"/>
  <method class="freemarker.template.EmptyMap" name="boolean containsValue(java.lang.Object)" map="containsValue"/>
  <method class="freemarker.template.EmptyMap" name="java.util.Set keySet()" map="keySet"/>
  <method class="freemarker.template.EmptyMap" name="boolean containsKey(java.lang.Object)" map="containsKey"/>
  <method class="freemarker.template.EmptyMap" name="void clear()" map="clear"/>
  <method class="freemarker.template.EmptyMap" name="java.util.Set entrySet()" map="entrySet"/>
  <method class="freemarker.template.EmptyMap" name="java.util.Collection values()" map="values"/>
  <method class="freemarker.template.EmptyMap" name="void putAll(java.util.Map)" map="putAll"/>
  <method class="freemarker.template.EmptyMap" name="java.lang.Object put(java.lang.Object, java.lang.Object)" map="put"/>
  <method class="freemarker.template.EmptyMap" name="java.lang.Object get(java.lang.Object)" map="get"/>
  <method class="freemarker.template.EmptyMap" name="int size()" map="size"/>
  <method class="freemarker.template.EmptyMap" name="boolean isEmpty()" map="isEmpty"/>
  <class name="freemarker.template.SimpleDate" map="p"/>
  <field class="freemarker.template.SimpleDate" name="date" map="&#x01c9;"/>
  <field class="freemarker.template.SimpleDate" name="type" map="&#x01ca;"/>
  <method class="freemarker.template.SimpleDate" name="java.util.Date getAsDate()" map="&#x00da;"/>
  <method class="freemarker.template.SimpleDate" name="int getDateType()" map="&#x00db;"/>
  <method class="freemarker.template.SimpleDate" name="java.lang.String toString()" map="toString"/>
  <class name="freemarker.template._TemplateAPI" map="q"/>
  <field class="freemarker.template._TemplateAPI" name="VERSION_INT_2_3_0" map="A"/>
  <field class="freemarker.template._TemplateAPI" name="VERSION_INT_2_4_0" map="B"/>
  <field class="freemarker.template._TemplateAPI" name="VERSION_INT_2_3_28" map="C"/>
  <field class="freemarker.template._TemplateAPI" name="VERSION_INT_2_3_27" map="D"/>
  <field class="freemarker.template._TemplateAPI" name="VERSION_INT_2_3_26" map="E"/>
  <field class="freemarker.template._TemplateAPI" name="VERSION_INT_2_3_25" map="F"/>
  <field class="freemarker.template._TemplateAPI" name="VERSION_INT_2_3_24" map="G"/>
  <field class="freemarker.template._TemplateAPI" name="VERSION_INT_2_3_23" map="H"/>
  <field class="freemarker.template._TemplateAPI" name="VERSION_INT_2_3_22" map="I"/>
  <field class="freemarker.template._TemplateAPI" name="VERSION_INT_2_3_19" map="J"/>
  <field class="freemarker.template._TemplateAPI" name="VERSION_INT_2_3_21" map="K"/>
  <field class="freemarker.template._TemplateAPI" name="VERSION_INT_2_3_20" map="L"/>
  <method class="freemarker.template._TemplateAPI" name="void setOutputFormat(freemarker.template.Template, freemarker.core.OutputFormat)" map="A"/>
  <method class="freemarker.template._TemplateAPI" name="boolean getDefaultLogTemplateExceptions(freemarker.template.Version)" map="A"/>
  <method class="freemarker.template._TemplateAPI" name="java.util.Set getConfigurationSettingNames(freemarker.template.Configuration, boolean)" map="A"/>
  <method class="freemarker.template._TemplateAPI" name="int getTemplateLanguageVersionAsInt(freemarker.template.Template)" map="A"/>
  <method class="freemarker.template._TemplateAPI" name="java.util.TimeZone getDefaultTimeZone()" map="A"/>
  <method class="freemarker.template._TemplateAPI" name="freemarker.template.AttemptExceptionReporter getDefaultAttemptExceptionReporter(freemarker.template.Version)" map="B"/>
  <method class="freemarker.template._TemplateAPI" name="void checkVersionNotNullAndSupported(freemarker.template.Version)" map="C"/>
  <method class="freemarker.template._TemplateAPI" name="boolean getDefaultWrapUncheckedExceptions(freemarker.template.Version)" map="D"/>
  <method class="freemarker.template._TemplateAPI" name="void setAutoEscaping(freemarker.template.Template, boolean)" map="A"/>
  <method class="freemarker.template._TemplateAPI" name="freemarker.core.Expression getBlamedExpression(freemarker.template.TemplateException)" map="A"/>
  <method class="freemarker.template._TemplateAPI" name="int getTemplateLanguageVersionAsInt(freemarker.core.TemplateObject)" map="A"/>
  <method class="freemarker.template._TemplateAPI" name="freemarker.template.TemplateExceptionHandler getDefaultTemplateExceptionHandler(freemarker.template.Version)" map="E"/>
  <method class="freemarker.template._TemplateAPI" name="java.util.Locale getDefaultLocale()" map="B"/>
  <class name="freemarker.template.TemplateNodeModelEx" map="r"/>
  <method class="freemarker.template.TemplateNodeModelEx" name="freemarker.template.TemplateNodeModelEx getNextSibling()" map="&#x00e2;"/>
  <method class="freemarker.template.TemplateNodeModelEx" name="freemarker.template.TemplateNodeModelEx getPreviousSibling()" map="&#x00e3;"/>
  <class name="freemarker.template.TemplateDirectiveModel" map="s"/>
  <method class="freemarker.template.TemplateDirectiveModel" name="void execute(freemarker.core.Environment, java.util.Map, freemarker.template.TemplateModel[], freemarker.template.TemplateDirectiveBody)" map="A"/>
  <class name="freemarker.template.SerializableTemplateBooleanModel" map="t"/>
  <class name="freemarker.template.TemplateHashModelEx2$KeyValuePairIterator" map="_A"/>
  <method class="freemarker.template.TemplateHashModelEx2$KeyValuePairIterator" name="boolean hasNext()" map="A"/>
  <method class="freemarker.template.TemplateHashModelEx2$KeyValuePairIterator" name="freemarker.template.TemplateHashModelEx2$KeyValuePair next()" map="B"/>
  <class name="freemarker.template.TemplateHashModelEx2$KeyValuePair" map="_B"/>
  <method class="freemarker.template.TemplateHashModelEx2$KeyValuePair" name="freemarker.template.TemplateModel getKey()" map="A"/>
  <method class="freemarker.template.TemplateHashModelEx2$KeyValuePair" name="freemarker.template.TemplateModel getValue()" map="B"/>
  <class name="freemarker.template.TemplateHashModelEx2" map="u"/>
  <method class="freemarker.template.TemplateHashModelEx2" name="freemarker.template.TemplateHashModelEx2$KeyValuePairIterator keyValuePairIterator()" map="&#x00cb;"/>
  <class name="freemarker.template.DefaultObjectWrapperBuilder$DefaultObjectWrapperFactory" map="_A"/>
  <field class="freemarker.template.DefaultObjectWrapperBuilder$DefaultObjectWrapperFactory" name="INSTANCE" map="A"/>
  <method class="freemarker.template.DefaultObjectWrapperBuilder$DefaultObjectWrapperFactory" name="freemarker.template.DefaultObjectWrapper create(freemarker.template.DefaultObjectWrapperConfiguration)" map="A"/>
  <method class="freemarker.template.DefaultObjectWrapperBuilder$DefaultObjectWrapperFactory" name="freemarker.template.DefaultObjectWrapperBuilder$DefaultObjectWrapperFactory access$000()" map="A"/>
  <method class="freemarker.template.DefaultObjectWrapperBuilder$DefaultObjectWrapperFactory" name="freemarker.ext.beans.BeansWrapper create(freemarker.ext.beans.BeansWrapperConfiguration)" map="A"/>
  <class name="freemarker.template.DefaultObjectWrapperBuilder" map="v"/>
  <field class="freemarker.template.DefaultObjectWrapperBuilder" name="INSTANCE_CACHE" map="L"/>
  <field class="freemarker.template.DefaultObjectWrapperBuilder" name="INSTANCE_CACHE_REF_QUEUE" map="M"/>
  <method class="freemarker.template.DefaultObjectWrapperBuilder" name="freemarker.template.DefaultObjectWrapper build()" map="M"/>
  <class name="freemarker.template.Version" map="w"/>
  <field class="freemarker.template.Version" name="extraInfo" map="A"/>
  <field class="freemarker.template.Version" name="intValue" map="B"/>
  <field class="freemarker.template.Version" name="originalStringValue" map="C"/>
  <field class="freemarker.template.Version" name="micro" map="D"/>
  <field class="freemarker.template.Version" name="calculatedStringValue" map="E"/>
  <field class="freemarker.template.Version" name="buildDate" map="F"/>
  <field class="freemarker.template.Version" name="minor" map="G"/>
  <field class="freemarker.template.Version" name="major" map="H"/>
  <field class="freemarker.template.Version" name="hashCode" map="I"/>
  <field class="freemarker.template.Version" name="gaeCompliant" map="J"/>
  <method class="freemarker.template.Version" name="boolean isNumber(char)" map="A"/>
  <method class="freemarker.template.Version" name="int hashCode()" map="hashCode"/>
  <method class="freemarker.template.Version" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="freemarker.template.Version" name="int calculateIntValue()" map="A"/>
  <method class="freemarker.template.Version" name="int getMinor()" map="B"/>
  <method class="freemarker.template.Version" name="int intValueFor(int, int, int)" map="A"/>
  <method class="freemarker.template.Version" name="java.lang.String getStringValue()" map="C"/>
  <method class="freemarker.template.Version" name="int getMajor()" map="D"/>
  <method class="freemarker.template.Version" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.template.Version" name="int intValue()" map="E"/>
  <class name="freemarker.template.TemplateHashModelEx" map="x"/>
  <method class="freemarker.template.TemplateHashModelEx" name="freemarker.template.TemplateCollectionModel keys()" map="&#x00c8;"/>
  <method class="freemarker.template.TemplateHashModelEx" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.TemplateHashModelEx" name="freemarker.template.TemplateCollectionModel values()" map="&#x00c9;"/>
  <class name="freemarker.template.FalseTemplateBooleanModel" map="y"/>
  <method class="freemarker.template.FalseTemplateBooleanModel" name="boolean getAsBoolean()" map="&#x00c3;"/>
  <class name="freemarker.template.WrappingTemplateModel" map="z"/>
  <field class="freemarker.template.WrappingTemplateModel" name="defaultObjectWrapper" map="&#x012e;"/>
  <field class="freemarker.template.WrappingTemplateModel" name="objectWrapper" map="&#x012f;"/>
  <method class="freemarker.template.WrappingTemplateModel" name="freemarker.template.TemplateModel wrap(java.lang.Object)" map="A"/>
  <method class="freemarker.template.WrappingTemplateModel" name="freemarker.template.ObjectWrapper getObjectWrapper()" map="&#x00ba;"/>
  <class name="freemarker.template.TemplateModelWithAPISupport" map="$A"/>
  <method class="freemarker.template.TemplateModelWithAPISupport" name="freemarker.template.TemplateModel getAPI()" map="&#x00ce;"/>
  <class name="freemarker.template.TemplateException$PrintStreamStackTraceWriter" map="_A"/>
  <field class="freemarker.template.TemplateException$PrintStreamStackTraceWriter" name="out" map="B"/>
  <method class="freemarker.template.TemplateException$PrintStreamStackTraceWriter" name="void println(java.lang.Object)" map="A"/>
  <method class="freemarker.template.TemplateException$PrintStreamStackTraceWriter" name="void print(java.lang.Object)" map="B"/>
  <method class="freemarker.template.TemplateException$PrintStreamStackTraceWriter" name="void printStandardStackTrace(java.lang.Throwable)" map="A"/>
  <method class="freemarker.template.TemplateException$PrintStreamStackTraceWriter" name="void println()" map="A"/>
  <class name="freemarker.template.TemplateException$StackTraceWriter" map="_B"/>
  <method class="freemarker.template.TemplateException$StackTraceWriter" name="void println(java.lang.Object)" map="A"/>
  <method class="freemarker.template.TemplateException$StackTraceWriter" name="void print(java.lang.Object)" map="B"/>
  <method class="freemarker.template.TemplateException$StackTraceWriter" name="void printStandardStackTrace(java.lang.Throwable)" map="A"/>
  <method class="freemarker.template.TemplateException$StackTraceWriter" name="void println()" map="A"/>
  <class name="freemarker.template.TemplateException$PrintWriterStackTraceWriter" map="_C"/>
  <field class="freemarker.template.TemplateException$PrintWriterStackTraceWriter" name="out" map="A"/>
  <method class="freemarker.template.TemplateException$PrintWriterStackTraceWriter" name="void println(java.lang.Object)" map="A"/>
  <method class="freemarker.template.TemplateException$PrintWriterStackTraceWriter" name="void print(java.lang.Object)" map="B"/>
  <method class="freemarker.template.TemplateException$PrintWriterStackTraceWriter" name="void printStandardStackTrace(java.lang.Throwable)" map="A"/>
  <method class="freemarker.template.TemplateException$PrintWriterStackTraceWriter" name="void println()" map="A"/>
  <class name="freemarker.template.TemplateException" map="AA"/>
  <field class="freemarker.template.TemplateException" name="blamedExpressionString" map="A"/>
  <field class="freemarker.template.TemplateException" name="endColumnNumber" map="B"/>
  <field class="freemarker.template.TemplateException" name="endLineNumber" map="C"/>
  <field class="freemarker.template.TemplateException" name="columnNumber" map="D"/>
  <field class="freemarker.template.TemplateException" name="templateSourceName" map="E"/>
  <field class="freemarker.template.TemplateException" name="templateName" map="F"/>
  <field class="freemarker.template.TemplateException" name="descriptionBuilder" map="G"/>
  <field class="freemarker.template.TemplateException" name="blamedExpression" map="H"/>
  <field class="freemarker.template.TemplateException" name="message" map="I"/>
  <field class="freemarker.template.TemplateException" name="ftlInstructionStackSnapshot" map="J"/>
  <field class="freemarker.template.TemplateException" name="lineNumber" map="K"/>
  <field class="freemarker.template.TemplateException" name="renderedFtlInstructionStackSnapshotTop" map="L"/>
  <field class="freemarker.template.TemplateException" name="messageWasAlreadyPrintedForThisTrace" map="M"/>
  <field class="freemarker.template.TemplateException" name="description" map="N"/>
  <field class="freemarker.template.TemplateException" name="messageWithoutStackTop" map="O"/>
  <field class="freemarker.template.TemplateException" name="blamedExpressionStringCalculated" map="P"/>
  <field class="freemarker.template.TemplateException" name="env" map="Q"/>
  <field class="freemarker.template.TemplateException" name="positionsCalculated" map="R"/>
  <field class="freemarker.template.TemplateException" name="renderedFtlInstructionStackSnapshot" map="S"/>
  <field class="freemarker.template.TemplateException" name="lock" map="T"/>
  <method class="freemarker.template.TemplateException" name="java.lang.String getBlamedExpressionString()" map="A"/>
  <method class="freemarker.template.TemplateException" name="void deleteFTLInstructionStackSnapshotIfNotNeeded()" map="B"/>
  <method class="freemarker.template.TemplateException" name="void printStandardStackTrace(java.io.PrintWriter)" map="A"/>
  <method class="freemarker.template.TemplateException" name="java.lang.String getMessage()" map="getMessage"/>
  <method class="freemarker.template.TemplateException" name="java.lang.String getFTLInstructionStackTopFew()" map="C"/>
  <method class="freemarker.template.TemplateException" name="void printStackTrace(java.io.PrintStream, boolean, boolean, boolean)" map="A"/>
  <method class="freemarker.template.TemplateException" name="freemarker.core.TemplateElement getFailingInstruction()" map="D"/>
  <method class="freemarker.template.TemplateException" name="void printStackTrace(java.io.PrintStream)" map="printStackTrace"/>
  <method class="freemarker.template.TemplateException" name="void readObject(java.io.ObjectInputStream)" map="A"/>
  <method class="freemarker.template.TemplateException" name="java.lang.String getMessageWithoutStackTop()" map="E"/>
  <method class="freemarker.template.TemplateException" name="void renderMessages()" map="F"/>
  <method class="freemarker.template.TemplateException" name="freemarker.core.Environment getEnvironment()" map="G"/>
  <method class="freemarker.template.TemplateException" name="void printStackTrace(java.io.PrintWriter)" map="printStackTrace"/>
  <method class="freemarker.template.TemplateException" name="void calculatePosition()" map="H"/>
  <method class="freemarker.template.TemplateException" name="void printStackTrace(java.io.PrintWriter, boolean, boolean, boolean)" map="A"/>
  <method class="freemarker.template.TemplateException" name="freemarker.core.Expression getBlamedExpression()" map="I"/>
  <method class="freemarker.template.TemplateException" name="void printStackTrace(freemarker.template.TemplateException$StackTraceWriter, boolean, boolean, boolean)" map="A"/>
  <method class="freemarker.template.TemplateException" name="java.lang.String getDescription()" map="J"/>
  <method class="freemarker.template.TemplateException" name="void writeObject(java.io.ObjectOutputStream)" map="A"/>
  <method class="freemarker.template.TemplateException" name="void printStandardStackTrace(java.io.PrintStream)" map="A"/>
  <method class="freemarker.template.TemplateException" name="java.lang.String getFTLInstructionStack()" map="K"/>
  <class name="freemarker.template.SimpleScalar" map="BA"/>
  <field class="freemarker.template.SimpleScalar" name="value" map="&#x0253;"/>
  <method class="freemarker.template.SimpleScalar" name="freemarker.template.SimpleScalar newInstanceOrNull(java.lang.String)" map="P"/>
  <method class="freemarker.template.SimpleScalar" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <method class="freemarker.template.SimpleScalar" name="java.lang.String toString()" map="toString"/>
  <class name="freemarker.template.DefaultEnumerationAdapter$SimpleTemplateModelIterator" map="_A"/>
  <field class="freemarker.template.DefaultEnumerationAdapter$SimpleTemplateModelIterator" name="this$0" map="&#x01b4;"/>
  <field class="freemarker.template.DefaultEnumerationAdapter$SimpleTemplateModelIterator" name="enumerationOwnedByMe" map="&#x01b5;"/>
  <method class="freemarker.template.DefaultEnumerationAdapter$SimpleTemplateModelIterator" name="boolean hasNext()" map="&#x00d1;"/>
  <method class="freemarker.template.DefaultEnumerationAdapter$SimpleTemplateModelIterator" name="void checkNotOwner()" map="&#x00d5;"/>
  <method class="freemarker.template.DefaultEnumerationAdapter$SimpleTemplateModelIterator" name="freemarker.template.TemplateModel next()" map="&#x00d2;"/>
  <class name="freemarker.template.DefaultEnumerationAdapter$1" map="1"/>
  <class name="freemarker.template.DefaultEnumerationAdapter" map="CA"/>
  <field class="freemarker.template.DefaultEnumerationAdapter" name="enumerationOwnedBySomeone" map="&#x0192;"/>
  <field class="freemarker.template.DefaultEnumerationAdapter" name="enumeration" map="&#x0193;"/>
  <method class="freemarker.template.DefaultEnumerationAdapter" name="java.util.Enumeration access$200(freemarker.template.DefaultEnumerationAdapter)" map="A"/>
  <method class="freemarker.template.DefaultEnumerationAdapter" name="java.lang.Object getAdaptedObject(java.lang.Class)" map="A"/>
  <method class="freemarker.template.DefaultEnumerationAdapter" name="boolean access$100(freemarker.template.DefaultEnumerationAdapter)" map="B"/>
  <method class="freemarker.template.DefaultEnumerationAdapter" name="freemarker.template.TemplateModel getAPI()" map="&#x00ce;"/>
  <method class="freemarker.template.DefaultEnumerationAdapter" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <method class="freemarker.template.DefaultEnumerationAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <method class="freemarker.template.DefaultEnumerationAdapter" name="freemarker.template.DefaultEnumerationAdapter adapt(java.util.Enumeration, freemarker.template.ObjectWrapper)" map="A"/>
  <method class="freemarker.template.DefaultEnumerationAdapter" name="boolean access$102(freemarker.template.DefaultEnumerationAdapter, boolean)" map="A"/>
  <class name="freemarker.template.DefaultListAdapter$1" map="1"/>
  <class name="freemarker.template.DefaultListAdapter$DefaultListAdapterWithCollectionSupport" map="_A"/>
  <method class="freemarker.template.DefaultListAdapter$DefaultListAdapterWithCollectionSupport" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <class name="freemarker.template.DefaultListAdapter" map="DA"/>
  <field class="freemarker.template.DefaultListAdapter" name="list" map="&#x0194;"/>
  <method class="freemarker.template.DefaultListAdapter" name="java.lang.Object getAdaptedObject(java.lang.Class)" map="A"/>
  <method class="freemarker.template.DefaultListAdapter" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.DefaultListAdapter" name="freemarker.template.TemplateModel getAPI()" map="&#x00ce;"/>
  <method class="freemarker.template.DefaultListAdapter" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.template.DefaultListAdapter" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <method class="freemarker.template.DefaultListAdapter" name="freemarker.template.DefaultListAdapter adapt(java.util.List, freemarker.template.utility.RichObjectWrapper)" map="A"/>
  <class name="freemarker.template.TemplateMethodModelEx" map="EA"/>
  <method class="freemarker.template.TemplateMethodModelEx" name="java.lang.Object exec(java.util.List)" map="A"/>
  <class name="freemarker.template.TemplateSequenceModel" map="FA"/>
  <method class="freemarker.template.TemplateSequenceModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.template.TemplateSequenceModel" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <class name="freemarker.template.AttemptExceptionReporter" map="GA"/>
  <field class="freemarker.template.AttemptExceptionReporter" name="LOG_ERROR_REPORTER" map="A"/>
  <field class="freemarker.template.AttemptExceptionReporter" name="LOG_WARN_REPORTER" map="B"/>
  <method class="freemarker.template.AttemptExceptionReporter" name="void report(freemarker.template.TemplateException, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.template.TemplateModel" map="HA"/>
  <field class="freemarker.template.TemplateModel" name="NOTHING" map="&#x00cf;"/>
  <package name="freemarker.log" map="E"/>
  <class name="freemarker.log._NullLoggerFactory$1" map="1"/>
  <method class="freemarker.log._NullLoggerFactory$1" name="void warn(java.lang.String)" map="D"/>
  <method class="freemarker.log._NullLoggerFactory$1" name="void error(java.lang.String, java.lang.Throwable)" map="B"/>
  <method class="freemarker.log._NullLoggerFactory$1" name="void info(java.lang.String, java.lang.Throwable)" map="C"/>
  <method class="freemarker.log._NullLoggerFactory$1" name="void debug(java.lang.String, java.lang.Throwable)" map="E"/>
  <method class="freemarker.log._NullLoggerFactory$1" name="boolean isInfoEnabled()" map="D"/>
  <method class="freemarker.log._NullLoggerFactory$1" name="boolean isDebugEnabled()" map="B"/>
  <method class="freemarker.log._NullLoggerFactory$1" name="void debug(java.lang.String)" map="C"/>
  <method class="freemarker.log._NullLoggerFactory$1" name="void error(java.lang.String)" map="E"/>
  <method class="freemarker.log._NullLoggerFactory$1" name="boolean isWarnEnabled()" map="E"/>
  <method class="freemarker.log._NullLoggerFactory$1" name="boolean isErrorEnabled()" map="A"/>
  <method class="freemarker.log._NullLoggerFactory$1" name="void info(java.lang.String)" map="F"/>
  <method class="freemarker.log._NullLoggerFactory$1" name="void warn(java.lang.String, java.lang.Throwable)" map="D"/>
  <class name="freemarker.log._NullLoggerFactory" map="A"/>
  <field class="freemarker.log._NullLoggerFactory" name="INSTANCE" map="A"/>
  <method class="freemarker.log._NullLoggerFactory" name="freemarker.log.Logger getLogger(java.lang.String)" map="A"/>
  <class name="freemarker.log.Logger$1" map="1"/>
  <field class="freemarker.log.Logger$1" name="val$key" map="A"/>
  <method class="freemarker.log.Logger$1" name="java.lang.Object run()" map="run"/>
  <class name="freemarker.log.Logger" map="B"/>
  <field class="freemarker.log.Logger" name="loggersByCategory" map="A"/>
  <field class="freemarker.log.Logger" name="loggerFactory" map="B"/>
  <field class="freemarker.log.Logger" name="categoryPrefix" map="C"/>
  <field class="freemarker.log.Logger" name="libraryEnum" map="D"/>
  <field class="freemarker.log.Logger" name="LIBRARIES_BY_PRIORITY" map="E"/>
  <field class="freemarker.log.Logger" name="initializedFromSystemProperty" map="F"/>
  <method class="freemarker.log.Logger" name="void logWarnInLogger(java.lang.String)" map="A"/>
  <method class="freemarker.log.Logger" name="freemarker.log.Logger getLogger(java.lang.String)" map="B"/>
  <method class="freemarker.log.Logger" name="java.lang.String tryToString(java.lang.Object)" map="A"/>
  <method class="freemarker.log.Logger" name="boolean isErrorEnabled()" map="A"/>
  <method class="freemarker.log.Logger" name="boolean isDebugEnabled()" map="B"/>
  <method class="freemarker.log.Logger" name="void ensureLoggerFactorySet(boolean)" map="A"/>
  <method class="freemarker.log.Logger" name="freemarker.log.LoggerFactory createLoggerFactoryForNonAuto(int)" map="A"/>
  <method class="freemarker.log.Logger" name="void logErrorInLogger(java.lang.String, java.lang.Throwable)" map="A"/>
  <method class="freemarker.log.Logger" name="void debug(java.lang.String)" map="C"/>
  <method class="freemarker.log.Logger" name="void setLibrary(int)" map="B"/>
  <method class="freemarker.log.Logger" name="void warn(java.lang.String)" map="D"/>
  <method class="freemarker.log.Logger" name="void error(java.lang.String)" map="E"/>
  <method class="freemarker.log.Logger" name="void error(java.lang.String, java.lang.Throwable)" map="B"/>
  <method class="freemarker.log.Logger" name="void info(java.lang.String, java.lang.Throwable)" map="C"/>
  <method class="freemarker.log.Logger" name="void logInLogger(boolean, java.lang.String, java.lang.Throwable)" map="A"/>
  <method class="freemarker.log.Logger" name="boolean hasLog4LibraryThatDelegatesToWorkingSLF4J()" map="C"/>
  <method class="freemarker.log.Logger" name="void warn(java.lang.String, java.lang.Throwable)" map="D"/>
  <method class="freemarker.log.Logger" name="java.lang.String getLibraryName(int)" map="C"/>
  <method class="freemarker.log.Logger" name="java.lang.String getAvailabilityCheckClassName(int)" map="D"/>
  <method class="freemarker.log.Logger" name="boolean isInfoEnabled()" map="D"/>
  <method class="freemarker.log.Logger" name="boolean isWarnEnabled()" map="E"/>
  <method class="freemarker.log.Logger" name="void debug(java.lang.String, java.lang.Throwable)" map="E"/>
  <method class="freemarker.log.Logger" name="void info(java.lang.String)" map="F"/>
  <method class="freemarker.log.Logger" name="freemarker.log.LoggerFactory createLoggerFactory(int)" map="E"/>
  <method class="freemarker.log.Logger" name="boolean isAutoDetected(int)" map="F"/>
  <method class="freemarker.log.Logger" name="java.lang.String getSystemProperty(java.lang.String)" map="G"/>
  <class name="freemarker.log._JULLoggerFactory$JULLogger" map="_A"/>
  <field class="freemarker.log._JULLoggerFactory$JULLogger" name="logger" map="G"/>
  <method class="freemarker.log._JULLoggerFactory$JULLogger" name="void warn(java.lang.String)" map="D"/>
  <method class="freemarker.log._JULLoggerFactory$JULLogger" name="void error(java.lang.String, java.lang.Throwable)" map="B"/>
  <method class="freemarker.log._JULLoggerFactory$JULLogger" name="void info(java.lang.String, java.lang.Throwable)" map="C"/>
  <method class="freemarker.log._JULLoggerFactory$JULLogger" name="void debug(java.lang.String, java.lang.Throwable)" map="E"/>
  <method class="freemarker.log._JULLoggerFactory$JULLogger" name="boolean isInfoEnabled()" map="D"/>
  <method class="freemarker.log._JULLoggerFactory$JULLogger" name="boolean isDebugEnabled()" map="B"/>
  <method class="freemarker.log._JULLoggerFactory$JULLogger" name="void debug(java.lang.String)" map="C"/>
  <method class="freemarker.log._JULLoggerFactory$JULLogger" name="void error(java.lang.String)" map="E"/>
  <method class="freemarker.log._JULLoggerFactory$JULLogger" name="boolean isWarnEnabled()" map="E"/>
  <method class="freemarker.log._JULLoggerFactory$JULLogger" name="boolean isErrorEnabled()" map="A"/>
  <method class="freemarker.log._JULLoggerFactory$JULLogger" name="void info(java.lang.String)" map="F"/>
  <method class="freemarker.log._JULLoggerFactory$JULLogger" name="void warn(java.lang.String, java.lang.Throwable)" map="D"/>
  <class name="freemarker.log._JULLoggerFactory" map="C"/>
  <method class="freemarker.log._JULLoggerFactory" name="freemarker.log.Logger getLogger(java.lang.String)" map="A"/>
  <class name="freemarker.log.LoggerFactory" map="D"/>
  <method class="freemarker.log.LoggerFactory" name="freemarker.log.Logger getLogger(java.lang.String)" map="A"/>
  <package name="freemarker.ext" map="F"/>
  <package name="freemarker.ext.util" map="A"/>
  <class name="freemarker.ext.util.WrapperTemplateModel" map="A"/>
  <method class="freemarker.ext.util.WrapperTemplateModel" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <class name="freemarker.ext.util.ModelCache$ModelReference" map="_A"/>
  <field class="freemarker.ext.util.ModelCache$ModelReference" name="object" map="A"/>
  <method class="freemarker.ext.util.ModelCache$ModelReference" name="freemarker.template.TemplateModel getModel()" map="A"/>
  <class name="freemarker.ext.util.ModelCache" map="B"/>
  <field class="freemarker.ext.util.ModelCache" name="useCache" map="A"/>
  <field class="freemarker.ext.util.ModelCache" name="refQueue" map="B"/>
  <field class="freemarker.ext.util.ModelCache" name="modelCache" map="C"/>
  <method class="freemarker.ext.util.ModelCache" name="boolean isCacheable(java.lang.Object)" map="A"/>
  <method class="freemarker.ext.util.ModelCache" name="freemarker.template.TemplateModel create(java.lang.Object)" map="B"/>
  <method class="freemarker.ext.util.ModelCache" name="freemarker.template.TemplateModel lookup(java.lang.Object)" map="C"/>
  <method class="freemarker.ext.util.ModelCache" name="void clearCache()" map="A"/>
  <method class="freemarker.ext.util.ModelCache" name="void register(freemarker.template.TemplateModel, java.lang.Object)" map="A"/>
  <method class="freemarker.ext.util.ModelCache" name="void setUseCache(boolean)" map="A"/>
  <method class="freemarker.ext.util.ModelCache" name="freemarker.template.TemplateModel getInstance(java.lang.Object)" map="D"/>
  <class name="freemarker.ext.util.ModelFactory" map="C"/>
  <method class="freemarker.ext.util.ModelFactory" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <package name="freemarker.ext.beans" map="B"/>
  <class name="freemarker.ext.beans.MaybeEmptyMemberAndArguments" map="A"/>
  <class name="freemarker.ext.beans.BeansWrapper$5" map="5"/>
  <method class="freemarker.ext.beans.BeansWrapper$5" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.beans.BeansWrapper$4" map="4"/>
  <method class="freemarker.ext.beans.BeansWrapper$4" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.beans.BeansWrapper$3" map="3"/>
  <field class="freemarker.ext.beans.BeansWrapper$3" name="this$0" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper$3" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.beans.BeansWrapper$2" map="2"/>
  <field class="freemarker.ext.beans.BeansWrapper$2" name="this$0" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper$2" name="void process(freemarker.ext.beans.BeansWrapper$MethodAppearanceDecisionInput, freemarker.ext.beans.BeansWrapper$MethodAppearanceDecision)" map="A"/>
  <class name="freemarker.ext.beans.BeansWrapper$1" map="1"/>
  <class name="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecision" map="_A"/>
  <field class="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecision" name="exposeMethodAs" map="A"/>
  <field class="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecision" name="exposeAsProperty" map="B"/>
  <field class="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecision" name="methodShadowsProperty" map="C"/>
  <field class="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecision" name="replaceExistingProperty" map="D"/>
  <method class="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecision" name="boolean getReplaceExistingProperty()" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecision" name="java.lang.String getExposeMethodAs()" map="B"/>
  <method class="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecision" name="boolean getMethodShadowsProperty()" map="C"/>
  <method class="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecision" name="java.beans.PropertyDescriptor getExposeAsProperty()" map="D"/>
  <method class="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecision" name="void setDefaults(java.lang.reflect.Method)" map="A"/>
  <class name="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecisionInput" map="_B"/>
  <field class="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecisionInput" name="containingClass" map="A"/>
  <field class="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecisionInput" name="method" map="B"/>
  <method class="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecisionInput" name="void setContainingClass(java.lang.Class)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecisionInput" name="void setMethod(java.lang.reflect.Method)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecisionInput" name="java.lang.Class getContainingClass()" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper$MethodAppearanceDecisionInput" name="java.lang.reflect.Method getMethod()" map="B"/>
  <class name="freemarker.ext.beans.BeansWrapper" map="B"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="nullModel" map="E"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="methodsShadowItems" map="F"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="ENUMERATION_FACTORY" map="G"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="BOOLEAN_FACTORY" map="H"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="falseModel" map="I"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="simpleMapWrapper" map="J"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="incompatibleImprovements" map="K"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="defaultDateType" map="L"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="LOG" map="M"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="modelCache" map="N"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="trueModel" map="O"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="CAN_NOT_UNWRAP" map="P"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="outerIdentity" map="Q"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="preferIndexedReadMethod" map="R"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="classIntrospector" map="S"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="staticModels" map="T"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="sharedIntrospectionLock" map="U"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="writeProtected" map="V"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="enumModels" map="W"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="ITERATOR_FACTORY" map="X"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="ftmaDeprecationWarnLogged" map="Y"/>
  <field class="freemarker.ext.beans.BeansWrapper" name="strict" map="Z"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="freemarker.ext.beans.BeansWrapper getDefaultInstance()" map="B"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="void writeProtect()" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="java.lang.Object coerceBigDecimal(java.math.BigDecimal, java.lang.Class)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="java.lang.Object tryUnwrapTo(freemarker.template.TemplateModel, java.lang.Class, int, java.util.Map)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="freemarker.template.Version getIncompatibleImprovements()" map="C"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="int getExposureLevel()" map="D"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="void coerceBigDecimals(java.lang.Class[], java.lang.Object[])" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="boolean is2321Bugfixed()" map="E"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="freemarker.ext.beans.BooleanModel access$000(freemarker.ext.beans.BeansWrapper)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="boolean isStrict()" map="F"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="boolean is2321Bugfixed(freemarker.template.Version)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="void setUseCache(boolean)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="java.lang.Object unwrap(freemarker.template.TemplateModel, java.lang.Class)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="void registerModelFactories()" map="G"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="boolean isMethodsShadowItems()" map="H"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="int getDefaultDateType()" map="I"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="boolean isWriteProtected()" map="J"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="boolean getPreferIndexedReadMethod()" map="K"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="java.lang.Object unwrap(freemarker.template.TemplateModel)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="boolean is2324Bugfixed(freemarker.template.Version)" map="B"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="java.lang.Object newInstance(java.lang.Class, java.util.List)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="void setStrict(boolean)" map="B"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="java.lang.Object tryUnwrapTo(freemarker.template.TemplateModel, java.lang.Class)" map="B"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="freemarker.ext.beans.BooleanModel access$100(freemarker.ext.beans.BeansWrapper)" map="B"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="void finetuneMethodAppearance(java.lang.Class, java.lang.reflect.Method, freemarker.ext.beans.BeansWrapper$MethodAppearanceDecision)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="void finalizeConstruction(boolean)" map="C"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="java.lang.String toPropertiesString()" map="L"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="java.lang.Object unwrapSequenceToArray(freemarker.template.TemplateSequenceModel, java.lang.Class, boolean, java.util.Map)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="java.lang.Object getSharedIntrospectionLock()" map="M"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="java.lang.Object tryUnwrapTo(freemarker.template.TemplateModel, java.lang.Class, int)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="freemarker.template.TemplateModel wrap(java.lang.Object)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="java.lang.Number forceUnwrappedNumberToType(java.lang.Number, java.lang.Class, boolean)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="void checkModifiable()" map="N"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="boolean is2324Bugfixed()" map="O"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="freemarker.template.TemplateHashModel wrapAsAPI(java.lang.Object)" map="B"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="freemarker.ext.beans.ClassIntrospector getClassIntrospector()" map="P"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="freemarker.template.TemplateModel invokeMethod(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="java.lang.Object listToArray(java.util.List, java.lang.Class, java.util.Map)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="freemarker.template.ObjectWrapper getOuterIdentity()" map="Q"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="java.util.List arrayToList(java.lang.Object)" map="C"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="freemarker.template.Version normalizeIncompatibleImprovementsVersion(freemarker.template.Version)" map="C"/>
  <method class="freemarker.ext.beans.BeansWrapper" name="freemarker.ext.util.ModelFactory getModelFactory(java.lang.Class)" map="A"/>
  <class name="freemarker.ext.beans.CollectionModel$1" map="1"/>
  <method class="freemarker.ext.beans.CollectionModel$1" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.beans.CollectionModel" map="C"/>
  <field class="freemarker.ext.beans.CollectionModel" name="FACTORY" map="&#x019a;"/>
  <method class="freemarker.ext.beans.CollectionModel" name="boolean getSupportsIndexedAccess()" map="&#x00d6;"/>
  <method class="freemarker.ext.beans.CollectionModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.ext.beans.CollectionModel" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.ext.beans.CollectionModel" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <class name="freemarker.ext.beans.SimpleMethod" map="D"/>
  <field class="freemarker.ext.beans.SimpleMethod" name="argTypes" map="&#x012c;"/>
  <field class="freemarker.ext.beans.SimpleMethod" name="member" map="&#x012d;"/>
  <method class="freemarker.ext.beans.SimpleMethod" name="freemarker.template.TemplateModelException createArgumentTypeMismarchException(int, freemarker.template.TemplateModel, java.lang.Class)" map="A"/>
  <method class="freemarker.ext.beans.SimpleMethod" name="java.lang.Object[] unwrapArguments(java.util.List, freemarker.ext.beans.BeansWrapper)" map="A"/>
  <method class="freemarker.ext.beans.SimpleMethod" name="freemarker.template.TemplateModelException createNullToPrimitiveArgumentException(int, java.lang.Class)" map="A"/>
  <method class="freemarker.ext.beans.SimpleMethod" name="java.lang.reflect.Member getMember()" map="&#x00b5;"/>
  <method class="freemarker.ext.beans.SimpleMethod" name="java.lang.Object[] unwrapArguments(java.util.List, java.lang.Class[], boolean, freemarker.ext.beans.BeansWrapper)" map="A"/>
  <class name="freemarker.ext.beans.SimpleMapModel$1" map="1"/>
  <method class="freemarker.ext.beans.SimpleMapModel$1" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.beans.SimpleMapModel" map="E"/>
  <field class="freemarker.ext.beans.SimpleMapModel" name="map" map="&#x0195;"/>
  <field class="freemarker.ext.beans.SimpleMapModel" name="FACTORY" map="&#x0196;"/>
  <method class="freemarker.ext.beans.SimpleMapModel" name="java.lang.Object getAdaptedObject(java.lang.Class)" map="A"/>
  <method class="freemarker.ext.beans.SimpleMapModel" name="freemarker.template.TemplateCollectionModel values()" map="&#x00c9;"/>
  <method class="freemarker.ext.beans.SimpleMapModel" name="freemarker.template.TemplateCollectionModel keys()" map="&#x00c8;"/>
  <method class="freemarker.ext.beans.SimpleMapModel" name="freemarker.template.TemplateModel getAPI()" map="&#x00ce;"/>
  <method class="freemarker.ext.beans.SimpleMapModel" name="freemarker.template.TemplateHashModelEx2$KeyValuePairIterator keyValuePairIterator()" map="&#x00cb;"/>
  <method class="freemarker.ext.beans.SimpleMapModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.ext.beans.SimpleMapModel" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <method class="freemarker.ext.beans.SimpleMapModel" name="java.lang.Object exec(java.util.List)" map="A"/>
  <method class="freemarker.ext.beans.SimpleMapModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.ext.beans.SimpleMapModel" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <class name="freemarker.ext.beans.UnsafeMethods" map="F"/>
  <field class="freemarker.ext.beans.UnsafeMethods" name="UNSAFE_METHODS" map="A"/>
  <method class="freemarker.ext.beans.UnsafeMethods" name="java.util.Map createPrimitiveClassesMap()" map="A"/>
  <method class="freemarker.ext.beans.UnsafeMethods" name="boolean isUnsafeMethod(java.lang.reflect.Method)" map="A"/>
  <method class="freemarker.ext.beans.UnsafeMethods" name="java.util.Set createUnsafeMethodsSet()" map="B"/>
  <method class="freemarker.ext.beans.UnsafeMethods" name="java.lang.reflect.Method parseMethodSpec(java.lang.String, java.util.Map)" map="A"/>
  <class name="freemarker.ext.beans.EnumerationModel" map="G"/>
  <field class="freemarker.ext.beans.EnumerationModel" name="accessed" map="&#x01bb;"/>
  <method class="freemarker.ext.beans.EnumerationModel" name="boolean hasNext()" map="&#x00d1;"/>
  <method class="freemarker.ext.beans.EnumerationModel" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <method class="freemarker.ext.beans.EnumerationModel" name="freemarker.template.TemplateModel next()" map="&#x00d2;"/>
  <class name="freemarker.ext.beans.ArgumentTypes$SpecialConversionCallableMemberDescriptor" map="_A"/>
  <field class="freemarker.ext.beans.ArgumentTypes$SpecialConversionCallableMemberDescriptor" name="callableMemberDesc" map="E"/>
  <method class="freemarker.ext.beans.ArgumentTypes$SpecialConversionCallableMemberDescriptor" name="boolean isConstructor()" map="A"/>
  <method class="freemarker.ext.beans.ArgumentTypes$SpecialConversionCallableMemberDescriptor" name="void convertArgsToReflectionCompatible(freemarker.ext.beans.BeansWrapper, java.lang.Object[])" map="B"/>
  <method class="freemarker.ext.beans.ArgumentTypes$SpecialConversionCallableMemberDescriptor" name="java.lang.Class[] getParamTypes()" map="B"/>
  <method class="freemarker.ext.beans.ArgumentTypes$SpecialConversionCallableMemberDescriptor" name="java.lang.String getDeclaration()" map="C"/>
  <method class="freemarker.ext.beans.ArgumentTypes$SpecialConversionCallableMemberDescriptor" name="boolean isStatic()" map="D"/>
  <method class="freemarker.ext.beans.ArgumentTypes$SpecialConversionCallableMemberDescriptor" name="boolean isVarargs()" map="E"/>
  <method class="freemarker.ext.beans.ArgumentTypes$SpecialConversionCallableMemberDescriptor" name="java.lang.Object invokeConstructor(freemarker.ext.beans.BeansWrapper, java.lang.Object[])" map="A"/>
  <method class="freemarker.ext.beans.ArgumentTypes$SpecialConversionCallableMemberDescriptor" name="freemarker.template.TemplateModel invokeMethod(freemarker.ext.beans.BeansWrapper, java.lang.Object, java.lang.Object[])" map="A"/>
  <class name="freemarker.ext.beans.ArgumentTypes$Null" map="_B"/>
  <class name="freemarker.ext.beans.ArgumentTypes" map="H"/>
  <field class="freemarker.ext.beans.ArgumentTypes" name="bugfixed" map="A"/>
  <field class="freemarker.ext.beans.ArgumentTypes" name="types" map="B"/>
  <method class="freemarker.ext.beans.ArgumentTypes" name="freemarker.ext.beans.MaybeEmptyCallableMemberDescriptor getMostSpecific(java.util.List, boolean)" map="A"/>
  <method class="freemarker.ext.beans.ArgumentTypes" name="int isMethodInvocationConvertible(java.lang.Class, java.lang.Class)" map="A"/>
  <method class="freemarker.ext.beans.ArgumentTypes" name="int compareParameterListPreferability_cmpTypeSpecificty(java.lang.Class, java.lang.Class)" map="B"/>
  <method class="freemarker.ext.beans.ArgumentTypes" name="int hashCode()" map="hashCode"/>
  <method class="freemarker.ext.beans.ArgumentTypes" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="freemarker.ext.beans.ArgumentTypes" name="int isApplicable(freemarker.ext.beans.ReflectionCallableMemberDescriptor, boolean)" map="A"/>
  <method class="freemarker.ext.beans.ArgumentTypes" name="java.util.LinkedList getApplicables(java.util.List, boolean)" map="B"/>
  <method class="freemarker.ext.beans.ArgumentTypes" name="int compareParameterListPreferability(java.lang.Class[], java.lang.Class[], boolean)" map="A"/>
  <method class="freemarker.ext.beans.ArgumentTypes" name="java.lang.Class getParamType(java.lang.Class[], int, int, boolean)" map="A"/>
  <class name="freemarker.ext.beans.SequenceAdapter" map="I"/>
  <field class="freemarker.ext.beans.SequenceAdapter" name="model" map="A"/>
  <field class="freemarker.ext.beans.SequenceAdapter" name="wrapper" map="B"/>
  <method class="freemarker.ext.beans.SequenceAdapter" name="freemarker.template.TemplateModel getTemplateModel()" map="getTemplateModel"/>
  <method class="freemarker.ext.beans.SequenceAdapter" name="int size()" map="size"/>
  <method class="freemarker.ext.beans.SequenceAdapter" name="freemarker.template.TemplateSequenceModel getTemplateSequenceModel()" map="A"/>
  <method class="freemarker.ext.beans.SequenceAdapter" name="java.lang.Object get(int)" map="get"/>
  <class name="freemarker.ext.beans.HashAdapter$1$1$1" map="1"/>
  <field class="freemarker.ext.beans.HashAdapter$1$1$1" name="val$key" map="A"/>
  <field class="freemarker.ext.beans.HashAdapter$1$1$1" name="this$2" map="B"/>
  <method class="freemarker.ext.beans.HashAdapter$1$1$1" name="java.lang.Object getKey()" map="getKey"/>
  <method class="freemarker.ext.beans.HashAdapter$1$1$1" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="freemarker.ext.beans.HashAdapter$1$1$1" name="int hashCode()" map="hashCode"/>
  <method class="freemarker.ext.beans.HashAdapter$1$1$1" name="java.lang.Object setValue(java.lang.Object)" map="setValue"/>
  <method class="freemarker.ext.beans.HashAdapter$1$1$1" name="java.lang.Object getValue()" map="getValue"/>
  <class name="freemarker.ext.beans.HashAdapter$1$1" map="1"/>
  <field class="freemarker.ext.beans.HashAdapter$1$1" name="val$i" map="A"/>
  <field class="freemarker.ext.beans.HashAdapter$1$1" name="this$1" map="B"/>
  <method class="freemarker.ext.beans.HashAdapter$1$1" name="boolean hasNext()" map="hasNext"/>
  <method class="freemarker.ext.beans.HashAdapter$1$1" name="void remove()" map="remove"/>
  <method class="freemarker.ext.beans.HashAdapter$1$1" name="java.lang.Object next()" map="next"/>
  <class name="freemarker.ext.beans.HashAdapter$1" map="1"/>
  <field class="freemarker.ext.beans.HashAdapter$1" name="this$0" map="A"/>
  <method class="freemarker.ext.beans.HashAdapter$1" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="freemarker.ext.beans.HashAdapter$1" name="int size()" map="size"/>
  <class name="freemarker.ext.beans.HashAdapter" map="J"/>
  <field class="freemarker.ext.beans.HashAdapter" name="entrySet" map="C"/>
  <field class="freemarker.ext.beans.HashAdapter" name="model" map="D"/>
  <field class="freemarker.ext.beans.HashAdapter" name="wrapper" map="E"/>
  <method class="freemarker.ext.beans.HashAdapter" name="freemarker.template.TemplateModel getTemplateModel()" map="getTemplateModel"/>
  <method class="freemarker.ext.beans.HashAdapter" name="boolean containsKey(java.lang.Object)" map="containsKey"/>
  <method class="freemarker.ext.beans.HashAdapter" name="freemarker.ext.beans.BeansWrapper access$100(freemarker.ext.beans.HashAdapter)" map="A"/>
  <method class="freemarker.ext.beans.HashAdapter" name="java.util.Set entrySet()" map="entrySet"/>
  <method class="freemarker.ext.beans.HashAdapter" name="java.lang.Object get(java.lang.Object)" map="get"/>
  <method class="freemarker.ext.beans.HashAdapter" name="freemarker.template.TemplateHashModelEx access$000(freemarker.ext.beans.HashAdapter)" map="B"/>
  <method class="freemarker.ext.beans.HashAdapter" name="freemarker.template.TemplateHashModelEx getModelEx()" map="B"/>
  <method class="freemarker.ext.beans.HashAdapter" name="int size()" map="size"/>
  <method class="freemarker.ext.beans.HashAdapter" name="boolean isEmpty()" map="isEmpty"/>
  <class name="freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair" map="_A"/>
  <field class="freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair" name="indexedReadMethod" map="A"/>
  <field class="freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair" name="readMethod" map="B"/>
  <method class="freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair" name="java.lang.reflect.Method access$000(freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair" name="java.lang.reflect.Method access$100(freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair)" map="B"/>
  <method class="freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair" name="int hashCode()" map="hashCode"/>
  <method class="freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair" name="freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair merge(freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair, freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair" name="freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair from(java.lang.Object)" map="A"/>
  <class name="freemarker.ext.beans.ClassIntrospector$MethodSignature" map="_B"/>
  <field class="freemarker.ext.beans.ClassIntrospector$MethodSignature" name="args" map="A"/>
  <field class="freemarker.ext.beans.ClassIntrospector$MethodSignature" name="name" map="B"/>
  <field class="freemarker.ext.beans.ClassIntrospector$MethodSignature" name="GET_STRING_SIGNATURE" map="C"/>
  <field class="freemarker.ext.beans.ClassIntrospector$MethodSignature" name="GET_OBJECT_SIGNATURE" map="D"/>
  <method class="freemarker.ext.beans.ClassIntrospector$MethodSignature" name="freemarker.ext.beans.ClassIntrospector$MethodSignature access$300()" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector$MethodSignature" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="freemarker.ext.beans.ClassIntrospector$MethodSignature" name="int hashCode()" map="hashCode"/>
  <method class="freemarker.ext.beans.ClassIntrospector$MethodSignature" name="freemarker.ext.beans.ClassIntrospector$MethodSignature access$200()" map="B"/>
  <class name="freemarker.ext.beans.ClassIntrospector" map="K"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="DEVELOPMENT_MODE" map="A"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="ARG_TYPES_BY_METHOD_KEY" map="B"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="CONSTRUCTORS_KEY" map="C"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="shared" map="D"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="treatDefaultMethodsAsBeanMembers" map="E"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="modelFactories" map="F"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="hasSharedInstanceRestrictons" map="G"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="bugfixed" map="H"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="clearingCounter" map="I"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="methodSorter" map="J"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="CLASS_CHANGE_NOTIFIER" map="K"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="exposureLevel" map="L"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="modelFactoriesRefQueue" map="M"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="LOG" map="N"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="GENERIC_GET_KEY" map="O"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="cache" map="P"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="classIntrospectionsInProgress" map="Q"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="cacheClassNames" map="R"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="methodAppearanceFineTuner" map="S"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="sharedLock" map="T"/>
  <field class="freemarker.ext.beans.ClassIntrospector" name="exposeFields" map="U"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="java.lang.reflect.Method getFirstAccessibleMethod(freemarker.ext.beans.ClassIntrospector$MethodSignature, java.util.Map)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void onSameNameClassesDetected(java.lang.String)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="int getExposureLevel()" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="int keyCount(java.lang.Class)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void addConstructorsToClassIntrospectionData(java.util.Map, java.lang.Class)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="int getClearingCounter()" map="B"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void sortMethodDescriptors(java.util.List)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void discoverAccessibleMethods(java.lang.Class, java.util.Map)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void registerModelFactory(freemarker.ext.beans.ClassBasedModelFactory)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void addPropertyDescriptorToClassIntrospectionData(java.util.Map, java.beans.PropertyDescriptor, java.lang.Class, java.util.Map)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="boolean getExposeFields()" map="C"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="java.util.Set keySet(java.lang.Class)" map="B"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void registerModelFactory(java.lang.Object)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="java.util.Map get(java.lang.Class)" map="C"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="java.lang.Class[] getArgTypes(java.util.Map, java.lang.reflect.Method)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void addFieldsToClassIntrospectionData(java.util.Map, java.lang.Class)" map="B"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="java.util.List getMethodDescriptors(java.beans.BeanInfo, java.lang.Class)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="boolean getTreatDefaultMethodsAsBeanMembers()" map="D"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="boolean isAllowedToExpose(java.lang.reflect.Method)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="java.util.Map createClassIntrospectionData(java.lang.Class)" map="D"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="java.util.Map getArgTypesByMethod(java.util.Map)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void mergeInPropertyDescriptor(java.util.LinkedHashMap, java.beans.PropertyDescriptor)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void putIfMergedPropertyReaderMethodPairDiffers(java.util.LinkedHashMap, java.lang.String, java.lang.Object, freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void mergeInPropertyReaderMethod(java.util.LinkedHashMap, java.lang.String, java.lang.reflect.Method)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="boolean isShared()" map="E"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void addGenericGetToClassIntrospectionData(java.util.Map, java.util.Map)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="boolean containsMethodWithSameParameterTypes(java.util.List, java.lang.reflect.Method)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="java.util.Map discoverAccessibleMethods(java.lang.Class)" map="E"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void forcedClearCache()" map="F"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void mergeInPropertyReaderMethodPair(java.util.LinkedHashMap, java.lang.String, freemarker.ext.beans.ClassIntrospector$PropertyReaderMethodPair)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="java.util.List getPropertyDescriptors(java.beans.BeanInfo, java.lang.Class)" map="B"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void registerModelFactory(freemarker.ext.util.ModelCache)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void addBeanInfoToClassIntrospectionData(java.util.Map, java.lang.Class, java.util.Map)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="java.lang.Object getSharedLock()" map="G"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="java.lang.reflect.Method getMatchingAccessibleMethod(java.lang.reflect.Method, java.util.Map)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospector" name="void removeClearedModelFactoryReferences()" map="H"/>
  <class name="freemarker.ext.beans._EnumModels" map="L"/>
  <method class="freemarker.ext.beans._EnumModels" name="freemarker.template.TemplateModel createModel(java.lang.Class)" map="B"/>
  <method class="freemarker.ext.beans._EnumModels" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.ext.beans._EnumModels" name="boolean isEmpty()" map="&#x00c7;"/>
  <class name="freemarker.ext.beans.StringModel$1" map="1"/>
  <method class="freemarker.ext.beans.StringModel$1" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.beans.StringModel" map="M"/>
  <field class="freemarker.ext.beans.StringModel" name="FACTORY" map="&#x019a;"/>
  <method class="freemarker.ext.beans.StringModel" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <class name="freemarker.ext.beans.NumberModel$1" map="1"/>
  <method class="freemarker.ext.beans.NumberModel$1" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.beans.NumberModel" map="N"/>
  <field class="freemarker.ext.beans.NumberModel" name="FACTORY" map="&#x019a;"/>
  <method class="freemarker.ext.beans.NumberModel" name="java.lang.Number getAsNumber()" map="&#x00d8;"/>
  <class name="freemarker.ext.beans.CollectionAdapter$1" map="1"/>
  <field class="freemarker.ext.beans.CollectionAdapter$1" name="this$0" map="A"/>
  <field class="freemarker.ext.beans.CollectionAdapter$1" name="i" map="B"/>
  <method class="freemarker.ext.beans.CollectionAdapter$1" name="boolean hasNext()" map="hasNext"/>
  <method class="freemarker.ext.beans.CollectionAdapter$1" name="void remove()" map="remove"/>
  <method class="freemarker.ext.beans.CollectionAdapter$1" name="java.lang.Object next()" map="next"/>
  <class name="freemarker.ext.beans.CollectionAdapter" map="O"/>
  <field class="freemarker.ext.beans.CollectionAdapter" name="model" map="F"/>
  <field class="freemarker.ext.beans.CollectionAdapter" name="wrapper" map="G"/>
  <method class="freemarker.ext.beans.CollectionAdapter" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="freemarker.ext.beans.CollectionAdapter" name="freemarker.template.TemplateModel getTemplateModel()" map="getTemplateModel"/>
  <method class="freemarker.ext.beans.CollectionAdapter" name="int size()" map="size"/>
  <method class="freemarker.ext.beans.CollectionAdapter" name="freemarker.ext.beans.BeansWrapper access$100(freemarker.ext.beans.CollectionAdapter)" map="A"/>
  <method class="freemarker.ext.beans.CollectionAdapter" name="freemarker.template.TemplateCollectionModel access$000(freemarker.ext.beans.CollectionAdapter)" map="B"/>
  <class name="freemarker.ext.beans.ResourceBundleModel$1" map="1"/>
  <method class="freemarker.ext.beans.ResourceBundleModel$1" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.beans.ResourceBundleModel" map="P"/>
  <field class="freemarker.ext.beans.ResourceBundleModel" name="formats" map="&#x01c1;"/>
  <field class="freemarker.ext.beans.ResourceBundleModel" name="FACTORY" map="&#x019a;"/>
  <method class="freemarker.ext.beans.ResourceBundleModel" name="java.util.ResourceBundle getBundle()" map="&#x00d9;"/>
  <method class="freemarker.ext.beans.ResourceBundleModel" name="java.lang.Object exec(java.util.List)" map="A"/>
  <method class="freemarker.ext.beans.ResourceBundleModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.ext.beans.ResourceBundleModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.ext.beans.ResourceBundleModel" name="java.util.Set keySet()" map="&#x00d0;"/>
  <method class="freemarker.ext.beans.ResourceBundleModel" name="freemarker.template.TemplateModel invokeGenericGet(java.util.Map, java.lang.Class, java.lang.String)" map="A"/>
  <method class="freemarker.ext.beans.ResourceBundleModel" name="java.lang.String format(java.lang.String, java.lang.Object[])" map="A"/>
  <class name="freemarker.ext.beans.NonPrimitiveArrayBackedReadOnlyList" map="Q"/>
  <field class="freemarker.ext.beans.NonPrimitiveArrayBackedReadOnlyList" name="array" map="A"/>
  <method class="freemarker.ext.beans.NonPrimitiveArrayBackedReadOnlyList" name="int size()" map="size"/>
  <method class="freemarker.ext.beans.NonPrimitiveArrayBackedReadOnlyList" name="java.lang.Object get(int)" map="get"/>
  <class name="freemarker.ext.beans.PrimtiveArrayBackedReadOnlyList" map="R"/>
  <field class="freemarker.ext.beans.PrimtiveArrayBackedReadOnlyList" name="array" map="A"/>
  <method class="freemarker.ext.beans.PrimtiveArrayBackedReadOnlyList" name="int size()" map="size"/>
  <method class="freemarker.ext.beans.PrimtiveArrayBackedReadOnlyList" name="java.lang.Object get(int)" map="get"/>
  <class name="freemarker.ext.beans.OverloadedVarArgsMethods" map="S"/>
  <method class="freemarker.ext.beans.OverloadedVarArgsMethods" name="freemarker.ext.beans.MaybeEmptyMemberAndArguments getMemberAndArguments(java.util.List, freemarker.ext.beans.BeansWrapper)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedVarArgsMethods" name="void widenHintsToCommonSupertypes(int, java.lang.Class[], int[])" map="A"/>
  <method class="freemarker.ext.beans.OverloadedVarArgsMethods" name="java.lang.Class[] preprocessParameterTypes(freemarker.ext.beans.CallableMemberDescriptor)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedVarArgsMethods" name="void afterWideningUnwrappingHints(java.lang.Class[], int[])" map="A"/>
  <method class="freemarker.ext.beans.OverloadedVarArgsMethods" name="java.lang.Object replaceVarargsSectionWithArray(java.lang.Object[], java.util.List, freemarker.ext.beans.CallableMemberDescriptor, freemarker.ext.beans.BeansWrapper)" map="A"/>
  <class name="freemarker.ext.beans.ArrayModel$1" map="1"/>
  <method class="freemarker.ext.beans.ArrayModel$1" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.beans.ArrayModel$Iterator" map="_A"/>
  <field class="freemarker.ext.beans.ArrayModel$Iterator" name="this$0" map="&#x01b6;"/>
  <field class="freemarker.ext.beans.ArrayModel$Iterator" name="position" map="&#x01b7;"/>
  <method class="freemarker.ext.beans.ArrayModel$Iterator" name="boolean hasNext()" map="&#x00d1;"/>
  <method class="freemarker.ext.beans.ArrayModel$Iterator" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.ext.beans.ArrayModel$Iterator" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.ext.beans.ArrayModel$Iterator" name="freemarker.template.TemplateModel next()" map="&#x00d2;"/>
  <class name="freemarker.ext.beans.ArrayModel" map="T"/>
  <field class="freemarker.ext.beans.ArrayModel" name="length" map="&#x01c2;"/>
  <field class="freemarker.ext.beans.ArrayModel" name="FACTORY" map="&#x019a;"/>
  <method class="freemarker.ext.beans.ArrayModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.ext.beans.ArrayModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.ext.beans.ArrayModel" name="int access$100(freemarker.ext.beans.ArrayModel)" map="A"/>
  <method class="freemarker.ext.beans.ArrayModel" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.ext.beans.ArrayModel" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <class name="freemarker.ext.beans.MemberAndArguments" map="U"/>
  <field class="freemarker.ext.beans.MemberAndArguments" name="args" map="A"/>
  <field class="freemarker.ext.beans.MemberAndArguments" name="callableMemberDesc" map="B"/>
  <method class="freemarker.ext.beans.MemberAndArguments" name="freemarker.template.TemplateModel invokeMethod(freemarker.ext.beans.BeansWrapper, java.lang.Object)" map="A"/>
  <method class="freemarker.ext.beans.MemberAndArguments" name="freemarker.ext.beans.CallableMemberDescriptor getCallableMemberDescriptor()" map="A"/>
  <method class="freemarker.ext.beans.MemberAndArguments" name="java.lang.Object invokeConstructor(freemarker.ext.beans.BeansWrapper)" map="A"/>
  <class name="freemarker.ext.beans.BeansWrapperSingletonHolder" map="V"/>
  <field class="freemarker.ext.beans.BeansWrapperSingletonHolder" name="INSTANCE" map="A"/>
  <class name="freemarker.ext.beans.MethodSorter" map="W"/>
  <method class="freemarker.ext.beans.MethodSorter" name="void sortMethodDescriptors(java.util.List)" map="A"/>
  <class name="freemarker.ext.beans.EmptyCallableMemberDescriptor" map="X"/>
  <field class="freemarker.ext.beans.EmptyCallableMemberDescriptor" name="AMBIGUOUS_METHOD" map="A"/>
  <field class="freemarker.ext.beans.EmptyCallableMemberDescriptor" name="NO_SUCH_METHOD" map="B"/>
  <class name="freemarker.ext.beans.BeansModelCache" map="Y"/>
  <field class="freemarker.ext.beans.BeansModelCache" name="classToFactory" map="D"/>
  <field class="freemarker.ext.beans.BeansModelCache" name="wrapper" map="E"/>
  <field class="freemarker.ext.beans.BeansModelCache" name="mappedClassNames" map="F"/>
  <method class="freemarker.ext.beans.BeansModelCache" name="boolean isCacheable(java.lang.Object)" map="A"/>
  <method class="freemarker.ext.beans.BeansModelCache" name="freemarker.template.TemplateModel create(java.lang.Object)" map="B"/>
  <class name="freemarker.ext.beans.OverloadedFixArgsMethods" map="Z"/>
  <method class="freemarker.ext.beans.OverloadedFixArgsMethods" name="freemarker.ext.beans.MaybeEmptyMemberAndArguments getMemberAndArguments(java.util.List, freemarker.ext.beans.BeansWrapper)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedFixArgsMethods" name="java.lang.Class[] preprocessParameterTypes(freemarker.ext.beans.CallableMemberDescriptor)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedFixArgsMethods" name="void afterWideningUnwrappingHints(java.lang.Class[], int[])" map="A"/>
  <class name="freemarker.ext.beans.OverloadedMethods$3" map="3"/>
  <field class="freemarker.ext.beans.OverloadedMethods$3" name="this$0" map="E"/>
  <method class="freemarker.ext.beans.OverloadedMethods$3" name="java.lang.String argumentToString(java.lang.Object)" map="B"/>
  <class name="freemarker.ext.beans.OverloadedMethods$2" map="2"/>
  <field class="freemarker.ext.beans.OverloadedMethods$2" name="this$0" map="E"/>
  <method class="freemarker.ext.beans.OverloadedMethods$2" name="java.lang.String argumentToString(java.lang.Object)" map="B"/>
  <class name="freemarker.ext.beans.OverloadedMethods$1" map="1"/>
  <field class="freemarker.ext.beans.OverloadedMethods$1" name="this$0" map="D"/>
  <method class="freemarker.ext.beans.OverloadedMethods$1" name="java.lang.String doConversion(java.lang.Object)" map="A"/>
  <class name="freemarker.ext.beans.OverloadedMethods$DelayedCallSignatureToString" map="_A"/>
  <field class="freemarker.ext.beans.OverloadedMethods$DelayedCallSignatureToString" name="this$0" map="E"/>
  <method class="freemarker.ext.beans.OverloadedMethods$DelayedCallSignatureToString" name="java.lang.String argumentToString(java.lang.Object)" map="B"/>
  <method class="freemarker.ext.beans.OverloadedMethods$DelayedCallSignatureToString" name="java.lang.String doConversion(java.lang.Object)" map="A"/>
  <class name="freemarker.ext.beans.OverloadedMethods" map="_"/>
  <field class="freemarker.ext.beans.OverloadedMethods" name="bugfixed" map="A"/>
  <field class="freemarker.ext.beans.OverloadedMethods" name="fixArgMethods" map="B"/>
  <field class="freemarker.ext.beans.OverloadedMethods" name="varargMethods" map="C"/>
  <method class="freemarker.ext.beans.OverloadedMethods" name="freemarker.core._DelayedConversionToString getTMActualParameterTypes(java.util.List)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethods" name="void addMarkupBITipAfterNoNoMarchIfApplicable(freemarker.core._ErrorDescriptionBuilder, java.util.List)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethods" name="java.lang.Object[] toCompositeErrorMessage(freemarker.ext.beans.EmptyMemberAndArguments, freemarker.ext.beans.EmptyMemberAndArguments, java.util.List)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethods" name="void addMethod(java.lang.reflect.Method)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethods" name="java.lang.Object[] toErrorMessage(freemarker.ext.beans.EmptyMemberAndArguments, java.util.List)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethods" name="freemarker.ext.beans.OverloadedMethodsSubset access$000(freemarker.ext.beans.OverloadedMethods)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethods" name="freemarker.ext.beans.MemberAndArguments getMemberAndArguments(java.util.List, freemarker.ext.beans.BeansWrapper)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethods" name="java.lang.Object getUnwrappedActualParameterTypes(java.lang.Object[])" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethods" name="void addCallableMemberDescriptor(freemarker.ext.beans.ReflectionCallableMemberDescriptor)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethods" name="void addConstructor(java.lang.reflect.Constructor)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethods" name="freemarker.core._DelayedConversionToString memberListToString()" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethods" name="freemarker.ext.beans.OverloadedMethodsSubset access$100(freemarker.ext.beans.OverloadedMethods)" map="B"/>
  <class name="freemarker.ext.beans._BeansAPI$_BeansWrapperSubclassFactory" map="_A"/>
  <method class="freemarker.ext.beans._BeansAPI$_BeansWrapperSubclassFactory" name="freemarker.ext.beans.BeansWrapper create(freemarker.ext.beans.BeansWrapperConfiguration)" map="A"/>
  <class name="freemarker.ext.beans._BeansAPI" map="a"/>
  <method class="freemarker.ext.beans._BeansAPI" name="freemarker.ext.beans.BeansWrapper getBeansWrapperSubclassSingleton(freemarker.ext.beans.BeansWrapperConfiguration, java.util.Map, java.lang.ref.ReferenceQueue, freemarker.ext.beans._BeansAPI$_BeansWrapperSubclassFactory)" map="A"/>
  <method class="freemarker.ext.beans._BeansAPI" name="freemarker.ext.beans.BeansWrapperConfiguration clone(freemarker.ext.beans.BeansWrapperConfiguration)" map="A"/>
  <method class="freemarker.ext.beans._BeansAPI" name="java.lang.String getAsClassicCompatibleString(freemarker.ext.beans.BeanModel)" map="A"/>
  <method class="freemarker.ext.beans._BeansAPI" name="void removeClearedReferencesFromCache(java.util.Map, java.lang.ref.ReferenceQueue)" map="A"/>
  <method class="freemarker.ext.beans._BeansAPI" name="freemarker.ext.beans.ClassIntrospectorBuilder getClassIntrospectorBuilder(freemarker.ext.beans.BeansWrapperConfiguration)" map="B"/>
  <class name="freemarker.ext.beans.StaticModels" map="b"/>
  <method class="freemarker.ext.beans.StaticModels" name="freemarker.template.TemplateModel createModel(java.lang.Class)" map="B"/>
  <class name="freemarker.ext.beans.InvalidPropertyException" map="c"/>
  <class name="freemarker.ext.beans.OverloadedMethodsModel" map="d"/>
  <field class="freemarker.ext.beans.OverloadedMethodsModel" name="overloadedMethods" map="&#x020c;"/>
  <field class="freemarker.ext.beans.OverloadedMethodsModel" name="object" map="&#x020d;"/>
  <field class="freemarker.ext.beans.OverloadedMethodsModel" name="wrapper" map="&#x020e;"/>
  <method class="freemarker.ext.beans.OverloadedMethodsModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.ext.beans.OverloadedMethodsModel" name="java.lang.Object exec(java.util.List)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethodsModel" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <class name="freemarker.ext.beans.SimpleMethodModel" map="e"/>
  <field class="freemarker.ext.beans.SimpleMethodModel" name="object" map="&#x020f;"/>
  <field class="freemarker.ext.beans.SimpleMethodModel" name="wrapper" map="&#x0210;"/>
  <method class="freemarker.ext.beans.SimpleMethodModel" name="java.lang.Object[] explainTypeError(java.lang.Class[])" map="A"/>
  <method class="freemarker.ext.beans.SimpleMethodModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.ext.beans.SimpleMethodModel" name="java.lang.Object exec(java.util.List)" map="A"/>
  <method class="freemarker.ext.beans.SimpleMethodModel" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.ext.beans.SimpleMethodModel" name="java.lang.String toString()" map="toString"/>
  <class name="freemarker.ext.beans.FastPropertyDescriptor" map="f"/>
  <field class="freemarker.ext.beans.FastPropertyDescriptor" name="indexedReadMethod" map="A"/>
  <field class="freemarker.ext.beans.FastPropertyDescriptor" name="readMethod" map="B"/>
  <method class="freemarker.ext.beans.FastPropertyDescriptor" name="java.lang.reflect.Method getIndexedReadMethod()" map="A"/>
  <method class="freemarker.ext.beans.FastPropertyDescriptor" name="java.lang.reflect.Method getReadMethod()" map="B"/>
  <class name="freemarker.ext.beans.EmptyMemberAndArguments" map="g"/>
  <field class="freemarker.ext.beans.EmptyMemberAndArguments" name="WRONG_NUMBER_OF_ARGUMENTS" map="C"/>
  <field class="freemarker.ext.beans.EmptyMemberAndArguments" name="unwrappedArguments" map="D"/>
  <field class="freemarker.ext.beans.EmptyMemberAndArguments" name="errorDescription" map="E"/>
  <field class="freemarker.ext.beans.EmptyMemberAndArguments" name="numberOfArgumentsWrong" map="F"/>
  <method class="freemarker.ext.beans.EmptyMemberAndArguments" name="freemarker.ext.beans.EmptyMemberAndArguments noCompatibleOverload(java.lang.Object[])" map="A"/>
  <method class="freemarker.ext.beans.EmptyMemberAndArguments" name="boolean isNumberOfArgumentsWrong()" map="B"/>
  <method class="freemarker.ext.beans.EmptyMemberAndArguments" name="freemarker.ext.beans.EmptyMemberAndArguments noCompatibleOverload(int)" map="A"/>
  <method class="freemarker.ext.beans.EmptyMemberAndArguments" name="java.lang.Object getErrorDescription()" map="C"/>
  <method class="freemarker.ext.beans.EmptyMemberAndArguments" name="freemarker.ext.beans.MaybeEmptyMemberAndArguments from(freemarker.ext.beans.EmptyCallableMemberDescriptor, java.lang.Object[])" map="A"/>
  <method class="freemarker.ext.beans.EmptyMemberAndArguments" name="freemarker.ext.beans.EmptyMemberAndArguments ambiguous(java.lang.Object[])" map="B"/>
  <method class="freemarker.ext.beans.EmptyMemberAndArguments" name="java.lang.Object[] getUnwrappedArguments()" map="D"/>
  <class name="freemarker.ext.beans.ClassBasedModelFactory" map="h"/>
  <field class="freemarker.ext.beans.ClassBasedModelFactory" name="cache" map="&#x0203;"/>
  <field class="freemarker.ext.beans.ClassBasedModelFactory" name="classIntrospectionsInProgress" map="&#x0204;"/>
  <field class="freemarker.ext.beans.ClassBasedModelFactory" name="wrapper" map="&#x0205;"/>
  <method class="freemarker.ext.beans.ClassBasedModelFactory" name="freemarker.template.TemplateModel createModel(java.lang.Class)" map="B"/>
  <method class="freemarker.ext.beans.ClassBasedModelFactory" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.ext.beans.ClassBasedModelFactory" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.ext.beans.ClassBasedModelFactory" name="freemarker.template.TemplateModel getInternal(java.lang.String)" map="L"/>
  <method class="freemarker.ext.beans.ClassBasedModelFactory" name="freemarker.ext.beans.BeansWrapper getWrapper()" map="&#x00f3;"/>
  <method class="freemarker.ext.beans.ClassBasedModelFactory" name="void clearCache()" map="&#x00f4;"/>
  <class name="freemarker.ext.beans.ClassIntrospectorBuilder" map="i"/>
  <field class="freemarker.ext.beans.ClassIntrospectorBuilder" name="bugfixed" map="A"/>
  <field class="freemarker.ext.beans.ClassIntrospectorBuilder" name="methodSorter" map="B"/>
  <field class="freemarker.ext.beans.ClassIntrospectorBuilder" name="INSTANCE_CACHE" map="C"/>
  <field class="freemarker.ext.beans.ClassIntrospectorBuilder" name="exposeFields" map="D"/>
  <field class="freemarker.ext.beans.ClassIntrospectorBuilder" name="exposureLevel" map="E"/>
  <field class="freemarker.ext.beans.ClassIntrospectorBuilder" name="INSTANCE_CACHE_REF_QUEUE" map="F"/>
  <field class="freemarker.ext.beans.ClassIntrospectorBuilder" name="methodAppearanceFineTuner" map="G"/>
  <field class="freemarker.ext.beans.ClassIntrospectorBuilder" name="treatDefaultMethodsAsBeanMembers" map="H"/>
  <method class="freemarker.ext.beans.ClassIntrospectorBuilder" name="void removeClearedReferencesFromInstanceCache()" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospectorBuilder" name="int hashCode()" map="hashCode"/>
  <method class="freemarker.ext.beans.ClassIntrospectorBuilder" name="int getExposureLevel()" map="B"/>
  <method class="freemarker.ext.beans.ClassIntrospectorBuilder" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="freemarker.ext.beans.ClassIntrospectorBuilder" name="void setMethodAppearanceFineTuner(freemarker.ext.beans.MethodAppearanceFineTuner)" map="A"/>
  <method class="freemarker.ext.beans.ClassIntrospectorBuilder" name="freemarker.ext.beans.MethodAppearanceFineTuner getMethodAppearanceFineTuner()" map="C"/>
  <method class="freemarker.ext.beans.ClassIntrospectorBuilder" name="freemarker.ext.beans.ClassIntrospector build()" map="D"/>
  <method class="freemarker.ext.beans.ClassIntrospectorBuilder" name="freemarker.ext.beans.MethodSorter getMethodSorter()" map="E"/>
  <method class="freemarker.ext.beans.ClassIntrospectorBuilder" name="boolean isBugfixed()" map="F"/>
  <method class="freemarker.ext.beans.ClassIntrospectorBuilder" name="boolean getExposeFields()" map="G"/>
  <method class="freemarker.ext.beans.ClassIntrospectorBuilder" name="java.lang.Object clone()" map="clone"/>
  <method class="freemarker.ext.beans.ClassIntrospectorBuilder" name="boolean getTreatDefaultMethodsAsBeanMembers()" map="H"/>
  <class name="freemarker.ext.beans.BeansWrapperConfiguration" map="j"/>
  <field class="freemarker.ext.beans.BeansWrapperConfiguration" name="strict" map="A"/>
  <field class="freemarker.ext.beans.BeansWrapperConfiguration" name="defaultDateType" map="B"/>
  <field class="freemarker.ext.beans.BeansWrapperConfiguration" name="outerIdentity" map="C"/>
  <field class="freemarker.ext.beans.BeansWrapperConfiguration" name="useModelCache" map="D"/>
  <field class="freemarker.ext.beans.BeansWrapperConfiguration" name="classIntrospectorBuilder" map="E"/>
  <field class="freemarker.ext.beans.BeansWrapperConfiguration" name="simpleMapWrapper" map="F"/>
  <field class="freemarker.ext.beans.BeansWrapperConfiguration" name="preferIndexedReadMethod" map="G"/>
  <field class="freemarker.ext.beans.BeansWrapperConfiguration" name="incompatibleImprovements" map="H"/>
  <method class="freemarker.ext.beans.BeansWrapperConfiguration" name="freemarker.ext.beans.ClassIntrospectorBuilder getClassIntrospectorBuilder()" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapperConfiguration" name="freemarker.template.Version getIncompatibleImprovements()" map="B"/>
  <method class="freemarker.ext.beans.BeansWrapperConfiguration" name="int hashCode()" map="hashCode"/>
  <method class="freemarker.ext.beans.BeansWrapperConfiguration" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="freemarker.ext.beans.BeansWrapperConfiguration" name="boolean isSimpleMapWrapper()" map="C"/>
  <method class="freemarker.ext.beans.BeansWrapperConfiguration" name="freemarker.template.ObjectWrapper getOuterIdentity()" map="D"/>
  <method class="freemarker.ext.beans.BeansWrapperConfiguration" name="void setMethodAppearanceFineTuner(freemarker.ext.beans.MethodAppearanceFineTuner)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapperConfiguration" name="freemarker.ext.beans.MethodAppearanceFineTuner getMethodAppearanceFineTuner()" map="E"/>
  <method class="freemarker.ext.beans.BeansWrapperConfiguration" name="boolean getUseModelCache()" map="F"/>
  <method class="freemarker.ext.beans.BeansWrapperConfiguration" name="java.lang.Object clone(boolean)" map="A"/>
  <method class="freemarker.ext.beans.BeansWrapperConfiguration" name="boolean isStrict()" map="G"/>
  <method class="freemarker.ext.beans.BeansWrapperConfiguration" name="int getDefaultDateType()" map="H"/>
  <method class="freemarker.ext.beans.BeansWrapperConfiguration" name="boolean getPreferIndexedReadMethod()" map="I"/>
  <class name="freemarker.ext.beans.APIModel" map="k"/>
  <class name="freemarker.ext.beans.IteratorModel" map="l"/>
  <field class="freemarker.ext.beans.IteratorModel" name="accessed" map="&#x01b8;"/>
  <method class="freemarker.ext.beans.IteratorModel" name="boolean hasNext()" map="&#x00d1;"/>
  <method class="freemarker.ext.beans.IteratorModel" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <method class="freemarker.ext.beans.IteratorModel" name="freemarker.template.TemplateModel next()" map="&#x00d2;"/>
  <class name="freemarker.ext.beans.SingletonCustomizer" map="m"/>
  <class name="freemarker.ext.beans.DateModel$1" map="1"/>
  <method class="freemarker.ext.beans.DateModel$1" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.beans.DateModel" map="n"/>
  <field class="freemarker.ext.beans.DateModel" name="type" map="&#x01cb;"/>
  <field class="freemarker.ext.beans.DateModel" name="FACTORY" map="&#x019a;"/>
  <method class="freemarker.ext.beans.DateModel" name="java.util.Date getAsDate()" map="&#x00da;"/>
  <method class="freemarker.ext.beans.DateModel" name="int getDateType()" map="&#x00db;"/>
  <class name="freemarker.ext.beans.TypeFlags" map="o"/>
  <method class="freemarker.ext.beans.TypeFlags" name="int classToTypeFlags(java.lang.Class)" map="A"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$BigIntegerOrDouble" map="_A"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrByte" map="_B"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrByte" name="w" map="B"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrByte" name="byte byteValue()" map="byteValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrByte" name="int intValue()" map="intValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrByte" name="long longValue()" map="longValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrByte" name="short shortValue()" map="shortValue"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrIntegerOrFloat" map="_C"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrIntegerOrFloat" name="w" map="C"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrIntegerOrFloat" name="int intValue()" map="intValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrIntegerOrFloat" name="long longValue()" map="longValue"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrWholeNumber" map="_D"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrWholeNumber" name="n" map="A"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrWholeNumber" name="double doubleValue()" map="doubleValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrWholeNumber" name="java.lang.Number getSourceNumber()" map="A"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$BigIntegerOrLong" map="_E"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$BigIntegerOrFloat" map="_F"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$BigIntegerOrInteger" map="_G"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$FloatOrInteger" map="_H"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$FloatOrInteger" name="w" map="P"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$FloatOrInteger" name="int intValue()" map="intValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$FloatOrInteger" name="long longValue()" map="longValue"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$BigIntegerOrByte" map="_I"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$FloatOrByte" map="_J"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$FloatOrByte" name="w" map="Q"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$FloatOrByte" name="byte byteValue()" map="byteValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$FloatOrByte" name="int intValue()" map="intValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$FloatOrByte" name="long longValue()" map="longValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$FloatOrByte" name="short shortValue()" map="shortValue"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$BigIntegerOrShort" map="_K"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$IntegerBigDecimal" map="_L"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$IntegerBigDecimal" name="n" map="G"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$IntegerBigDecimal" name="java.math.BigInteger bigIntegerValue()" map="B"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$IntegerBigDecimal" name="java.lang.Number getSourceNumber()" map="A"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$LongOrShort" map="_M"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$LongOrShort" name="w" map="L"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$LongOrShort" name="short shortValue()" map="shortValue"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$IntegerOrByte" map="_N"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$IntegerOrByte" name="w" map="T"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$IntegerOrByte" name="byte byteValue()" map="byteValue"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$BigIntegerOrPrimitive" map="_O"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$BigIntegerOrPrimitive" name="n" map="V"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$BigIntegerOrPrimitive" name="java.lang.Number getSourceNumber()" map="A"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$IntegerOrShort" map="_P"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$IntegerOrShort" name="w" map="U"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$IntegerOrShort" name="short shortValue()" map="shortValue"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$LongOrInteger" map="_Q"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$LongOrInteger" name="w" map="M"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$LongOrInteger" name="int intValue()" map="intValue"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$ShortOrByte" map="_R"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$ShortOrByte" name="w" map="H"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$ShortOrByte" name="n" map="I"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$ShortOrByte" name="byte byteValue()" map="byteValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$ShortOrByte" name="short shortValue()" map="shortValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$ShortOrByte" name="java.lang.Number getSourceNumber()" map="A"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrFloat" map="_S"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrFloat" name="n" map="J"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrFloat" name="double doubleValue()" map="doubleValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrFloat" name="float floatValue()" map="floatValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrFloat" name="java.lang.Number getSourceNumber()" map="A"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrInteger" map="_T"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrInteger" name="w" map="D"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrInteger" name="int intValue()" map="intValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrInteger" name="long longValue()" map="longValue"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$FloatOrShort" map="_U"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$FloatOrShort" name="w" map="R"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$FloatOrShort" name="int intValue()" map="intValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$FloatOrShort" name="long longValue()" map="longValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$FloatOrShort" name="short shortValue()" map="shortValue"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$LongOrByte" map="_V"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$LongOrByte" name="w" map="N"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$LongOrByte" name="byte byteValue()" map="byteValue"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$LongOrSmallerInteger" map="_W"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$LongOrSmallerInteger" name="n" map="K"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$LongOrSmallerInteger" name="long longValue()" map="longValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$LongOrSmallerInteger" name="java.lang.Number getSourceNumber()" map="A"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$NumberWithFallbackType" map="_X"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$NumberWithFallbackType" name="java.lang.Number getSourceNumber()" map="A"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$NumberWithFallbackType" name="int hashCode()" map="hashCode"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$NumberWithFallbackType" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$NumberWithFallbackType" name="long longValue()" map="longValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$NumberWithFallbackType" name="short shortValue()" map="shortValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$NumberWithFallbackType" name="double doubleValue()" map="doubleValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$NumberWithFallbackType" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$NumberWithFallbackType" name="byte byteValue()" map="byteValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$NumberWithFallbackType" name="int intValue()" map="intValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$NumberWithFallbackType" name="float floatValue()" map="floatValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$NumberWithFallbackType" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrShort" map="_Y"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrShort" name="w" map="E"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrShort" name="int intValue()" map="intValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrShort" name="long longValue()" map="longValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrShort" name="short shortValue()" map="shortValue"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$FloatOrWholeNumber" map="_Z"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$FloatOrWholeNumber" name="n" map="O"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$FloatOrWholeNumber" name="float floatValue()" map="floatValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$FloatOrWholeNumber" name="java.lang.Number getSourceNumber()" map="A"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$BigIntegerOrFPPrimitive" map="__"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$BigIntegerOrFPPrimitive" name="double doubleValue()" map="doubleValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$BigIntegerOrFPPrimitive" name="float floatValue()" map="floatValue"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrLong" map="_a"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrLong" name="w" map="F"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$DoubleOrLong" name="long longValue()" map="longValue"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil$IntegerOrSmallerInteger" map="_b"/>
  <field class="freemarker.ext.beans.OverloadedNumberUtil$IntegerOrSmallerInteger" name="n" map="S"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$IntegerOrSmallerInteger" name="int intValue()" map="intValue"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil$IntegerOrSmallerInteger" name="java.lang.Number getSourceNumber()" map="A"/>
  <class name="freemarker.ext.beans.OverloadedNumberUtil" map="p"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil" name="int compareNumberTypeSpecificity(java.lang.Class, java.lang.Class)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil" name="java.lang.Number addFallbackType(java.lang.Number, int)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedNumberUtil" name="int getArgumentConversionPrice(java.lang.Class, java.lang.Class)" map="B"/>
  <class name="freemarker.ext.beans.CallableMemberDescriptor" map="q"/>
  <method class="freemarker.ext.beans.CallableMemberDescriptor" name="boolean isConstructor()" map="A"/>
  <method class="freemarker.ext.beans.CallableMemberDescriptor" name="java.lang.Class[] getParamTypes()" map="B"/>
  <method class="freemarker.ext.beans.CallableMemberDescriptor" name="java.lang.String getDeclaration()" map="C"/>
  <method class="freemarker.ext.beans.CallableMemberDescriptor" name="boolean isStatic()" map="D"/>
  <method class="freemarker.ext.beans.CallableMemberDescriptor" name="boolean isVarargs()" map="E"/>
  <method class="freemarker.ext.beans.CallableMemberDescriptor" name="java.lang.Object invokeConstructor(freemarker.ext.beans.BeansWrapper, java.lang.Object[])" map="A"/>
  <method class="freemarker.ext.beans.CallableMemberDescriptor" name="freemarker.template.TemplateModel invokeMethod(freemarker.ext.beans.BeansWrapper, java.lang.Object, java.lang.Object[])" map="A"/>
  <class name="freemarker.ext.beans.BooleanModel" map="r"/>
  <field class="freemarker.ext.beans.BooleanModel" name="value" map="&#x01cc;"/>
  <method class="freemarker.ext.beans.BooleanModel" name="boolean getAsBoolean()" map="&#x00c3;"/>
  <class name="freemarker.ext.beans._MethodUtil$1" map="1"/>
  <method class="freemarker.ext.beans._MethodUtil$1" name="java.lang.String doConversion(java.lang.Object)" map="A"/>
  <class name="freemarker.ext.beans._MethodUtil" map="s"/>
  <method class="freemarker.ext.beans._MethodUtil" name="java.lang.Object[] invocationErrorMessageStart(java.lang.Object, boolean)" map="A"/>
  <method class="freemarker.ext.beans._MethodUtil" name="java.lang.Class[] getParameterTypes(java.lang.reflect.Member)" map="A"/>
  <method class="freemarker.ext.beans._MethodUtil" name="java.util.Set getAssignables(java.lang.Class, java.lang.Class)" map="A"/>
  <method class="freemarker.ext.beans._MethodUtil" name="freemarker.template.TemplateModelException newInvocationTemplateModelException(java.lang.Object, freemarker.ext.beans.CallableMemberDescriptor, java.lang.Throwable)" map="A"/>
  <method class="freemarker.ext.beans._MethodUtil" name="freemarker.template.TemplateModelException newInvocationTemplateModelException(java.lang.Object, java.lang.reflect.Member, java.lang.Throwable)" map="A"/>
  <method class="freemarker.ext.beans._MethodUtil" name="void collectAssignables(java.lang.Class, java.lang.Class, java.util.Set)" map="A"/>
  <method class="freemarker.ext.beans._MethodUtil" name="java.lang.String toString(java.lang.reflect.Member)" map="B"/>
  <method class="freemarker.ext.beans._MethodUtil" name="boolean isVarargs(java.lang.reflect.Member)" map="C"/>
  <method class="freemarker.ext.beans._MethodUtil" name="boolean isWideningBoxedNumberConversion(java.lang.Class, java.lang.Class)" map="B"/>
  <method class="freemarker.ext.beans._MethodUtil" name="int isMoreOrSameSpecificParameterType(java.lang.Class, java.lang.Class, boolean, int)" map="A"/>
  <method class="freemarker.ext.beans._MethodUtil" name="freemarker.template.TemplateModelException newInvocationTemplateModelException(java.lang.Object, java.lang.Object, boolean, boolean, java.lang.Throwable)" map="A"/>
  <method class="freemarker.ext.beans._MethodUtil" name="boolean isWideningPrimitiveNumberConversion(java.lang.Class, java.lang.Class)" map="C"/>
  <method class="freemarker.ext.beans._MethodUtil" name="java.lang.String getBeanPropertyNameFromReaderMethodName(java.lang.String, java.lang.Class)" map="A"/>
  <method class="freemarker.ext.beans._MethodUtil" name="java.lang.Object[] invocationErrorMessageStart(java.lang.reflect.Member)" map="D"/>
  <class name="freemarker.ext.beans.ClassChangeNotifier" map="t"/>
  <method class="freemarker.ext.beans.ClassChangeNotifier" name="void subscribe(freemarker.ext.beans.ClassIntrospector)" map="A"/>
  <class name="freemarker.ext.beans.ReflectionCallableMemberDescriptor" map="u"/>
  <field class="freemarker.ext.beans.ReflectionCallableMemberDescriptor" name="paramTypes" map="C"/>
  <field class="freemarker.ext.beans.ReflectionCallableMemberDescriptor" name="member" map="D"/>
  <method class="freemarker.ext.beans.ReflectionCallableMemberDescriptor" name="boolean isConstructor()" map="A"/>
  <method class="freemarker.ext.beans.ReflectionCallableMemberDescriptor" name="java.lang.Class[] getParamTypes()" map="B"/>
  <method class="freemarker.ext.beans.ReflectionCallableMemberDescriptor" name="java.lang.String getDeclaration()" map="C"/>
  <method class="freemarker.ext.beans.ReflectionCallableMemberDescriptor" name="boolean isStatic()" map="D"/>
  <method class="freemarker.ext.beans.ReflectionCallableMemberDescriptor" name="boolean isVarargs()" map="E"/>
  <method class="freemarker.ext.beans.ReflectionCallableMemberDescriptor" name="java.lang.Object invokeConstructor(freemarker.ext.beans.BeansWrapper, java.lang.Object[])" map="A"/>
  <method class="freemarker.ext.beans.ReflectionCallableMemberDescriptor" name="freemarker.template.TemplateModel invokeMethod(freemarker.ext.beans.BeansWrapper, java.lang.Object, java.lang.Object[])" map="A"/>
  <class name="freemarker.ext.beans.BeanModel$1" map="1"/>
  <method class="freemarker.ext.beans.BeanModel$1" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.beans.BeanModel" map="v"/>
  <field class="freemarker.ext.beans.BeanModel" name="LOG" map="&#x0197;"/>
  <field class="freemarker.ext.beans.BeanModel" name="object" map="&#x0198;"/>
  <field class="freemarker.ext.beans.BeanModel" name="UNKNOWN" map="&#x0199;"/>
  <field class="freemarker.ext.beans.BeanModel" name="FACTORY" map="&#x019a;"/>
  <field class="freemarker.ext.beans.BeanModel" name="memberCache" map="&#x019b;"/>
  <field class="freemarker.ext.beans.BeanModel" name="wrapper" map="&#x019c;"/>
  <method class="freemarker.ext.beans.BeanModel" name="java.lang.String getAsClassicCompatibleString()" map="&#x00cf;"/>
  <method class="freemarker.ext.beans.BeanModel" name="java.lang.Object getAdaptedObject(java.lang.Class)" map="A"/>
  <method class="freemarker.ext.beans.BeanModel" name="java.util.Set keySet()" map="&#x00d0;"/>
  <method class="freemarker.ext.beans.BeanModel" name="void logNoSuchKey(java.lang.String, java.util.Map)" map="A"/>
  <method class="freemarker.ext.beans.BeanModel" name="freemarker.template.TemplateModel invokeThroughDescriptor(java.lang.Object, java.util.Map)" map="A"/>
  <method class="freemarker.ext.beans.BeanModel" name="freemarker.template.TemplateCollectionModel values()" map="&#x00c9;"/>
  <method class="freemarker.ext.beans.BeanModel" name="freemarker.template.TemplateCollectionModel keys()" map="&#x00c8;"/>
  <method class="freemarker.ext.beans.BeanModel" name="freemarker.template.TemplateModel wrap(java.lang.Object)" map="B"/>
  <method class="freemarker.ext.beans.BeanModel" name="freemarker.template.TemplateModel getAPI()" map="&#x00ce;"/>
  <method class="freemarker.ext.beans.BeanModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.ext.beans.BeanModel" name="java.lang.String toString()" map="toString"/>
  <method class="freemarker.ext.beans.BeanModel" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <method class="freemarker.ext.beans.BeanModel" name="freemarker.template.TemplateModel invokeGenericGet(java.util.Map, java.lang.Class, java.lang.String)" map="A"/>
  <method class="freemarker.ext.beans.BeanModel" name="java.lang.Object unwrap(freemarker.template.TemplateModel)" map="D"/>
  <method class="freemarker.ext.beans.BeanModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.ext.beans.BeanModel" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <class name="freemarker.ext.beans.MapModel$1" map="1"/>
  <method class="freemarker.ext.beans.MapModel$1" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.beans.MapModel" map="w"/>
  <field class="freemarker.ext.beans.MapModel" name="FACTORY" map="&#x019a;"/>
  <method class="freemarker.ext.beans.MapModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.ext.beans.MapModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.ext.beans.MapModel" name="java.lang.Object exec(java.util.List)" map="A"/>
  <method class="freemarker.ext.beans.MapModel" name="java.util.Set keySet()" map="&#x00d0;"/>
  <method class="freemarker.ext.beans.MapModel" name="freemarker.template.TemplateModel invokeGenericGet(java.util.Map, java.lang.Class, java.lang.String)" map="A"/>
  <class name="freemarker.ext.beans.StaticModel" map="x"/>
  <field class="freemarker.ext.beans.StaticModel" name="LOG" map="&#x01ed;"/>
  <field class="freemarker.ext.beans.StaticModel" name="clazz" map="&#x01ee;"/>
  <field class="freemarker.ext.beans.StaticModel" name="map" map="&#x01ef;"/>
  <field class="freemarker.ext.beans.StaticModel" name="wrapper" map="&#x01f0;"/>
  <method class="freemarker.ext.beans.StaticModel" name="freemarker.template.TemplateCollectionModel keys()" map="&#x00c8;"/>
  <method class="freemarker.ext.beans.StaticModel" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.ext.beans.StaticModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.ext.beans.StaticModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.ext.beans.StaticModel" name="freemarker.template.TemplateCollectionModel values()" map="&#x00c9;"/>
  <method class="freemarker.ext.beans.StaticModel" name="void populate()" map="&#x00f0;"/>
  <class name="freemarker.ext.beans.MaybeEmptyCallableMemberDescriptor" map="y"/>
  <class name="freemarker.ext.beans.SetAdapter" map="z"/>
  <class name="freemarker.ext.beans.MethodAppearanceFineTuner" map="$A"/>
  <method class="freemarker.ext.beans.MethodAppearanceFineTuner" name="void process(freemarker.ext.beans.BeansWrapper$MethodAppearanceDecisionInput, freemarker.ext.beans.BeansWrapper$MethodAppearanceDecision)" map="A"/>
  <class name="freemarker.ext.beans.CharacterOrString" map="AA"/>
  <field class="freemarker.ext.beans.CharacterOrString" name="stringValue" map="A"/>
  <method class="freemarker.ext.beans.CharacterOrString" name="char getAsChar()" map="A"/>
  <method class="freemarker.ext.beans.CharacterOrString" name="java.lang.String getAsString()" map="B"/>
  <class name="freemarker.ext.beans.OverloadedMethodsSubset" map="BA"/>
  <field class="freemarker.ext.beans.OverloadedMethodsSubset" name="bugfixed" map="A"/>
  <field class="freemarker.ext.beans.OverloadedMethodsSubset" name="memberDescs" map="B"/>
  <field class="freemarker.ext.beans.OverloadedMethodsSubset" name="unwrappingHintsByParamCount" map="C"/>
  <field class="freemarker.ext.beans.OverloadedMethodsSubset" name="argTypesToMemberDescCache" map="D"/>
  <field class="freemarker.ext.beans.OverloadedMethodsSubset" name="typeFlagsByParamCount" map="E"/>
  <field class="freemarker.ext.beans.OverloadedMethodsSubset" name="ZERO_PARAM_COUNT_TYPE_FLAGS_ARRAY" map="F"/>
  <field class="freemarker.ext.beans.OverloadedMethodsSubset" name="ALL_ZEROS_ARRAY" map="G"/>
  <method class="freemarker.ext.beans.OverloadedMethodsSubset" name="void mergeInTypesFlags(int, int[])" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethodsSubset" name="java.util.Iterator getMemberDescriptors()" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethodsSubset" name="java.lang.Class[][] getUnwrappingHintsByParamCount()" map="B"/>
  <method class="freemarker.ext.beans.OverloadedMethodsSubset" name="void forceNumberArgumentsToParameterTypes(java.lang.Object[], java.lang.Class[], int[])" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethodsSubset" name="freemarker.ext.beans.MaybeEmptyCallableMemberDescriptor getMemberDescriptorForArgs(java.lang.Object[], boolean)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethodsSubset" name="int[] getTypeFlags(int)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethodsSubset" name="freemarker.ext.beans.MaybeEmptyMemberAndArguments getMemberAndArguments(java.util.List, freemarker.ext.beans.BeansWrapper)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethodsSubset" name="void addCallableMemberDescriptor(freemarker.ext.beans.ReflectionCallableMemberDescriptor)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethodsSubset" name="void afterWideningUnwrappingHints(java.lang.Class[], int[])" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethodsSubset" name="java.lang.Class[] preprocessParameterTypes(freemarker.ext.beans.CallableMemberDescriptor)" map="A"/>
  <method class="freemarker.ext.beans.OverloadedMethodsSubset" name="java.lang.Class getCommonSupertypeForUnwrappingHint(java.lang.Class, java.lang.Class)" map="A"/>
  <package name="freemarker.ext.jython" map="C"/>
  <class name="freemarker.ext.jython.JythonVersionAdapterHolder" map="A"/>
  <field class="freemarker.ext.jython.JythonVersionAdapterHolder" name="INSTANCE" map="A"/>
  <method class="freemarker.ext.jython.JythonVersionAdapterHolder" name="java.lang.RuntimeException adapterCreationException(java.lang.Exception)" map="A"/>
  <class name="freemarker.ext.jython.JythonModel$1" map="1"/>
  <method class="freemarker.ext.jython.JythonModel$1" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.jython.JythonModel" map="B"/>
  <field class="freemarker.ext.jython.JythonModel" name="object" map="&#x01be;"/>
  <field class="freemarker.ext.jython.JythonModel" name="FACTORY" map="&#x01bf;"/>
  <field class="freemarker.ext.jython.JythonModel" name="wrapper" map="&#x01c0;"/>
  <method class="freemarker.ext.jython.JythonModel" name="java.lang.Object getAdaptedObject(java.lang.Class)" map="A"/>
  <method class="freemarker.ext.jython.JythonModel" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.ext.jython.JythonModel" name="java.lang.Object exec(java.util.List)" map="A"/>
  <method class="freemarker.ext.jython.JythonModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.ext.jython.JythonModel" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <method class="freemarker.ext.jython.JythonModel" name="boolean getAsBoolean()" map="&#x00c3;"/>
  <method class="freemarker.ext.jython.JythonModel" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <class name="freemarker.ext.jython.JythonWrapper$TemplateModelToJythonAdapter" map="_A"/>
  <field class="freemarker.ext.jython.JythonWrapper$TemplateModelToJythonAdapter" name="this$0" map="this$0"/>
  <field class="freemarker.ext.jython.JythonWrapper$TemplateModelToJythonAdapter" name="model" map="H"/>
  <method class="freemarker.ext.jython.JythonWrapper$TemplateModelToJythonAdapter" name="org.python.core.PyObject __finditem__(int)" map="__finditem__"/>
  <method class="freemarker.ext.jython.JythonWrapper$TemplateModelToJythonAdapter" name="org.python.core.PyObject __finditem__(org.python.core.PyObject)" map="__finditem__"/>
  <method class="freemarker.ext.jython.JythonWrapper$TemplateModelToJythonAdapter" name="freemarker.template.TemplateModel getTemplateModel()" map="getTemplateModel"/>
  <method class="freemarker.ext.jython.JythonWrapper$TemplateModelToJythonAdapter" name="java.lang.String getModelClass()" map="C"/>
  <method class="freemarker.ext.jython.JythonWrapper$TemplateModelToJythonAdapter" name="org.python.core.PyObject __finditem__(java.lang.String)" map="__finditem__"/>
  <method class="freemarker.ext.jython.JythonWrapper$TemplateModelToJythonAdapter" name="int __len__()" map="__len__"/>
  <method class="freemarker.ext.jython.JythonWrapper$TemplateModelToJythonAdapter" name="org.python.core.PyObject __call__(org.python.core.PyObject[], java.lang.String[])" map="__call__"/>
  <method class="freemarker.ext.jython.JythonWrapper$TemplateModelToJythonAdapter" name="boolean __nonzero__()" map="__nonzero__"/>
  <class name="freemarker.ext.jython.JythonWrapper" map="C"/>
  <field class="freemarker.ext.jython.JythonWrapper" name="PYOBJECT_CLASS" map="g"/>
  <field class="freemarker.ext.jython.JythonWrapper" name="attributesShadowItems" map="h"/>
  <field class="freemarker.ext.jython.JythonWrapper" name="INSTANCE" map="i"/>
  <field class="freemarker.ext.jython.JythonWrapper" name="modelCache" map="j"/>
  <method class="freemarker.ext.jython.JythonWrapper" name="org.python.core.PyObject unwrap(freemarker.template.TemplateModel)" map="B"/>
  <method class="freemarker.ext.jython.JythonWrapper" name="freemarker.template.TemplateModel wrap(java.lang.Object)" map="A"/>
  <method class="freemarker.ext.jython.JythonWrapper" name="boolean isAttributesShadowItems()" map="T"/>
  <class name="freemarker.ext.jython.JythonVersionAdapter" map="D"/>
  <method class="freemarker.ext.jython.JythonVersionAdapter" name="java.lang.String getPythonClassName(org.python.core.PyObject)" map="A"/>
  <method class="freemarker.ext.jython.JythonVersionAdapter" name="boolean isPyInstance(java.lang.Object)" map="A"/>
  <method class="freemarker.ext.jython.JythonVersionAdapter" name="java.lang.Object pyInstanceToJava(java.lang.Object)" map="B"/>
  <class name="freemarker.ext.jython.JythonModelCache" map="E"/>
  <field class="freemarker.ext.jython.JythonModelCache" name="wrapper" map="G"/>
  <method class="freemarker.ext.jython.JythonModelCache" name="boolean isCacheable(java.lang.Object)" map="A"/>
  <method class="freemarker.ext.jython.JythonModelCache" name="freemarker.template.TemplateModel create(java.lang.Object)" map="B"/>
  <class name="freemarker.ext.jython.JythonHashModel$1" map="1"/>
  <method class="freemarker.ext.jython.JythonHashModel$1" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.jython.JythonHashModel" map="F"/>
  <field class="freemarker.ext.jython.JythonHashModel" name="FACTORY" map="&#x01bf;"/>
  <method class="freemarker.ext.jython.JythonHashModel" name="freemarker.template.TemplateCollectionModel keys()" map="&#x00c8;"/>
  <method class="freemarker.ext.jython.JythonHashModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.ext.jython.JythonHashModel" name="freemarker.template.TemplateCollectionModel values()" map="&#x00c9;"/>
  <class name="freemarker.ext.jython.JythonNumberModel$1" map="1"/>
  <method class="freemarker.ext.jython.JythonNumberModel$1" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.jython.JythonNumberModel" map="G"/>
  <field class="freemarker.ext.jython.JythonNumberModel" name="FACTORY" map="&#x01bf;"/>
  <method class="freemarker.ext.jython.JythonNumberModel" name="java.lang.Number getAsNumber()" map="&#x00d8;"/>
  <class name="freemarker.ext.jython.JythonSequenceModel$2" map="2"/>
  <field class="freemarker.ext.jython.JythonSequenceModel$2" name="this$0" map="&#x01b9;"/>
  <field class="freemarker.ext.jython.JythonSequenceModel$2" name="i" map="&#x01ba;"/>
  <method class="freemarker.ext.jython.JythonSequenceModel$2" name="boolean hasNext()" map="&#x00d1;"/>
  <method class="freemarker.ext.jython.JythonSequenceModel$2" name="freemarker.template.TemplateModel next()" map="&#x00d2;"/>
  <class name="freemarker.ext.jython.JythonSequenceModel$1" map="1"/>
  <method class="freemarker.ext.jython.JythonSequenceModel$1" name="freemarker.template.TemplateModel create(java.lang.Object, freemarker.template.ObjectWrapper)" map="A"/>
  <class name="freemarker.ext.jython.JythonSequenceModel" map="H"/>
  <field class="freemarker.ext.jython.JythonSequenceModel" name="FACTORY" map="&#x01bf;"/>
  <method class="freemarker.ext.jython.JythonSequenceModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.ext.jython.JythonSequenceModel" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.ext.jython.JythonSequenceModel" name="freemarker.template.TemplateModelIterator iterator()" map="&#x00c0;"/>
  <package name="freemarker.ext.dom" map="D"/>
  <class name="freemarker.ext.dom.DocumentModel" map="A"/>
  <field class="freemarker.ext.dom.DocumentModel" name="rootElement" map="&#x01e1;"/>
  <method class="freemarker.ext.dom.DocumentModel" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.ext.dom.DocumentModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.ext.dom.DocumentModel" name="freemarker.ext.dom.ElementModel getRootElement()" map="&#x00ea;"/>
  <method class="freemarker.ext.dom.DocumentModel" name="java.lang.String getNodeName()" map="&#x00de;"/>
  <class name="freemarker.ext.dom.DomStringUtil" map="B"/>
  <method class="freemarker.ext.dom.DomStringUtil" name="boolean isXMLNameLike(java.lang.String, int)" map="A"/>
  <method class="freemarker.ext.dom.DomStringUtil" name="boolean matchesName(java.lang.String, java.lang.String, java.lang.String, freemarker.core.Environment)" map="A"/>
  <method class="freemarker.ext.dom.DomStringUtil" name="boolean isXMLNameLike(java.lang.String)" map="A"/>
  <class name="freemarker.ext.dom.PINodeModel" map="C"/>
  <method class="freemarker.ext.dom.PINodeModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.ext.dom.PINodeModel" name="java.lang.String getNodeName()" map="&#x00de;"/>
  <method class="freemarker.ext.dom.PINodeModel" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <class name="freemarker.ext.dom.NodeOutputter" map="D"/>
  <field class="freemarker.ext.dom.NodeOutputter" name="namespaceDecl" map="A"/>
  <field class="freemarker.ext.dom.NodeOutputter" name="explicitDefaultNSPrefix" map="B"/>
  <field class="freemarker.ext.dom.NodeOutputter" name="nextGeneratedPrefixNumber" map="C"/>
  <field class="freemarker.ext.dom.NodeOutputter" name="contextNode" map="D"/>
  <field class="freemarker.ext.dom.NodeOutputter" name="hasDefaultNS" map="E"/>
  <field class="freemarker.ext.dom.NodeOutputter" name="env" map="F"/>
  <field class="freemarker.ext.dom.NodeOutputter" name="defaultNS" map="G"/>
  <field class="freemarker.ext.dom.NodeOutputter" name="namespacesToPrefixLookup" map="H"/>
  <method class="freemarker.ext.dom.NodeOutputter" name="void buildPrefixLookup(org.w3c.dom.Node)" map="A"/>
  <method class="freemarker.ext.dom.NodeOutputter" name="java.lang.String getOpeningTag(org.w3c.dom.Element)" map="A"/>
  <method class="freemarker.ext.dom.NodeOutputter" name="void outputQualifiedName(org.w3c.dom.Node, java.lang.StringBuilder)" map="A"/>
  <method class="freemarker.ext.dom.NodeOutputter" name="void setContext(org.w3c.dom.Element)" map="B"/>
  <method class="freemarker.ext.dom.NodeOutputter" name="void outputContent(org.w3c.dom.NodeList, java.lang.StringBuilder)" map="A"/>
  <method class="freemarker.ext.dom.NodeOutputter" name="void outputContent(org.w3c.dom.Node, java.lang.StringBuilder)" map="B"/>
  <method class="freemarker.ext.dom.NodeOutputter" name="void constructNamespaceDecl()" map="A"/>
  <method class="freemarker.ext.dom.NodeOutputter" name="void outputContent(org.w3c.dom.NamedNodeMap, java.lang.StringBuilder)" map="A"/>
  <method class="freemarker.ext.dom.NodeOutputter" name="java.lang.String getClosingTag(org.w3c.dom.Element)" map="C"/>
  <class name="freemarker.ext.dom.NodeModel" map="E"/>
  <field class="freemarker.ext.dom.NodeModel" name="xpathSupportClass" map="&#x01d9;"/>
  <field class="freemarker.ext.dom.NodeModel" name="xpathSupportMap" map="&#x01da;"/>
  <field class="freemarker.ext.dom.NodeModel" name="LOG" map="&#x01db;"/>
  <field class="freemarker.ext.dom.NodeModel" name="children" map="&#x01dc;"/>
  <field class="freemarker.ext.dom.NodeModel" name="parent" map="&#x01dd;"/>
  <field class="freemarker.ext.dom.NodeModel" name="node" map="&#x01de;"/>
  <field class="freemarker.ext.dom.NodeModel" name="jaxenXPathSupport" map="&#x01df;"/>
  <field class="freemarker.ext.dom.NodeModel" name="STATIC_LOCK" map="&#x01e0;"/>
  <method class="freemarker.ext.dom.NodeModel" name="freemarker.ext.dom.NodeModel wrap(org.w3c.dom.Node)" map="A"/>
  <method class="freemarker.ext.dom.NodeModel" name="java.lang.String getQualifiedName()" map="&#x00e4;"/>
  <method class="freemarker.ext.dom.NodeModel" name="freemarker.template.TemplateNodeModelEx getNextSibling()" map="&#x00e2;"/>
  <method class="freemarker.ext.dom.NodeModel" name="freemarker.template.TemplateSequenceModel getChildNodes()" map="&#x00df;"/>
  <method class="freemarker.ext.dom.NodeModel" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="freemarker.ext.dom.NodeModel" name="java.lang.String getNodeType()" map="&#x00dd;"/>
  <method class="freemarker.ext.dom.NodeModel" name="void useXalanXPathSupport()" map="&#x00e5;"/>
  <method class="freemarker.ext.dom.NodeModel" name="freemarker.template.TemplateModel get(int)" map="N"/>
  <method class="freemarker.ext.dom.NodeModel" name="java.lang.String getNodeNamespace()" map="&#x00e0;"/>
  <method class="freemarker.ext.dom.NodeModel" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.ext.dom.NodeModel" name="int hashCode()" map="hashCode"/>
  <method class="freemarker.ext.dom.NodeModel" name="java.lang.Object getAdaptedObject(java.lang.Class)" map="A"/>
  <method class="freemarker.ext.dom.NodeModel" name="java.lang.Object getWrappedObject()" map="&#x00cd;"/>
  <method class="freemarker.ext.dom.NodeModel" name="freemarker.template.TemplateNodeModel getParentNode()" map="&#x00e1;"/>
  <method class="freemarker.ext.dom.NodeModel" name="int size()" map="&#x00c1;"/>
  <method class="freemarker.ext.dom.NodeModel" name="java.lang.String getText(org.w3c.dom.Node)" map="B"/>
  <method class="freemarker.ext.dom.NodeModel" name="void useDefaultXPathSupport()" map="&#x00e6;"/>
  <method class="freemarker.ext.dom.NodeModel" name="freemarker.template.TemplateNodeModelEx getPreviousSibling()" map="&#x00e3;"/>
  <method class="freemarker.ext.dom.NodeModel" name="java.lang.Object[] explainTypeError(java.lang.Class[])" map="A"/>
  <method class="freemarker.ext.dom.NodeModel" name="freemarker.ext.dom.XPathSupport getXPathSupport()" map="&#x00e7;"/>
  <method class="freemarker.ext.dom.NodeModel" name="void useJaxenXPathSupport()" map="&#x00e8;"/>
  <method class="freemarker.ext.dom.NodeModel" name="void useSunInternalXPathSupport()" map="&#x00e9;"/>
  <class name="freemarker.ext.dom.NodeListModel$1" map="1"/>
  <method class="freemarker.ext.dom.NodeListModel$1" name="freemarker.template.TemplateModel wrap(java.lang.Object)" map="A"/>
  <class name="freemarker.ext.dom.NodeListModel" map="F"/>
  <field class="freemarker.ext.dom.NodeListModel" name="contextNode" map="&#x0209;"/>
  <field class="freemarker.ext.dom.NodeListModel" name="NODE_WRAPPER" map="&#x020a;"/>
  <field class="freemarker.ext.dom.NodeListModel" name="xpathSupport" map="&#x020b;"/>
  <method class="freemarker.ext.dom.NodeListModel" name="freemarker.ext.dom.NodeListModel filterByName(java.lang.String)" map="M"/>
  <method class="freemarker.ext.dom.NodeListModel" name="java.lang.Object[] explainTypeError(java.lang.Class[])" map="A"/>
  <method class="freemarker.ext.dom.NodeListModel" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.ext.dom.NodeListModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.ext.dom.NodeListModel" name="java.lang.Object[] newTypeErrorExplanation(java.lang.String)" map="N"/>
  <method class="freemarker.ext.dom.NodeListModel" name="freemarker.ext.dom.XPathSupport getXPathSupport()" map="&#x00f5;"/>
  <method class="freemarker.ext.dom.NodeListModel" name="java.util.List rawNodeList()" map="&#x00f6;"/>
  <class name="freemarker.ext.dom.AttributeNodeModel" map="G"/>
  <method class="freemarker.ext.dom.AttributeNodeModel" name="java.lang.String getQualifiedName()" map="&#x00e4;"/>
  <method class="freemarker.ext.dom.AttributeNodeModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.ext.dom.AttributeNodeModel" name="java.lang.String getNodeName()" map="&#x00de;"/>
  <method class="freemarker.ext.dom.AttributeNodeModel" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <class name="freemarker.ext.dom._ExtDomApi" map="H"/>
  <method class="freemarker.ext.dom._ExtDomApi" name="boolean matchesName(java.lang.String, java.lang.String, java.lang.String, freemarker.core.Environment)" map="A"/>
  <class name="freemarker.ext.dom.CharacterDataNodeModel" map="I"/>
  <method class="freemarker.ext.dom.CharacterDataNodeModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.ext.dom.CharacterDataNodeModel" name="java.lang.String getNodeName()" map="&#x00de;"/>
  <method class="freemarker.ext.dom.CharacterDataNodeModel" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <class name="freemarker.ext.dom.DocumentTypeModel" map="J"/>
  <method class="freemarker.ext.dom.DocumentTypeModel" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.ext.dom.DocumentTypeModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.ext.dom.DocumentTypeModel" name="java.lang.String getNodeName()" map="&#x00de;"/>
  <class name="freemarker.ext.dom.ElementModel" map="K"/>
  <method class="freemarker.ext.dom.ElementModel" name="boolean isXMLWhiteSpace(char)" map="A"/>
  <method class="freemarker.ext.dom.ElementModel" name="java.lang.String getAsString()" map="&#x00c2;"/>
  <method class="freemarker.ext.dom.ElementModel" name="java.lang.String getNodeName()" map="&#x00de;"/>
  <method class="freemarker.ext.dom.ElementModel" name="boolean isBlankXMLText(java.lang.String)" map="H"/>
  <method class="freemarker.ext.dom.ElementModel" name="org.w3c.dom.Attr getAttribute(java.lang.String)" map="I"/>
  <method class="freemarker.ext.dom.ElementModel" name="java.lang.String getQualifiedName()" map="&#x00e4;"/>
  <method class="freemarker.ext.dom.ElementModel" name="boolean isSignificantNode(org.w3c.dom.Node)" map="C"/>
  <method class="freemarker.ext.dom.ElementModel" name="boolean isEmpty()" map="&#x00c7;"/>
  <method class="freemarker.ext.dom.ElementModel" name="freemarker.template.TemplateModel get(java.lang.String)" map="G"/>
  <method class="freemarker.ext.dom.ElementModel" name="boolean matchesName(java.lang.String, freemarker.core.Environment)" map="D"/>
  <class name="freemarker.ext.dom.XPathSupport" map="L"/>
  <method class="freemarker.ext.dom.XPathSupport" name="freemarker.template.TemplateModel executeQuery(java.lang.Object, java.lang.String)" map="A"/>
  <class name="freemarker.ext.dom.AtAtKey" map="M"/>
  <field class="freemarker.ext.dom.AtAtKey" name="ATTRIBUTES_MARKUP" map="A"/>
  <field class="freemarker.ext.dom.AtAtKey" name="END_TAG" map="B"/>
  <field class="freemarker.ext.dom.AtAtKey" name="NESTED_MARKUP" map="C"/>
  <field class="freemarker.ext.dom.AtAtKey" name="$VALUES" map="D"/>
  <field class="freemarker.ext.dom.AtAtKey" name="NEXT_SIBLING_ELEMENT" map="E"/>
  <field class="freemarker.ext.dom.AtAtKey" name="ATTRIBUTES" map="F"/>
  <field class="freemarker.ext.dom.AtAtKey" name="LOCAL_NAME" map="G"/>
  <field class="freemarker.ext.dom.AtAtKey" name="NAMESPACE" map="H"/>
  <field class="freemarker.ext.dom.AtAtKey" name="PREVIOUS_SIBLING_ELEMENT" map="I"/>
  <field class="freemarker.ext.dom.AtAtKey" name="START_TAG" map="J"/>
  <field class="freemarker.ext.dom.AtAtKey" name="TEXT" map="K"/>
  <field class="freemarker.ext.dom.AtAtKey" name="key" map="L"/>
  <field class="freemarker.ext.dom.AtAtKey" name="MARKUP" map="M"/>
  <field class="freemarker.ext.dom.AtAtKey" name="QNAME" map="N"/>
  <method class="freemarker.ext.dom.AtAtKey" name="freemarker.ext.dom.AtAtKey valueOf(java.lang.String)" map="valueOf"/>
  <method class="freemarker.ext.dom.AtAtKey" name="boolean containsKey(java.lang.String)" map="A"/>
  <method class="freemarker.ext.dom.AtAtKey" name="java.lang.String getKey()" map="A"/>
  <method class="freemarker.ext.dom.AtAtKey" name="freemarker.ext.dom.AtAtKey[] values()" map="values"/>
  <package name="javax" map="B"/>
  <package name="javax.xml" map="A"/>
  <package name="javax.xml.transform" map="A"/>
  <package name="javax.xml.transform.stream" map="A"/>
  <class name="javax.xml.transform.stream.StreamResult" map="A"/>
  <field class="javax.xml.transform.stream.StreamResult" name="outputStream" map="A"/>
  <field class="javax.xml.transform.stream.StreamResult" name="writer" map="B"/>
  <method class="javax.xml.transform.stream.StreamResult" name="void setOutputStream(java.io.OutputStream)" map="A"/>
  <method class="javax.xml.transform.stream.StreamResult" name="java.io.Writer getWriter()" map="A"/>
  <method class="javax.xml.transform.stream.StreamResult" name="void setWriter(java.io.Writer)" map="A"/>
  <package name="javax.xml.transform.dom" map="B"/>
  <class name="javax.xml.transform.dom.DOMSource" map="A"/>
  <field class="javax.xml.transform.dom.DOMSource" name="node" map="A"/>
  <method class="javax.xml.transform.dom.DOMSource" name="void setNode(org.w3c.dom.Node)" map="A"/>
  <class name="javax.xml.transform.SecuritySupport$5" map="5"/>
  <field class="javax.xml.transform.SecuritySupport$5" name="val$f" map="val$f"/>
  <method class="javax.xml.transform.SecuritySupport$5" name="java.lang.Object run()" map="run"/>
  <class name="javax.xml.transform.SecuritySupport$4" map="4"/>
  <field class="javax.xml.transform.SecuritySupport$4" name="val$name" map="val$name"/>
  <field class="javax.xml.transform.SecuritySupport$4" name="val$cl" map="val$cl"/>
  <method class="javax.xml.transform.SecuritySupport$4" name="java.lang.Object run()" map="run"/>
  <class name="javax.xml.transform.SecuritySupport$3" map="3"/>
  <field class="javax.xml.transform.SecuritySupport$3" name="val$file" map="val$file"/>
  <method class="javax.xml.transform.SecuritySupport$3" name="java.lang.Object run()" map="run"/>
  <class name="javax.xml.transform.SecuritySupport$2" map="2"/>
  <field class="javax.xml.transform.SecuritySupport$2" name="val$propName" map="val$propName"/>
  <method class="javax.xml.transform.SecuritySupport$2" name="java.lang.Object run()" map="run"/>
  <class name="javax.xml.transform.SecuritySupport$1" map="1"/>
  <method class="javax.xml.transform.SecuritySupport$1" name="java.lang.Object run()" map="run"/>
  <class name="javax.xml.transform.SecuritySupport" map="A"/>
  <method class="javax.xml.transform.SecuritySupport" name="java.io.InputStream getResourceAsStream(java.lang.ClassLoader, java.lang.String)" map="A"/>
  <method class="javax.xml.transform.SecuritySupport" name="boolean doesFileExist(java.io.File)" map="A"/>
  <method class="javax.xml.transform.SecuritySupport" name="java.lang.ClassLoader getContextClassLoader()" map="A"/>
  <method class="javax.xml.transform.SecuritySupport" name="java.io.FileInputStream getFileInputStream(java.io.File)" map="B"/>
  <method class="javax.xml.transform.SecuritySupport" name="java.lang.String getSystemProperty(java.lang.String)" map="A"/>
  <class name="javax.xml.transform.TransformerException" map="B"/>
  <class name="javax.xml.transform.FactoryFinder$ConfigurationError" map="_A"/>
  <field class="javax.xml.transform.FactoryFinder$ConfigurationError" name="exception" map="A"/>
  <method class="javax.xml.transform.FactoryFinder$ConfigurationError" name="java.lang.Exception getException()" map="A"/>
  <class name="javax.xml.transform.FactoryFinder" map="C"/>
  <field class="javax.xml.transform.FactoryFinder" name="debug" map="A"/>
  <field class="javax.xml.transform.FactoryFinder" name="class$javax$xml$transform$FactoryFinder" map="class$B$A$A$C"/>
  <field class="javax.xml.transform.FactoryFinder" name="cacheProps" map="B"/>
  <field class="javax.xml.transform.FactoryFinder" name="firstTime" map="C"/>
  <method class="javax.xml.transform.FactoryFinder" name="java.lang.Object find(java.lang.String, java.lang.String)" map="A"/>
  <method class="javax.xml.transform.FactoryFinder" name="void dPrint(java.lang.String)" map="A"/>
  <method class="javax.xml.transform.FactoryFinder" name="java.lang.Object findJarServiceProvider(java.lang.String)" map="B"/>
  <method class="javax.xml.transform.FactoryFinder" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="javax.xml.transform.FactoryFinder" name="java.lang.Object newInstance(java.lang.String, java.lang.ClassLoader, boolean)" map="A"/>
  <class name="javax.xml.transform.Source" map="D"/>
  <class name="javax.xml.transform.TransformerFactory" map="E"/>
  <method class="javax.xml.transform.TransformerFactory" name="javax.xml.transform.TransformerFactory newInstance()" map="A"/>
  <method class="javax.xml.transform.TransformerFactory" name="javax.xml.transform.Transformer newTransformer()" map="B"/>
  <class name="javax.xml.transform.TransformerFactoryConfigurationError" map="F"/>
  <field class="javax.xml.transform.TransformerFactoryConfigurationError" name="exception" map="A"/>
  <method class="javax.xml.transform.TransformerFactoryConfigurationError" name="java.lang.String getMessage()" map="getMessage"/>
  <class name="javax.xml.transform.Result" map="G"/>
  <package name="javax.xml.parsers" map="B"/>
  <class name="javax.xml.parsers.SecuritySupport$5" map="5"/>
  <field class="javax.xml.parsers.SecuritySupport$5" name="val$f" map="val$f"/>
  <method class="javax.xml.parsers.SecuritySupport$5" name="java.lang.Object run()" map="run"/>
  <class name="javax.xml.parsers.SecuritySupport$4" map="4"/>
  <field class="javax.xml.parsers.SecuritySupport$4" name="val$name" map="val$name"/>
  <field class="javax.xml.parsers.SecuritySupport$4" name="val$cl" map="val$cl"/>
  <method class="javax.xml.parsers.SecuritySupport$4" name="java.lang.Object run()" map="run"/>
  <class name="javax.xml.parsers.SecuritySupport$3" map="3"/>
  <field class="javax.xml.parsers.SecuritySupport$3" name="val$file" map="val$file"/>
  <method class="javax.xml.parsers.SecuritySupport$3" name="java.lang.Object run()" map="run"/>
  <class name="javax.xml.parsers.SecuritySupport$2" map="2"/>
  <field class="javax.xml.parsers.SecuritySupport$2" name="val$propName" map="val$propName"/>
  <method class="javax.xml.parsers.SecuritySupport$2" name="java.lang.Object run()" map="run"/>
  <class name="javax.xml.parsers.SecuritySupport$1" map="1"/>
  <method class="javax.xml.parsers.SecuritySupport$1" name="java.lang.Object run()" map="run"/>
  <class name="javax.xml.parsers.SecuritySupport" map="A"/>
  <method class="javax.xml.parsers.SecuritySupport" name="java.io.InputStream getResourceAsStream(java.lang.ClassLoader, java.lang.String)" map="A"/>
  <method class="javax.xml.parsers.SecuritySupport" name="boolean doesFileExist(java.io.File)" map="A"/>
  <method class="javax.xml.parsers.SecuritySupport" name="java.lang.ClassLoader getContextClassLoader()" map="A"/>
  <method class="javax.xml.parsers.SecuritySupport" name="java.io.FileInputStream getFileInputStream(java.io.File)" map="B"/>
  <method class="javax.xml.parsers.SecuritySupport" name="java.lang.String getSystemProperty(java.lang.String)" map="A"/>
  <class name="javax.xml.parsers.FactoryFinder$ConfigurationError" map="_A"/>
  <field class="javax.xml.parsers.FactoryFinder$ConfigurationError" name="exception" map="A"/>
  <method class="javax.xml.parsers.FactoryFinder$ConfigurationError" name="java.lang.Exception getException()" map="A"/>
  <class name="javax.xml.parsers.FactoryFinder" map="B"/>
  <field class="javax.xml.parsers.FactoryFinder" name="debug" map="A"/>
  <field class="javax.xml.parsers.FactoryFinder" name="cacheProps" map="B"/>
  <field class="javax.xml.parsers.FactoryFinder" name="class$javax$xml$parsers$FactoryFinder" map="class$B$A$B$B"/>
  <field class="javax.xml.parsers.FactoryFinder" name="firstTime" map="C"/>
  <method class="javax.xml.parsers.FactoryFinder" name="java.lang.Object find(java.lang.String, java.lang.String)" map="A"/>
  <method class="javax.xml.parsers.FactoryFinder" name="void dPrint(java.lang.String)" map="A"/>
  <method class="javax.xml.parsers.FactoryFinder" name="java.lang.Object findJarServiceProvider(java.lang.String)" map="B"/>
  <method class="javax.xml.parsers.FactoryFinder" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="javax.xml.parsers.FactoryFinder" name="java.lang.Object newInstance(java.lang.String, java.lang.ClassLoader, boolean)" map="A"/>
  <class name="javax.xml.parsers.FactoryConfigurationError" map="C"/>
  <field class="javax.xml.parsers.FactoryConfigurationError" name="exception" map="A"/>
  <method class="javax.xml.parsers.FactoryConfigurationError" name="java.lang.String getMessage()" map="getMessage"/>
  <class name="javax.xml.parsers.DocumentBuilderFactory" map="D"/>
  <method class="javax.xml.parsers.DocumentBuilderFactory" name="void setXIncludeAware(boolean)" map="A"/>
  <method class="javax.xml.parsers.DocumentBuilderFactory" name="javax.xml.parsers.DocumentBuilderFactory newInstance()" map="A"/>
  <method class="javax.xml.parsers.DocumentBuilderFactory" name="void setNamespaceAware(boolean)" map="B"/>
  <method class="javax.xml.parsers.DocumentBuilderFactory" name="void setValidating(boolean)" map="C"/>
  <method class="javax.xml.parsers.DocumentBuilderFactory" name="void setExpandEntityReferences(boolean)" map="D"/>
  <method class="javax.xml.parsers.DocumentBuilderFactory" name="void setCoalescing(boolean)" map="E"/>
  <method class="javax.xml.parsers.DocumentBuilderFactory" name="void setFeature(java.lang.String, boolean)" map="A"/>
  <method class="javax.xml.parsers.DocumentBuilderFactory" name="javax.xml.parsers.DocumentBuilder newDocumentBuilder()" map="B"/>
  <method class="javax.xml.parsers.DocumentBuilderFactory" name="void setIgnoringComments(boolean)" map="F"/>
  <method class="javax.xml.parsers.DocumentBuilderFactory" name="void setIgnoringElementContentWhitespace(boolean)" map="G"/>
  <class name="javax.xml.parsers.ParserConfigurationException" map="E"/>
  <package name="javax.xml.namespace" map="C"/>
  <class name="javax.xml.namespace.QName$1" map="1"/>
  <method class="javax.xml.namespace.QName$1" name="java.lang.Object run()" map="run"/>
  <class name="javax.xml.namespace.QName" map="A"/>
  <field class="javax.xml.namespace.QName" name="localPart" map="A"/>
  <field class="javax.xml.namespace.QName" name="namespaceURI" map="B"/>
  <field class="javax.xml.namespace.QName" name="prefix" map="C"/>
  <field class="javax.xml.namespace.QName" name="qNameAsString" map="D"/>
  <field class="javax.xml.namespace.QName" name="serialVersionUID" map="E"/>
  <method class="javax.xml.namespace.QName" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="javax.xml.namespace.QName" name="java.lang.String getLocalPart()" map="A"/>
  <method class="javax.xml.namespace.QName" name="int hashCode()" map="hashCode"/>
  <method class="javax.xml.namespace.QName" name="java.lang.String getNamespaceURI()" map="B"/>
  <method class="javax.xml.namespace.QName" name="java.lang.String toString()" map="toString"/>
  <method class="javax.xml.namespace.QName" name="java.lang.String getPrefix()" map="C"/>
  <class name="javax.xml.namespace.NamespaceContext" map="B"/>
  <method class="javax.xml.namespace.NamespaceContext" name="java.lang.String getNamespaceURI(java.lang.String)" map="A"/>
  <method class="javax.xml.namespace.NamespaceContext" name="java.lang.String getPrefix(java.lang.String)" map="B"/>
  <package name="javax.xml.datatype" map="D"/>
  <class name="javax.xml.datatype.DatatypeFactory" map="A"/>
  <field class="javax.xml.datatype.DatatypeFactory" name="DATATYPEFACTORY_IMPLEMENTATION_CLASS" map="A"/>
  <package name="javax.xml.crypto" map="E"/>
  <package name="javax.xml.crypto.dsig" map="A"/>
  <package name="javax.xml.crypto.dsig.spec" map="A"/>
  <class name="javax.xml.crypto.dsig.spec.XPathType$Filter" map="_A"/>
  <field class="javax.xml.crypto.dsig.spec.XPathType$Filter" name="operation" map="A"/>
  <field class="javax.xml.crypto.dsig.spec.XPathType$Filter" name="SUBTRACT" map="B"/>
  <field class="javax.xml.crypto.dsig.spec.XPathType$Filter" name="INTERSECT" map="C"/>
  <field class="javax.xml.crypto.dsig.spec.XPathType$Filter" name="UNION" map="D"/>
  <method class="javax.xml.crypto.dsig.spec.XPathType$Filter" name="java.lang.String toString()" map="toString"/>
  <class name="javax.xml.crypto.dsig.spec.XPathType" map="A"/>
  <field class="javax.xml.crypto.dsig.spec.XPathType" name="nsMap" map="A"/>
  <field class="javax.xml.crypto.dsig.spec.XPathType" name="filter" map="B"/>
  <field class="javax.xml.crypto.dsig.spec.XPathType" name="expression" map="C"/>
  <class name="javax.xml.crypto.dsig.spec.TransformParameterSpec" map="B"/>
  <class name="javax.xml.crypto.dsig.spec.C14NMethodParameterSpec" map="C"/>
  <class name="javax.xml.crypto.dsig.spec.XPathFilter2ParameterSpec" map="D"/>
  <field class="javax.xml.crypto.dsig.spec.XPathFilter2ParameterSpec" name="xPathList" map="A"/>
  <method class="javax.xml.crypto.dsig.spec.XPathFilter2ParameterSpec" name="java.util.List unmodifiableCopyOfList(java.util.List)" map="A"/>
  <package name="javax.xml.crypto.dsig.keyinfo" map="B"/>
  <class name="javax.xml.crypto.dsig.keyinfo.KeyInfoFactory" map="A"/>
  <method class="javax.xml.crypto.dsig.keyinfo.KeyInfoFactory" name="javax.xml.crypto.dsig.keyinfo.KeyInfo newKeyInfo(java.util.List)" map="A"/>
  <method class="javax.xml.crypto.dsig.keyinfo.KeyInfoFactory" name="javax.xml.crypto.dsig.keyinfo.X509Data newX509Data(java.util.List)" map="B"/>
  <method class="javax.xml.crypto.dsig.keyinfo.KeyInfoFactory" name="javax.xml.crypto.dsig.keyinfo.KeyValue newKeyValue(java.security.PublicKey)" map="A"/>
  <class name="javax.xml.crypto.dsig.keyinfo.X509Data" map="B"/>
  <method class="javax.xml.crypto.dsig.keyinfo.X509Data" name="java.util.List getContent()" map="F"/>
  <class name="javax.xml.crypto.dsig.keyinfo.KeyInfo" map="C"/>
  <method class="javax.xml.crypto.dsig.keyinfo.KeyInfo" name="java.lang.String getId()" map="A"/>
  <method class="javax.xml.crypto.dsig.keyinfo.KeyInfo" name="java.util.List getContent()" map="B"/>
  <class name="javax.xml.crypto.dsig.keyinfo.KeyValue" map="D"/>
  <method class="javax.xml.crypto.dsig.keyinfo.KeyValue" name="java.security.PublicKey getPublicKey()" map="C"/>
  <package name="javax.xml.crypto.dsig.dom" map="C"/>
  <class name="javax.xml.crypto.dsig.dom.DOMSignContext" map="A"/>
  <field class="javax.xml.crypto.dsig.dom.DOMSignContext" name="parent" map="G"/>
  <field class="javax.xml.crypto.dsig.dom.DOMSignContext" name="nextSibling" map="H"/>
  <method class="javax.xml.crypto.dsig.dom.DOMSignContext" name="org.w3c.dom.Node getParent()" map="B"/>
  <method class="javax.xml.crypto.dsig.dom.DOMSignContext" name="org.w3c.dom.Node getNextSibling()" map="C"/>
  <class name="javax.xml.crypto.dsig.dom.DOMValidateContext" map="B"/>
  <class name="javax.xml.crypto.dsig.XMLSignature" map="A"/>
  <class name="javax.xml.crypto.dsig.Reference" map="B"/>
  <class name="javax.xml.crypto.dsig.XMLSignatureFactory" map="C"/>
  <field class="javax.xml.crypto.dsig.XMLSignatureFactory" name="mechanismType" map="A"/>
  <field class="javax.xml.crypto.dsig.XMLSignatureFactory" name="provider" map="B"/>
  <method class="javax.xml.crypto.dsig.XMLSignatureFactory" name="javax.xml.crypto.dsig.CanonicalizationMethod newCanonicalizationMethod(java.lang.String, javax.xml.crypto.dsig.spec.C14NMethodParameterSpec)" map="A"/>
  <method class="javax.xml.crypto.dsig.XMLSignatureFactory" name="javax.xml.crypto.dsig.Reference newReference(java.lang.String, javax.xml.crypto.dsig.DigestMethod, java.util.List, java.lang.String, java.lang.String)" map="A"/>
  <method class="javax.xml.crypto.dsig.XMLSignatureFactory" name="javax.xml.crypto.dsig.SignedInfo newSignedInfo(javax.xml.crypto.dsig.CanonicalizationMethod, javax.xml.crypto.dsig.SignatureMethod, java.util.List)" map="A"/>
  <method class="javax.xml.crypto.dsig.XMLSignatureFactory" name="java.security.Provider getProvider(java.lang.String, java.lang.String)" map="A"/>
  <method class="javax.xml.crypto.dsig.XMLSignatureFactory" name="javax.xml.crypto.dsig.DigestMethod newDigestMethod(java.lang.String, javax.xml.crypto.dsig.spec.DigestMethodParameterSpec)" map="A"/>
  <method class="javax.xml.crypto.dsig.XMLSignatureFactory" name="javax.xml.crypto.dsig.XMLObject newXMLObject(java.util.List, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="javax.xml.crypto.dsig.XMLSignatureFactory" name="javax.xml.crypto.dsig.XMLSignatureFactory getInstance(java.lang.String, java.security.Provider)" map="A"/>
  <method class="javax.xml.crypto.dsig.XMLSignatureFactory" name="javax.xml.crypto.dsig.XMLSignature newXMLSignature(javax.xml.crypto.dsig.SignedInfo, javax.xml.crypto.dsig.keyinfo.KeyInfo, java.util.List, java.lang.String, java.lang.String)" map="A"/>
  <method class="javax.xml.crypto.dsig.XMLSignatureFactory" name="javax.xml.crypto.dsig.SignedInfo newSignedInfo(javax.xml.crypto.dsig.CanonicalizationMethod, javax.xml.crypto.dsig.SignatureMethod, java.util.List, java.lang.String)" map="A"/>
  <method class="javax.xml.crypto.dsig.XMLSignatureFactory" name="javax.xml.crypto.dsig.Transform newTransform(java.lang.String, javax.xml.crypto.dsig.spec.TransformParameterSpec)" map="A"/>
  <method class="javax.xml.crypto.dsig.XMLSignatureFactory" name="javax.xml.crypto.dsig.XMLSignatureFactory findInstance(java.lang.String, java.security.Provider)" map="B"/>
  <method class="javax.xml.crypto.dsig.XMLSignatureFactory" name="javax.xml.crypto.dsig.SignatureMethod newSignatureMethod(java.lang.String, javax.xml.crypto.dsig.spec.SignatureMethodParameterSpec)" map="A"/>
  <class name="javax.xml.crypto.dsig.XMLValidateContext" map="D"/>
  <class name="javax.xml.crypto.dsig.SignedInfo" map="E"/>
  <class name="javax.xml.crypto.dsig.XMLObject" map="F"/>
  <class name="javax.xml.crypto.dsig.XMLSignContext" map="G"/>
  <package name="javax.xml.crypto.dom" map="B"/>
  <class name="javax.xml.crypto.dom.DOMStructure" map="A"/>
  <field class="javax.xml.crypto.dom.DOMStructure" name="node" map="W"/>
  <class name="javax.xml.crypto.dom.DOMURIReference" map="B"/>
  <class name="javax.xml.crypto.dom.DOMCryptoContext" map="C"/>
  <field class="javax.xml.crypto.dom.DOMCryptoContext" name="objMap" map="A"/>
  <field class="javax.xml.crypto.dom.DOMCryptoContext" name="nsMap" map="B"/>
  <field class="javax.xml.crypto.dom.DOMCryptoContext" name="defaultPrefix" map="C"/>
  <field class="javax.xml.crypto.dom.DOMCryptoContext" name="idMap" map="D"/>
  <field class="javax.xml.crypto.dom.DOMCryptoContext" name="ks" map="E"/>
  <field class="javax.xml.crypto.dom.DOMCryptoContext" name="propMap" map="F"/>
  <method class="javax.xml.crypto.dom.DOMCryptoContext" name="void setKeySelector(javax.xml.crypto.KeySelector)" map="A"/>
  <method class="javax.xml.crypto.dom.DOMCryptoContext" name="java.lang.String getDefaultNamespacePrefix()" map="A"/>
  <method class="javax.xml.crypto.dom.DOMCryptoContext" name="java.lang.String getNamespacePrefix(java.lang.String, java.lang.String)" map="A"/>
  <class name="javax.xml.crypto.URIReference" map="A"/>
  <class name="javax.xml.crypto.NoSuchMechanismException" map="B"/>
  <field class="javax.xml.crypto.NoSuchMechanismException" name="cause" map="A"/>
  <method class="javax.xml.crypto.NoSuchMechanismException" name="java.lang.Throwable getCause()" map="getCause"/>
  <method class="javax.xml.crypto.NoSuchMechanismException" name="void printStackTrace()" map="printStackTrace"/>
  <method class="javax.xml.crypto.NoSuchMechanismException" name="void printStackTrace(java.io.PrintWriter)" map="printStackTrace"/>
  <method class="javax.xml.crypto.NoSuchMechanismException" name="void printStackTrace(java.io.PrintStream)" map="printStackTrace"/>
  <class name="javax.xml.crypto.XMLCryptoContext" map="C"/>
  <method class="javax.xml.crypto.XMLCryptoContext" name="java.lang.String getDefaultNamespacePrefix()" map="A"/>
  <method class="javax.xml.crypto.XMLCryptoContext" name="java.lang.String getNamespacePrefix(java.lang.String, java.lang.String)" map="A"/>
  <class name="javax.xml.crypto.KeySelector$SingletonKeySelector" map="_A"/>
  <field class="javax.xml.crypto.KeySelector$SingletonKeySelector" name="key" map="A"/>
  <class name="javax.xml.crypto.KeySelector" map="D"/>
  <method class="javax.xml.crypto.KeySelector" name="javax.xml.crypto.KeySelector singletonKeySelector(java.security.Key)" map="A"/>
  <class name="javax.xml.crypto.XMLStructure" map="E"/>
  <package name="javax.xml.stream" map="F"/>
  <package name="javax.xml.stream.events" map="A"/>
  <class name="javax.xml.stream.events.EndElement" map="A"/>
  <method class="javax.xml.stream.events.EndElement" name="javax.xml.namespace.QName getName()" map="c"/>
  <method class="javax.xml.stream.events.EndElement" name="java.util.Iterator getNamespaces()" map="d"/>
  <class name="javax.xml.stream.events.ProcessingInstruction" map="B"/>
  <method class="javax.xml.stream.events.ProcessingInstruction" name="java.lang.String getTarget()" map="V"/>
  <method class="javax.xml.stream.events.ProcessingInstruction" name="java.lang.String getData()" map="W"/>
  <class name="javax.xml.stream.events.Attribute" map="C"/>
  <method class="javax.xml.stream.events.Attribute" name="java.lang.String getValue()" map="Y"/>
  <method class="javax.xml.stream.events.Attribute" name="javax.xml.namespace.QName getName()" map="Z"/>
  <method class="javax.xml.stream.events.Attribute" name="boolean isSpecified()" map="_"/>
  <method class="javax.xml.stream.events.Attribute" name="java.lang.String getDTDType()" map="a"/>
  <class name="javax.xml.stream.events.Characters" map="D"/>
  <method class="javax.xml.stream.events.Characters" name="java.lang.String getData()" map="X"/>
  <class name="javax.xml.stream.events.EntityReference" map="E"/>
  <class name="javax.xml.stream.events.XMLEvent" map="F"/>
  <method class="javax.xml.stream.events.XMLEvent" name="javax.xml.stream.events.EndElement asEndElement()" map="P"/>
  <method class="javax.xml.stream.events.XMLEvent" name="javax.xml.stream.events.StartElement asStartElement()" map="Q"/>
  <method class="javax.xml.stream.events.XMLEvent" name="javax.xml.stream.events.Characters asCharacters()" map="R"/>
  <method class="javax.xml.stream.events.XMLEvent" name="boolean isStartDocument()" map="S"/>
  <method class="javax.xml.stream.events.XMLEvent" name="int getEventType()" map="T"/>
  <method class="javax.xml.stream.events.XMLEvent" name="javax.xml.stream.Location getLocation()" map="U"/>
  <class name="javax.xml.stream.events.Comment" map="G"/>
  <class name="javax.xml.stream.events.StartDocument" map="H"/>
  <class name="javax.xml.stream.events.Namespace" map="I"/>
  <method class="javax.xml.stream.events.Namespace" name="java.lang.String getPrefix()" map="b"/>
  <class name="javax.xml.stream.events.StartElement" map="J"/>
  <method class="javax.xml.stream.events.StartElement" name="javax.xml.namespace.QName getName()" map="c"/>
  <method class="javax.xml.stream.events.StartElement" name="javax.xml.namespace.NamespaceContext getNamespaceContext()" map="e"/>
  <method class="javax.xml.stream.events.StartElement" name="java.util.Iterator getAttributes()" map="f"/>
  <method class="javax.xml.stream.events.StartElement" name="java.util.Iterator getNamespaces()" map="d"/>
  <class name="javax.xml.stream.events.NotationDeclaration" map="K"/>
  <class name="javax.xml.stream.events.DTD" map="L"/>
  <class name="javax.xml.stream.events.EndDocument" map="M"/>
  <class name="javax.xml.stream.events.EntityDeclaration" map="N"/>
  <class name="javax.xml.stream.XMLEventReader" map="A"/>
  <method class="javax.xml.stream.XMLEventReader" name="javax.xml.stream.events.XMLEvent nextEvent()" map="A"/>
  <method class="javax.xml.stream.XMLEventReader" name="javax.xml.stream.events.XMLEvent peek()" map="B"/>
  <method class="javax.xml.stream.XMLEventReader" name="boolean hasNext()" map="hasNext"/>
  <class name="javax.xml.stream.Location" map="B"/>
  <method class="javax.xml.stream.Location" name="java.lang.String getPublicId()" map="A"/>
  <method class="javax.xml.stream.Location" name="int getCharacterOffset()" map="B"/>
  <method class="javax.xml.stream.Location" name="int getLineNumber()" map="C"/>
  <method class="javax.xml.stream.Location" name="int getColumnNumber()" map="D"/>
  <method class="javax.xml.stream.Location" name="java.lang.String getSystemId()" map="E"/>
  <class name="javax.xml.stream.XMLStreamReader" map="C"/>
  <method class="javax.xml.stream.XMLStreamReader" name="java.lang.String getAttributeLocalName(int)" map="A"/>
  <method class="javax.xml.stream.XMLStreamReader" name="java.lang.String getAttributePrefix(int)" map="B"/>
  <method class="javax.xml.stream.XMLStreamReader" name="javax.xml.stream.Location getLocation()" map="A"/>
  <method class="javax.xml.stream.XMLStreamReader" name="int getTextStart()" map="B"/>
  <method class="javax.xml.stream.XMLStreamReader" name="int getAttributeCount()" map="C"/>
  <method class="javax.xml.stream.XMLStreamReader" name="java.lang.String getPrefix()" map="D"/>
  <method class="javax.xml.stream.XMLStreamReader" name="int getTextLength()" map="E"/>
  <method class="javax.xml.stream.XMLStreamReader" name="java.lang.String getAttributeValue(int)" map="C"/>
  <method class="javax.xml.stream.XMLStreamReader" name="boolean hasNext()" map="F"/>
  <method class="javax.xml.stream.XMLStreamReader" name="java.lang.String getPITarget()" map="G"/>
  <method class="javax.xml.stream.XMLStreamReader" name="java.lang.String getAttributeNamespace(int)" map="D"/>
  <method class="javax.xml.stream.XMLStreamReader" name="java.lang.String getNamespaceURI()" map="H"/>
  <method class="javax.xml.stream.XMLStreamReader" name="java.lang.String getNamespacePrefix(int)" map="E"/>
  <method class="javax.xml.stream.XMLStreamReader" name="int next()" map="I"/>
  <method class="javax.xml.stream.XMLStreamReader" name="int getEventType()" map="J"/>
  <method class="javax.xml.stream.XMLStreamReader" name="javax.xml.namespace.NamespaceContext getNamespaceContext()" map="K"/>
  <method class="javax.xml.stream.XMLStreamReader" name="java.lang.String getLocalName()" map="L"/>
  <method class="javax.xml.stream.XMLStreamReader" name="java.lang.String getPIData()" map="M"/>
  <method class="javax.xml.stream.XMLStreamReader" name="boolean isAttributeSpecified(int)" map="F"/>
  <method class="javax.xml.stream.XMLStreamReader" name="char[] getTextCharacters()" map="N"/>
  <method class="javax.xml.stream.XMLStreamReader" name="int getNamespaceCount()" map="O"/>
  <method class="javax.xml.stream.XMLStreamReader" name="java.lang.String getAttributeType(int)" map="G"/>
  <class name="javax.xml.stream.XMLStreamException" map="D"/>
  <field class="javax.xml.stream.XMLStreamException" name="location" map="A"/>
  <field class="javax.xml.stream.XMLStreamException" name="nested" map="B"/>
  <method class="javax.xml.stream.XMLStreamException" name="java.lang.Throwable getNestedException()" map="A"/>
  <method class="javax.xml.stream.XMLStreamException" name="javax.xml.stream.Location getLocation()" map="B"/>
  <class name="javax.xml.stream.XMLStreamConstants" map="E"/>
  <package name="com" map="C"/>
  <package name="com.google" map="A"/>
  <package name="com.google.zxing" map="A"/>
  <package name="com.google.zxing.common" map="A"/>
  <package name="com.google.zxing.common.reedsolomon" map="A"/>
  <class name="com.google.zxing.common.reedsolomon.GenericGFPoly" map="A"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGFPoly" name="coefficients" map="A"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGFPoly" name="field" map="B"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGFPoly" name="com.google.zxing.common.reedsolomon.GenericGFPoly[] divide(com.google.zxing.common.reedsolomon.GenericGFPoly)" map="A"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGFPoly" name="int getCoefficient(int)" map="A"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGFPoly" name="int[] getCoefficients()" map="A"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGFPoly" name="boolean isZero()" map="B"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGFPoly" name="com.google.zxing.common.reedsolomon.GenericGFPoly multiply(com.google.zxing.common.reedsolomon.GenericGFPoly)" map="B"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGFPoly" name="com.google.zxing.common.reedsolomon.GenericGFPoly multiplyByMonomial(int, int)" map="A"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGFPoly" name="int getDegree()" map="C"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGFPoly" name="java.lang.String toString()" map="toString"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGFPoly" name="com.google.zxing.common.reedsolomon.GenericGFPoly addOrSubtract(com.google.zxing.common.reedsolomon.GenericGFPoly)" map="C"/>
  <class name="com.google.zxing.common.reedsolomon.GenericGF" map="B"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGF" name="logTable" map="A"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGF" name="QR_CODE_FIELD_256" map="B"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGF" name="expTable" map="C"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGF" name="initialized" map="D"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGF" name="AZTEC_PARAM" map="E"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGF" name="primitive" map="F"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGF" name="one" map="G"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGF" name="MAXICODE_FIELD_64" map="H"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGF" name="zero" map="I"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGF" name="AZTEC_DATA_12" map="J"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGF" name="AZTEC_DATA_10" map="K"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGF" name="AZTEC_DATA_8" map="L"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGF" name="DATA_MATRIX_FIELD_256" map="M"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGF" name="AZTEC_DATA_6" map="N"/>
  <field class="com.google.zxing.common.reedsolomon.GenericGF" name="size" map="O"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGF" name="int multiply(int, int)" map="A"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGF" name="void checkInit()" map="A"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGF" name="int addOrSubtract(int, int)" map="B"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGF" name="void initialize()" map="B"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGF" name="com.google.zxing.common.reedsolomon.GenericGFPoly getZero()" map="C"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGF" name="com.google.zxing.common.reedsolomon.GenericGFPoly buildMonomial(int, int)" map="C"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGF" name="int log(int)" map="A"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGF" name="int exp(int)" map="B"/>
  <method class="com.google.zxing.common.reedsolomon.GenericGF" name="int inverse(int)" map="C"/>
  <class name="com.google.zxing.common.reedsolomon.ReedSolomonEncoder" map="C"/>
  <field class="com.google.zxing.common.reedsolomon.ReedSolomonEncoder" name="cachedGenerators" map="A"/>
  <field class="com.google.zxing.common.reedsolomon.ReedSolomonEncoder" name="field" map="B"/>
  <method class="com.google.zxing.common.reedsolomon.ReedSolomonEncoder" name="void encode(int[], int)" map="A"/>
  <method class="com.google.zxing.common.reedsolomon.ReedSolomonEncoder" name="com.google.zxing.common.reedsolomon.GenericGFPoly buildGenerator(int)" map="A"/>
  <class name="com.google.zxing.common.CharacterSetECI" map="A"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="VALUE_TO_ECI" map="A"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="values" map="B"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ISO8859_9" map="C"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="NAME_TO_ECI" map="D"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ISO8859_8" map="E"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ISO8859_7" map="F"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="UnicodeBigUnmarked" map="G"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ISO8859_6" map="H"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="GB18030" map="I"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ISO8859_5" map="J"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ISO8859_4" map="K"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ISO8859_3" map="L"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ISO8859_2" map="M"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ISO8859_1" map="N"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="SJIS" map="O"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="Cp1256" map="P"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ISO8859_16" map="Q"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ISO8859_15" map="R"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="EUC_KR" map="S"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ISO8859_14" map="T"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="Cp1252" map="U"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ISO8859_13" map="V"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="Cp1251" map="W"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="Cp1250" map="X"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ISO8859_11" map="Y"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ISO8859_10" map="Z"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="otherEncodingNames" map="_"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="$VALUES" map="a"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="UTF8" map="b"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="ASCII" map="c"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="Big5" map="d"/>
  <field class="com.google.zxing.common.CharacterSetECI" name="Cp437" map="e"/>
  <method class="com.google.zxing.common.CharacterSetECI" name="com.google.zxing.common.CharacterSetECI getCharacterSetECIByName(java.lang.String)" map="A"/>
  <method class="com.google.zxing.common.CharacterSetECI" name="int getValue()" map="A"/>
  <method class="com.google.zxing.common.CharacterSetECI" name="com.google.zxing.common.CharacterSetECI valueOf(java.lang.String)" map="valueOf"/>
  <method class="com.google.zxing.common.CharacterSetECI" name="com.google.zxing.common.CharacterSetECI[] values()" map="values"/>
  <class name="com.google.zxing.common.BitArray" map="B"/>
  <field class="com.google.zxing.common.BitArray" name="size" map="A"/>
  <field class="com.google.zxing.common.BitArray" name="bits" map="B"/>
  <method class="com.google.zxing.common.BitArray" name="void toBytes(int, byte[], int, int)" map="A"/>
  <method class="com.google.zxing.common.BitArray" name="void xor(com.google.zxing.common.BitArray)" map="A"/>
  <method class="com.google.zxing.common.BitArray" name="int getSizeInBytes()" map="A"/>
  <method class="com.google.zxing.common.BitArray" name="void appendBitArray(com.google.zxing.common.BitArray)" map="B"/>
  <method class="com.google.zxing.common.BitArray" name="int[] makeArray(int)" map="A"/>
  <method class="com.google.zxing.common.BitArray" name="int getSize()" map="B"/>
  <method class="com.google.zxing.common.BitArray" name="java.lang.String toString()" map="toString"/>
  <method class="com.google.zxing.common.BitArray" name="void appendBit(boolean)" map="A"/>
  <method class="com.google.zxing.common.BitArray" name="boolean get(int)" map="B"/>
  <method class="com.google.zxing.common.BitArray" name="void ensureCapacity(int)" map="C"/>
  <method class="com.google.zxing.common.BitArray" name="void appendBits(int, int)" map="A"/>
  <package name="com.google.zxing.qrcode" map="B"/>
  <package name="com.google.zxing.qrcode.encoder" map="A"/>
  <class name="com.google.zxing.qrcode.encoder.MatrixUtil" map="A"/>
  <field class="com.google.zxing.qrcode.encoder.MatrixUtil" name="POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE" map="A"/>
  <field class="com.google.zxing.qrcode.encoder.MatrixUtil" name="POSITION_DETECTION_PATTERN" map="B"/>
  <field class="com.google.zxing.qrcode.encoder.MatrixUtil" name="TYPE_INFO_COORDINATES" map="C"/>
  <field class="com.google.zxing.qrcode.encoder.MatrixUtil" name="POSITION_ADJUSTMENT_PATTERN" map="D"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void embedTypeInfo(com.google.zxing.qrcode.decoder.ErrorCorrectionLevel, int, com.google.zxing.qrcode.encoder.ByteMatrix)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void makeVersionInfoBits(com.google.zxing.qrcode.decoder.Version, com.google.zxing.common.BitArray)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void embedTimingPatterns(com.google.zxing.qrcode.encoder.ByteMatrix)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void embedPositionDetectionPatternsAndSeparators(com.google.zxing.qrcode.encoder.ByteMatrix)" map="B"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void embedVerticalSeparationPattern(int, int, com.google.zxing.qrcode.encoder.ByteMatrix)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="int findMSBSet(int)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void clearMatrix(com.google.zxing.qrcode.encoder.ByteMatrix)" map="C"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void embedPositionDetectionPattern(int, int, com.google.zxing.qrcode.encoder.ByteMatrix)" map="B"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="boolean isEmpty(int)" map="B"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void embedHorizontalSeparationPattern(int, int, com.google.zxing.qrcode.encoder.ByteMatrix)" map="C"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void embedDataBits(com.google.zxing.common.BitArray, int, com.google.zxing.qrcode.encoder.ByteMatrix)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void embedBasicPatterns(com.google.zxing.qrcode.decoder.Version, com.google.zxing.qrcode.encoder.ByteMatrix)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void embedDarkDotAtLeftBottomCorner(com.google.zxing.qrcode.encoder.ByteMatrix)" map="D"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="int calculateBCHCode(int, int)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void maybeEmbedPositionAdjustmentPatterns(com.google.zxing.qrcode.decoder.Version, com.google.zxing.qrcode.encoder.ByteMatrix)" map="B"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void maybeEmbedVersionInfo(com.google.zxing.qrcode.decoder.Version, com.google.zxing.qrcode.encoder.ByteMatrix)" map="C"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void buildMatrix(com.google.zxing.common.BitArray, com.google.zxing.qrcode.decoder.ErrorCorrectionLevel, com.google.zxing.qrcode.decoder.Version, int, com.google.zxing.qrcode.encoder.ByteMatrix)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void makeTypeInfoBits(com.google.zxing.qrcode.decoder.ErrorCorrectionLevel, int, com.google.zxing.common.BitArray)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.MatrixUtil" name="void embedPositionAdjustmentPattern(int, int, com.google.zxing.qrcode.encoder.ByteMatrix)" map="D"/>
  <class name="com.google.zxing.qrcode.encoder.MaskUtil" map="B"/>
  <method class="com.google.zxing.qrcode.encoder.MaskUtil" name="int applyMaskPenaltyRule2(com.google.zxing.qrcode.encoder.ByteMatrix)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.MaskUtil" name="int applyMaskPenaltyRule1Internal(com.google.zxing.qrcode.encoder.ByteMatrix, boolean)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.MaskUtil" name="int applyMaskPenaltyRule1(com.google.zxing.qrcode.encoder.ByteMatrix)" map="B"/>
  <method class="com.google.zxing.qrcode.encoder.MaskUtil" name="boolean getDataMaskBit(int, int, int)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.MaskUtil" name="int applyMaskPenaltyRule4(com.google.zxing.qrcode.encoder.ByteMatrix)" map="C"/>
  <method class="com.google.zxing.qrcode.encoder.MaskUtil" name="int applyMaskPenaltyRule3(com.google.zxing.qrcode.encoder.ByteMatrix)" map="D"/>
  <class name="com.google.zxing.qrcode.encoder.Encoder$1" map="1"/>
  <field class="com.google.zxing.qrcode.encoder.Encoder$1" name="$SwitchMap$com$google$zxing$qrcode$decoder$Mode" map="A"/>
  <class name="com.google.zxing.qrcode.encoder.Encoder" map="C"/>
  <field class="com.google.zxing.qrcode.encoder.Encoder" name="ALPHANUMERIC_TABLE" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="int calculateMaskPenalty(com.google.zxing.qrcode.encoder.ByteMatrix)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="void appendKanjiBytes(java.lang.String, com.google.zxing.common.BitArray)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="void getNumDataBytesAndNumECBytesForBlockID(int, int, int, int, int[], int[])" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="boolean isOnlyDoubleByteKanji(java.lang.String)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="void appendAlphanumericBytes(java.lang.CharSequence, com.google.zxing.common.BitArray)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="void terminateBits(int, com.google.zxing.common.BitArray)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="int chooseMaskPattern(com.google.zxing.common.BitArray, com.google.zxing.qrcode.decoder.ErrorCorrectionLevel, com.google.zxing.qrcode.decoder.Version, com.google.zxing.qrcode.encoder.ByteMatrix)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="byte[] generateECBytes(byte[], int)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="void appendModeInfo(com.google.zxing.qrcode.decoder.Mode, com.google.zxing.common.BitArray)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="void append8BitBytes(java.lang.String, com.google.zxing.common.BitArray, java.lang.String)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="com.google.zxing.qrcode.decoder.Mode chooseMode(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="com.google.zxing.qrcode.encoder.QRCode encode(java.lang.String, com.google.zxing.qrcode.decoder.ErrorCorrectionLevel)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="com.google.zxing.common.BitArray interleaveWithECBytes(com.google.zxing.common.BitArray, int, int, int)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="com.google.zxing.qrcode.decoder.Version chooseVersion(int, com.google.zxing.qrcode.decoder.ErrorCorrectionLevel)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="int getAlphanumericCode(int)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="com.google.zxing.qrcode.encoder.QRCode encode(java.lang.String, com.google.zxing.qrcode.decoder.ErrorCorrectionLevel, java.util.Map)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="void appendLengthInfo(int, com.google.zxing.qrcode.decoder.Version, com.google.zxing.qrcode.decoder.Mode, com.google.zxing.common.BitArray)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="void appendNumericBytes(java.lang.CharSequence, com.google.zxing.common.BitArray)" map="B"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="void appendECI(com.google.zxing.common.CharacterSetECI, com.google.zxing.common.BitArray)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.Encoder" name="void appendBytes(java.lang.String, com.google.zxing.qrcode.decoder.Mode, com.google.zxing.common.BitArray, java.lang.String)" map="A"/>
  <class name="com.google.zxing.qrcode.encoder.ByteMatrix" map="D"/>
  <field class="com.google.zxing.qrcode.encoder.ByteMatrix" name="height" map="A"/>
  <field class="com.google.zxing.qrcode.encoder.ByteMatrix" name="bytes" map="B"/>
  <field class="com.google.zxing.qrcode.encoder.ByteMatrix" name="width" map="C"/>
  <method class="com.google.zxing.qrcode.encoder.ByteMatrix" name="void clear(byte)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.ByteMatrix" name="void set(int, int, boolean)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.ByteMatrix" name="void set(int, int, int)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.ByteMatrix" name="int getWidth()" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.ByteMatrix" name="java.lang.String toString()" map="toString"/>
  <method class="com.google.zxing.qrcode.encoder.ByteMatrix" name="byte get(int, int)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.ByteMatrix" name="byte[][] getArray()" map="B"/>
  <method class="com.google.zxing.qrcode.encoder.ByteMatrix" name="int getHeight()" map="C"/>
  <class name="com.google.zxing.qrcode.encoder.QRCode" map="E"/>
  <field class="com.google.zxing.qrcode.encoder.QRCode" name="version" map="A"/>
  <field class="com.google.zxing.qrcode.encoder.QRCode" name="matrix" map="B"/>
  <field class="com.google.zxing.qrcode.encoder.QRCode" name="ecLevel" map="C"/>
  <field class="com.google.zxing.qrcode.encoder.QRCode" name="maskPattern" map="D"/>
  <field class="com.google.zxing.qrcode.encoder.QRCode" name="mode" map="E"/>
  <method class="com.google.zxing.qrcode.encoder.QRCode" name="com.google.zxing.qrcode.encoder.ByteMatrix getMatrix()" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.QRCode" name="void setVersion(com.google.zxing.qrcode.decoder.Version)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.QRCode" name="void setECLevel(com.google.zxing.qrcode.decoder.ErrorCorrectionLevel)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.QRCode" name="java.lang.String toString()" map="toString"/>
  <method class="com.google.zxing.qrcode.encoder.QRCode" name="boolean isValidMaskPattern(int)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.QRCode" name="void setMaskPattern(int)" map="B"/>
  <method class="com.google.zxing.qrcode.encoder.QRCode" name="void setMode(com.google.zxing.qrcode.decoder.Mode)" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.QRCode" name="void setMatrix(com.google.zxing.qrcode.encoder.ByteMatrix)" map="A"/>
  <class name="com.google.zxing.qrcode.encoder.BlockPair" map="F"/>
  <field class="com.google.zxing.qrcode.encoder.BlockPair" name="dataBytes" map="A"/>
  <field class="com.google.zxing.qrcode.encoder.BlockPair" name="errorCorrectionBytes" map="B"/>
  <method class="com.google.zxing.qrcode.encoder.BlockPair" name="byte[] getErrorCorrectionBytes()" map="A"/>
  <method class="com.google.zxing.qrcode.encoder.BlockPair" name="byte[] getDataBytes()" map="B"/>
  <package name="com.google.zxing.qrcode.decoder" map="B"/>
  <class name="com.google.zxing.qrcode.decoder.ErrorCorrectionLevel" map="A"/>
  <field class="com.google.zxing.qrcode.decoder.ErrorCorrectionLevel" name="L" map="A"/>
  <field class="com.google.zxing.qrcode.decoder.ErrorCorrectionLevel" name="$VALUES" map="B"/>
  <field class="com.google.zxing.qrcode.decoder.ErrorCorrectionLevel" name="H" map="C"/>
  <field class="com.google.zxing.qrcode.decoder.ErrorCorrectionLevel" name="FOR_BITS" map="D"/>
  <field class="com.google.zxing.qrcode.decoder.ErrorCorrectionLevel" name="Q" map="E"/>
  <field class="com.google.zxing.qrcode.decoder.ErrorCorrectionLevel" name="bits" map="F"/>
  <field class="com.google.zxing.qrcode.decoder.ErrorCorrectionLevel" name="M" map="G"/>
  <method class="com.google.zxing.qrcode.decoder.ErrorCorrectionLevel" name="int getBits()" map="A"/>
  <method class="com.google.zxing.qrcode.decoder.ErrorCorrectionLevel" name="com.google.zxing.qrcode.decoder.ErrorCorrectionLevel valueOf(java.lang.String)" map="valueOf"/>
  <method class="com.google.zxing.qrcode.decoder.ErrorCorrectionLevel" name="com.google.zxing.qrcode.decoder.ErrorCorrectionLevel[] values()" map="values"/>
  <class name="com.google.zxing.qrcode.decoder.Mode" map="B"/>
  <field class="com.google.zxing.qrcode.decoder.Mode" name="characterCountBitsForVersions" map="A"/>
  <field class="com.google.zxing.qrcode.decoder.Mode" name="ALPHANUMERIC" map="B"/>
  <field class="com.google.zxing.qrcode.decoder.Mode" name="NUMERIC" map="C"/>
  <field class="com.google.zxing.qrcode.decoder.Mode" name="TERMINATOR" map="D"/>
  <field class="com.google.zxing.qrcode.decoder.Mode" name="HANZI" map="E"/>
  <field class="com.google.zxing.qrcode.decoder.Mode" name="$VALUES" map="F"/>
  <field class="com.google.zxing.qrcode.decoder.Mode" name="FNC1_SECOND_POSITION" map="G"/>
  <field class="com.google.zxing.qrcode.decoder.Mode" name="ECI" map="H"/>
  <field class="com.google.zxing.qrcode.decoder.Mode" name="KANJI" map="I"/>
  <field class="com.google.zxing.qrcode.decoder.Mode" name="FNC1_FIRST_POSITION" map="J"/>
  <field class="com.google.zxing.qrcode.decoder.Mode" name="bits" map="K"/>
  <field class="com.google.zxing.qrcode.decoder.Mode" name="BYTE" map="L"/>
  <field class="com.google.zxing.qrcode.decoder.Mode" name="STRUCTURED_APPEND" map="M"/>
  <method class="com.google.zxing.qrcode.decoder.Mode" name="int getBits()" map="A"/>
  <method class="com.google.zxing.qrcode.decoder.Mode" name="com.google.zxing.qrcode.decoder.Mode valueOf(java.lang.String)" map="valueOf"/>
  <method class="com.google.zxing.qrcode.decoder.Mode" name="com.google.zxing.qrcode.decoder.Mode[] values()" map="values"/>
  <method class="com.google.zxing.qrcode.decoder.Mode" name="int getCharacterCountBits(com.google.zxing.qrcode.decoder.Version)" map="A"/>
  <class name="com.google.zxing.qrcode.decoder.Version$ECB" map="_A"/>
  <field class="com.google.zxing.qrcode.decoder.Version$ECB" name="dataCodewords" map="A"/>
  <field class="com.google.zxing.qrcode.decoder.Version$ECB" name="count" map="B"/>
  <method class="com.google.zxing.qrcode.decoder.Version$ECB" name="int getDataCodewords()" map="A"/>
  <method class="com.google.zxing.qrcode.decoder.Version$ECB" name="int getCount()" map="B"/>
  <class name="com.google.zxing.qrcode.decoder.Version$ECBlocks" map="_B"/>
  <field class="com.google.zxing.qrcode.decoder.Version$ECBlocks" name="ecBlocks" map="A"/>
  <field class="com.google.zxing.qrcode.decoder.Version$ECBlocks" name="ecCodewordsPerBlock" map="B"/>
  <method class="com.google.zxing.qrcode.decoder.Version$ECBlocks" name="int getTotalECCodewords()" map="A"/>
  <method class="com.google.zxing.qrcode.decoder.Version$ECBlocks" name="int getECCodewordsPerBlock()" map="B"/>
  <method class="com.google.zxing.qrcode.decoder.Version$ECBlocks" name="int getNumBlocks()" map="C"/>
  <method class="com.google.zxing.qrcode.decoder.Version$ECBlocks" name="com.google.zxing.qrcode.decoder.Version$ECB[] getECBlocks()" map="D"/>
  <class name="com.google.zxing.qrcode.decoder.Version" map="C"/>
  <field class="com.google.zxing.qrcode.decoder.Version" name="totalCodewords" map="A"/>
  <field class="com.google.zxing.qrcode.decoder.Version" name="alignmentPatternCenters" map="B"/>
  <field class="com.google.zxing.qrcode.decoder.Version" name="versionNumber" map="C"/>
  <field class="com.google.zxing.qrcode.decoder.Version" name="VERSION_DECODE_INFO" map="D"/>
  <field class="com.google.zxing.qrcode.decoder.Version" name="ecBlocks" map="E"/>
  <field class="com.google.zxing.qrcode.decoder.Version" name="VERSIONS" map="F"/>
  <method class="com.google.zxing.qrcode.decoder.Version" name="int getVersionNumber()" map="A"/>
  <method class="com.google.zxing.qrcode.decoder.Version" name="com.google.zxing.qrcode.decoder.Version$ECBlocks getECBlocksForLevel(com.google.zxing.qrcode.decoder.ErrorCorrectionLevel)" map="A"/>
  <method class="com.google.zxing.qrcode.decoder.Version" name="int getDimensionForVersion()" map="B"/>
  <method class="com.google.zxing.qrcode.decoder.Version" name="com.google.zxing.qrcode.decoder.Version getVersionForNumber(int)" map="A"/>
  <method class="com.google.zxing.qrcode.decoder.Version" name="int getTotalCodewords()" map="C"/>
  <method class="com.google.zxing.qrcode.decoder.Version" name="java.lang.String toString()" map="toString"/>
  <method class="com.google.zxing.qrcode.decoder.Version" name="com.google.zxing.qrcode.decoder.Version[] buildVersions()" map="D"/>
  <class name="com.google.zxing.EncodeHintType" map="A"/>
  <field class="com.google.zxing.EncodeHintType" name="PDF417_DIMENSIONS" map="A"/>
  <field class="com.google.zxing.EncodeHintType" name="PDF417_COMPACT" map="B"/>
  <field class="com.google.zxing.EncodeHintType" name="CHARACTER_SET" map="C"/>
  <field class="com.google.zxing.EncodeHintType" name="$VALUES" map="D"/>
  <field class="com.google.zxing.EncodeHintType" name="MARGIN" map="E"/>
  <field class="com.google.zxing.EncodeHintType" name="ERROR_CORRECTION" map="F"/>
  <field class="com.google.zxing.EncodeHintType" name="PDF417_COMPACTION" map="G"/>
  <method class="com.google.zxing.EncodeHintType" name="com.google.zxing.EncodeHintType valueOf(java.lang.String)" map="valueOf"/>
  <method class="com.google.zxing.EncodeHintType" name="com.google.zxing.EncodeHintType[] values()" map="values"/>
  <class name="com.google.zxing.WriterException" map="B"/>
  <package name="com.itextpdf" map="B"/>
  <package name="com.itextpdf.tool" map="A"/>
  <package name="com.itextpdf.tool.xml" map="A"/>
  <package name="com.itextpdf.tool.xml.pipeline" map="A"/>
  <package name="com.itextpdf.tool.xml.pipeline.end" map="A"/>
  <class name="com.itextpdf.tool.xml.pipeline.end.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.pipeline.end.PdfWriterPipeline" map="A"/>
  <field class="com.itextpdf.tool.xml.pipeline.end.PdfWriterPipeline" name="LOG" map="D"/>
  <field class="com.itextpdf.tool.xml.pipeline.end.PdfWriterPipeline" name="continiously" map="E"/>
  <field class="com.itextpdf.tool.xml.pipeline.end.PdfWriterPipeline" name="writer" map="F"/>
  <field class="com.itextpdf.tool.xml.pipeline.end.PdfWriterPipeline" name="doc" map="G"/>
  <method class="com.itextpdf.tool.xml.pipeline.end.PdfWriterPipeline" name="com.itextpdf.tool.xml.Pipeline content(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag, java.lang.String, com.itextpdf.tool.xml.ProcessObject)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.end.PdfWriterPipeline" name="com.itextpdf.tool.xml.Pipeline open(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag, com.itextpdf.tool.xml.ProcessObject)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.end.PdfWriterPipeline" name="com.itextpdf.tool.xml.Pipeline close(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag, com.itextpdf.tool.xml.ProcessObject)" map="B"/>
  <method class="com.itextpdf.tool.xml.pipeline.end.PdfWriterPipeline" name="com.itextpdf.tool.xml.Pipeline init(com.itextpdf.tool.xml.WorkerContext)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.end.PdfWriterPipeline" name="void write(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.ProcessObject)" map="A"/>
  <package name="com.itextpdf.tool.xml.pipeline.ctx" map="B"/>
  <class name="com.itextpdf.tool.xml.pipeline.ctx.MapContext" map="A"/>
  <field class="com.itextpdf.tool.xml.pipeline.ctx.MapContext" name="map" map="O"/>
  <method class="com.itextpdf.tool.xml.pipeline.ctx.MapContext" name="java.lang.Object get(java.lang.String)" map="B"/>
  <method class="com.itextpdf.tool.xml.pipeline.ctx.MapContext" name="void put(java.lang.String, java.lang.Object)" map="A"/>
  <class name="com.itextpdf.tool.xml.pipeline.ctx.WorkerContextImpl" map="B"/>
  <field class="com.itextpdf.tool.xml.pipeline.ctx.WorkerContextImpl" name="tag" map="A"/>
  <field class="com.itextpdf.tool.xml.pipeline.ctx.WorkerContextImpl" name="mc" map="B"/>
  <method class="com.itextpdf.tool.xml.pipeline.ctx.WorkerContextImpl" name="void put(java.lang.String, com.itextpdf.tool.xml.CustomContext)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.ctx.WorkerContextImpl" name="com.itextpdf.tool.xml.CustomContext get(java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.ctx.WorkerContextImpl" name="void setCurrentTag(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.ctx.WorkerContextImpl" name="com.itextpdf.tool.xml.Tag getCurrentTag()" map="A"/>
  <class name="com.itextpdf.tool.xml.pipeline.ctx.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.pipeline.ctx.ObjectContext" map="C"/>
  <field class="com.itextpdf.tool.xml.pipeline.ctx.ObjectContext" name="obj" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.ctx.ObjectContext" name="java.lang.Object get()" map="A"/>
  <package name="com.itextpdf.tool.xml.pipeline.html" map="C"/>
  <class name="com.itextpdf.tool.xml.pipeline.html.ImageProvider" map="A"/>
  <class name="com.itextpdf.tool.xml.pipeline.html.NoStackException" map="B"/>
  <class name="com.itextpdf.tool.xml.pipeline.html.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.pipeline.html.StackKeeper" map="C"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.StackKeeper" name="stack" map="A"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.StackKeeper" name="tag" map="B"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.StackKeeper" name="void add(com.itextpdf.text.Element)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.StackKeeper" name="java.util.List getElements()" map="A"/>
  <class name="com.itextpdf.tool.xml.pipeline.html.LinkProvider" map="D"/>
  <class name="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" map="E"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="cssAppliers" map="B"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="tagFactory" map="C"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="imageProvider" map="D"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="autoBookmark" map="E"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="charset" map="F"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="ctn" map="G"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="memory" map="H"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="linkprovider" map="I"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="queue" map="J"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="roottags" map="K"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="acceptUnknown" map="L"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="resourcesRootPath" map="M"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="pageSize" map="N"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext clone()" map="B"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext setImageProvider(com.itextpdf.tool.xml.pipeline.html.ImageProvider)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="void addFirst(com.itextpdf.tool.xml.pipeline.html.StackKeeper)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="java.lang.Object clone()" map="clone"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="com.itextpdf.tool.xml.pipeline.html.StackKeeper peek()" map="C"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext setTagFactory(com.itextpdf.tool.xml.html.TagProcessorFactory)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="com.itextpdf.tool.xml.html.TagProcessor resolveProcessor(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="void setCssAppliers(com.itextpdf.tool.xml.html.CssAppliers)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="boolean acceptUnknown()" map="D"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext setLinkProvider(com.itextpdf.tool.xml.pipeline.html.LinkProvider)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext autoBookmark(boolean)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext setPageSize(com.itextpdf.text.Rectangle)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext setRootTags(java.util.List)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="java.util.List currentContent()" map="E"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext setAcceptUnknown(boolean)" map="B"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext setCssApplier(com.itextpdf.tool.xml.html.CssAppliers)" map="B"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="com.itextpdf.tool.xml.pipeline.html.StackKeeper poll()" map="F"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext charSet(java.nio.charset.Charset)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="void setResourcesRootPath(java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext" name="java.util.Map getMemory()" map="G"/>
  <class name="com.itextpdf.tool.xml.pipeline.html.HtmlPipeline" map="F"/>
  <field class="com.itextpdf.tool.xml.pipeline.html.HtmlPipeline" name="hpc" map="B"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipeline" name="com.itextpdf.tool.xml.Pipeline content(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag, java.lang.String, com.itextpdf.tool.xml.ProcessObject)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipeline" name="com.itextpdf.tool.xml.Pipeline open(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag, com.itextpdf.tool.xml.ProcessObject)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipeline" name="void addStackKeeper(com.itextpdf.tool.xml.Tag, com.itextpdf.tool.xml.pipeline.html.HtmlPipelineContext, com.itextpdf.tool.xml.html.TagProcessor)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipeline" name="com.itextpdf.tool.xml.Pipeline close(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag, com.itextpdf.tool.xml.ProcessObject)" map="B"/>
  <method class="com.itextpdf.tool.xml.pipeline.html.HtmlPipeline" name="com.itextpdf.tool.xml.Pipeline init(com.itextpdf.tool.xml.WorkerContext)" map="A"/>
  <package name="com.itextpdf.tool.xml.pipeline.css" map="D"/>
  <class name="com.itextpdf.tool.xml.pipeline.css.CssResolverPipeline" map="A"/>
  <field class="com.itextpdf.tool.xml.pipeline.css.CssResolverPipeline" name="resolver" map="C"/>
  <method class="com.itextpdf.tool.xml.pipeline.css.CssResolverPipeline" name="com.itextpdf.tool.xml.Pipeline open(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag, com.itextpdf.tool.xml.ProcessObject)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.css.CssResolverPipeline" name="com.itextpdf.tool.xml.Pipeline init(com.itextpdf.tool.xml.WorkerContext)" map="A"/>
  <class name="com.itextpdf.tool.xml.pipeline.css.CSSResolver" map="B"/>
  <method class="com.itextpdf.tool.xml.pipeline.css.CSSResolver" name="void resolveStyles(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.css.CSSResolver" name="com.itextpdf.tool.xml.pipeline.css.CSSResolver clear()" map="A"/>
  <class name="com.itextpdf.tool.xml.pipeline.css.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.pipeline.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.pipeline.WritableElement" map="A"/>
  <field class="com.itextpdf.tool.xml.pipeline.WritableElement" name="list" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.WritableElement" name="void add(com.itextpdf.text.Element)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.WritableElement" name="java.util.List elements()" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.WritableElement" name="void addAll(java.util.List)" map="A"/>
  <class name="com.itextpdf.tool.xml.pipeline.AbstractPipeline" map="B"/>
  <field class="com.itextpdf.tool.xml.pipeline.AbstractPipeline" name="next" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.AbstractPipeline" name="com.itextpdf.tool.xml.Pipeline content(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag, java.lang.String, com.itextpdf.tool.xml.ProcessObject)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.AbstractPipeline" name="void setNext(com.itextpdf.tool.xml.Pipeline)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.AbstractPipeline" name="com.itextpdf.tool.xml.Pipeline getNext()" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.AbstractPipeline" name="com.itextpdf.tool.xml.Pipeline open(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag, com.itextpdf.tool.xml.ProcessObject)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.AbstractPipeline" name="com.itextpdf.tool.xml.Pipeline close(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag, com.itextpdf.tool.xml.ProcessObject)" map="B"/>
  <method class="com.itextpdf.tool.xml.pipeline.AbstractPipeline" name="com.itextpdf.tool.xml.Pipeline init(com.itextpdf.tool.xml.WorkerContext)" map="A"/>
  <method class="com.itextpdf.tool.xml.pipeline.AbstractPipeline" name="java.lang.String getContextKey()" map="B"/>
  <method class="com.itextpdf.tool.xml.pipeline.AbstractPipeline" name="com.itextpdf.tool.xml.CustomContext getLocalContext(com.itextpdf.tool.xml.WorkerContext)" map="B"/>
  <package name="com.itextpdf.tool.xml.html" map="B"/>
  <package name="com.itextpdf.tool.xml.html.head" map="A"/>
  <class name="com.itextpdf.tool.xml.html.head.package-info" map="package-info"/>
  <package name="com.itextpdf.tool.xml.html.table" map="B"/>
  <class name="com.itextpdf.tool.xml.html.table.package-info" map="package-info"/>
  <package name="com.itextpdf.tool.xml.html.pdfelement" map="C"/>
  <class name="com.itextpdf.tool.xml.html.pdfelement.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.html.Tags" map="A"/>
  <field class="com.itextpdf.tool.xml.html.Tags" name="dummyTagProcessor" map="A"/>
  <field class="com.itextpdf.tool.xml.html.Tags" name="defaultpackage" map="B"/>
  <field class="com.itextpdf.tool.xml.html.Tags" name="span" map="C"/>
  <field class="com.itextpdf.tool.xml.html.Tags" name="nonSanitized" map="D"/>
  <field class="com.itextpdf.tool.xml.html.Tags" name="headers" map="E"/>
  <field class="com.itextpdf.tool.xml.html.Tags" name="paragraph" map="F"/>
  <method class="com.itextpdf.tool.xml.html.Tags" name="com.itextpdf.tool.xml.html.TagProcessorFactory getHtmlTagProcessorFactory()" map="A"/>
  <class name="com.itextpdf.tool.xml.html.CssAppliers" map="B"/>
  <method class="com.itextpdf.tool.xml.html.CssAppliers" name="com.itextpdf.tool.xml.html.CssAppliers clone()" map="A"/>
  <class name="com.itextpdf.tool.xml.html.CssAppliersImpl" map="C"/>
  <field class="com.itextpdf.tool.xml.html.CssAppliersImpl" name="lineseparator" map="A"/>
  <field class="com.itextpdf.tool.xml.html.CssAppliersImpl" name="chunk" map="B"/>
  <field class="com.itextpdf.tool.xml.html.CssAppliersImpl" name="htmlcell" map="C"/>
  <field class="com.itextpdf.tool.xml.html.CssAppliersImpl" name="nonewlineparagraph" map="D"/>
  <field class="com.itextpdf.tool.xml.html.CssAppliersImpl" name="list" map="E"/>
  <field class="com.itextpdf.tool.xml.html.CssAppliersImpl" name="image" map="F"/>
  <field class="com.itextpdf.tool.xml.html.CssAppliersImpl" name="div" map="G"/>
  <field class="com.itextpdf.tool.xml.html.CssAppliersImpl" name="paragraph" map="H"/>
  <method class="com.itextpdf.tool.xml.html.CssAppliersImpl" name="java.lang.Object clone()" map="clone"/>
  <method class="com.itextpdf.tool.xml.html.CssAppliersImpl" name="com.itextpdf.tool.xml.html.CssAppliersImpl getClonedObject()" map="B"/>
  <method class="com.itextpdf.tool.xml.html.CssAppliersImpl" name="com.itextpdf.tool.xml.html.CssAppliers clone()" map="A"/>
  <class name="com.itextpdf.tool.xml.html.DefaultTagProcessorFactory$FactoryObject" map="_A"/>
  <field class="com.itextpdf.tool.xml.html.DefaultTagProcessorFactory$FactoryObject" name="this$0" map="A"/>
  <field class="com.itextpdf.tool.xml.html.DefaultTagProcessorFactory$FactoryObject" name="proc" map="B"/>
  <field class="com.itextpdf.tool.xml.html.DefaultTagProcessorFactory$FactoryObject" name="className" map="C"/>
  <method class="com.itextpdf.tool.xml.html.DefaultTagProcessorFactory$FactoryObject" name="com.itextpdf.tool.xml.html.TagProcessor getProcessor()" map="A"/>
  <class name="com.itextpdf.tool.xml.html.DefaultTagProcessorFactory" map="D"/>
  <field class="com.itextpdf.tool.xml.html.DefaultTagProcessorFactory" name="map" map="A"/>
  <method class="com.itextpdf.tool.xml.html.DefaultTagProcessorFactory" name="void addProcessor(java.lang.String, java.lang.String)" map="B"/>
  <method class="com.itextpdf.tool.xml.html.DefaultTagProcessorFactory" name="com.itextpdf.tool.xml.html.TagProcessor load(java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.html.DefaultTagProcessorFactory" name="com.itextpdf.tool.xml.html.TagProcessor getProcessor(java.lang.String, java.lang.String)" map="A"/>
  <class name="com.itextpdf.tool.xml.html.CssAppliersAware" map="E"/>
  <method class="com.itextpdf.tool.xml.html.CssAppliersAware" name="void setCssAppliers(com.itextpdf.tool.xml.html.CssAppliers)" map="A"/>
  <class name="com.itextpdf.tool.xml.html.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.html.TagProcessorFactory" map="F"/>
  <method class="com.itextpdf.tool.xml.html.TagProcessorFactory" name="com.itextpdf.tool.xml.html.TagProcessor getProcessor(java.lang.String, java.lang.String)" map="A"/>
  <class name="com.itextpdf.tool.xml.html.TagProcessor" map="G"/>
  <method class="com.itextpdf.tool.xml.html.TagProcessor" name="java.util.List content(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag, java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.html.TagProcessor" name="java.util.List endElement(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag, java.util.List)" map="A"/>
  <method class="com.itextpdf.tool.xml.html.TagProcessor" name="java.util.List startElement(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.html.TagProcessor" name="boolean isStackOwner()" map="A"/>
  <package name="com.itextpdf.tool.xml.exceptions" map="C"/>
  <class name="com.itextpdf.tool.xml.exceptions.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.exceptions.NoTagProcessorException" map="A"/>
  <class name="com.itextpdf.tool.xml.exceptions.LocaleMessages" map="B"/>
  <field class="com.itextpdf.tool.xml.exceptions.LocaleMessages" name="bundle" map="A"/>
  <field class="com.itextpdf.tool.xml.exceptions.LocaleMessages" name="myself" map="B"/>
  <method class="com.itextpdf.tool.xml.exceptions.LocaleMessages" name="java.lang.String getMessage(java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.exceptions.LocaleMessages" name="com.itextpdf.tool.xml.exceptions.LocaleMessages getInstance()" map="A"/>
  <class name="com.itextpdf.tool.xml.exceptions.CssResolverException" map="C"/>
  <class name="com.itextpdf.tool.xml.exceptions.RuntimeWorkerException" map="D"/>
  <package name="com.itextpdf.tool.xml.css" map="D"/>
  <package name="com.itextpdf.tool.xml.css.apply" map="A"/>
  <class name="com.itextpdf.tool.xml.css.apply.PageSizeContainable" map="A"/>
  <class name="com.itextpdf.tool.xml.css.apply.ChunkCssApplier" map="B"/>
  <field class="com.itextpdf.tool.xml.css.apply.ChunkCssApplier" name="utils" map="A"/>
  <field class="com.itextpdf.tool.xml.css.apply.ChunkCssApplier" name="fontProvider" map="B"/>
  <field class="com.itextpdf.tool.xml.css.apply.ChunkCssApplier" name="BOLD" map="C"/>
  <method class="com.itextpdf.tool.xml.css.apply.ChunkCssApplier" name="void setFontProvider(com.itextpdf.text.FontProvider)" map="A"/>
  <class name="com.itextpdf.tool.xml.css.apply.ParagraphCssApplier" map="C"/>
  <field class="com.itextpdf.tool.xml.css.apply.ParagraphCssApplier" name="appliers" map="A"/>
  <class name="com.itextpdf.tool.xml.css.apply.HtmlCellCssApplier" map="D"/>
  <field class="com.itextpdf.tool.xml.css.apply.HtmlCellCssApplier" name="utils" map="A"/>
  <class name="com.itextpdf.tool.xml.css.apply.ImageCssApplier" map="E"/>
  <class name="com.itextpdf.tool.xml.css.apply.DivCssApplier" map="F"/>
  <field class="com.itextpdf.tool.xml.css.apply.DivCssApplier" name="utils" map="A"/>
  <field class="com.itextpdf.tool.xml.css.apply.DivCssApplier" name="LOG" map="B"/>
  <class name="com.itextpdf.tool.xml.css.apply.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.css.apply.MarginMemory" map="G"/>
  <class name="com.itextpdf.tool.xml.css.apply.NoNewLineParagraphCssApplier" map="H"/>
  <field class="com.itextpdf.tool.xml.css.apply.NoNewLineParagraphCssApplier" name="utils" map="A"/>
  <class name="com.itextpdf.tool.xml.css.apply.ListStyleTypeCssApplier" map="I"/>
  <field class="com.itextpdf.tool.xml.css.apply.ListStyleTypeCssApplier" name="utils" map="A"/>
  <field class="com.itextpdf.tool.xml.css.apply.ListStyleTypeCssApplier" name="LOG" map="B"/>
  <class name="com.itextpdf.tool.xml.css.apply.LineSeparatorCssApplier" map="J"/>
  <package name="com.itextpdf.tool.xml.css.parser" map="B"/>
  <package name="com.itextpdf.tool.xml.css.parser.state" map="A"/>
  <class name="com.itextpdf.tool.xml.css.parser.state.Properties" map="A"/>
  <field class="com.itextpdf.tool.xml.css.parser.state.Properties" name="controller" map="H"/>
  <method class="com.itextpdf.tool.xml.css.parser.state.Properties" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.css.parser.state.CommentInside" map="B"/>
  <field class="com.itextpdf.tool.xml.css.parser.state.CommentInside" name="controller" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.state.CommentInside" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.css.parser.state.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.css.parser.state.Rule" map="C"/>
  <field class="com.itextpdf.tool.xml.css.parser.state.Rule" name="isCss3AtRule" map="B"/>
  <field class="com.itextpdf.tool.xml.css.parser.state.Rule" name="controller" map="C"/>
  <field class="com.itextpdf.tool.xml.css.parser.state.Rule" name="openParenthesesCount" map="D"/>
  <method class="com.itextpdf.tool.xml.css.parser.state.Rule" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.css.parser.state.CommentEnd" map="D"/>
  <field class="com.itextpdf.tool.xml.css.parser.state.CommentEnd" name="controller" map="E"/>
  <method class="com.itextpdf.tool.xml.css.parser.state.CommentEnd" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.css.parser.state.Unknown" map="E"/>
  <field class="com.itextpdf.tool.xml.css.parser.state.Unknown" name="controller" map="F"/>
  <method class="com.itextpdf.tool.xml.css.parser.state.Unknown" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.css.parser.state.CommentStart" map="F"/>
  <field class="com.itextpdf.tool.xml.css.parser.state.CommentStart" name="controller" map="G"/>
  <method class="com.itextpdf.tool.xml.css.parser.state.CommentStart" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.css.parser.State" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.State" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.css.parser.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.css.parser.CssStateController" map="B"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssStateController" name="currentSelector" map="A"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssStateController" name="unknown" map="B"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssStateController" name="buffer" map="C"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssStateController" name="css" map="D"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssStateController" name="previous" map="E"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssStateController" name="commentStart" map="F"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssStateController" name="current" map="G"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssStateController" name="properties" map="H"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssStateController" name="rule" map="I"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssStateController" name="commentInside" map="J"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssStateController" name="utils" map="K"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssStateController" name="commentEnd" map="L"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssStateController" name="void process(char)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssStateController" name="void stateCommentEnd()" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssStateController" name="void stateCommentStart()" map="B"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssStateController" name="void storeSelector()" map="C"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssStateController" name="void append(char)" map="B"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssStateController" name="void setPrevious()" map="D"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssStateController" name="void stateProperties()" map="E"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssStateController" name="void processProps(java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssStateController" name="void stateCommentInside()" map="F"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssStateController" name="void setState(com.itextpdf.tool.xml.css.parser.State)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssStateController" name="void previous()" map="G"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssStateController" name="void stateRule()" map="H"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssStateController" name="void stateUnknown()" map="I"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssStateController" name="void storeProperties()" map="J"/>
  <class name="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssIdSelector" map="_A"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssIdSelector" name="id" map="I"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssIdSelector" name="int getSpecificity()" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssIdSelector" name="boolean matches(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssIdSelector" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssIdSelector" name="char getSeparator()" map="B"/>
  <class name="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssPseudoSelector" map="_B"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssPseudoSelector" name="selector" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssPseudoSelector" name="int getSpecificity()" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssPseudoSelector" name="boolean matches(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssPseudoSelector" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssPseudoSelector" name="char getSeparator()" map="B"/>
  <class name="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssSeparatorSelector" map="_C"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssSeparatorSelector" name="separator" map="B"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssSeparatorSelector" name="int getSpecificity()" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssSeparatorSelector" name="boolean matches(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssSeparatorSelector" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssSeparatorSelector" name="char getSeparator()" map="B"/>
  <class name="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssClassSelector" map="_D"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssClassSelector" name="className" map="C"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssClassSelector" name="int getSpecificity()" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssClassSelector" name="boolean matches(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssClassSelector" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssClassSelector" name="char getSeparator()" map="B"/>
  <class name="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssAttributeSelector" map="_E"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssAttributeSelector" name="value" map="D"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssAttributeSelector" name="property" map="E"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssAttributeSelector" name="matchSymbol" map="F"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssAttributeSelector" name="int getSpecificity()" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssAttributeSelector" name="boolean matches(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssAttributeSelector" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssAttributeSelector" name="char getSeparator()" map="B"/>
  <class name="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssTagSelector" map="_F"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssTagSelector" name="t" map="G"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssTagSelector" name="isUniversal" map="H"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssTagSelector" name="int getSpecificity()" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssTagSelector" name="boolean matches(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssTagSelector" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser$CssTagSelector" name="char getSeparator()" map="B"/>
  <class name="com.itextpdf.tool.xml.css.parser.CssSelectorParser" map="C"/>
  <field class="com.itextpdf.tool.xml.css.parser.CssSelectorParser" name="selectorPattern" map="A"/>
  <method class="com.itextpdf.tool.xml.css.parser.CssSelectorParser" name="java.util.List createCssSelector(java.lang.String)" map="A"/>
  <class name="com.itextpdf.tool.xml.css.CssInheritanceRules" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssInheritanceRules" name="boolean inheritCssTag(java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssInheritanceRules" name="boolean inheritCssSelector(com.itextpdf.tool.xml.Tag, java.lang.String)" map="A"/>
  <class name="com.itextpdf.tool.xml.css.CssFileProcessor" map="B"/>
  <field class="com.itextpdf.tool.xml.css.CssFileProcessor" name="controller" map="A"/>
  <field class="com.itextpdf.tool.xml.css.CssFileProcessor" name="css" map="B"/>
  <method class="com.itextpdf.tool.xml.css.CssFileProcessor" name="com.itextpdf.tool.xml.css.CssFile getCss()" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssFileProcessor" name="void process(int)" map="A"/>
  <class name="com.itextpdf.tool.xml.css.CssUtils" map="C"/>
  <field class="com.itextpdf.tool.xml.css.CssUtils" name="instance" map="A"/>
  <field class="com.itextpdf.tool.xml.css.CssUtils" name="backgroundPositions" map="B"/>
  <field class="com.itextpdf.tool.xml.css.CssUtils" name="borderstyle" map="C"/>
  <field class="com.itextpdf.tool.xml.css.CssUtils" name="borderwidth" map="D"/>
  <method class="com.itextpdf.tool.xml.css.CssUtils" name="java.util.Map processBackground(java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssUtils" name="java.util.Map parseBoxValues(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssUtils" name="java.lang.String stripDoubleSpacesTrimAndToLowerCase(java.lang.String)" map="B"/>
  <method class="com.itextpdf.tool.xml.css.CssUtils" name="boolean isNumericValue(java.lang.String)" map="C"/>
  <method class="com.itextpdf.tool.xml.css.CssUtils" name="java.lang.String stripDoubleSpacesAndTrim(java.lang.String)" map="D"/>
  <method class="com.itextpdf.tool.xml.css.CssUtils" name="java.util.Map parseBorder(java.lang.String)" map="E"/>
  <method class="com.itextpdf.tool.xml.css.CssUtils" name="java.util.Map processListStyle(java.lang.String)" map="F"/>
  <method class="com.itextpdf.tool.xml.css.CssUtils" name="boolean isMetricValue(java.lang.String)" map="G"/>
  <method class="com.itextpdf.tool.xml.css.CssUtils" name="java.lang.String[] splitComplexCssStyle(java.lang.String)" map="H"/>
  <method class="com.itextpdf.tool.xml.css.CssUtils" name="java.util.Map processFont(java.lang.String)" map="I"/>
  <method class="com.itextpdf.tool.xml.css.CssUtils" name="com.itextpdf.tool.xml.css.CssUtils getInstance()" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssUtils" name="java.util.Map parseBorder(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssUtils" name="boolean isRelativeValue(java.lang.String)" map="J"/>
  <method class="com.itextpdf.tool.xml.css.CssUtils" name="java.util.Map parseBoxValues(java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <class name="com.itextpdf.tool.xml.css.CssFileImpl" map="D"/>
  <field class="com.itextpdf.tool.xml.css.CssFileImpl" name="persistent" map="C"/>
  <field class="com.itextpdf.tool.xml.css.CssFileImpl" name="rules" map="D"/>
  <method class="com.itextpdf.tool.xml.css.CssFileImpl" name="boolean add(java.lang.String, java.util.Map)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssFileImpl" name="java.util.List get(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssFileImpl" name="boolean isPersistent()" map="A"/>
  <class name="com.itextpdf.tool.xml.css.DefaultCssInheritanceRules" map="E"/>
  <field class="com.itextpdf.tool.xml.css.DefaultCssInheritanceRules" name="GLOBAL" map="A"/>
  <field class="com.itextpdf.tool.xml.css.DefaultCssInheritanceRules" name="PARENT_TO_TABLE" map="B"/>
  <field class="com.itextpdf.tool.xml.css.DefaultCssInheritanceRules" name="TD_TO_CONTENT" map="C"/>
  <field class="com.itextpdf.tool.xml.css.DefaultCssInheritanceRules" name="DIV_TO_CONTENT" map="D"/>
  <field class="com.itextpdf.tool.xml.css.DefaultCssInheritanceRules" name="TABLE_IN_ROW" map="E"/>
  <method class="com.itextpdf.tool.xml.css.DefaultCssInheritanceRules" name="boolean inheritCssTag(java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.DefaultCssInheritanceRules" name="boolean inheritCssSelector(com.itextpdf.tool.xml.Tag, java.lang.String)" map="A"/>
  <class name="com.itextpdf.tool.xml.css.CssFile" map="F"/>
  <method class="com.itextpdf.tool.xml.css.CssFile" name="boolean add(java.lang.String, java.util.Map)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssFile" name="java.util.List get(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssFile" name="boolean isPersistent()" map="A"/>
  <class name="com.itextpdf.tool.xml.css.CssSelectorItem" map="G"/>
  <method class="com.itextpdf.tool.xml.css.CssSelectorItem" name="int getSpecificity()" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssSelectorItem" name="boolean matches(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssSelectorItem" name="char getSeparator()" map="B"/>
  <class name="com.itextpdf.tool.xml.css.CssFilesImpl" map="H"/>
  <field class="com.itextpdf.tool.xml.css.CssFilesImpl" name="utils" map="A"/>
  <field class="com.itextpdf.tool.xml.css.CssFilesImpl" name="files" map="B"/>
  <method class="com.itextpdf.tool.xml.css.CssFilesImpl" name="java.util.Map getCSS(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssFilesImpl" name="void clear()" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssFilesImpl" name="void populateOneCss(java.util.Map, java.util.Map)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssFilesImpl" name="void add(com.itextpdf.tool.xml.css.CssFile)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssFilesImpl" name="void populateCss(com.itextpdf.tool.xml.Tag, java.util.Map)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssFilesImpl" name="boolean hasFiles()" map="B"/>
  <class name="com.itextpdf.tool.xml.css.CssFiles" map="I"/>
  <method class="com.itextpdf.tool.xml.css.CssFiles" name="java.util.Map getCSS(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssFiles" name="void clear()" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssFiles" name="boolean hasFiles()" map="B"/>
  <class name="com.itextpdf.tool.xml.css.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.css.CssSelector" map="J"/>
  <field class="com.itextpdf.tool.xml.css.CssSelector" name="selectorItems" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssSelector" name="int calculateSpecifity()" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssSelector" name="boolean matches(com.itextpdf.tool.xml.Tag, int)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssSelector" name="boolean matches(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssSelector" name="java.lang.String toString()" map="toString"/>
  <class name="com.itextpdf.tool.xml.css.CSSFileWrapper" map="K"/>
  <field class="com.itextpdf.tool.xml.css.CSSFileWrapper" name="persistent" map="A"/>
  <field class="com.itextpdf.tool.xml.css.CSSFileWrapper" name="css" map="B"/>
  <method class="com.itextpdf.tool.xml.css.CSSFileWrapper" name="boolean add(java.lang.String, java.util.Map)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CSSFileWrapper" name="java.util.List get(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CSSFileWrapper" name="boolean isPersistent()" map="A"/>
  <class name="com.itextpdf.tool.xml.css.CssRule" map="L"/>
  <field class="com.itextpdf.tool.xml.css.CssRule" name="importantMatcher" map="A"/>
  <field class="com.itextpdf.tool.xml.css.CssRule" name="selector" map="B"/>
  <field class="com.itextpdf.tool.xml.css.CssRule" name="normalDeclarations" map="C"/>
  <field class="com.itextpdf.tool.xml.css.CssRule" name="importantDeclarations" map="D"/>
  <method class="com.itextpdf.tool.xml.css.CssRule" name="java.util.Map getImportantDeclarations()" map="A"/>
  <method class="com.itextpdf.tool.xml.css.CssRule" name="com.itextpdf.tool.xml.css.CssSelector getSelector()" map="B"/>
  <method class="com.itextpdf.tool.xml.css.CssRule" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.tool.xml.css.CssRule" name="java.util.Map getNormalDeclarations()" map="C"/>
  <method class="com.itextpdf.tool.xml.css.CssRule" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <method class="com.itextpdf.tool.xml.css.CssRule" name="int compareTo(com.itextpdf.tool.xml.css.CssRule)" map="A"/>
  <class name="com.itextpdf.tool.xml.css.StyleAttrCSSResolver" map="M"/>
  <field class="com.itextpdf.tool.xml.css.StyleAttrCSSResolver" name="cssFiles" map="A"/>
  <field class="com.itextpdf.tool.xml.css.StyleAttrCSSResolver" name="utils" map="B"/>
  <field class="com.itextpdf.tool.xml.css.StyleAttrCSSResolver" name="inherit" map="C"/>
  <field class="com.itextpdf.tool.xml.css.StyleAttrCSSResolver" name="retrieve" map="D"/>
  <method class="com.itextpdf.tool.xml.css.StyleAttrCSSResolver" name="void splitRules(java.util.Map, java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.StyleAttrCSSResolver" name="boolean canInherite(com.itextpdf.tool.xml.Tag, java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.StyleAttrCSSResolver" name="void resolveStyles(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.StyleAttrCSSResolver" name="boolean mustInherit(java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.StyleAttrCSSResolver" name="java.lang.String mergeTextDecorationRules(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.css.StyleAttrCSSResolver" name="com.itextpdf.tool.xml.pipeline.css.CSSResolver clear()" map="A"/>
  <package name="com.itextpdf.tool.xml.net" map="E"/>
  <class name="com.itextpdf.tool.xml.net.FileRetrieveImpl" map="A"/>
  <field class="com.itextpdf.tool.xml.net.FileRetrieveImpl" name="LOGGER" map="A"/>
  <field class="com.itextpdf.tool.xml.net.FileRetrieveImpl" name="rootdirs" map="B"/>
  <field class="com.itextpdf.tool.xml.net.FileRetrieveImpl" name="urls" map="C"/>
  <class name="com.itextpdf.tool.xml.net.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.net.FileRetrieve" map="B"/>
  <class name="com.itextpdf.tool.xml.net.ReadingProcessor" map="C"/>
  <package name="com.itextpdf.tool.xml.parser" map="F"/>
  <package name="com.itextpdf.tool.xml.parser.state" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.UnknownState" map="A"/>
  <field class="com.itextpdf.tool.xml.parser.state.UnknownState" name="parser" map="V"/>
  <method class="com.itextpdf.tool.xml.parser.state.UnknownState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.DoubleQuotedAttrValueState" map="B"/>
  <field class="com.itextpdf.tool.xml.parser.state.DoubleQuotedAttrValueState" name="parser" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.state.DoubleQuotedAttrValueState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.AttributeValueState" map="C"/>
  <field class="com.itextpdf.tool.xml.parser.state.AttributeValueState" name="parser" map="B"/>
  <method class="com.itextpdf.tool.xml.parser.state.AttributeValueState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.CdataState" map="D"/>
  <field class="com.itextpdf.tool.xml.parser.state.CdataState" name="parser" map="C"/>
  <method class="com.itextpdf.tool.xml.parser.state.CdataState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.UnquotedAttrState" map="E"/>
  <field class="com.itextpdf.tool.xml.parser.state.UnquotedAttrState" name="parser" map="D"/>
  <method class="com.itextpdf.tool.xml.parser.state.UnquotedAttrState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.InsideTagState" map="F"/>
  <field class="com.itextpdf.tool.xml.parser.state.InsideTagState" name="parser" map="E"/>
  <method class="com.itextpdf.tool.xml.parser.state.InsideTagState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.ProcessingInstructionEncounteredState" map="G"/>
  <field class="com.itextpdf.tool.xml.parser.state.ProcessingInstructionEncounteredState" name="name" map="G"/>
  <method class="com.itextpdf.tool.xml.parser.state.ProcessingInstructionEncounteredState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.TagAttributeState" map="H"/>
  <field class="com.itextpdf.tool.xml.parser.state.TagAttributeState" name="parser" map="F"/>
  <method class="com.itextpdf.tool.xml.parser.state.TagAttributeState" name="void checkAttributeWithNoValue()" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.state.TagAttributeState" name="boolean setAttribute()" map="B"/>
  <method class="com.itextpdf.tool.xml.parser.state.TagAttributeState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.ClosingTagState" map="I"/>
  <field class="com.itextpdf.tool.xml.parser.state.ClosingTagState" name="parser" map="H"/>
  <method class="com.itextpdf.tool.xml.parser.state.ClosingTagState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.StarCommentState" map="J"/>
  <field class="com.itextpdf.tool.xml.parser.state.StarCommentState" name="parser" map="I"/>
  <method class="com.itextpdf.tool.xml.parser.state.StarCommentState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.CommentState" map="K"/>
  <field class="com.itextpdf.tool.xml.parser.state.CommentState" name="parser" map="J"/>
  <method class="com.itextpdf.tool.xml.parser.state.CommentState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.DocTypeState" map="L"/>
  <field class="com.itextpdf.tool.xml.parser.state.DocTypeState" name="parser" map="K"/>
  <method class="com.itextpdf.tool.xml.parser.state.DocTypeState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.SingleQuotedAttrValueState" map="M"/>
  <field class="com.itextpdf.tool.xml.parser.state.SingleQuotedAttrValueState" name="parser" map="L"/>
  <method class="com.itextpdf.tool.xml.parser.state.SingleQuotedAttrValueState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.parser.state.TagEncounteredState" map="N"/>
  <field class="com.itextpdf.tool.xml.parser.state.TagEncounteredState" name="parser" map="M"/>
  <method class="com.itextpdf.tool.xml.parser.state.TagEncounteredState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.XmlState" map="O"/>
  <field class="com.itextpdf.tool.xml.parser.state.XmlState" name="parser" map="N"/>
  <method class="com.itextpdf.tool.xml.parser.state.XmlState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.CloseCommentState" map="P"/>
  <field class="com.itextpdf.tool.xml.parser.state.CloseCommentState" name="parser" map="O"/>
  <method class="com.itextpdf.tool.xml.parser.state.CloseCommentState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.CloseStarCommentState" map="Q"/>
  <field class="com.itextpdf.tool.xml.parser.state.CloseStarCommentState" name="parser" map="P"/>
  <method class="com.itextpdf.tool.xml.parser.state.CloseStarCommentState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.InsideTagHTMLState" map="R"/>
  <field class="com.itextpdf.tool.xml.parser.state.InsideTagHTMLState" name="ignoreLastChars" map="Q"/>
  <field class="com.itextpdf.tool.xml.parser.state.InsideTagHTMLState" name="noSanitize" map="R"/>
  <field class="com.itextpdf.tool.xml.parser.state.InsideTagHTMLState" name="parser" map="S"/>
  <method class="com.itextpdf.tool.xml.parser.state.InsideTagHTMLState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.SpecialCharState" map="S"/>
  <field class="com.itextpdf.tool.xml.parser.state.SpecialCharState" name="parser" map="T"/>
  <method class="com.itextpdf.tool.xml.parser.state.SpecialCharState" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.state.SelfClosingTagState" map="T"/>
  <field class="com.itextpdf.tool.xml.parser.state.SelfClosingTagState" name="parser" map="U"/>
  <method class="com.itextpdf.tool.xml.parser.state.SelfClosingTagState" name="void process(char)" map="A"/>
  <package name="com.itextpdf.tool.xml.parser.io" map="B"/>
  <class name="com.itextpdf.tool.xml.parser.io.MonitorInputReader" map="A"/>
  <field class="com.itextpdf.tool.xml.parser.io.MonitorInputReader" name="monitor" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.io.MonitorInputReader" name="int read(char[])" map="read"/>
  <class name="com.itextpdf.tool.xml.parser.io.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.parser.io.ParserMonitor" map="B"/>
  <method class="com.itextpdf.tool.xml.parser.io.ParserMonitor" name="void read(char[])" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.TagState" map="A"/>
  <field class="com.itextpdf.tool.xml.parser.TagState" name="$VALUES" map="A"/>
  <field class="com.itextpdf.tool.xml.parser.TagState" name="OPEN" map="B"/>
  <field class="com.itextpdf.tool.xml.parser.TagState" name="NONE" map="C"/>
  <field class="com.itextpdf.tool.xml.parser.TagState" name="CLOSE" map="D"/>
  <method class="com.itextpdf.tool.xml.parser.TagState" name="com.itextpdf.tool.xml.parser.TagState[] values()" map="values"/>
  <method class="com.itextpdf.tool.xml.parser.TagState" name="com.itextpdf.tool.xml.parser.TagState valueOf(java.lang.String)" map="valueOf"/>
  <class name="com.itextpdf.tool.xml.parser.XMLParser" map="B"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParser" name="monitor" map="A"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParser" name="controller" map="B"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParser" name="listeners" map="C"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParser" name="state" map="D"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParser" name="text" map="E"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParser" name="charset" map="F"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParser" name="tagState" map="G"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParser" name="memory" map="H"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="void flush()" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="int bufferSize()" map="B"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="java.lang.String bufferToString()" map="C"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="void parseWithReader(java.io.Reader)" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="com.itextpdf.tool.xml.parser.XMLParserMemory memory()" map="D"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="void text(java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="void setState(com.itextpdf.tool.xml.parser.State)" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="com.itextpdf.tool.xml.parser.XMLParser append(char)" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="java.lang.String currentTag()" map="E"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="void parse(java.io.Reader)" map="B"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="void unknownData()" map="F"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="void comment()" map="G"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="java.lang.String current()" map="H"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="void callText()" map="I"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="com.itextpdf.tool.xml.parser.StateController selectState()" map="J"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="void startElement()" map="K"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="com.itextpdf.tool.xml.parser.XMLParser addListener(com.itextpdf.tool.xml.parser.XMLParserListener)" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="com.itextpdf.tool.xml.parser.TagState currentTagState()" map="L"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="void endElement()" map="M"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="com.itextpdf.tool.xml.parser.XMLParser append(java.lang.String)" map="B"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParser" name="void currentTagState(com.itextpdf.tool.xml.parser.TagState)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.State" map="C"/>
  <method class="com.itextpdf.tool.xml.parser.State" name="void process(char)" map="A"/>
  <class name="com.itextpdf.tool.xml.parser.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.parser.XMLParserListener" map="D"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserListener" name="void endElement(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserListener" name="void startElement(java.lang.String, java.util.Map, java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserListener" name="void text(java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserListener" name="void close()" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserListener" name="void unknownText(java.lang.String)" map="B"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserListener" name="void init()" map="B"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserListener" name="void comment(java.lang.String)" map="C"/>
  <class name="com.itextpdf.tool.xml.parser.XMLParserMemory" map="E"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="isHtml" map="A"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="storedString" map="B"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="currentAttr" map="C"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="comment" map="D"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="attr" map="E"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="wsTag" map="F"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="currentEntity" map="G"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="currentTag" map="H"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="currentNameSpace" map="I"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="lastChar" map="J"/>
  <field class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="baos" map="K"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="java.lang.StringBuilder current()" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="char lastChar()" map="B"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="java.lang.String getCurrentTag()" map="C"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="java.lang.StringBuilder currentEntity()" map="D"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="void currentAttr(java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="void flushNameSpace()" map="E"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="void setStoredString(java.lang.String)" map="B"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="java.lang.StringBuilder comment()" map="F"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="void resetBuffer()" map="G"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="boolean hasCurrentAttribute()" map="H"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="java.lang.String getNameSpace()" map="I"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="java.lang.String getStoredString()" map="J"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="java.util.Map getAttributes()" map="K"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="java.lang.String whitespaceTag()" map="L"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="void lastChar(char)" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="void putCurrentAttrValue(java.lang.String)" map="C"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="void currentTag(java.lang.String)" map="D"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="void whitespaceTag(java.lang.String)" map="E"/>
  <method class="com.itextpdf.tool.xml.parser.XMLParserMemory" name="void namespace(java.lang.String)" map="F"/>
  <class name="com.itextpdf.tool.xml.parser.StateController" map="F"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="cdata" map="A"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="comment" map="B"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="closeComment" map="C"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="parser" map="D"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="previousState" map="E"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="tagEncountered" map="F"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="specialChar" map="G"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="xml" map="H"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="closingTag" map="I"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="doubleQuoted" map="J"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="closeStarComment" map="K"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="tagAttributes" map="L"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="inTag" map="M"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="attrValue" map="N"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="selfClosing" map="O"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="starComment" map="P"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="processingInstruction" map="Q"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="singleQuoted" map="R"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="unquoted" map="S"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="unknown" map="T"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="doctype" map="U"/>
  <field class="com.itextpdf.tool.xml.parser.StateController" name="currentState" map="V"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser attributeValue()" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser unquotedAttr()" map="B"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser tagEncountered()" map="C"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser singleQuotedAttr()" map="D"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser processingInstructions()" map="E"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser unknown()" map="F"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser doctype()" map="G"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser tagAttributes()" map="H"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser inTag()" map="I"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser starComment()" map="J"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser cdata()" map="K"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser closeComment()" map="L"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser closingTag()" map="M"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser closeStarComment()" map="N"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser selfClosing()" map="O"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser setState(com.itextpdf.tool.xml.parser.State)" map="A"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser specialChar()" map="P"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser comment()" map="Q"/>
  <method class="com.itextpdf.tool.xml.parser.StateController" name="com.itextpdf.tool.xml.parser.XMLParser doubleQuotedAttr()" map="R"/>
  <class name="com.itextpdf.tool.xml.XMLWorker$1" map="1"/>
  <method class="com.itextpdf.tool.xml.XMLWorker$1" name="java.lang.Object initialValue()" map="initialValue"/>
  <method class="com.itextpdf.tool.xml.XMLWorker$1" name="com.itextpdf.tool.xml.pipeline.ctx.WorkerContextImpl initialValue()" map="A"/>
  <class name="com.itextpdf.tool.xml.XMLWorker" map="A"/>
  <field class="com.itextpdf.tool.xml.XMLWorker" name="parseHtml" map="A"/>
  <field class="com.itextpdf.tool.xml.XMLWorker" name="context" map="B"/>
  <field class="com.itextpdf.tool.xml.XMLWorker" name="rootpPipe" map="C"/>
  <method class="com.itextpdf.tool.xml.XMLWorker" name="void comment(java.lang.String)" map="C"/>
  <method class="com.itextpdf.tool.xml.XMLWorker" name="void close()" map="A"/>
  <method class="com.itextpdf.tool.xml.XMLWorker" name="boolean ignoreCdata()" map="C"/>
  <method class="com.itextpdf.tool.xml.XMLWorker" name="com.itextpdf.tool.xml.WorkerContext getLocalWC()" map="D"/>
  <method class="com.itextpdf.tool.xml.XMLWorker" name="void unknownText(java.lang.String)" map="B"/>
  <method class="com.itextpdf.tool.xml.XMLWorker" name="void closeLocalWC()" map="E"/>
  <method class="com.itextpdf.tool.xml.XMLWorker" name="com.itextpdf.tool.xml.Tag createTag(java.lang.String, java.util.Map, java.lang.String)" map="B"/>
  <method class="com.itextpdf.tool.xml.XMLWorker" name="void text(java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.XMLWorker" name="void startElement(java.lang.String, java.util.Map, java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.XMLWorker" name="void endElement(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.XMLWorker" name="void init()" map="B"/>
  <class name="com.itextpdf.tool.xml.CustomContext" map="B"/>
  <class name="com.itextpdf.tool.xml.Tag" map="C"/>
  <field class="com.itextpdf.tool.xml.Tag" name="tag" map="A"/>
  <field class="com.itextpdf.tool.xml.Tag" name="attributes" map="B"/>
  <field class="com.itextpdf.tool.xml.Tag" name="children" map="C"/>
  <field class="com.itextpdf.tool.xml.Tag" name="css" map="D"/>
  <field class="com.itextpdf.tool.xml.Tag" name="ns" map="E"/>
  <field class="com.itextpdf.tool.xml.Tag" name="parent" map="F"/>
  <field class="com.itextpdf.tool.xml.Tag" name="lastMarginBottom" map="G"/>
  <method class="com.itextpdf.tool.xml.Tag" name="com.itextpdf.tool.xml.Tag getParent()" map="A"/>
  <method class="com.itextpdf.tool.xml.Tag" name="java.util.List getChildren()" map="B"/>
  <method class="com.itextpdf.tool.xml.Tag" name="java.util.Map getCSS()" map="C"/>
  <method class="com.itextpdf.tool.xml.Tag" name="java.lang.Object getLastMarginBottom()" map="D"/>
  <method class="com.itextpdf.tool.xml.Tag" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="com.itextpdf.tool.xml.Tag" name="java.lang.String getNameSpace()" map="E"/>
  <method class="com.itextpdf.tool.xml.Tag" name="void addChild(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.Tag" name="boolean hasParent()" map="F"/>
  <method class="com.itextpdf.tool.xml.Tag" name="void setLastMarginBottom(java.lang.Object)" map="A"/>
  <method class="com.itextpdf.tool.xml.Tag" name="java.lang.String getName()" map="G"/>
  <method class="com.itextpdf.tool.xml.Tag" name="java.util.Map getAttributes()" map="H"/>
  <method class="com.itextpdf.tool.xml.Tag" name="void setParent(com.itextpdf.tool.xml.Tag)" map="B"/>
  <method class="com.itextpdf.tool.xml.Tag" name="java.lang.String toString()" map="toString"/>
  <class name="com.itextpdf.tool.xml.Pipeline" map="D"/>
  <method class="com.itextpdf.tool.xml.Pipeline" name="com.itextpdf.tool.xml.Pipeline content(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag, java.lang.String, com.itextpdf.tool.xml.ProcessObject)" map="A"/>
  <method class="com.itextpdf.tool.xml.Pipeline" name="com.itextpdf.tool.xml.Pipeline open(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag, com.itextpdf.tool.xml.ProcessObject)" map="A"/>
  <method class="com.itextpdf.tool.xml.Pipeline" name="com.itextpdf.tool.xml.Pipeline close(com.itextpdf.tool.xml.WorkerContext, com.itextpdf.tool.xml.Tag, com.itextpdf.tool.xml.ProcessObject)" map="B"/>
  <method class="com.itextpdf.tool.xml.Pipeline" name="com.itextpdf.tool.xml.Pipeline init(com.itextpdf.tool.xml.WorkerContext)" map="A"/>
  <class name="com.itextpdf.tool.xml.NoCustomContextException" map="E"/>
  <class name="com.itextpdf.tool.xml.XMLWorkerFontProvider" map="F"/>
  <field class="com.itextpdf.tool.xml.XMLWorkerFontProvider" name="useUnicode" map="G"/>
  <field class="com.itextpdf.tool.xml.XMLWorkerFontProvider" name="fontSubstitutionMap" map="H"/>
  <method class="com.itextpdf.tool.xml.XMLWorkerFontProvider" name="com.itextpdf.text.Font getUnicodeFont(java.lang.String, java.lang.String, float, int)" map="A"/>
  <method class="com.itextpdf.tool.xml.XMLWorkerFontProvider" name="com.itextpdf.text.Font getFont(java.lang.String, java.lang.String, float, int)" map="B"/>
  <method class="com.itextpdf.tool.xml.XMLWorkerFontProvider" name="com.itextpdf.text.Font getFont(java.lang.String, java.lang.String, boolean, float, int, com.itextpdf.text.BaseColor)" map="A"/>
  <class name="com.itextpdf.tool.xml.Writable" map="G"/>
  <class name="com.itextpdf.tool.xml.package-info" map="package-info"/>
  <class name="com.itextpdf.tool.xml.PipelineException" map="H"/>
  <class name="com.itextpdf.tool.xml.ProcessObject" map="I"/>
  <field class="com.itextpdf.tool.xml.ProcessObject" name="queue" map="A"/>
  <method class="com.itextpdf.tool.xml.ProcessObject" name="void add(com.itextpdf.tool.xml.Writable)" map="A"/>
  <method class="com.itextpdf.tool.xml.ProcessObject" name="boolean containsWritable()" map="A"/>
  <method class="com.itextpdf.tool.xml.ProcessObject" name="com.itextpdf.tool.xml.Writable poll()" map="B"/>
  <class name="com.itextpdf.tool.xml.XMLWorkerHelper" map="J"/>
  <field class="com.itextpdf.tool.xml.XMLWorkerHelper" name="myself" map="A"/>
  <field class="com.itextpdf.tool.xml.XMLWorkerHelper" name="defaultCssFile" map="B"/>
  <field class="com.itextpdf.tool.xml.XMLWorkerHelper" name="tpf" map="C"/>
  <method class="com.itextpdf.tool.xml.XMLWorkerHelper" name="com.itextpdf.tool.xml.css.CssFile getDefaultCSS()" map="A"/>
  <method class="com.itextpdf.tool.xml.XMLWorkerHelper" name="com.itextpdf.tool.xml.css.CssFile getCSS(java.io.InputStream)" map="A"/>
  <method class="com.itextpdf.tool.xml.XMLWorkerHelper" name="com.itextpdf.tool.xml.html.TagProcessorFactory getDefaultTagProcessorFactory()" map="B"/>
  <method class="com.itextpdf.tool.xml.XMLWorkerHelper" name="com.itextpdf.tool.xml.XMLWorkerHelper getInstance()" map="C"/>
  <method class="com.itextpdf.tool.xml.XMLWorkerHelper" name="void parseXHtml(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document, java.io.Reader)" map="A"/>
  <class name="com.itextpdf.tool.xml.WorkerContext" map="K"/>
  <method class="com.itextpdf.tool.xml.WorkerContext" name="void put(java.lang.String, com.itextpdf.tool.xml.CustomContext)" map="A"/>
  <method class="com.itextpdf.tool.xml.WorkerContext" name="com.itextpdf.tool.xml.CustomContext get(java.lang.String)" map="A"/>
  <method class="com.itextpdf.tool.xml.WorkerContext" name="void setCurrentTag(com.itextpdf.tool.xml.Tag)" map="A"/>
  <method class="com.itextpdf.tool.xml.WorkerContext" name="com.itextpdf.tool.xml.Tag getCurrentTag()" map="A"/>
  <package name="com.itextpdf.awt" map="B"/>
  <package name="com.itextpdf.awt.geom" map="A"/>
  <package name="com.itextpdf.awt.geom.misc" map="A"/>
  <class name="com.itextpdf.awt.geom.misc.HashCode" map="A"/>
  <field class="com.itextpdf.awt.geom.misc.HashCode" name="hashCode" map="A"/>
  <method class="com.itextpdf.awt.geom.misc.HashCode" name="int combine(int, long)" map="A"/>
  <method class="com.itextpdf.awt.geom.misc.HashCode" name="com.itextpdf.awt.geom.misc.HashCode append(double)" map="A"/>
  <method class="com.itextpdf.awt.geom.misc.HashCode" name="int combine(int, double)" map="A"/>
  <method class="com.itextpdf.awt.geom.misc.HashCode" name="int combine(int, int)" map="A"/>
  <method class="com.itextpdf.awt.geom.misc.HashCode" name="int hashCode()" map="hashCode"/>
  <class name="com.itextpdf.awt.geom.AffineTransform" map="A"/>
  <field class="com.itextpdf.awt.geom.AffineTransform" name="type" map="A"/>
  <field class="com.itextpdf.awt.geom.AffineTransform" name="m02" map="B"/>
  <field class="com.itextpdf.awt.geom.AffineTransform" name="m01" map="C"/>
  <field class="com.itextpdf.awt.geom.AffineTransform" name="m12" map="D"/>
  <field class="com.itextpdf.awt.geom.AffineTransform" name="m00" map="E"/>
  <field class="com.itextpdf.awt.geom.AffineTransform" name="m11" map="F"/>
  <field class="com.itextpdf.awt.geom.AffineTransform" name="m10" map="G"/>
  <method class="com.itextpdf.awt.geom.AffineTransform" name="boolean isIdentity()" map="A"/>
  <method class="com.itextpdf.awt.geom.AffineTransform" name="int getType()" map="B"/>
  <method class="com.itextpdf.awt.geom.AffineTransform" name="int hashCode()" map="hashCode"/>
  <method class="com.itextpdf.awt.geom.AffineTransform" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="com.itextpdf.awt.geom.AffineTransform" name="com.itextpdf.awt.geom.AffineTransform multiply(com.itextpdf.awt.geom.AffineTransform, com.itextpdf.awt.geom.AffineTransform)" map="A"/>
  <method class="com.itextpdf.awt.geom.AffineTransform" name="void transform(float[], int, float[], int, int)" map="A"/>
  <method class="com.itextpdf.awt.geom.AffineTransform" name="java.lang.Object clone()" map="clone"/>
  <method class="com.itextpdf.awt.geom.AffineTransform" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.awt.geom.AffineTransform" name="void setTransform(com.itextpdf.awt.geom.AffineTransform)" map="A"/>
  <method class="com.itextpdf.awt.geom.AffineTransform" name="void concatenate(com.itextpdf.awt.geom.AffineTransform)" map="B"/>
  <method class="com.itextpdf.awt.geom.AffineTransform" name="void setTransform(double, double, double, double, double, double)" map="A"/>
  <method class="com.itextpdf.awt.geom.AffineTransform" name="void transform(com.itextpdf.awt.geom.Point2D[], int, com.itextpdf.awt.geom.Point2D[], int, int)" map="A"/>
  <class name="com.itextpdf.awt.geom.Point2D$Double" map="_A"/>
  <field class="com.itextpdf.awt.geom.Point2D$Double" name="x" map="C"/>
  <field class="com.itextpdf.awt.geom.Point2D$Double" name="y" map="D"/>
  <method class="com.itextpdf.awt.geom.Point2D$Double" name="double getY()" map="A"/>
  <method class="com.itextpdf.awt.geom.Point2D$Double" name="double getX()" map="B"/>
  <method class="com.itextpdf.awt.geom.Point2D$Double" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.awt.geom.Point2D$Double" name="void setLocation(double, double)" map="A"/>
  <class name="com.itextpdf.awt.geom.Point2D$Float" map="_B"/>
  <field class="com.itextpdf.awt.geom.Point2D$Float" name="x" map="A"/>
  <field class="com.itextpdf.awt.geom.Point2D$Float" name="y" map="B"/>
  <method class="com.itextpdf.awt.geom.Point2D$Float" name="double getY()" map="A"/>
  <method class="com.itextpdf.awt.geom.Point2D$Float" name="double getX()" map="B"/>
  <method class="com.itextpdf.awt.geom.Point2D$Float" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.awt.geom.Point2D$Float" name="void setLocation(double, double)" map="A"/>
  <class name="com.itextpdf.awt.geom.Point2D" map="B"/>
  <method class="com.itextpdf.awt.geom.Point2D" name="double getY()" map="A"/>
  <method class="com.itextpdf.awt.geom.Point2D" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="com.itextpdf.awt.geom.Point2D" name="java.lang.Object clone()" map="clone"/>
  <method class="com.itextpdf.awt.geom.Point2D" name="double getX()" map="B"/>
  <method class="com.itextpdf.awt.geom.Point2D" name="int hashCode()" map="hashCode"/>
  <method class="com.itextpdf.awt.geom.Point2D" name="void setLocation(double, double)" map="A"/>
  <package name="com.itextpdf.text" map="C"/>
  <package name="com.itextpdf.text.pdf" map="A"/>
  <package name="com.itextpdf.text.pdf.draw" map="A"/>
  <class name="com.itextpdf.text.pdf.draw.VerticalPositionMark" map="A"/>
  <method class="com.itextpdf.text.pdf.draw.VerticalPositionMark" name="void draw(com.itextpdf.text.pdf.PdfContentByte, float, float, float, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.draw.VerticalPositionMark" name="boolean isContent()" map="A"/>
  <method class="com.itextpdf.text.pdf.draw.VerticalPositionMark" name="java.util.List getChunks()" map="B"/>
  <method class="com.itextpdf.text.pdf.draw.VerticalPositionMark" name="int type()" map="C"/>
  <method class="com.itextpdf.text.pdf.draw.VerticalPositionMark" name="boolean process(com.itextpdf.text.ElementListener)" map="A"/>
  <class name="com.itextpdf.text.pdf.draw.LineSeparator" map="B"/>
  <method class="com.itextpdf.text.pdf.draw.LineSeparator" name="float getPercentage()" map="&#x0257;"/>
  <class name="com.itextpdf.text.pdf.draw.DrawInterface" map="C"/>
  <method class="com.itextpdf.text.pdf.draw.DrawInterface" name="void draw(com.itextpdf.text.pdf.PdfContentByte, float, float, float, float, float)" map="A"/>
  <package name="com.itextpdf.text.pdf.internal" map="B"/>
  <class name="com.itextpdf.text.pdf.internal.PdfVersionImp" map="A"/>
  <field class="com.itextpdf.text.pdf.internal.PdfVersionImp" name="catalog_version" map="&#x000905;"/>
  <field class="com.itextpdf.text.pdf.internal.PdfVersionImp" name="header_version" map="&#x000906;"/>
  <field class="com.itextpdf.text.pdf.internal.PdfVersionImp" name="appendmode" map="&#x000907;"/>
  <field class="com.itextpdf.text.pdf.internal.PdfVersionImp" name="version" map="&#x000908;"/>
  <field class="com.itextpdf.text.pdf.internal.PdfVersionImp" name="extensions" map="&#x000909;"/>
  <field class="com.itextpdf.text.pdf.internal.PdfVersionImp" name="HEADER" map="&#x00090a;"/>
  <field class="com.itextpdf.text.pdf.internal.PdfVersionImp" name="headerWasWritten" map="&#x00090b;"/>
  <method class="com.itextpdf.text.pdf.internal.PdfVersionImp" name="com.itextpdf.text.pdf.PdfName getVersionAsName(char)" map="A"/>
  <method class="com.itextpdf.text.pdf.internal.PdfVersionImp" name="byte[] getVersionAsByteArray(char)" map="B"/>
  <method class="com.itextpdf.text.pdf.internal.PdfVersionImp" name="void addToCatalog(com.itextpdf.text.pdf.PdfDictionary)" map="F"/>
  <method class="com.itextpdf.text.pdf.internal.PdfVersionImp" name="void writeHeader(com.itextpdf.text.pdf.OutputStreamCounter)" map="A"/>
  <method class="com.itextpdf.text.pdf.internal.PdfVersionImp" name="char getVersion()" map="&#x01ab;"/>
  <class name="com.itextpdf.text.pdf.internal.PdfAnnotationsImp" map="B"/>
  <field class="com.itextpdf.text.pdf.internal.PdfAnnotationsImp" name="delayedAnnotations" map="A"/>
  <field class="com.itextpdf.text.pdf.internal.PdfAnnotationsImp" name="annotations" map="B"/>
  <field class="com.itextpdf.text.pdf.internal.PdfAnnotationsImp" name="acroForm" map="C"/>
  <method class="com.itextpdf.text.pdf.internal.PdfAnnotationsImp" name="com.itextpdf.text.pdf.PdfAnnotation convertAnnotation(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Annotation, com.itextpdf.text.Rectangle)" map="A"/>
  <method class="com.itextpdf.text.pdf.internal.PdfAnnotationsImp" name="boolean hasValidAcroForm()" map="A"/>
  <method class="com.itextpdf.text.pdf.internal.PdfAnnotationsImp" name="boolean hasUnusedAnnotations()" map="B"/>
  <method class="com.itextpdf.text.pdf.internal.PdfAnnotationsImp" name="void addPlainAnnotation(com.itextpdf.text.pdf.PdfAnnotation)" map="A"/>
  <method class="com.itextpdf.text.pdf.internal.PdfAnnotationsImp" name="void addAnnotation(com.itextpdf.text.pdf.PdfAnnotation)" map="B"/>
  <method class="com.itextpdf.text.pdf.internal.PdfAnnotationsImp" name="void resetAnnotations()" map="C"/>
  <method class="com.itextpdf.text.pdf.internal.PdfAnnotationsImp" name="com.itextpdf.text.pdf.PdfArray rotateAnnotations(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Rectangle)" map="A"/>
  <method class="com.itextpdf.text.pdf.internal.PdfAnnotationsImp" name="void addFormFieldRaw(com.itextpdf.text.pdf.PdfFormField)" map="A"/>
  <method class="com.itextpdf.text.pdf.internal.PdfAnnotationsImp" name="com.itextpdf.text.pdf.PdfAcroForm getAcroForm()" map="D"/>
  <class name="com.itextpdf.text.pdf.internal.PdfViewerPreferencesImp" map="C"/>
  <field class="com.itextpdf.text.pdf.internal.PdfViewerPreferencesImp" name="NONFULLSCREENPAGEMODE_PREFERENCES" map="&#x06c6;"/>
  <field class="com.itextpdf.text.pdf.internal.PdfViewerPreferencesImp" name="viewerPreferences" map="&#x06c7;"/>
  <field class="com.itextpdf.text.pdf.internal.PdfViewerPreferencesImp" name="PAGE_BOUNDARIES" map="&#x06c8;"/>
  <field class="com.itextpdf.text.pdf.internal.PdfViewerPreferencesImp" name="pageLayoutAndMode" map="&#x06c9;"/>
  <field class="com.itextpdf.text.pdf.internal.PdfViewerPreferencesImp" name="VIEWER_PREFERENCES" map="&#x06ca;"/>
  <field class="com.itextpdf.text.pdf.internal.PdfViewerPreferencesImp" name="DIRECTION_PREFERENCES" map="&#x06cb;"/>
  <field class="com.itextpdf.text.pdf.internal.PdfViewerPreferencesImp" name="DUPLEX_PREFERENCES" map="&#x06cc;"/>
  <field class="com.itextpdf.text.pdf.internal.PdfViewerPreferencesImp" name="PRINTSCALING_PREFERENCES" map="&#x06cd;"/>
  <method class="com.itextpdf.text.pdf.internal.PdfViewerPreferencesImp" name="void addToCatalog(com.itextpdf.text.pdf.PdfDictionary)" map="E"/>
  <class name="com.itextpdf.text.pdf.internal.PdfXConformanceImp" map="D"/>
  <field class="com.itextpdf.text.pdf.internal.PdfXConformanceImp" name="writer" map="A"/>
  <field class="com.itextpdf.text.pdf.internal.PdfXConformanceImp" name="pdfxConformance" map="B"/>
  <method class="com.itextpdf.text.pdf.internal.PdfXConformanceImp" name="boolean isPdfX32002()" map="D"/>
  <method class="com.itextpdf.text.pdf.internal.PdfXConformanceImp" name="boolean isPdfX1A2001()" map="E"/>
  <method class="com.itextpdf.text.pdf.internal.PdfXConformanceImp" name="boolean isPdfX()" map="B"/>
  <method class="com.itextpdf.text.pdf.internal.PdfXConformanceImp" name="int getPDFXConformance()" map="C"/>
  <method class="com.itextpdf.text.pdf.internal.PdfXConformanceImp" name="boolean isPdfIso()" map="A"/>
  <method class="com.itextpdf.text.pdf.internal.PdfXConformanceImp" name="void checkPdfIsoConformance(int, java.lang.Object)" map="A"/>
  <package name="com.itextpdf.text.pdf.codec" map="C"/>
  <class name="com.itextpdf.text.pdf.codec.Base64" map="A"/>
  <field class="com.itextpdf.text.pdf.codec.Base64" name="_URL_SAFE_DECODABET" map="A"/>
  <field class="com.itextpdf.text.pdf.codec.Base64" name="_ORDERED_ALPHABET" map="B"/>
  <field class="com.itextpdf.text.pdf.codec.Base64" name="_STANDARD_DECODABET" map="C"/>
  <field class="com.itextpdf.text.pdf.codec.Base64" name="_STANDARD_ALPHABET" map="D"/>
  <field class="com.itextpdf.text.pdf.codec.Base64" name="_URL_SAFE_ALPHABET" map="E"/>
  <field class="com.itextpdf.text.pdf.codec.Base64" name="_ORDERED_DECODABET" map="F"/>
  <method class="com.itextpdf.text.pdf.codec.Base64" name="byte[] decode(byte[], int, int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.codec.Base64" name="byte[] decode(java.lang.String, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.codec.Base64" name="int decode4to3(byte[], int, byte[], int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.codec.Base64" name="byte[] decode(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.codec.Base64" name="byte[] getDecodabet(int)" map="A"/>
  <package name="com.itextpdf.text.pdf.languages" map="D"/>
  <class name="com.itextpdf.text.pdf.languages.IndicGlyphRepositioner" map="A"/>
  <method class="com.itextpdf.text.pdf.languages.IndicGlyphRepositioner" name="void repositionGlyphs(java.util.List)" map="A"/>
  <method class="com.itextpdf.text.pdf.languages.IndicGlyphRepositioner" name="java.util.List getCharactersToBeShiftedLeftByOnePosition()" map="A"/>
  <method class="com.itextpdf.text.pdf.languages.IndicGlyphRepositioner" name="com.itextpdf.text.pdf.Glyph getNextGlyph(java.util.List, int)" map="A"/>
  <class name="com.itextpdf.text.pdf.languages.IndicCompositeCharacterComparator" map="B"/>
  <method class="com.itextpdf.text.pdf.languages.IndicCompositeCharacterComparator" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <method class="com.itextpdf.text.pdf.languages.IndicCompositeCharacterComparator" name="int compare(java.lang.String, java.lang.String)" map="A"/>
  <class name="com.itextpdf.text.pdf.languages.ArabicLigaturizer$charstruct" map="_A"/>
  <field class="com.itextpdf.text.pdf.languages.ArabicLigaturizer$charstruct" name="numshapes" map="A"/>
  <field class="com.itextpdf.text.pdf.languages.ArabicLigaturizer$charstruct" name="vowel" map="B"/>
  <field class="com.itextpdf.text.pdf.languages.ArabicLigaturizer$charstruct" name="mark1" map="C"/>
  <field class="com.itextpdf.text.pdf.languages.ArabicLigaturizer$charstruct" name="lignum" map="D"/>
  <field class="com.itextpdf.text.pdf.languages.ArabicLigaturizer$charstruct" name="basechar" map="E"/>
  <class name="com.itextpdf.text.pdf.languages.ArabicLigaturizer" map="C"/>
  <field class="com.itextpdf.text.pdf.languages.ArabicLigaturizer" name="reverseLigatureMapTable" map="A"/>
  <field class="com.itextpdf.text.pdf.languages.ArabicLigaturizer" name="chartable" map="B"/>
  <field class="com.itextpdf.text.pdf.languages.ArabicLigaturizer" name="maptable" map="C"/>
  <method class="com.itextpdf.text.pdf.languages.ArabicLigaturizer" name="void shape(char[], java.lang.StringBuffer, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.languages.ArabicLigaturizer" name="void copycstostring(java.lang.StringBuffer, com.itextpdf.text.pdf.languages.ArabicLigaturizer$charstruct, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.languages.ArabicLigaturizer" name="boolean isVowel(char)" map="A"/>
  <method class="com.itextpdf.text.pdf.languages.ArabicLigaturizer" name="void doublelig(java.lang.StringBuffer, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.languages.ArabicLigaturizer" name="java.lang.Character getReverseMapping(char)" map="B"/>
  <method class="com.itextpdf.text.pdf.languages.ArabicLigaturizer" name="boolean connects_to_left(com.itextpdf.text.pdf.languages.ArabicLigaturizer$charstruct)" map="A"/>
  <method class="com.itextpdf.text.pdf.languages.ArabicLigaturizer" name="void processNumbers(char[], int, int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.languages.ArabicLigaturizer" name="void shapeToArabicDigitsWithContext(char[], int, int, char, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.languages.ArabicLigaturizer" name="int arabic_shape(char[], int, int, char[], int, int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.languages.ArabicLigaturizer" name="int shapecount(char)" map="C"/>
  <method class="com.itextpdf.text.pdf.languages.ArabicLigaturizer" name="char charshape(char, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.languages.ArabicLigaturizer" name="int ligature(char, com.itextpdf.text.pdf.languages.ArabicLigaturizer$charstruct)" map="A"/>
  <class name="com.itextpdf.text.pdf.languages.LanguageProcessor" map="D"/>
  <class name="com.itextpdf.text.pdf.languages.BanglaGlyphRepositioner" map="E"/>
  <field class="com.itextpdf.text.pdf.languages.BanglaGlyphRepositioner" name="glyphSubstitutionMap" map="A"/>
  <field class="com.itextpdf.text.pdf.languages.BanglaGlyphRepositioner" name="cmap31" map="B"/>
  <field class="com.itextpdf.text.pdf.languages.BanglaGlyphRepositioner" name="CHARCTERS_TO_BE_SHIFTED_LEFT_BY_1" map="C"/>
  <method class="com.itextpdf.text.pdf.languages.BanglaGlyphRepositioner" name="com.itextpdf.text.pdf.Glyph getGlyph(char)" map="A"/>
  <method class="com.itextpdf.text.pdf.languages.BanglaGlyphRepositioner" name="void repositionGlyphs(java.util.List)" map="A"/>
  <method class="com.itextpdf.text.pdf.languages.BanglaGlyphRepositioner" name="java.util.List getCharactersToBeShiftedLeftByOnePosition()" map="A"/>
  <method class="com.itextpdf.text.pdf.languages.BanglaGlyphRepositioner" name="void handleOKaarAndOUKaar(int, java.util.List, char, char)" map="A"/>
  <class name="com.itextpdf.text.pdf.languages.GlyphRepositioner" map="F"/>
  <method class="com.itextpdf.text.pdf.languages.GlyphRepositioner" name="void repositionGlyphs(java.util.List)" map="A"/>
  <package name="com.itextpdf.text.pdf.interfaces" map="E"/>
  <class name="com.itextpdf.text.pdf.interfaces.PdfVersion" map="A"/>
  <class name="com.itextpdf.text.pdf.interfaces.PdfRunDirection" map="B"/>
  <class name="com.itextpdf.text.pdf.interfaces.PdfAnnotations" map="C"/>
  <class name="com.itextpdf.text.pdf.interfaces.PdfEncryptionSettings" map="D"/>
  <class name="com.itextpdf.text.pdf.interfaces.IAccessibleElement" map="E"/>
  <method class="com.itextpdf.text.pdf.interfaces.IAccessibleElement" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.pdf.interfaces.IAccessibleElement" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.pdf.interfaces.IAccessibleElement" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.interfaces.IAccessibleElement" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.interfaces.IAccessibleElement" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.pdf.interfaces.IAccessibleElement" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.pdf.interfaces.IAccessibleElement" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.pdf.interfaces.IAccessibleElement" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <class name="com.itextpdf.text.pdf.interfaces.IPdfStructureElement" map="F"/>
  <method class="com.itextpdf.text.pdf.interfaces.IPdfStructureElement" name="com.itextpdf.text.pdf.PdfObject getAttribute(com.itextpdf.text.pdf.PdfName)" map="L"/>
  <class name="com.itextpdf.text.pdf.interfaces.PdfDocumentActions" map="G"/>
  <class name="com.itextpdf.text.pdf.interfaces.PdfXConformance" map="H"/>
  <method class="com.itextpdf.text.pdf.interfaces.PdfXConformance" name="boolean isPdfX()" map="B"/>
  <method class="com.itextpdf.text.pdf.interfaces.PdfXConformance" name="int getPDFXConformance()" map="C"/>
  <class name="com.itextpdf.text.pdf.interfaces.PdfIsoConformance" map="I"/>
  <method class="com.itextpdf.text.pdf.interfaces.PdfIsoConformance" name="boolean isPdfIso()" map="A"/>
  <method class="com.itextpdf.text.pdf.interfaces.PdfIsoConformance" name="void checkPdfIsoConformance(int, java.lang.Object)" map="A"/>
  <class name="com.itextpdf.text.pdf.interfaces.IAlternateDescription" map="J"/>
  <class name="com.itextpdf.text.pdf.interfaces.PdfPageActions" map="K"/>
  <class name="com.itextpdf.text.pdf.interfaces.PdfViewerPreferences" map="L"/>
  <package name="com.itextpdf.text.pdf.collection" map="F"/>
  <class name="com.itextpdf.text.pdf.collection.PdfCollection" map="A"/>
  <package name="com.itextpdf.text.pdf.fonts" map="G"/>
  <package name="com.itextpdf.text.pdf.fonts.otf" map="A"/>
  <class name="com.itextpdf.text.pdf.fonts.otf.Language" map="A"/>
  <field class="com.itextpdf.text.pdf.fonts.otf.Language" name="codes" map="A"/>
  <field class="com.itextpdf.text.pdf.fonts.otf.Language" name="$VALUES" map="B"/>
  <field class="com.itextpdf.text.pdf.fonts.otf.Language" name="BENGALI" map="C"/>
  <method class="com.itextpdf.text.pdf.fonts.otf.Language" name="com.itextpdf.text.pdf.fonts.otf.Language valueOf(java.lang.String)" map="valueOf"/>
  <method class="com.itextpdf.text.pdf.fonts.otf.Language" name="com.itextpdf.text.pdf.fonts.otf.Language[] values()" map="values"/>
  <package name="com.itextpdf.text.pdf.fonts.cmaps" map="B"/>
  <class name="com.itextpdf.text.pdf.fonts.cmaps.CMapUniCid" map="A"/>
  <field class="com.itextpdf.text.pdf.fonts.cmaps.CMapUniCid" name="map" map="H"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.CMapUniCid" name="void addChar(com.itextpdf.text.pdf.PdfString, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.CMapUniCid" name="int lookup(int)" map="D"/>
  <class name="com.itextpdf.text.pdf.fonts.cmaps.CMapParserEx" map="B"/>
  <field class="com.itextpdf.text.pdf.fonts.cmaps.CMapParserEx" name="CMAPNAME" map="A"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.CMapParserEx" name="void parseCid(java.lang.String, com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap, com.itextpdf.text.pdf.fonts.cmaps.CidLocation)" map="A"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.CMapParserEx" name="void parseCid(java.lang.String, com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap, com.itextpdf.text.pdf.fonts.cmaps.CidLocation, int)" map="A"/>
  <class name="com.itextpdf.text.pdf.fonts.cmaps.CidLocation" map="C"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.CidLocation" name="com.itextpdf.text.pdf.PRTokeniser getLocation(java.lang.String)" map="A"/>
  <class name="com.itextpdf.text.pdf.fonts.cmaps.CMapCidUni" map="D"/>
  <field class="com.itextpdf.text.pdf.fonts.cmaps.CMapCidUni" name="map" map="E"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.CMapCidUni" name="void addChar(com.itextpdf.text.pdf.PdfString, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.CMapCidUni" name="int lookup(int)" map="B"/>
  <class name="com.itextpdf.text.pdf.fonts.cmaps.CMapCidByte" map="E"/>
  <field class="com.itextpdf.text.pdf.fonts.cmaps.CMapCidByte" name="EMPTY" map="F"/>
  <field class="com.itextpdf.text.pdf.fonts.cmaps.CMapCidByte" name="map" map="G"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.CMapCidByte" name="void addChar(com.itextpdf.text.pdf.PdfString, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.CMapCidByte" name="byte[] lookup(int)" map="C"/>
  <class name="com.itextpdf.text.pdf.fonts.cmaps.CidResource" map="F"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.CidResource" name="com.itextpdf.text.pdf.PRTokeniser getLocation(java.lang.String)" map="A"/>
  <class name="com.itextpdf.text.pdf.fonts.cmaps.CMapCache" map="G"/>
  <field class="com.itextpdf.text.pdf.fonts.cmaps.CMapCache" name="cacheCidByte" map="A"/>
  <field class="com.itextpdf.text.pdf.fonts.cmaps.CMapCache" name="cacheByteCid" map="B"/>
  <field class="com.itextpdf.text.pdf.fonts.cmaps.CMapCache" name="cacheUniCid" map="C"/>
  <field class="com.itextpdf.text.pdf.fonts.cmaps.CMapCache" name="cacheCidUni" map="D"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.CMapCache" name="com.itextpdf.text.pdf.fonts.cmaps.CMapUniCid getCachedCMapUniCid(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.CMapCache" name="com.itextpdf.text.pdf.fonts.cmaps.CMapCidUni getCachedCMapCidUni(java.lang.String)" map="B"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.CMapCache" name="com.itextpdf.text.pdf.fonts.cmaps.CMapCidByte getCachedCMapCidByte(java.lang.String)" map="C"/>
  <class name="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" map="H"/>
  <field class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="cmapName" map="A"/>
  <field class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="registry" map="B"/>
  <field class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="supplement" map="C"/>
  <field class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="ordering" map="D"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="void intToByteArray(int, byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="void addRange(com.itextpdf.text.pdf.PdfString, com.itextpdf.text.pdf.PdfString, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="java.lang.String getOrdering()" map="A"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="void setSupplement(int)" map="A"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="java.lang.String getRegistry()" map="B"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="void setName(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="byte[] decodeStringToByte(com.itextpdf.text.pdf.PdfString)" map="A"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="void setOrdering(java.lang.String)" map="B"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="void addChar(com.itextpdf.text.pdf.PdfString, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="int byteArrayToInt(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="java.lang.String decodeStringToUnicode(com.itextpdf.text.pdf.PdfString)" map="B"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="void setRegistry(java.lang.String)" map="C"/>
  <method class="com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap" name="int getSupplement()" map="C"/>
  <class name="com.itextpdf.text.pdf.fonts.FontsResourceAnchor" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfBorderArray" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfException" map="B"/>
  <class name="com.itextpdf.text.pdf.PdfIsoConformanceException" map="C"/>
  <class name="com.itextpdf.text.pdf.HyphenationEvent" map="D"/>
  <method class="com.itextpdf.text.pdf.HyphenationEvent" name="java.lang.String getHyphenatedWordPre(java.lang.String, com.itextpdf.text.pdf.BaseFont, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.HyphenationEvent" name="java.lang.String getHyphenatedWordPost()" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfAcroForm" map="E"/>
  <field class="com.itextpdf.text.pdf.PdfAcroForm" name="calculationOrder" map="&#x0579;"/>
  <field class="com.itextpdf.text.pdf.PdfAcroForm" name="fieldTemplates" map="&#x057a;"/>
  <field class="com.itextpdf.text.pdf.PdfAcroForm" name="sigFlags" map="&#x057b;"/>
  <field class="com.itextpdf.text.pdf.PdfAcroForm" name="writer" map="&#x057c;"/>
  <field class="com.itextpdf.text.pdf.PdfAcroForm" name="documentFields" map="&#x057d;"/>
  <method class="com.itextpdf.text.pdf.PdfAcroForm" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfAcroForm" name="boolean isValid()" map="&#x0140;"/>
  <method class="com.itextpdf.text.pdf.PdfAcroForm" name="void addDocumentField(com.itextpdf.text.pdf.PdfIndirectReference)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfAcroForm" name="void addFieldTemplates(java.util.HashSet)" map="A"/>
  <class name="com.itextpdf.text.pdf.FloatLayout" map="F"/>
  <field class="com.itextpdf.text.pdf.FloatLayout" name="maxY" map="A"/>
  <field class="com.itextpdf.text.pdf.FloatLayout" name="filledWidth" map="B"/>
  <field class="com.itextpdf.text.pdf.FloatLayout" name="minY" map="C"/>
  <field class="com.itextpdf.text.pdf.FloatLayout" name="leftX" map="D"/>
  <field class="com.itextpdf.text.pdf.FloatLayout" name="rightX" map="E"/>
  <field class="com.itextpdf.text.pdf.FloatLayout" name="content" map="F"/>
  <field class="com.itextpdf.text.pdf.FloatLayout" name="useAscender" map="G"/>
  <field class="com.itextpdf.text.pdf.FloatLayout" name="yLine" map="H"/>
  <field class="com.itextpdf.text.pdf.FloatLayout" name="compositeColumn" map="I"/>
  <field class="com.itextpdf.text.pdf.FloatLayout" name="floatRightX" map="J"/>
  <field class="com.itextpdf.text.pdf.FloatLayout" name="floatLeftX" map="K"/>
  <method class="com.itextpdf.text.pdf.FloatLayout" name="int floatingLayout(java.util.List, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.FloatLayout" name="int layout(com.itextpdf.text.pdf.PdfContentByte, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.FloatLayout" name="float getYLine()" map="A"/>
  <method class="com.itextpdf.text.pdf.FloatLayout" name="void setSimpleColumn(float, float, float, float)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfNameTree" map="G"/>
  <method class="com.itextpdf.text.pdf.PdfNameTree" name="com.itextpdf.text.pdf.PdfDictionary writeTree(java.util.HashMap, com.itextpdf.text.pdf.PdfWriter)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfReader" map="H"/>
  <field class="com.itextpdf.text.pdf.PdfReader" name="debugmode" map="&#x06ce;"/>
  <field class="com.itextpdf.text.pdf.PdfReader" name="LOGGER" map="&#x06d0;"/>
  <field class="com.itextpdf.text.pdf.PdfReader" name="appendable" map="&#x06d1;"/>
  <field class="com.itextpdf.text.pdf.PdfReader" name="endobj" map="&#x06d2;"/>
  <field class="com.itextpdf.text.pdf.PdfReader" name="endstream" map="&#x06d3;"/>
  <field class="com.itextpdf.text.pdf.PdfReader" name="unethicalreading" map="&#x06d5;"/>
  <field class="com.itextpdf.text.pdf.PdfReader" name="COUNTER" map="&#x06e5;"/>
  <field class="com.itextpdf.text.pdf.PdfReader" name="pageInhCandidates" map="&#x06e6;"/>
  <method class="com.itextpdf.text.pdf.PdfReader" name="com.itextpdf.text.pdf.PdfObject getPdfObject(com.itextpdf.text.pdf.PdfObject, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfReader" name="com.itextpdf.text.pdf.PdfReaderInstance getPdfReaderInstance(com.itextpdf.text.pdf.PdfWriter)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfReader" name="com.itextpdf.text.pdf.PdfObject getPdfObject(int)" map="a"/>
  <method class="com.itextpdf.text.pdf.PdfReader" name="com.itextpdf.text.pdf.PdfObject getPdfObject(com.itextpdf.text.pdf.PdfObject)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfReader" name="boolean isAppendable()" map="&#x01aa;"/>
  <class name="com.itextpdf.text.pdf.PdfGState" map="I"/>
  <field class="com.itextpdf.text.pdf.PdfGState" name="BM_DARKEN" map="&#x057e;"/>
  <field class="com.itextpdf.text.pdf.PdfGState" name="BM_HARDLIGHT" map="&#x057f;"/>
  <field class="com.itextpdf.text.pdf.PdfGState" name="BM_SCREEN" map="&#x0580;"/>
  <field class="com.itextpdf.text.pdf.PdfGState" name="BM_COMPATIBLE" map="&#x0581;"/>
  <field class="com.itextpdf.text.pdf.PdfGState" name="BM_DIFFERENCE" map="&#x0582;"/>
  <field class="com.itextpdf.text.pdf.PdfGState" name="BM_OVERLAY" map="&#x0583;"/>
  <field class="com.itextpdf.text.pdf.PdfGState" name="BM_MULTIPLY" map="&#x0584;"/>
  <field class="com.itextpdf.text.pdf.PdfGState" name="BM_NORMAL" map="&#x0585;"/>
  <field class="com.itextpdf.text.pdf.PdfGState" name="BM_EXCLUSION" map="&#x0586;"/>
  <field class="com.itextpdf.text.pdf.PdfGState" name="BM_LIGHTEN" map="&#x0587;"/>
  <field class="com.itextpdf.text.pdf.PdfGState" name="BM_COLORBURN" map="&#x05d0;"/>
  <field class="com.itextpdf.text.pdf.PdfGState" name="BM_SOFTLIGHT" map="&#x05d1;"/>
  <field class="com.itextpdf.text.pdf.PdfGState" name="BM_COLORDODGE" map="&#x05d2;"/>
  <method class="com.itextpdf.text.pdf.PdfGState" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfGState" name="void setFillOpacity(float)" map="Y"/>
  <method class="com.itextpdf.text.pdf.PdfGState" name="void setStrokeOpacity(float)" map="Z"/>
  <class name="com.itextpdf.text.pdf.PdfPCellEvent" map="J"/>
  <method class="com.itextpdf.text.pdf.PdfPCellEvent" name="void cellLayout(com.itextpdf.text.pdf.PdfPCell, com.itextpdf.text.Rectangle, com.itextpdf.text.pdf.PdfContentByte[])" map="A"/>
  <class name="com.itextpdf.text.pdf.ColorDetails" map="K"/>
  <field class="com.itextpdf.text.pdf.ColorDetails" name="colorSpace" map="A"/>
  <field class="com.itextpdf.text.pdf.ColorDetails" name="colorSpaceName" map="B"/>
  <field class="com.itextpdf.text.pdf.ColorDetails" name="indirectReference" map="C"/>
  <method class="com.itextpdf.text.pdf.ColorDetails" name="com.itextpdf.text.pdf.PdfObject getPdfObject(com.itextpdf.text.pdf.PdfWriter)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColorDetails" name="com.itextpdf.text.pdf.PdfName getColorSpaceName()" map="A"/>
  <method class="com.itextpdf.text.pdf.ColorDetails" name="com.itextpdf.text.pdf.PdfIndirectReference getIndirectReference()" map="B"/>
  <class name="com.itextpdf.text.pdf.PdfPageEvent" map="L"/>
  <method class="com.itextpdf.text.pdf.PdfPageEvent" name="void onParagraphEnd(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPageEvent" name="void onStartPage(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPageEvent" name="void onChapterEnd(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document, float)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfPageEvent" name="void onSectionEnd(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document, float)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfPageEvent" name="void onEndPage(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfPageEvent" name="void onCloseDocument(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfPageEvent" name="void onChapter(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document, float, com.itextpdf.text.Paragraph)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPageEvent" name="void onSection(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document, float, int, com.itextpdf.text.Paragraph)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPageEvent" name="void onGenericTag(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document, com.itextpdf.text.Rectangle, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPageEvent" name="void onParagraph(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document, float)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfPageEvent" name="void onOpenDocument(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document)" map="D"/>
  <class name="com.itextpdf.text.pdf.PdfWriter$PdfBody$PdfCrossReference" map="_A"/>
  <field class="com.itextpdf.text.pdf.PdfWriter$PdfBody$PdfCrossReference" name="refnum" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfWriter$PdfBody$PdfCrossReference" name="type" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfWriter$PdfBody$PdfCrossReference" name="generation" map="C"/>
  <field class="com.itextpdf.text.pdf.PdfWriter$PdfBody$PdfCrossReference" name="offset" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody$PdfCrossReference" name="void toPdf(int, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody$PdfCrossReference" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody$PdfCrossReference" name="int hashCode()" map="hashCode"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody$PdfCrossReference" name="int compareTo(com.itextpdf.text.pdf.PdfWriter$PdfBody$PdfCrossReference)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody$PdfCrossReference" name="void toPdf(java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody$PdfCrossReference" name="int getRefnum()" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody$PdfCrossReference" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <class name="com.itextpdf.text.pdf.PdfWriter$PdfBody" map="_A"/>
  <field class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="position" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="index" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="currentObjNum" map="C"/>
  <field class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="streamObjects" map="D"/>
  <field class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="refnum" map="E"/>
  <field class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="numObj" map="F"/>
  <field class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="writer" map="G"/>
  <field class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="xrefs" map="H"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="com.itextpdf.text.pdf.PdfIndirectObject add(com.itextpdf.text.pdf.PdfObject, com.itextpdf.text.pdf.PdfIndirectReference)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="int getIndirectReferenceNumber()" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="void flushObjStm()" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="com.itextpdf.text.pdf.PdfIndirectObject add(com.itextpdf.text.pdf.PdfObject, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="void write(com.itextpdf.text.pdf.PdfIndirectObject, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="com.itextpdf.text.pdf.PdfIndirectObject add(com.itextpdf.text.pdf.PdfObject, com.itextpdf.text.pdf.PdfIndirectReference, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="com.itextpdf.text.pdf.PdfIndirectObject add(com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="long offset()" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="void write(com.itextpdf.text.pdf.PdfIndirectObject, int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="com.itextpdf.text.pdf.PdfIndirectObject add(com.itextpdf.text.pdf.PdfObject, int, int, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="com.itextpdf.text.pdf.PdfWriter$PdfBody$PdfCrossReference addToObjStm(com.itextpdf.text.pdf.PdfObject, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="com.itextpdf.text.pdf.PdfIndirectObject add(com.itextpdf.text.pdf.PdfObject, int)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="void writeCrossReferenceTable(java.io.OutputStream, com.itextpdf.text.pdf.PdfIndirectReference, com.itextpdf.text.pdf.PdfIndirectReference, com.itextpdf.text.pdf.PdfIndirectReference, com.itextpdf.text.pdf.PdfObject, long)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="int size()" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfBody" name="com.itextpdf.text.pdf.PdfIndirectReference getPdfIndirectReference()" map="E"/>
  <class name="com.itextpdf.text.pdf.PdfWriter$PdfTrailer" map="_B"/>
  <field class="com.itextpdf.text.pdf.PdfWriter$PdfTrailer" name="offset" map="&#x05d3;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter$PdfTrailer" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfWriter" map="M"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="PAGE_OPEN" map="&#x00090c;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="documentOCG" map="&#x00090d;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="WILL_SAVE" map="&#x00090e;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="ttfUnicodeWriter" map="&#x00090f;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="prevxref" map="&#x000910;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="compressionLevel" map="&#x000911;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="readerInstances" map="&#x000912;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="patternColorspaceCMYK" map="&#x000913;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="newBookmarks" map="&#x000914;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="images" map="&#x000915;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="COUNTER" map="&#x000916;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="documentSpotPatterns" map="&#x000917;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="crypto" map="&#x000918;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="body" map="&#x000919;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="DID_SAVE" map="&#x00091a;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="fullCompression" map="&#x00091b;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="taggingMode" map="&#x00091c;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="DID_PRINT" map="&#x00091d;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="documentPatterns" map="&#x00091e;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="structureTreeRoot" map="&#x00091f;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="pageDictEntries" map="&#x000920;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="tagged" map="&#x000921;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="formXObjectsCounter" map="&#x000922;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="OCGRadioGroup" map="&#x000923;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="standardStructElems_1_7" map="&#x000924;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="pdfIsoConformance" map="&#x000925;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="xmpWriter" map="&#x000926;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="runDirection" map="&#x000927;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="standardStructElems_1_4" map="&#x000928;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="documentOCGorder" map="&#x000929;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="documentProperties" map="&#x00092a;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="directContent" map="&#x00092b;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="documentFonts" map="&#x00092c;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="xmpMetadata" map="&#x00092d;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="PAGE_CLOSE" map="&#x00092e;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="documentExtGState" map="&#x00092f;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="rgbTransparencyBlending" map="&#x000930;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="documentShadingPatterns" map="&#x000931;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="tabs" map="&#x000932;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="documentColors" map="&#x000933;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="group" map="&#x000934;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="fontNumber" map="&#x000935;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="extraCatalog" map="&#x000936;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="DOCUMENT_CLOSE" map="&#x000937;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="patternNumber" map="&#x000938;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="pageEvent" map="&#x000939;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="JBIG2Globals" map="&#x00093d;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="pdf_version" map="&#x000958;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="pageReferences" map="&#x000959;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="currentPdfReaderInstance" map="&#x00095a;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="userProperties" map="&#x00095b;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="WILL_PRINT" map="&#x00095c;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="directContentUnder" map="&#x00095d;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="pdf" map="&#x00095e;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="currentPageNumber" map="&#x00095f;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="colorNumber" map="&#x000960;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="imageDictionary" map="&#x000961;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="spaceCharRatio" map="&#x000985;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="OCGLocked" map="&#x000986;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="patternColorspaceRGB" map="&#x000987;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="root" map="&#x000988;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="OCProperties" map="&#x000989;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="documentShadings" map="&#x00098a;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="patternColorspaceGRAY" map="&#x00098b;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="originalFileID" map="&#x00098c;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="PDF_VERSION_1_7" map="&#x00098f;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="PDF_VERSION_1_6" map="&#x000990;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="defaultColorspace" map="&#x000993;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="PDF_VERSION_1_5" map="&#x000994;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="formXObjects" map="&#x000995;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="PDF_VERSION_1_4" map="&#x000996;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="PDF_VERSION_1_3" map="&#x000997;"/>
  <field class="com.itextpdf.text.pdf.PdfWriter" name="PDF_VERSION_1_2" map="&#x000998;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="int getCurrentPageNumber()" map="&#x01ac;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfDictionary getDefaultColorspace()" map="&#x01ad;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfIndirectObject addToBody(com.itextpdf.text.pdf.PdfObject)" map="E"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfAnnotation createAnnotation(float, float, float, float, com.itextpdf.text.pdf.PdfString, com.itextpdf.text.pdf.PdfString, com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void flushTaggedObjects()" map="&#x01ae;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="boolean isFullCompression()" map="&#x01af;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfReaderInstance getPdfReaderInstance(com.itextpdf.text.pdf.PdfReader)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void addSimpleShadingPattern(com.itextpdf.text.pdf.PdfShadingPattern)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void addASEvent(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfName getColorspaceName()" map="&#x01b0;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfPageEvent getPageEvent()" map="&#x01b1;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfName addDirectImageSimple(com.itextpdf.text.Image, com.itextpdf.text.pdf.PdfIndirectReference)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfContentByte getDirectContent()" map="&#x01b2;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void open()" map="&#x01a7;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfObject[] addSimpleProperty(java.lang.Object, com.itextpdf.text.pdf.PdfIndirectReference)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void addLocalDestinations(java.util.TreeMap)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void buildStructTreeRootForTagged(com.itextpdf.text.pdf.PdfDictionary)" map="G"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfName addDirectImageSimple(com.itextpdf.text.Image)" map="E"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.FontDetails addSimple(com.itextpdf.text.pdf.BaseFont)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfIndirectReference getReferenceJBIG2Globals(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void setDefaultColorspace(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void addSimpleShading(com.itextpdf.text.pdf.PdfShading)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfIndirectReference getPageReference(int)" map="b"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfContentByte getDirectContentUnder()" map="&#x01b3;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void flushAcroFields()" map="&#x01b4;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfIndirectReference getPdfIndirectReference()" map="&#x01b5;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void completeExtraCatalog(com.itextpdf.text.pdf.PdfDictionary)" map="H"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfIndirectObject addToBody(com.itextpdf.text.pdf.PdfObject, com.itextpdf.text.pdf.PdfIndirectReference, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfIndirectObject addToBody(com.itextpdf.text.pdf.PdfObject, com.itextpdf.text.pdf.PdfIndirectReference)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfAnnotation createAnnotation(float, float, float, float, com.itextpdf.text.pdf.PdfAction, com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void getOCGOrder(com.itextpdf.text.pdf.PdfArray, com.itextpdf.text.pdf.PdfLayer)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.ColorDetails addSimplePatternColorspace(com.itextpdf.text.BaseColor)" map="E"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void writeKeyInfo(java.io.OutputStream)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="int getNewObjectNumber(com.itextpdf.text.pdf.PdfReader, int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void checkElementRole(com.itextpdf.text.pdf.interfaces.IAccessibleElement, com.itextpdf.text.pdf.interfaces.IAccessibleElement)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfDictionary getPageDictEntries()" map="&#x01b6;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfDictionary getInfo()" map="&#x01b7;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void resetPageDictEntries()" map="&#x01b8;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="boolean isPdfIso()" map="&#x01b9;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="boolean needToBeMarkedInContent(com.itextpdf.text.pdf.interfaces.IAccessibleElement)" map="F"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfName getTabs()" map="&#x01ba;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void checkPdfIsoConformance(int, java.lang.Object)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void checkPdfIsoConformance(com.itextpdf.text.pdf.PdfWriter, int, java.lang.Object)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="float getSpaceCharRatio()" map="&#x01bb;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.OutputStreamCounter getOs()" map="&#x01bc;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfName addDirectTemplateSimple(com.itextpdf.text.pdf.PdfTemplate, com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfDictionary getCatalog(com.itextpdf.text.pdf.PdfIndirectReference)" map="G"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void completeInfoDictionary(com.itextpdf.text.pdf.PdfDictionary)" map="I"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void resetContent()" map="&#x01bd;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfIndirectReference add(com.itextpdf.text.pdf.PdfImage, com.itextpdf.text.pdf.PdfIndirectReference)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfWriter getInstance(com.itextpdf.text.Document, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfObject[] addSimpleExtGState(com.itextpdf.text.pdf.PdfDictionary)" map="J"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="int getCompressionLevel()" map="&#x01be;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void writeOutlines(com.itextpdf.text.pdf.PdfDictionary, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.ColorDetails addSimple(com.itextpdf.text.pdf.ICachedColorSpace)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfIndirectReference getImageReference(com.itextpdf.text.pdf.PdfName)" map="N"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void addSharedObjectsToBody()" map="&#x01bf;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfAnnotation createAnnotation(com.itextpdf.text.Rectangle, com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.log.Counter getCounter()" map="&#x01c0;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void cacheObject(com.itextpdf.text.pdf.PdfIndirectObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="boolean isTagged()" map="&#x01c1;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="boolean propertyExists(java.lang.Object)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void addXFormsToBody()" map="&#x01c2;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfStructureTreeRoot getStructureTreeRoot()" map="&#x01c3;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void fillOCProperties(boolean)" map="T"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfDocument getPdfDocument()" map="&#x01c4;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfIndirectReference getCurrentPage()" map="&#x01c5;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfIndirectReference add(com.itextpdf.text.pdf.PdfICCBased)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfEncryption getEncryption()" map="&#x01c6;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void close()" map="&#x01a6;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="int getPDFXConformance()" map="&#x01c7;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfDictionary getExtraCatalog()" map="&#x01c8;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="boolean isRgbTransparencyBlending()" map="&#x01c9;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="boolean isPdfX()" map="&#x01ca;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.interfaces.PdfIsoConformance initPdfIsoConformance()" map="&#x01cb;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void addAnnotation(com.itextpdf.text.pdf.PdfAnnotation)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfName addSimplePattern(com.itextpdf.text.pdf.PdfPatternPainter)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfIndirectObject addToBody(com.itextpdf.text.pdf.PdfObject, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.TtfUnicodeWriter getTtfUnicodeWriter()" map="&#x01cc;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.PdfIndirectReference add(com.itextpdf.text.pdf.PdfPage, com.itextpdf.text.pdf.PdfContents)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="java.util.List getStandardStructElems()" map="&#x01cd;"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="void eliminateFontSubset(com.itextpdf.text.pdf.PdfDictionary)" map="K"/>
  <method class="com.itextpdf.text.pdf.PdfWriter" name="com.itextpdf.text.pdf.internal.PdfVersionImp getPdfVersion()" map="&#x01ce;"/>
  <class name="com.itextpdf.text.pdf.PdfEncryption" map="N"/>
  <field class="com.itextpdf.text.pdf.PdfEncryption" name="seq" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfEncryption" name="metadataPad" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfEncryption" name="salt" map="C"/>
  <field class="com.itextpdf.text.pdf.PdfEncryption" name="pad" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfEncryption" name="byte[] encryptByteArray(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncryption" name="byte[] createDocumentId()" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncryption" name="boolean isMetadataEncrypted()" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfEncryption" name="com.itextpdf.text.pdf.OutputStreamEncryption getEncryptionStream(java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncryption" name="com.itextpdf.text.pdf.PdfObject createInfoId(byte[], boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncryption" name="com.itextpdf.text.pdf.PdfObject getFileID(boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncryption" name="void setHashKey(int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncryption" name="int calculateStreamSize(int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncryption" name="boolean isEmbeddedFilesOnly()" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfEncryption" name="com.itextpdf.text.pdf.PdfDictionary getEncryptionDictionary()" map="D"/>
  <class name="com.itextpdf.text.pdf.PdfDictionary" map="O"/>
  <field class="com.itextpdf.text.pdf.PdfDictionary" name="PAGES" map="&#x0572;"/>
  <field class="com.itextpdf.text.pdf.PdfDictionary" name="dictionaryType" map="&#x0573;"/>
  <field class="com.itextpdf.text.pdf.PdfDictionary" name="PAGE" map="&#x0574;"/>
  <field class="com.itextpdf.text.pdf.PdfDictionary" name="CATALOG" map="&#x0575;"/>
  <field class="com.itextpdf.text.pdf.PdfDictionary" name="FONT" map="&#x0576;"/>
  <field class="com.itextpdf.text.pdf.PdfDictionary" name="OUTLINES" map="&#x0577;"/>
  <field class="com.itextpdf.text.pdf.PdfDictionary" name="hashMap" map="&#x0578;"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="com.itextpdf.text.pdf.PdfName getAsName(com.itextpdf.text.pdf.PdfName)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="com.itextpdf.text.pdf.PdfArray getAsArray(com.itextpdf.text.pdf.PdfName)" map="E"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="void mergeDifferent(com.itextpdf.text.pdf.PdfDictionary)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="void put(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="com.itextpdf.text.pdf.PdfObject getDirectObject(com.itextpdf.text.pdf.PdfName)" map="F"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="java.util.Set getKeys()" map="&#x013e;"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="boolean contains(com.itextpdf.text.pdf.PdfName)" map="G"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="void remove(com.itextpdf.text.pdf.PdfName)" map="H"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="com.itextpdf.text.pdf.PdfObject get(com.itextpdf.text.pdf.PdfName)" map="I"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="void putAll(com.itextpdf.text.pdf.PdfDictionary)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="com.itextpdf.text.pdf.PdfDictionary getAsDict(com.itextpdf.text.pdf.PdfName)" map="J"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="int size()" map="&#x013f;"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="com.itextpdf.text.pdf.PdfString getAsString(com.itextpdf.text.pdf.PdfName)" map="K"/>
  <method class="com.itextpdf.text.pdf.PdfDictionary" name="void merge(com.itextpdf.text.pdf.PdfDictionary)" map="C"/>
  <class name="com.itextpdf.text.pdf.PdfFormField" map="P"/>
  <field class="com.itextpdf.text.pdf.PdfFormField" name="kids" map="&#x0688;"/>
  <field class="com.itextpdf.text.pdf.PdfFormField" name="IF_SCALE_ALWAYS" map="&#x0689;"/>
  <field class="com.itextpdf.text.pdf.PdfFormField" name="IF_SCALE_BIGGER" map="&#x068a;"/>
  <field class="com.itextpdf.text.pdf.PdfFormField" name="mergeTarget" map="&#x068b;"/>
  <field class="com.itextpdf.text.pdf.PdfFormField" name="IF_SCALE_PROPORTIONAL" map="&#x068c;"/>
  <field class="com.itextpdf.text.pdf.PdfFormField" name="IF_SCALE_SMALLER" map="&#x068d;"/>
  <field class="com.itextpdf.text.pdf.PdfFormField" name="parent" map="&#x068e;"/>
  <field class="com.itextpdf.text.pdf.PdfFormField" name="IF_SCALE_ANAMORPHIC" map="&#x068f;"/>
  <field class="com.itextpdf.text.pdf.PdfFormField" name="IF_SCALE_NEVER" map="&#x0690;"/>
  <method class="com.itextpdf.text.pdf.PdfFormField" name="com.itextpdf.text.pdf.PdfAnnotation shallowDuplicate(com.itextpdf.text.pdf.PdfAnnotation)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfFormField" name="java.util.ArrayList getKids()" map="&#x0169;"/>
  <method class="com.itextpdf.text.pdf.PdfFormField" name="void mergeResources(com.itextpdf.text.pdf.PdfDictionary, com.itextpdf.text.pdf.PdfDictionary, com.itextpdf.text.pdf.PdfStamperImp)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfFormField" name="void setUsed()" map="&#x0163;"/>
  <method class="com.itextpdf.text.pdf.PdfFormField" name="void mergeResources(com.itextpdf.text.pdf.PdfDictionary, com.itextpdf.text.pdf.PdfDictionary)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfFormField" name="com.itextpdf.text.pdf.PdfFormField getParent()" map="&#x016a;"/>
  <class name="com.itextpdf.text.pdf.BidiLine" map="Q"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="storedRunDirection" map="A"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="detailChunks" map="B"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="indexChunkChar" map="C"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="indexChunk" map="D"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="isWordSplit" map="E"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="currentChar" map="F"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="storedOrderLevels" map="G"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="indexChars" map="H"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="runDirection" map="I"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="chunks" map="J"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="text" map="K"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="totalTextLength" map="L"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="storedIndexChunkChar" map="M"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="storedIndexChunk" map="N"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="storedText" map="O"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="arabicOptions" map="P"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="mirrorChars" map="Q"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="storedCurrentChar" map="R"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="storedIndexChars" map="S"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="orderLevels" map="T"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="storedDetailChunks" map="U"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="shortStore" map="V"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="pieceSize" map="W"/>
  <field class="com.itextpdf.text.pdf.BidiLine" name="storedTotalTextLength" map="X"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="void save()" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="void doArabicShapping()" map="B"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="java.util.ArrayList createArrayOfPdfChunks(int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="void addPiece(char, com.itextpdf.text.pdf.PdfChunk)" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="int trimLeftEx(int, int)" map="B"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="void reorder(int, int)" map="C"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="int trimRight(int, int)" map="D"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="void mirrorGlyphs()" map="C"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="java.util.ArrayList createArrayOfPdfChunks(int, int, com.itextpdf.text.pdf.PdfChunk)" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="boolean isWS(char)" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="void restore()" map="D"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="float getWidth(int, int)" map="E"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="boolean getParagraph(int)" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="void flip(int, int)" map="F"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="boolean isEmpty()" map="E"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="int trimRightEx(int, int)" map="G"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="boolean isWordSplit()" map="F"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="float getWidth(int, int, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="void addChunk(com.itextpdf.text.pdf.PdfChunk)" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="com.itextpdf.text.pdf.PdfLine processLine(float, float, int, int, int, float, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiLine" name="int[] getWord(int, int)" map="H"/>
  <class name="com.itextpdf.text.pdf.TrueTypeFontUnicode" map="R"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="glyphSubstitutionMap" map="&#x00e7;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="SUPPORTED_LANGUAGES_FOR_OTF" map="&#x00e8;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="rotbits" map="&#x00e9;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="supportedLanguage" map="&#x00ea;"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="com.itextpdf.text.pdf.fonts.otf.Language getSupportedLanguage()" map="h"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="com.itextpdf.text.pdf.PdfDictionary getCIDFontType2(com.itextpdf.text.pdf.PdfIndirectReference, java.lang.String, java.lang.Object[])" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="com.itextpdf.text.pdf.PdfStream getToUnicode(java.lang.Object[])" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="int[] getMetricsTT(int)" map="J"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="java.lang.String toHex4(int)" map="L"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="void process(byte[], boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="java.util.Map getGlyphSubstitutionMap()" map="i"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="void writeFont(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.pdf.PdfIndirectReference, java.lang.Object[])" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="java.lang.String toHex(int)" map="M"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="int compare(int[], int[])" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="int getWidth(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="byte[] convertToBytes(int)" map="C"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="int getWidth(int)" map="D"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="byte[] convertToBytes(java.lang.String)" map="D"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontUnicode" name="com.itextpdf.text.pdf.PdfDictionary getFontBaseType(com.itextpdf.text.pdf.PdfIndirectReference, java.lang.String, com.itextpdf.text.pdf.PdfIndirectReference)" map="B"/>
  <class name="com.itextpdf.text.pdf.PdfArray" map="S"/>
  <field class="com.itextpdf.text.pdf.PdfArray" name="arrayList" map="&#x00d6;"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="com.itextpdf.text.pdf.PdfObject set(int, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="boolean contains(com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="com.itextpdf.text.pdf.PdfName getAsName(int)" map="L"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="com.itextpdf.text.pdf.PdfObject getPdfObject(int)" map="M"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="boolean add(int[])" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="void add(int, com.itextpdf.text.pdf.PdfObject)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="com.itextpdf.text.pdf.PdfDictionary getAsDict(int)" map="N"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="com.itextpdf.text.pdf.PdfObject getDirectObject(int)" map="O"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="java.util.ArrayList getArrayList()" map="&#x012b;"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="com.itextpdf.text.pdf.PdfNumber getAsNumber(int)" map="P"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="boolean isEmpty()" map="&#x012c;"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="boolean add(float[])" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="void addFirst(com.itextpdf.text.pdf.PdfObject)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="boolean add(com.itextpdf.text.pdf.PdfObject)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="int size()" map="&#x012d;"/>
  <method class="com.itextpdf.text.pdf.PdfArray" name="com.itextpdf.text.pdf.PdfObject remove(int)" map="Q"/>
  <class name="com.itextpdf.text.pdf.PdfDestination" map="T"/>
  <field class="com.itextpdf.text.pdf.PdfDestination" name="status" map="&#x00d8;"/>
  <method class="com.itextpdf.text.pdf.PdfDestination" name="boolean addPage(com.itextpdf.text.pdf.PdfIndirectReference)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDestination" name="boolean hasPage()" map="&#x012e;"/>
  <class name="com.itextpdf.text.pdf.PRTokeniser$TokenType" map="_A"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser$TokenType" name="ENDOFFILE" map="A"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser$TokenType" name="END_DIC" map="B"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser$TokenType" name="END_ARRAY" map="C"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser$TokenType" name="START_ARRAY" map="D"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser$TokenType" name="OTHER" map="E"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser$TokenType" name="NUMBER" map="F"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser$TokenType" name="$VALUES" map="G"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser$TokenType" name="STRING" map="H"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser$TokenType" name="START_DIC" map="I"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser$TokenType" name="REF" map="J"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser$TokenType" name="COMMENT" map="K"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser$TokenType" name="NAME" map="L"/>
  <method class="com.itextpdf.text.pdf.PRTokeniser$TokenType" name="com.itextpdf.text.pdf.PRTokeniser$TokenType[] values()" map="values"/>
  <method class="com.itextpdf.text.pdf.PRTokeniser$TokenType" name="com.itextpdf.text.pdf.PRTokeniser$TokenType valueOf(java.lang.String)" map="valueOf"/>
  <class name="com.itextpdf.text.pdf.PRTokeniser" map="U"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser" name="stringValue" map="A"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser" name="hexString" map="B"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser" name="outBuf" map="C"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser" name="file" map="D"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser" name="type" map="E"/>
  <field class="com.itextpdf.text.pdf.PRTokeniser" name="delims" map="F"/>
  <method class="com.itextpdf.text.pdf.PRTokeniser" name="boolean isWhitespace(int, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PRTokeniser" name="boolean isWhitespace(int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PRTokeniser" name="void close()" map="A"/>
  <method class="com.itextpdf.text.pdf.PRTokeniser" name="com.itextpdf.text.pdf.PRTokeniser$TokenType getTokenType()" map="B"/>
  <method class="com.itextpdf.text.pdf.PRTokeniser" name="void backOnePosition(int)" map="B"/>
  <method class="com.itextpdf.text.pdf.PRTokeniser" name="boolean isHexString()" map="C"/>
  <method class="com.itextpdf.text.pdf.PRTokeniser" name="boolean nextToken()" map="D"/>
  <method class="com.itextpdf.text.pdf.PRTokeniser" name="void throwError(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PRTokeniser" name="java.lang.String getStringValue()" map="E"/>
  <method class="com.itextpdf.text.pdf.PRTokeniser" name="int getHex(int)" map="C"/>
  <class name="com.itextpdf.text.pdf.PdfOutline" map="V"/>
  <field class="com.itextpdf.text.pdf.PdfOutline" name="style" map="&#x05d4;"/>
  <field class="com.itextpdf.text.pdf.PdfOutline" name="kids" map="&#x05d5;"/>
  <field class="com.itextpdf.text.pdf.PdfOutline" name="writer" map="&#x05d6;"/>
  <field class="com.itextpdf.text.pdf.PdfOutline" name="reference" map="&#x05d7;"/>
  <field class="com.itextpdf.text.pdf.PdfOutline" name="color" map="&#x05d8;"/>
  <field class="com.itextpdf.text.pdf.PdfOutline" name="action" map="&#x05d9;"/>
  <field class="com.itextpdf.text.pdf.PdfOutline" name="open" map="&#x05da;"/>
  <field class="com.itextpdf.text.pdf.PdfOutline" name="count" map="&#x05db;"/>
  <field class="com.itextpdf.text.pdf.PdfOutline" name="destination" map="&#x05dc;"/>
  <field class="com.itextpdf.text.pdf.PdfOutline" name="parent" map="&#x05dd;"/>
  <method class="com.itextpdf.text.pdf.PdfOutline" name="com.itextpdf.text.pdf.PdfIndirectReference indirectReference()" map="&#x0141;"/>
  <method class="com.itextpdf.text.pdf.PdfOutline" name="int level()" map="&#x0142;"/>
  <method class="com.itextpdf.text.pdf.PdfOutline" name="void initOutline(com.itextpdf.text.pdf.PdfOutline, java.lang.String, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfOutline" name="boolean isOpen()" map="&#x0143;"/>
  <method class="com.itextpdf.text.pdf.PdfOutline" name="void addKid(com.itextpdf.text.pdf.PdfOutline)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfOutline" name="int getCount()" map="&#x0144;"/>
  <method class="com.itextpdf.text.pdf.PdfOutline" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfOutline" name="boolean setDestinationPage(com.itextpdf.text.pdf.PdfIndirectReference)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfOutline" name="void setIndirectReference(com.itextpdf.text.pdf.PdfIndirectReference)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfOutline" name="java.util.ArrayList getKids()" map="&#x0145;"/>
  <method class="com.itextpdf.text.pdf.PdfOutline" name="void setCount(int)" map="R"/>
  <method class="com.itextpdf.text.pdf.PdfOutline" name="com.itextpdf.text.pdf.PdfOutline parent()" map="&#x0146;"/>
  <class name="com.itextpdf.text.pdf.Type1Font" map="W"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="FullName" map="X"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="FamilyName" map="Y"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="EncodingScheme" map="Z"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="CharMetrics" map="_"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="StdVW" map="a"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="PFB_TYPES" map="b"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="Descender" map="c"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="Weight" map="d"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="StdHW" map="e"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="UnderlineThickness" map="f"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="resourceAnchor" map="g"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="FontName" map="h"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="pfb" map="i"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="Ascender" map="j"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="CharacterSet" map="k"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="IsFixedPitch" map="l"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="ItalicAngle" map="m"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="builtinFont" map="n"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="XHeight" map="o"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="KernPairs" map="p"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="lly" map="q"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="UnderlinePosition" map="r"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="fileName" map="s"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="llx" map="t"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="ury" map="u"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="urx" map="v"/>
  <field class="com.itextpdf.text.pdf.Type1Font" name="CapHeight" map="w"/>
  <method class="com.itextpdf.text.pdf.Type1Font" name="int getRawWidth(int, java.lang.String)" map="B"/>
  <method class="com.itextpdf.text.pdf.Type1Font" name="float getFontDescriptor(int, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.Type1Font" name="java.lang.String[][] getFamilyFontName()" map="B"/>
  <method class="com.itextpdf.text.pdf.Type1Font" name="java.lang.String[][] getFullFontName()" map="E"/>
  <method class="com.itextpdf.text.pdf.Type1Font" name="boolean hasKernPairs()" map="C"/>
  <method class="com.itextpdf.text.pdf.Type1Font" name="void writeFont(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.pdf.PdfIndirectReference, java.lang.Object[])" map="A"/>
  <method class="com.itextpdf.text.pdf.Type1Font" name="int[] getRawCharBBox(int, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.Type1Font" name="java.lang.String getPostscriptFontName()" map="G"/>
  <method class="com.itextpdf.text.pdf.Type1Font" name="com.itextpdf.text.pdf.PdfDictionary getFontBaseType(com.itextpdf.text.pdf.PdfIndirectReference, int, int, byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.Type1Font" name="com.itextpdf.text.pdf.PdfStream getFullFontStream()" map="L"/>
  <method class="com.itextpdf.text.pdf.Type1Font" name="int getKerning(int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.Type1Font" name="void process(com.itextpdf.text.pdf.RandomAccessFileOrArray)" map="A"/>
  <method class="com.itextpdf.text.pdf.Type1Font" name="com.itextpdf.text.pdf.PdfDictionary getFontDescriptor(com.itextpdf.text.pdf.PdfIndirectReference)" map="A"/>
  <class name="com.itextpdf.text.pdf.Pfm2afm" map="X"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="bits" map="A"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="Win2PSStd" map="B"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="avgwidth" map="C"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="res2" map="D"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="lastchar" map="E"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="res1" map="F"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="chartab" map="G"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="capheight" map="H"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="kernpairs" map="I"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="uline" map="J"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="defchar" map="K"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="bitoff" map="L"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="pixheight" map="M"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="face" map="N"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="extlen" map="O"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="firstchar" map="P"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="vers" map="Q"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="xheight" map="R"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="isMono" map="S"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="copyright" map="T"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="ascent" map="U"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="widthby" map="V"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="italic" map="W"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="psext" map="X"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="intleading" map="Y"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="WinChars" map="Z"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="brkchar" map="_"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="in" map="a"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="fontname" map="b"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="descender" map="c"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="verres" map="d"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="charset" map="e"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="points" map="f"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="maxwidth" map="g"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="horres" map="h"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="ascender" map="i"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="out" map="j"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="weight" map="k"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="kind" map="l"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="WinClass" map="m"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="device" map="n"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="h_len" map="o"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="extleading" map="p"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="pixwidth" map="q"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="overs" map="r"/>
  <field class="com.itextpdf.text.pdf.Pfm2afm" name="type" map="s"/>
  <method class="com.itextpdf.text.pdf.Pfm2afm" name="void outval(int)" map="A"/>
  <method class="com.itextpdf.text.pdf.Pfm2afm" name="void putchartab()" map="A"/>
  <method class="com.itextpdf.text.pdf.Pfm2afm" name="void convert(com.itextpdf.text.pdf.RandomAccessFileOrArray, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.Pfm2afm" name="void outchar(int, int, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.Pfm2afm" name="java.lang.String readString(int)" map="B"/>
  <method class="com.itextpdf.text.pdf.Pfm2afm" name="void openpfm()" map="B"/>
  <method class="com.itextpdf.text.pdf.Pfm2afm" name="void puttrailer()" map="C"/>
  <method class="com.itextpdf.text.pdf.Pfm2afm" name="void putheader()" map="D"/>
  <method class="com.itextpdf.text.pdf.Pfm2afm" name="java.lang.String readString()" map="E"/>
  <method class="com.itextpdf.text.pdf.Pfm2afm" name="void putkerntab()" map="F"/>
  <class name="com.itextpdf.text.pdf.PdfImage" map="Y"/>
  <field class="com.itextpdf.text.pdf.PdfImage" name="name" map="&#x062c;"/>
  <field class="com.itextpdf.text.pdf.PdfImage" name="image" map="&#x062d;"/>
  <method class="com.itextpdf.text.pdf.PdfImage" name="void generateImgResName(com.itextpdf.text.Image)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfImage" name="com.itextpdf.text.pdf.PdfName name()" map="&#x0158;"/>
  <method class="com.itextpdf.text.pdf.PdfImage" name="void transferBytes(java.io.InputStream, java.io.OutputStream, int)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfStamperImp" map="Z"/>
  <method class="com.itextpdf.text.pdf.PdfStamperImp" name="void markUsed(com.itextpdf.text.pdf.PdfObject)" map="F"/>
  <class name="com.itextpdf.text.pdf.BaseFont$StreamFont" map="_A"/>
  <class name="com.itextpdf.text.pdf.BaseFont" map="_"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="subsetRanges" map="A"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="unicodeDifferences" map="B"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="charBBoxes" map="C"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="vertical" map="D"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="DEFAULT_FONT_MATRIX" map="E"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="embedded" map="F"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="encoding" map="G"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="directTextToByte" map="H"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="subset" map="I"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="CHAR_RANGE_LATIN" map="J"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="widths" map="K"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="specialMap" map="L"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="CHAR_RANGE_ARABIC" map="M"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="CHAR_RANGE_HEBREW" map="N"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="differences" map="O"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="compressionLevel" map="P"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="fontType" map="Q"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="forceWidthsOutput" map="R"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="fastWinansi" map="S"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="CHAR_RANGE_CYRILLIC" map="T"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="fontCache" map="U"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="fontSpecific" map="V"/>
  <field class="com.itextpdf.text.pdf.BaseFont" name="BuiltinFonts14" map="W"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="void writeFont(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.pdf.PdfIndirectReference, java.lang.Object[])" map="A"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="int getWidth(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="int[] getRawCharBBox(int, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="float getWidthPointKerned(java.lang.String, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="char getUnicodeDifferences(int)" map="A"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="java.lang.String[] enumerateTTCNames(java.lang.String)" map="B"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="com.itextpdf.text.pdf.BaseFont createFont(java.lang.String, java.lang.String, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="com.itextpdf.text.pdf.BaseFont createFont(java.lang.String, java.lang.String, boolean, boolean, byte[], byte[], boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="int getUnicodeEquivalent(int)" map="B"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="java.lang.String getEncoding()" map="A"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="java.lang.String[][] getFamilyFontName()" map="B"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="boolean hasKernPairs()" map="C"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="float getWidthPoint(java.lang.String, float)" map="B"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="byte[] convertToBytes(int)" map="C"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="int getRawWidth(int, java.lang.String)" map="B"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="void setSubset(boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="boolean isFontSpecific()" map="D"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="java.lang.String normalizeEncoding(java.lang.String)" map="C"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="java.lang.String[][] getFullFontName()" map="E"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="com.itextpdf.text.pdf.BaseFont createFont(java.lang.String, java.lang.String, boolean, boolean, byte[], byte[], boolean, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="boolean isVertical()" map="F"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="float getFontDescriptor(int, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="float getWidthPoint(int, float)" map="B"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="int getKerning(int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="java.lang.String getPostscriptFontName()" map="G"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="int getWidth(int)" map="D"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="int getFontType()" map="H"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="java.lang.String createSubsetPrefix()" map="I"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="boolean isEmbedded()" map="J"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="java.lang.Object[] getAllFontNames(java.lang.String, java.lang.String, byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="byte[] convertToBytes(java.lang.String)" map="D"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="com.itextpdf.text.pdf.BaseFont createFont(java.lang.String, java.lang.String, boolean, boolean, byte[], byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="void createEncoding()" map="K"/>
  <method class="com.itextpdf.text.pdf.BaseFont" name="java.lang.String getBaseName(java.lang.String)" map="E"/>
  <class name="com.itextpdf.text.pdf.ColumnText" map="a"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="alignment" map="A"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="currentLeading" map="B"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="rightWall" map="C"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="lineStatus" map="D"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="spaceCharRatio" map="E"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="LOGGER" map="F"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="lastX" map="G"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="canvas" map="H"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="useAscender" map="I"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="listIdx" map="J"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="fixedLeading" map="K"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="linesWritten" map="L"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="splittedRow" map="M"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="leftX" map="N"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="indent" map="O"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="waitPhrase" map="P"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="maxY" map="Q"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="filledWidth" map="R"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="compositeElements" map="S"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="repeatFirstLineIndent" map="T"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="extraParagraphSpace" map="U"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="firstLineYDone" map="V"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="multipliedLeading" map="W"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="rightX" map="X"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="inheritGraphicState" map="Y"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="isWordSplit" map="Z"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="firstLineY" map="_"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="rectangularWidth" map="a"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="descender" map="b"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="ignoreSpacingBefore" map="c"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="leftWall" map="d"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="composite" map="e"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="rightIndent" map="f"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="rectangularMode" map="g"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="lastWasNewline" map="h"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="minY" map="i"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="canvases" map="j"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="followingIndent" map="k"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="bidiLine" map="l"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="adjustFirstLine" map="m"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="compositeColumn" map="n"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="runDirection" map="o"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="rowIdx" map="p"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="yLine" map="q"/>
  <field class="com.itextpdf.text.pdf.ColumnText" name="arabicOptions" map="r"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="float[] findLimitsOneLine()" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void addWaitingPhrase()" map="B"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setIgnoreSpacingBefore(boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setAdjustFirstLine(boolean)" map="B"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="com.itextpdf.text.pdf.PdfContentByte getCanvas()" map="C"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="float[] findLimitsTwoLines()" map="D"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="java.util.List getCompositeElements()" map="E"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setLeading(float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="int getRunDirection()" map="F"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="int goComposite(boolean)" map="C"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setAlignment(int)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setRightIndent(float)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void showTextAligned(com.itextpdf.text.pdf.PdfContentByte, int, com.itextpdf.text.Phrase, float, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="boolean isWordSplit()" map="G"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="boolean isIgnoreSpacingBefore()" map="H"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="float getYLine()" map="I"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setLeading(float)" map="B"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setUseAscender(boolean)" map="D"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setArabicOptions(int)" map="B"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void addElement(com.itextpdf.text.Element)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setCanvas(com.itextpdf.text.pdf.PdfContentByte)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setInheritGraphicState(boolean)" map="E"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="boolean isTagged(com.itextpdf.text.pdf.PdfContentByte)" map="B"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void addText(com.itextpdf.text.Phrase)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="com.itextpdf.text.pdf.ColumnText setACopy(com.itextpdf.text.pdf.ColumnText)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="float getIndent()" map="J"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="float getLastX()" map="K"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="int getAlignment()" map="L"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setFilledWidth(float)" map="C"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="int go()" map="M"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setSimpleColumn(com.itextpdf.text.Phrase, float, float, float, float, float, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setIndent(float, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="int go(boolean)" map="F"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="float getFilledWidth()" map="N"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="int go(boolean, com.itextpdf.text.pdf.interfaces.IAccessibleElement)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="boolean isUseAscender()" map="O"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setSimpleVars(com.itextpdf.text.pdf.ColumnText)" map="B"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="com.itextpdf.text.pdf.ColumnText duplicate(com.itextpdf.text.pdf.ColumnText)" map="C"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setSpaceCharRatio(float)" map="D"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="int getLinesWritten()" map="P"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void updateFilledWidth(float)" map="E"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setFollowingIndent(float)" map="F"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="boolean zeroHeightElement()" map="Q"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setExtraParagraphSpace(float)" map="G"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="float findLimitsPoint(java.util.ArrayList)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setCanvases(com.itextpdf.text.pdf.PdfContentByte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void showTextAligned(com.itextpdf.text.pdf.PdfContentByte, int, com.itextpdf.text.Phrase, float, float, float, int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setText(com.itextpdf.text.Phrase)" map="B"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setSimpleColumn(float, float, float, float, float, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setSimpleColumn(float, float, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="float getDescender()" map="R"/>
  <method class="com.itextpdf.text.pdf.ColumnText" name="void setRunDirection(int)" map="C"/>
  <class name="com.itextpdf.text.pdf.PdfContentByte$GraphicState" map="_A"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="CTM" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="wordSpace" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="aTLM" map="C"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="fontDetails" map="D"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="bTLM" map="E"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="colorStroke" map="F"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="charSpace" map="G"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="cTLM" map="H"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="textRenderMode" map="I"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="extGState" map="J"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="colorFill" map="K"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="xTLM" map="L"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="size" map="M"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="dTLM" map="N"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="yTLM" map="O"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="colorDetails" map="P"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="tx" map="Q"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="leading" map="R"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="scale" map="S"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="void copyParameters(com.itextpdf.text.pdf.PdfContentByte$GraphicState)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte$GraphicState" name="void restore(com.itextpdf.text.pdf.PdfContentByte$GraphicState)" map="B"/>
  <class name="com.itextpdf.text.pdf.PdfContentByte$UncoloredPattern" map="_B"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$UncoloredPattern" name="color" map="f"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte$UncoloredPattern" name="tint" map="g"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte$UncoloredPattern" name="boolean equals(java.lang.Object)" map="equals"/>
  <class name="com.itextpdf.text.pdf.PdfContentByte" map="b"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte" name="state" map="&#x0691;"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte" name="pdf" map="&#x0692;"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte" name="writer" map="&#x0693;"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte" name="stateList" map="&#x0694;"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte" name="mcElements" map="&#x0695;"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte" name="separator" map="&#x0696;"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte" name="layerDepth" map="&#x0697;"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte" name="abrev" map="&#x0698;"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte" name="duplicatedFrom" map="&#x0699;"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte" name="content" map="&#x069a;"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte" name="markedContentSize" map="&#x069b;"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte" name="mcDepth" map="&#x069c;"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte" name="unitRect" map="&#x069d;"/>
  <field class="com.itextpdf.text.pdf.PdfContentByte" name="inText" map="&#x069e;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void showText(com.itextpdf.text.pdf.PdfTextArray)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void beginMarkedContentSequence(com.itextpdf.text.pdf.PdfStructureElement, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void checkNoPattern(com.itextpdf.text.pdf.PdfTemplate)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setMcDepth(int)" map="V"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void restoreMCBlocks(java.util.ArrayList)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setGrayFill(float)" map="_"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setTextMatrix(float, float, float, float, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="java.util.ArrayList saveMCBlocks()" map="&#x016b;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void rectangle(float, float, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setLineCap(int)" map="W"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setTextMatrix(float, float)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="int size(boolean)" map="N"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void resetGrayFill()" map="&#x016c;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void reset(boolean)" map="O"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setGrayStroke(float)" map="a"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void addAnnotation(com.itextpdf.text.pdf.PdfAnnotation, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void saveState()" map="&#x016d;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void rectangle(double, double, double, double)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="boolean getInText()" map="&#x016e;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void closeMCBlock(com.itextpdf.text.pdf.interfaces.IAccessibleElement)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setCharacterSpacing(float)" map="b"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void addImage(com.itextpdf.text.Image, double, double, double, double, double, double, boolean, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void addImage(com.itextpdf.text.Image, double, double, double, double, double, double, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="com.itextpdf.text.pdf.PdfContentByte getDuplicate(boolean)" map="P"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void resetRGBColorFill()" map="&#x016f;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void stroke()" map="&#x0170;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void lineTo(float, float)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void checkWriter()" map="&#x0171;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setPatternFill(com.itextpdf.text.pdf.PdfPatternPainter)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void lineTo(double, double)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setColorStroke(com.itextpdf.text.pdf.PdfSpotColor, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void beginText()" map="&#x0172;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void beginLayer2(com.itextpdf.text.pdf.PdfOCG)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void ensureDocumentTagIsOpen()" map="&#x0173;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setShadingStroke(com.itextpdf.text.pdf.PdfShadingPattern)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setColorFill(com.itextpdf.text.pdf.PdfSpotColor, float)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="int size()" map="&#x0174;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setPatternStroke(com.itextpdf.text.pdf.PdfPatternPainter, com.itextpdf.text.BaseColor, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="com.itextpdf.text.pdf.ByteBuffer getInternalBuffer()" map="&#x0175;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void rectangle(com.itextpdf.text.Rectangle)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void fill()" map="&#x0176;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void HelperCMYK(float, float, float, float)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setPatternFill(com.itextpdf.text.pdf.PdfPatternPainter, com.itextpdf.text.BaseColor, float)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void addImage(com.itextpdf.text.Image, float, float, float, float, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setShadingFill(com.itextpdf.text.pdf.PdfShadingPattern)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="int getMcDepth()" map="&#x0177;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void showText(java.lang.String)" map="I"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void beginMarkedContentSequence(com.itextpdf.text.pdf.PdfName)" map="M"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="boolean compareColors(com.itextpdf.text.BaseColor, com.itextpdf.text.BaseColor)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void endMarkedContentSequence()" map="&#x0178;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void newPath()" map="&#x0179;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void addImage(com.itextpdf.text.Image)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void beginLayer(com.itextpdf.text.pdf.PdfOCG)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void endText()" map="&#x017a;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void moveTo(float, float)" map="E"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void variableRectangle(com.itextpdf.text.Rectangle)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="com.itextpdf.text.pdf.PdfDictionary getParentStructureElement()" map="&#x017b;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void moveTo(double, double)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setLineWidth(float)" map="c"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void concatCTM(double, double, double, double, double, double)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void saveColor(com.itextpdf.text.BaseColor, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setColorStroke(com.itextpdf.text.pdf.PdfDeviceNColor, float[])" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void endLayer()" map="&#x017c;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setPatternFill(com.itextpdf.text.pdf.PdfPatternPainter, com.itextpdf.text.BaseColor)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="com.itextpdf.text.pdf.PdfStructureElement openMCBlockInt(com.itextpdf.text.pdf.interfaces.IAccessibleElement)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setLineWidth(double)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void showText2(java.lang.String)" map="J"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void beginMarkedContentSequence(com.itextpdf.text.pdf.PdfStructureElement)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="float getYTLM()" map="&#x017d;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void beginText(boolean)" map="Q"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setCMYKColorStrokeF(float, float, float, float)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setColorFill(com.itextpdf.text.BaseColor)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="java.util.ArrayList getMcElements()" map="&#x017e;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setPatternStroke(com.itextpdf.text.pdf.PdfPatternPainter, com.itextpdf.text.BaseColor)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void addImage(com.itextpdf.text.Image, float, float, float, float, float, float, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setTextRenderingMode(int)" map="X"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void resetGrayStroke()" map="&#x017f;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="com.itextpdf.text.pdf.PdfContentByte getDuplicate()" map="&#x0180;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void updateTx(java.lang.String, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void beginMarkedContentSequence(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfDictionary, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void restoreState()" map="&#x0181;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setMcElements(java.util.ArrayList)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="float getXTLM()" map="&#x0182;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void addImage(com.itextpdf.text.Image, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void add(com.itextpdf.text.pdf.PdfContentByte)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="byte[] toPdf(com.itextpdf.text.pdf.PdfWriter)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void outputColorNumbers(com.itextpdf.text.BaseColor, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setColorFill(com.itextpdf.text.pdf.PdfDeviceNColor, float[])" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setColorFill(com.itextpdf.text.pdf.PdfLabColor, float, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void moveText(float, float)" map="F"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setGState(com.itextpdf.text.pdf.PdfGState)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="float getEffectiveStringWidth(java.lang.String, boolean, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void reset()" map="&#x0183;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setTextRise(float)" map="d"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="boolean isTagged()" map="&#x0184;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void checkState()" map="&#x0185;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setWordSpacing(float)" map="e"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void closeMCBlockInt(com.itextpdf.text.pdf.interfaces.IAccessibleElement)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void openMCBlock(com.itextpdf.text.pdf.interfaces.IAccessibleElement)" map="E"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="com.itextpdf.text.pdf.PdfIndirectReference getCurrentPage()" map="&#x0186;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="com.itextpdf.text.pdf.PdfDocument getPdfDocument()" map="&#x0187;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void sanityCheck()" map="&#x0188;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="com.itextpdf.text.pdf.PdfWriter getPdfWriter()" map="&#x0189;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void resetRGBColorStroke()" map="&#x018a;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setRGBColorStroke(int, int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setTextRise(double)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void HelperRGB(float, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setFontAndSize(com.itextpdf.text.pdf.BaseFont, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void addAnnotation(com.itextpdf.text.pdf.PdfAnnotation)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setColorStroke(com.itextpdf.text.BaseColor)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="float getCharacterSpacing()" map="&#x018b;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="com.itextpdf.text.pdf.PageResources getPageResources()" map="&#x018c;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void clip()" map="&#x018d;"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setRGBColorFill(int, int, int)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void concatCTM(float, float, float, float, float, float)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setLineJoin(int)" map="Y"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setColorStroke(com.itextpdf.text.pdf.PdfLabColor, float, float, float)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setCMYKColorFillF(float, float, float, float)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void setPatternStroke(com.itextpdf.text.pdf.PdfPatternPainter)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentByte" name="void addTemplate(com.itextpdf.text.pdf.PdfTemplate, double, double, double, double, double, double, boolean, boolean)" map="A"/>
  <class name="com.itextpdf.text.pdf.TrueTypeFont$FontHeader" map="_A"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$FontHeader" name="yMin" map="A"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$FontHeader" name="unitsPerEm" map="B"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$FontHeader" name="flags" map="C"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$FontHeader" name="macStyle" map="D"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$FontHeader" name="xMin" map="E"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$FontHeader" name="yMax" map="F"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$FontHeader" name="xMax" map="G"/>
  <class name="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" map="_B"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="usWinDescent" map="A"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="sTypoLineGap" map="B"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="yStrikeoutSize" map="C"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="usWidthClass" map="D"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="xAvgCharWidth" map="E"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="ySuperscriptYOffset" map="F"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="sFamilyClass" map="G"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="ySubscriptXSize" map="H"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="usFirstCharIndex" map="I"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="panose" map="J"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="usWinAscent" map="K"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="usWeightClass" map="L"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="sTypoDescender" map="M"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="ySubscriptYOffset" map="N"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="ySuperscriptYSize" map="O"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="ySubscriptXOffset" map="P"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="usLastCharIndex" map="Q"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="ySuperscriptXOffset" map="R"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="achVendID" map="S"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="fsSelection" map="T"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="sTypoAscender" map="U"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="fsType" map="V"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="ulCodePageRange2" map="W"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="ulCodePageRange1" map="X"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="ySubscriptYSize" map="Y"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="ySuperscriptXSize" map="Z"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="yStrikeoutPosition" map="_"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$WindowsMetrics" name="sCapHeight" map="a"/>
  <class name="com.itextpdf.text.pdf.TrueTypeFont$HorizontalHeader" map="_C"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$HorizontalHeader" name="minRightSideBearing" map="A"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$HorizontalHeader" name="Descender" map="B"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$HorizontalHeader" name="Ascender" map="C"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$HorizontalHeader" name="LineGap" map="D"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$HorizontalHeader" name="xMaxExtent" map="E"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$HorizontalHeader" name="caretSlopeRun" map="F"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$HorizontalHeader" name="caretSlopeRise" map="G"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$HorizontalHeader" name="minLeftSideBearing" map="H"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$HorizontalHeader" name="numberOfHMetrics" map="I"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont$HorizontalHeader" name="advanceWidthMax" map="J"/>
  <class name="com.itextpdf.text.pdf.TrueTypeFont" map="c"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="cmap31" map="&#x00c7;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="justNames" map="&#x00c8;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="ttcIndex" map="&#x00c9;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="cffLength" map="&#x00ca;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="italicAngle" map="&#x00cb;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="subFamily" map="&#x00cc;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="cffOffset" map="&#x00cd;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="head" map="&#x00ce;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="allNameEntries" map="&#x00cf;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="glyphWidthsByIndex" map="&#x00d0;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="bboxes" map="&#x00d1;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="cff" map="&#x00d2;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="hhea" map="&#x00d3;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="tables" map="&#x00d4;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="cmap10" map="&#x00d5;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="maxGlyphId" map="&#x00d6;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="os_2" map="&#x00d8;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="directoryOffset" map="&#x00d9;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="underlineThickness" map="&#x00da;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="kerning" map="&#x00db;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="fontName" map="&#x00dc;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="cmapExt" map="&#x00dd;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="rf" map="&#x00de;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="familyName" map="&#x00df;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="codePages" map="&#x00e0;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="style" map="&#x00e1;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="fileName" map="&#x00e2;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="underlinePosition" map="&#x00e3;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="isFixedPitch" map="&#x00e4;"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFont" name="fullName" map="&#x00e5;"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="void writeFont(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.pdf.PdfIndirectReference, java.lang.Object[])" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="java.lang.String getBaseFont()" map="S"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="float getFontDescriptor(int, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="int getKerning(int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="int getGlyphWidth(int)" map="G"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="void readKerning()" map="T"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="void addRangeUni(java.util.HashSet, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="java.util.HashMap readFormat0()" map="U"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="byte[] readCffFont()" map="V"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="java.lang.String[][] getAllNames()" map="W"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="java.lang.String[][] getNames(int)" map="H"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="java.util.HashMap readFormat12()" map="X"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="byte[] getFullFont()" map="Y"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="int getRawWidth(int, java.lang.String)" map="B"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="int[] getRawCharBBox(int, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="void readGlyphWidths()" map="Z"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="com.itextpdf.text.pdf.PdfDictionary getFontBaseType(com.itextpdf.text.pdf.PdfIndirectReference, java.lang.String, int, int, byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="void readCMaps()" map="_"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="java.lang.String readUnicodeString(int)" map="I"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="void process(byte[], boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="java.util.HashMap readFormat4()" map="a"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="java.lang.String[][] getFamilyFontName()" map="B"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="void addRangeUni(java.util.HashMap, boolean, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="void checkCff()" map="b"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="int[] compactRanges(java.util.ArrayList)" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="byte[] getSubSet(java.util.HashSet, boolean)" map="B"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="java.util.HashMap readFormat6()" map="c"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="com.itextpdf.text.pdf.PdfDictionary getFontDescriptor(com.itextpdf.text.pdf.PdfIndirectReference, java.lang.String, com.itextpdf.text.pdf.PdfIndirectReference)" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="java.lang.String getTTCName(java.lang.String)" map="I"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="void readBbox()" map="d"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="void fillTables()" map="e"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="java.lang.String getPostscriptFontName()" map="G"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="boolean hasKernPairs()" map="C"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="int[] getMetricsTT(int)" map="J"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="java.lang.String readStandardString(int)" map="K"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFont" name="java.lang.String[][] getFullFontName()" map="E"/>
  <class name="com.itextpdf.text.pdf.PdfImportedPage" map="d"/>
  <method class="com.itextpdf.text.pdf.PdfImportedPage" name="com.itextpdf.text.pdf.PdfReaderInstance getPdfReaderInstance()" map="&#x019a;"/>
  <class name="com.itextpdf.text.pdf.PdfSpotColor" map="e"/>
  <method class="com.itextpdf.text.pdf.PdfSpotColor" name="com.itextpdf.text.pdf.PdfObject getPdfObject(com.itextpdf.text.pdf.PdfWriter)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfSpotColor" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="com.itextpdf.text.pdf.PdfSpotColor" name="int hashCode()" map="hashCode"/>
  <method class="com.itextpdf.text.pdf.PdfSpotColor" name="com.itextpdf.text.pdf.ColorDetails[] getColorantDetails(com.itextpdf.text.pdf.PdfWriter)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfSpotColor" name="com.itextpdf.text.BaseColor getAlternativeCS()" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfContentParser$1" map="1"/>
  <field class="com.itextpdf.text.pdf.PdfContentParser$1" name="$SwitchMap$com$itextpdf$text$pdf$PRTokeniser$TokenType" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfContentParser" map="f"/>
  <field class="com.itextpdf.text.pdf.PdfContentParser" name="tokeniser" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentParser" name="java.util.ArrayList parse(java.util.ArrayList)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentParser" name="com.itextpdf.text.pdf.PdfDictionary readDictionary()" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfContentParser" name="com.itextpdf.text.pdf.PdfObject readPRObject()" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfContentParser" name="com.itextpdf.text.pdf.PdfArray readArray()" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfContentParser" name="boolean nextValidToken()" map="D"/>
  <class name="com.itextpdf.text.pdf.DocumentFont" map="g"/>
  <field class="com.itextpdf.text.pdf.DocumentFont" name="stdEnc" map="x"/>
  <method class="com.itextpdf.text.pdf.DocumentFont" name="com.itextpdf.text.pdf.PdfIndirectReference getIndirectReference()" map="M"/>
  <class name="com.itextpdf.text.pdf.SimpleBookmark" map="h"/>
  <method class="com.itextpdf.text.pdf.SimpleBookmark" name="java.lang.Object[] iterateOutlines(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.pdf.PdfIndirectReference, java.util.List, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.SimpleBookmark" name="void createOutlineAction(com.itextpdf.text.pdf.PdfDictionary, java.util.HashMap, com.itextpdf.text.pdf.PdfWriter, boolean)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfOCProperties" map="i"/>
  <class name="com.itextpdf.text.pdf.PdfString" map="j"/>
  <field class="com.itextpdf.text.pdf.PdfString" name="objGen" map="&#x00dd;"/>
  <field class="com.itextpdf.text.pdf.PdfString" name="originalValue" map="&#x00de;"/>
  <field class="com.itextpdf.text.pdf.PdfString" name="hexWriting" map="&#x00df;"/>
  <field class="com.itextpdf.text.pdf.PdfString" name="objNum" map="&#x00e0;"/>
  <field class="com.itextpdf.text.pdf.PdfString" name="encoding" map="&#x00e1;"/>
  <field class="com.itextpdf.text.pdf.PdfString" name="value" map="&#x00e2;"/>
  <method class="com.itextpdf.text.pdf.PdfString" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfString" name="java.lang.String toUnicodeString()" map="&#x0135;"/>
  <method class="com.itextpdf.text.pdf.PdfString" name="boolean isHexWriting()" map="&#x0136;"/>
  <method class="com.itextpdf.text.pdf.PdfString" name="byte[] getBytes()" map="&#x0122;"/>
  <method class="com.itextpdf.text.pdf.PdfString" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.pdf.PdfString" name="com.itextpdf.text.pdf.PdfString setHexWriting(boolean)" map="L"/>
  <class name="com.itextpdf.text.pdf.GrayColor" map="k"/>
  <field class="com.itextpdf.text.pdf.GrayColor" name="gray" map="P"/>
  <field class="com.itextpdf.text.pdf.GrayColor" name="GRAYBLACK" map="Q"/>
  <field class="com.itextpdf.text.pdf.GrayColor" name="GRAYWHITE" map="R"/>
  <method class="com.itextpdf.text.pdf.GrayColor" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="com.itextpdf.text.pdf.GrayColor" name="int hashCode()" map="hashCode"/>
  <method class="com.itextpdf.text.pdf.GrayColor" name="float getGray()" map="G"/>
  <class name="com.itextpdf.text.pdf.PdfTransparencyGroup" map="l"/>
  <class name="com.itextpdf.text.pdf.PdfStructureTreeRoot" map="m"/>
  <field class="com.itextpdf.text.pdf.PdfStructureTreeRoot" name="reference" map="&#x05e3;"/>
  <field class="com.itextpdf.text.pdf.PdfStructureTreeRoot" name="numTree" map="&#x05e4;"/>
  <field class="com.itextpdf.text.pdf.PdfStructureTreeRoot" name="classes" map="&#x05e5;"/>
  <field class="com.itextpdf.text.pdf.PdfStructureTreeRoot" name="idTreeMap" map="&#x05e6;"/>
  <field class="com.itextpdf.text.pdf.PdfStructureTreeRoot" name="classMap" map="&#x05e7;"/>
  <field class="com.itextpdf.text.pdf.PdfStructureTreeRoot" name="parentTree" map="&#x05e8;"/>
  <field class="com.itextpdf.text.pdf.PdfStructureTreeRoot" name="writer" map="&#x05e9;"/>
  <method class="com.itextpdf.text.pdf.PdfStructureTreeRoot" name="void createNumTree()" map="&#x014b;"/>
  <method class="com.itextpdf.text.pdf.PdfStructureTreeRoot" name="void buildTree()" map="&#x014c;"/>
  <method class="com.itextpdf.text.pdf.PdfStructureTreeRoot" name="com.itextpdf.text.pdf.PdfIndirectReference getReference()" map="&#x014d;"/>
  <method class="com.itextpdf.text.pdf.PdfStructureTreeRoot" name="com.itextpdf.text.pdf.PdfWriter getWriter()" map="&#x014e;"/>
  <method class="com.itextpdf.text.pdf.PdfStructureTreeRoot" name="void setAnnotationMark(int, com.itextpdf.text.pdf.PdfIndirectReference)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureTreeRoot" name="void setPageMark(int, com.itextpdf.text.pdf.PdfIndirectReference)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfStructureTreeRoot" name="void putIDTree(java.lang.String, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureTreeRoot" name="com.itextpdf.text.pdf.PdfObject getAttribute(com.itextpdf.text.pdf.PdfName)" map="L"/>
  <class name="com.itextpdf.text.pdf.PdfLayerMembership" map="n"/>
  <field class="com.itextpdf.text.pdf.PdfLayerMembership" name="ANYON" map="&#x05ea;"/>
  <field class="com.itextpdf.text.pdf.PdfLayerMembership" name="ALLON" map="&#x05f0;"/>
  <field class="com.itextpdf.text.pdf.PdfLayerMembership" name="ALLOFF" map="&#x05f1;"/>
  <field class="com.itextpdf.text.pdf.PdfLayerMembership" name="ANYOFF" map="&#x05f2;"/>
  <method class="com.itextpdf.text.pdf.PdfLayerMembership" name="com.itextpdf.text.pdf.PdfObject getPdfObject()" map="&#x014f;"/>
  <method class="com.itextpdf.text.pdf.PdfLayerMembership" name="com.itextpdf.text.pdf.PdfIndirectReference getRef()" map="&#x0150;"/>
  <class name="com.itextpdf.text.pdf.TtfUnicodeWriter" map="o"/>
  <field class="com.itextpdf.text.pdf.TtfUnicodeWriter" name="writer" map="A"/>
  <method class="com.itextpdf.text.pdf.TtfUnicodeWriter" name="void writeFont(com.itextpdf.text.pdf.TrueTypeFontUnicode, com.itextpdf.text.pdf.PdfIndirectReference, java.lang.Object[], byte[])" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfNull" map="p"/>
  <field class="com.itextpdf.text.pdf.PdfNull" name="PDFNULL" map="&#x00e4;"/>
  <method class="com.itextpdf.text.pdf.PdfNull" name="java.lang.String toString()" map="toString"/>
  <class name="com.itextpdf.text.pdf.GlyphList" map="q"/>
  <field class="com.itextpdf.text.pdf.GlyphList" name="names2unicode" map="A"/>
  <field class="com.itextpdf.text.pdf.GlyphList" name="unicode2names" map="B"/>
  <method class="com.itextpdf.text.pdf.GlyphList" name="int[] nameToUnicode(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.GlyphList" name="java.lang.String unicodeToName(int)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfFormXObject" map="r"/>
  <field class="com.itextpdf.text.pdf.PdfFormXObject" name="ZERO" map="&#x062e;"/>
  <field class="com.itextpdf.text.pdf.PdfFormXObject" name="MATRIX" map="&#x062f;"/>
  <field class="com.itextpdf.text.pdf.PdfFormXObject" name="ONE" map="&#x0630;"/>
  <class name="com.itextpdf.text.pdf.OutputStreamCounter" map="s"/>
  <field class="com.itextpdf.text.pdf.OutputStreamCounter" name="counter" map="A"/>
  <field class="com.itextpdf.text.pdf.OutputStreamCounter" name="out" map="B"/>
  <method class="com.itextpdf.text.pdf.OutputStreamCounter" name="long getCounter()" map="A"/>
  <method class="com.itextpdf.text.pdf.OutputStreamCounter" name="void flush()" map="flush"/>
  <method class="com.itextpdf.text.pdf.OutputStreamCounter" name="void write(byte[], int, int)" map="write"/>
  <method class="com.itextpdf.text.pdf.OutputStreamCounter" name="void write(byte[])" map="write"/>
  <method class="com.itextpdf.text.pdf.OutputStreamCounter" name="void write(int)" map="write"/>
  <method class="com.itextpdf.text.pdf.OutputStreamCounter" name="void close()" map="close"/>
  <class name="com.itextpdf.text.pdf.CJKFont" map="t"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="uniMap" map="y"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="cjkFonts" map="z"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="style" map="&#x00a2;"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="fontName" map="&#x00a3;"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="registryNames" map="&#x00a4;"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="fontDesc" map="&#x00a5;"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="propertiesLoaded" map="&#x00aa;"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="hMetrics" map="&#x00b5;"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="cidByte" map="&#x00ba;"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="uniCid" map="&#x00c0;"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="CMap" map="&#x00c1;"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="cidDirect" map="&#x00c2;"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="allFonts" map="&#x00c3;"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="cjkEncodings" map="&#x00c4;"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="cidUni" map="&#x00c5;"/>
  <field class="com.itextpdf.text.pdf.CJKFont" name="vMetrics" map="&#x00c6;"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="int getWidth(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="void writeFont(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.pdf.PdfIndirectReference, java.lang.Object[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="int[] getRawCharBBox(int, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="void loadRegistry()" map="N"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="int getUnicodeEquivalent(int)" map="B"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="com.itextpdf.text.pdf.PdfDictionary getFontBaseType(com.itextpdf.text.pdf.PdfIndirectReference)" map="B"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="com.itextpdf.text.pdf.PdfDictionary getFontDescriptor()" map="O"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="java.lang.String[][] getFamilyFontName()" map="B"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="int getCidCode(int)" map="E"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="void loadProperties()" map="P"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="boolean hasKernPairs()" map="C"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="void loadCMaps()" map="Q"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="com.itextpdf.text.pdf.PdfDictionary getCIDFont(com.itextpdf.text.pdf.PdfIndirectReference, com.itextpdf.text.pdf.IntHashtable)" map="A"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="byte[] convertToBytes(int)" map="C"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="int getRawWidth(int, java.lang.String)" map="B"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="java.lang.String convertToHCIDMetrics(int[], com.itextpdf.text.pdf.IntHashtable)" map="A"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="java.lang.String[][] getFullFontName()" map="E"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="float getDescNumber(java.lang.String)" map="F"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="float getBBox(int)" map="F"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="float getFontDescriptor(int, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="int getKerning(int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="com.itextpdf.text.pdf.IntHashtable createMetric(java.lang.String)" map="G"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="int getWidth(int)" map="D"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="java.lang.String getPostscriptFontName()" map="G"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="java.util.HashMap readFontProperties(java.lang.String)" map="H"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="boolean isCJKFont(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="boolean isIdentity()" map="R"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="byte[] convertToBytes(java.lang.String)" map="D"/>
  <method class="com.itextpdf.text.pdf.CJKFont" name="java.lang.String convertToVCIDMetrics(int[], com.itextpdf.text.pdf.IntHashtable, com.itextpdf.text.pdf.IntHashtable)" map="A"/>
  <class name="com.itextpdf.text.pdf.DeviceNColor" map="u"/>
  <field class="com.itextpdf.text.pdf.DeviceNColor" name="pdfDeviceNColor" map="S"/>
  <field class="com.itextpdf.text.pdf.DeviceNColor" name="tints" map="T"/>
  <method class="com.itextpdf.text.pdf.DeviceNColor" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="com.itextpdf.text.pdf.DeviceNColor" name="int hashCode()" map="hashCode"/>
  <method class="com.itextpdf.text.pdf.DeviceNColor" name="float[] getTints()" map="H"/>
  <method class="com.itextpdf.text.pdf.DeviceNColor" name="com.itextpdf.text.pdf.PdfDeviceNColor getPdfDeviceNColor()" map="I"/>
  <class name="com.itextpdf.text.pdf.PdfLine" map="v"/>
  <field class="com.itextpdf.text.pdf.PdfLine" name="listItem" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfLine" name="originalWidth" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfLine" name="width" map="C"/>
  <field class="com.itextpdf.text.pdf.PdfLine" name="isRTL" map="D"/>
  <field class="com.itextpdf.text.pdf.PdfLine" name="tabStopAnchorPosition" map="E"/>
  <field class="com.itextpdf.text.pdf.PdfLine" name="left" map="F"/>
  <field class="com.itextpdf.text.pdf.PdfLine" name="tabStop" map="G"/>
  <field class="com.itextpdf.text.pdf.PdfLine" name="alignment" map="H"/>
  <field class="com.itextpdf.text.pdf.PdfLine" name="newlineSplit" map="I"/>
  <field class="com.itextpdf.text.pdf.PdfLine" name="height" map="J"/>
  <field class="com.itextpdf.text.pdf.PdfLine" name="tabPosition" map="K"/>
  <field class="com.itextpdf.text.pdf.PdfLine" name="line" map="L"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="void flush()" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="int numberOfSpaces()" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="float[] getMaxSize(float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="boolean hasToBeJustified()" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="float getDescender()" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="com.itextpdf.text.pdf.PdfChunk add(com.itextpdf.text.pdf.PdfChunk, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="boolean isNewlineSplit()" map="E"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="com.itextpdf.text.ListItem listItem()" map="F"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="int getLineLengthUtf32()" map="G"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="java.util.Iterator iterator()" map="H"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="float getOriginalWidth()" map="I"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="float widthLeft()" map="J"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="float getAscender()" map="K"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="void resetAlignment()" map="L"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="void addToLine(com.itextpdf.text.pdf.PdfChunk)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="int getLastStrokeChunk()" map="M"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="com.itextpdf.text.Chunk listSymbol()" map="N"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="void setListItem(com.itextpdf.text.ListItem)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="float indentLeft()" map="O"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="com.itextpdf.text.pdf.PdfChunk getChunk(int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="boolean isRTL()" map="P"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="int size()" map="Q"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="float height()" map="R"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="void setExtraIndent(float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="float listIndent()" map="S"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="com.itextpdf.text.pdf.PdfChunk add(com.itextpdf.text.pdf.PdfChunk)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfLine" name="int getSeparatorCount()" map="T"/>
  <class name="com.itextpdf.text.pdf.PatternColor" map="w"/>
  <field class="com.itextpdf.text.pdf.PatternColor" name="painter" map="e"/>
  <method class="com.itextpdf.text.pdf.PatternColor" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="com.itextpdf.text.pdf.PatternColor" name="int hashCode()" map="hashCode"/>
  <method class="com.itextpdf.text.pdf.PatternColor" name="com.itextpdf.text.pdf.PdfPatternPainter getPainter()" map="U"/>
  <class name="com.itextpdf.text.pdf.PdfChunk" map="x"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="imageScalePercentage" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="keysAttributes" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="encoding" map="C"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="attributes" map="D"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="accessibleElement" map="E"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="newlineSplit" map="F"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="noStroke" map="G"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="font" map="H"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="image" map="I"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="changeLeading" map="J"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="value" map="K"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="keysNoStroke" map="L"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="singleSpace" map="M"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="offsetY" map="N"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="offsetX" map="O"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="splitCharacter" map="P"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="baseFont" map="Q"/>
  <field class="com.itextpdf.text.pdf.PdfChunk" name="leading" map="R"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="boolean noPrint(int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="float height()" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="void setTabStop(com.itextpdf.text.TabStop)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="com.itextpdf.text.pdf.PdfChunk split(float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="boolean isSeparator()" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="boolean isImage()" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="float getCharWidth(int)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="boolean isSpecialEncoding()" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="com.itextpdf.text.pdf.PdfChunk truncate(float)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="float getImageScalePercentage()" map="E"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="com.itextpdf.text.Image getImage()" map="F"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="float getImageOffsetY()" map="G"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="boolean changeLeading()" map="H"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="float trimLastSpace()" map="I"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="com.itextpdf.text.TabStop getTabStop()" map="J"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="boolean isStroked()" map="K"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="float width()" map="L"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="boolean isNewlineSplit()" map="M"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="float getImageHeight()" map="N"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="void adjustLeft(float)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="int length()" map="O"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="java.lang.Object getAttribute(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="float getLeading()" map="P"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="boolean isTab()" map="Q"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="int lengthUtf32()" map="R"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="int getWord(java.lang.String, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="com.itextpdf.text.TabStop getTabStop(com.itextpdf.text.pdf.PdfChunk, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="boolean isAttribute(java.lang.String)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="void setImageScalePercentage(float)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="int getUnicodeEquivalent(int)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="boolean isHorizontalSeparator()" map="S"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="float getImageOffsetX()" map="T"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="java.lang.String trim(java.lang.String)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="float trimFirstSpace()" map="U"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="float getTextRise()" map="V"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="float getImageWidth()" map="W"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="float width(java.lang.String)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="boolean isExtSplitCharacter(int, int, int, char[], com.itextpdf.text.pdf.PdfChunk[])" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="com.itextpdf.text.BaseColor color()" map="X"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="float getWidthCorrected(float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfChunk" name="com.itextpdf.text.pdf.PdfFont font()" map="Y"/>
  <class name="com.itextpdf.text.pdf.BidiOrder" map="y"/>
  <field class="com.itextpdf.text.pdf.BidiOrder" name="resultLevels" map="A"/>
  <field class="com.itextpdf.text.pdf.BidiOrder" name="baseTypes" map="B"/>
  <field class="com.itextpdf.text.pdf.BidiOrder" name="resultTypes" map="C"/>
  <field class="com.itextpdf.text.pdf.BidiOrder" name="rtypes" map="D"/>
  <field class="com.itextpdf.text.pdf.BidiOrder" name="paragraphEmbeddingLevel" map="E"/>
  <field class="com.itextpdf.text.pdf.BidiOrder" name="textLength" map="F"/>
  <field class="com.itextpdf.text.pdf.BidiOrder" name="embeddings" map="G"/>
  <field class="com.itextpdf.text.pdf.BidiOrder" name="initialTypes" map="H"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="byte typeForLevel(int)" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="void setLevels(int, int, byte)" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="void resolveWeakTypes(int, int, byte, byte, byte)" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="void validateLineBreaks(int[], int)" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="int reinsertExplicitCodes(int)" map="B"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="void validateParagraphEmbeddingLevel(byte)" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="byte[] getLevels()" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="int findRunLimit(int, int, byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="void runAlgorithm()" map="B"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="byte[] processEmbeddings(byte[], byte)" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="byte getDirection(char)" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="void resolveNeutralTypes(int, int, byte, byte, byte)" map="B"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="byte[] getLevels(int[])" map="A"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="void determineParagraphEmbeddingLevel()" map="C"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="void resolveImplicitLevels(int, int, byte, byte, byte)" map="C"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="void setTypes(int, int, byte)" map="B"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="void determineExplicitEmbeddingLevels()" map="D"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="boolean isWhitespace(byte)" map="B"/>
  <method class="com.itextpdf.text.pdf.BidiOrder" name="int removeExplicitCodes()" map="E"/>
  <class name="com.itextpdf.text.pdf.PdfLiteral" map="z"/>
  <field class="com.itextpdf.text.pdf.PdfLiteral" name="position" map="&#x00e5;"/>
  <method class="com.itextpdf.text.pdf.PdfLiteral" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfRendition" map="$A"/>
  <class name="com.itextpdf.text.pdf.PdfDate" map="AA"/>
  <field class="com.itextpdf.text.pdf.PdfDate" name="DATE_SPACE" map="&#x00e3;"/>
  <method class="com.itextpdf.text.pdf.PdfDate" name="java.lang.String setLength(int, int)" map="F"/>
  <class name="com.itextpdf.text.pdf.PdfBody" map="BA"/>
  <method class="com.itextpdf.text.pdf.PdfBody" name="boolean isContent()" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfBody" name="java.util.List getChunks()" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfBody" name="int type()" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfBody" name="boolean process(com.itextpdf.text.ElementListener)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfDiv$FloatType" map="_A"/>
  <field class="com.itextpdf.text.pdf.PdfDiv$FloatType" name="LEFT" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfDiv$FloatType" name="$VALUES" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfDiv$FloatType" name="RIGHT" map="C"/>
  <field class="com.itextpdf.text.pdf.PdfDiv$FloatType" name="NONE" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfDiv$FloatType" name="com.itextpdf.text.pdf.PdfDiv$FloatType valueOf(java.lang.String)" map="valueOf"/>
  <method class="com.itextpdf.text.pdf.PdfDiv$FloatType" name="com.itextpdf.text.pdf.PdfDiv$FloatType[] values()" map="values"/>
  <class name="com.itextpdf.text.pdf.PdfDiv" map="CA"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="int type()" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="float getActualWidth()" map="&#x0118;"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="int getTextAlignment()" map="&#x0119;"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="float getYLine()" map="&#x011a;"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="java.util.ArrayList getContent()" map="&#x011b;"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="boolean getKeepTogether()" map="&#x011c;"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="float getPaddingTop()" map="c"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="boolean isContent()" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="float getSpacingBefore()" map="d"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="int layout(com.itextpdf.text.pdf.PdfContentByte, boolean, boolean, float, float, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="float getActualHeight()" map="&#x011d;"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="com.itextpdf.text.pdf.PdfDiv$FloatType getFloatType()" map="&#x011e;"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="java.util.List getChunks()" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="boolean process(com.itextpdf.text.ElementListener)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDiv" name="com.itextpdf.text.BaseColor getBackgroundColor()" map="&#x011f;"/>
  <class name="com.itextpdf.text.pdf.PdfICCBased" map="DA"/>
  <class name="com.itextpdf.text.pdf.PdfTextArray" map="EA"/>
  <field class="com.itextpdf.text.pdf.PdfTextArray" name="lastNum" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfTextArray" name="arrayList" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfTextArray" name="lastStr" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfTextArray" name="java.util.ArrayList getArrayList()" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfTextArray" name="void add(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfTextArray" name="void replaceLast(java.lang.Object)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfTextArray" name="void add(float)" map="A"/>
  <class name="com.itextpdf.text.pdf.CMYKColor" map="FA"/>
  <field class="com.itextpdf.text.pdf.CMYKColor" name="magenta" map="U"/>
  <field class="com.itextpdf.text.pdf.CMYKColor" name="cyan" map="V"/>
  <field class="com.itextpdf.text.pdf.CMYKColor" name="yellow" map="W"/>
  <field class="com.itextpdf.text.pdf.CMYKColor" name="black" map="X"/>
  <method class="com.itextpdf.text.pdf.CMYKColor" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="com.itextpdf.text.pdf.CMYKColor" name="float getCyan()" map="J"/>
  <method class="com.itextpdf.text.pdf.CMYKColor" name="int hashCode()" map="hashCode"/>
  <method class="com.itextpdf.text.pdf.CMYKColor" name="float getYellow()" map="K"/>
  <method class="com.itextpdf.text.pdf.CMYKColor" name="float getBlack()" map="L"/>
  <method class="com.itextpdf.text.pdf.CMYKColor" name="float getMagenta()" map="M"/>
  <class name="com.itextpdf.text.pdf.ExtendedColor" map="GA"/>
  <field class="com.itextpdf.text.pdf.ExtendedColor" name="type" map="O"/>
  <method class="com.itextpdf.text.pdf.ExtendedColor" name="int getType()" map="F"/>
  <method class="com.itextpdf.text.pdf.ExtendedColor" name="float normalize(float)" map="A"/>
  <method class="com.itextpdf.text.pdf.ExtendedColor" name="int getType(com.itextpdf.text.BaseColor)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfPTableFooter" map="HA"/>
  <field class="com.itextpdf.text.pdf.PdfPTableFooter" name="role" map="&#x06ae;"/>
  <method class="com.itextpdf.text.pdf.PdfPTableFooter" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTableFooter" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <class name="com.itextpdf.text.pdf.PdfStream" map="IA"/>
  <field class="com.itextpdf.text.pdf.PdfStream" name="inputStream" map="&#x0621;"/>
  <field class="com.itextpdf.text.pdf.PdfStream" name="compressionLevel" map="&#x0622;"/>
  <field class="com.itextpdf.text.pdf.PdfStream" name="ref" map="&#x0623;"/>
  <field class="com.itextpdf.text.pdf.PdfStream" name="writer" map="&#x0624;"/>
  <field class="com.itextpdf.text.pdf.PdfStream" name="ENDSTREAM" map="&#x0625;"/>
  <field class="com.itextpdf.text.pdf.PdfStream" name="STARTSTREAM" map="&#x0626;"/>
  <field class="com.itextpdf.text.pdf.PdfStream" name="streamBytes" map="&#x0627;"/>
  <field class="com.itextpdf.text.pdf.PdfStream" name="compressed" map="&#x0628;"/>
  <field class="com.itextpdf.text.pdf.PdfStream" name="inputStreamLength" map="&#x0629;"/>
  <field class="com.itextpdf.text.pdf.PdfStream" name="SIZESTREAM" map="&#x062a;"/>
  <field class="com.itextpdf.text.pdf.PdfStream" name="rawLength" map="&#x062b;"/>
  <method class="com.itextpdf.text.pdf.PdfStream" name="void writeContent(java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStream" name="void superToPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfStream" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStream" name="void writeLength()" map="&#x0156;"/>
  <method class="com.itextpdf.text.pdf.PdfStream" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.pdf.PdfStream" name="int getRawLength()" map="&#x0157;"/>
  <method class="com.itextpdf.text.pdf.PdfStream" name="void flateCompress(int)" map="T"/>
  <class name="com.itextpdf.text.pdf.TrueTypeFontSubSet" map="JA"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="locaTableRealSize" map="A"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="newLocaTable" map="B"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="includeCmap" map="C"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="tableNamesExtra" map="D"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="directoryOffset" map="E"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="locaTable" map="F"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="tableNamesSimple" map="G"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="tableNamesCmap" map="H"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="fontPtr" map="I"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="glyphsInList" map="J"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="outFont" map="K"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="locaShortTable" map="L"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="rf" map="M"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="tableGlyphOffset" map="N"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="includeExtras" map="O"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="glyfTableRealSize" map="P"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="newLocaTableOut" map="Q"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="entrySelectors" map="R"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="newGlyfTable" map="S"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="fileName" map="T"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="tableDirectory" map="U"/>
  <field class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="glyphsUsed" map="V"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="void assembleFont()" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="void flatGlyphs()" map="B"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="void writeFontShort(int)" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="void checkGlyphComposite(int)" map="B"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="void createTableDirectory()" map="C"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="void locaTobytes()" map="D"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="java.lang.String readStandardString(int)" map="C"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="void createNewGlyphTables()" map="E"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="int calculateChecksum(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="void writeFontString(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="void readLoca()" map="F"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="byte[] process()" map="G"/>
  <method class="com.itextpdf.text.pdf.TrueTypeFontSubSet" name="void writeFontInt(int)" map="D"/>
  <class name="com.itextpdf.text.pdf.PdfArtifact" map="KA"/>
  <field class="com.itextpdf.text.pdf.PdfArtifact" name="accessibleAttributes" map="&#x00cf;"/>
  <field class="com.itextpdf.text.pdf.PdfArtifact" name="allowedArtifactTypes" map="&#x00d0;"/>
  <field class="com.itextpdf.text.pdf.PdfArtifact" name="id" map="&#x00d1;"/>
  <field class="com.itextpdf.text.pdf.PdfArtifact" name="role" map="&#x00d2;"/>
  <method class="com.itextpdf.text.pdf.PdfArtifact" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfArtifact" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.pdf.PdfArtifact" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfArtifact" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfArtifact" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.pdf.PdfArtifact" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.pdf.PdfArtifact" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.pdf.PdfArtifact" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <class name="com.itextpdf.text.pdf.ByteBuffer" map="LA"/>
  <field class="com.itextpdf.text.pdf.ByteBuffer" name="bytes" map="A"/>
  <field class="com.itextpdf.text.pdf.ByteBuffer" name="buf" map="B"/>
  <field class="com.itextpdf.text.pdf.ByteBuffer" name="byteCache" map="C"/>
  <field class="com.itextpdf.text.pdf.ByteBuffer" name="chars" map="D"/>
  <field class="com.itextpdf.text.pdf.ByteBuffer" name="count" map="E"/>
  <field class="com.itextpdf.text.pdf.ByteBuffer" name="dfs" map="F"/>
  <field class="com.itextpdf.text.pdf.ByteBuffer" name="byteCacheSize" map="G"/>
  <field class="com.itextpdf.text.pdf.ByteBuffer" name="HIGH_PRECISION" map="H"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="java.lang.String formatDouble(double)" map="A"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="com.itextpdf.text.pdf.ByteBuffer append(byte[], int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="void writeTo(java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="com.itextpdf.text.pdf.ByteBuffer appendHex(byte)" map="A"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="com.itextpdf.text.pdf.ByteBuffer append(com.itextpdf.text.pdf.ByteBuffer)" map="A"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="void reset()" map="A"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="void write(byte[], int, int)" map="write"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="java.lang.String formatDouble(double, com.itextpdf.text.pdf.ByteBuffer)" map="A"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="com.itextpdf.text.pdf.ByteBuffer append(char)" map="A"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="void setSize(int)" map="A"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="com.itextpdf.text.pdf.ByteBuffer append(float)" map="A"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="com.itextpdf.text.pdf.ByteBuffer append(int)" map="B"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="com.itextpdf.text.pdf.ByteBuffer append(byte)" map="B"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="com.itextpdf.text.pdf.ByteBuffer append_i(int)" map="C"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="int size()" map="B"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="com.itextpdf.text.pdf.ByteBuffer append(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="com.itextpdf.text.pdf.ByteBuffer append(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="void write(int)" map="write"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="com.itextpdf.text.pdf.ByteBuffer append(double)" map="B"/>
  <method class="com.itextpdf.text.pdf.ByteBuffer" name="byte[] toByteArray()" map="C"/>
  <class name="com.itextpdf.text.pdf.StringUtils" map="MA"/>
  <field class="com.itextpdf.text.pdf.StringUtils" name="b" map="A"/>
  <field class="com.itextpdf.text.pdf.StringUtils" name="t" map="B"/>
  <field class="com.itextpdf.text.pdf.StringUtils" name="r" map="C"/>
  <field class="com.itextpdf.text.pdf.StringUtils" name="f" map="D"/>
  <field class="com.itextpdf.text.pdf.StringUtils" name="n" map="E"/>
  <method class="com.itextpdf.text.pdf.StringUtils" name="byte[] escapeString(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.StringUtils" name="void escapeString(byte[], com.itextpdf.text.pdf.ByteBuffer)" map="A"/>
  <method class="com.itextpdf.text.pdf.StringUtils" name="byte[] convertCharsToBytes(char[])" map="A"/>
  <class name="com.itextpdf.text.pdf.IntHashtable$Entry" map="_A"/>
  <field class="com.itextpdf.text.pdf.IntHashtable$Entry" name="key" map="A"/>
  <field class="com.itextpdf.text.pdf.IntHashtable$Entry" name="next" map="B"/>
  <field class="com.itextpdf.text.pdf.IntHashtable$Entry" name="value" map="C"/>
  <field class="com.itextpdf.text.pdf.IntHashtable$Entry" name="hash" map="D"/>
  <method class="com.itextpdf.text.pdf.IntHashtable$Entry" name="java.lang.Object clone()" map="clone"/>
  <class name="com.itextpdf.text.pdf.IntHashtable" map="NA"/>
  <field class="com.itextpdf.text.pdf.IntHashtable" name="threshold" map="A"/>
  <field class="com.itextpdf.text.pdf.IntHashtable" name="count" map="B"/>
  <field class="com.itextpdf.text.pdf.IntHashtable" name="table" map="C"/>
  <field class="com.itextpdf.text.pdf.IntHashtable" name="loadFactor" map="D"/>
  <method class="com.itextpdf.text.pdf.IntHashtable" name="int[] toOrderedKeys()" map="A"/>
  <method class="com.itextpdf.text.pdf.IntHashtable" name="java.lang.Object clone()" map="clone"/>
  <method class="com.itextpdf.text.pdf.IntHashtable" name="int size()" map="B"/>
  <method class="com.itextpdf.text.pdf.IntHashtable" name="int[] getKeys()" map="C"/>
  <method class="com.itextpdf.text.pdf.IntHashtable" name="int put(int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.IntHashtable" name="void rehash()" map="D"/>
  <method class="com.itextpdf.text.pdf.IntHashtable" name="int get(int)" map="A"/>
  <method class="com.itextpdf.text.pdf.IntHashtable" name="boolean containsKey(int)" map="B"/>
  <class name="com.itextpdf.text.pdf.PdfEFStream" map="OA"/>
  <method class="com.itextpdf.text.pdf.PdfEFStream" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfOCG" map="PA"/>
  <method class="com.itextpdf.text.pdf.PdfOCG" name="com.itextpdf.text.pdf.PdfObject getPdfObject()" map="&#x014f;"/>
  <method class="com.itextpdf.text.pdf.PdfOCG" name="com.itextpdf.text.pdf.PdfIndirectReference getRef()" map="&#x0150;"/>
  <class name="com.itextpdf.text.pdf.RandomAccessFileOrArray" map="QA"/>
  <field class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="back" map="A"/>
  <field class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="isBack" map="B"/>
  <field class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="byteSource" map="C"/>
  <field class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="byteSourcePosition" map="D"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="void pushBack(byte)" map="A"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="double readDouble()" map="readDouble"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="char readChar()" map="readChar"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="byte readByte()" map="readByte"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="void readFully(byte[])" map="readFully"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="void seek(long)" map="A"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="int readUnsignedShortLE()" map="A"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="void close()" map="B"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="java.lang.String readLine()" map="readLine"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="java.lang.String readString(int, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="int readUnsignedShort()" map="readUnsignedShort"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="int skipBytes(int)" map="skipBytes"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="short readShort()" map="readShort"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="float readFloat()" map="readFloat"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="int readIntLE()" map="C"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="int read(byte[], int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="int readInt()" map="readInt"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="long readLong()" map="readLong"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="boolean readBoolean()" map="readBoolean"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="int read()" map="D"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="long skip(long)" map="B"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="void reOpen()" map="E"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="long getFilePointer()" map="F"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="short readShortLE()" map="G"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="int readUnsignedByte()" map="readUnsignedByte"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="java.lang.String readUTF()" map="readUTF"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="long length()" map="H"/>
  <method class="com.itextpdf.text.pdf.RandomAccessFileOrArray" name="void readFully(byte[], int, int)" map="readFully"/>
  <class name="com.itextpdf.text.pdf.PageResources" map="RA"/>
  <field class="com.itextpdf.text.pdf.PageResources" name="propertyDictionary" map="A"/>
  <field class="com.itextpdf.text.pdf.PageResources" name="originalResources" map="B"/>
  <field class="com.itextpdf.text.pdf.PageResources" name="shadingDictionary" map="C"/>
  <field class="com.itextpdf.text.pdf.PageResources" name="extGStateDictionary" map="D"/>
  <field class="com.itextpdf.text.pdf.PageResources" name="fontDictionary" map="E"/>
  <field class="com.itextpdf.text.pdf.PageResources" name="colorDictionary" map="F"/>
  <field class="com.itextpdf.text.pdf.PageResources" name="forbiddenNames" map="G"/>
  <field class="com.itextpdf.text.pdf.PageResources" name="patternDictionary" map="H"/>
  <field class="com.itextpdf.text.pdf.PageResources" name="namePtr" map="I"/>
  <field class="com.itextpdf.text.pdf.PageResources" name="usedNames" map="J"/>
  <field class="com.itextpdf.text.pdf.PageResources" name="xObjectDictionary" map="K"/>
  <method class="com.itextpdf.text.pdf.PageResources" name="com.itextpdf.text.pdf.PdfDictionary getResources()" map="A"/>
  <method class="com.itextpdf.text.pdf.PageResources" name="void addDefaultColor(com.itextpdf.text.pdf.PdfDictionary)" map="A"/>
  <method class="com.itextpdf.text.pdf.PageResources" name="com.itextpdf.text.pdf.PdfName addExtGState(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfIndirectReference)" map="A"/>
  <method class="com.itextpdf.text.pdf.PageResources" name="com.itextpdf.text.pdf.PdfName translateName(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PageResources" name="com.itextpdf.text.pdf.PdfName addFont(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfIndirectReference)" map="B"/>
  <method class="com.itextpdf.text.pdf.PageResources" name="com.itextpdf.text.pdf.PdfName addColor(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfIndirectReference)" map="C"/>
  <method class="com.itextpdf.text.pdf.PageResources" name="void addDefaultColorDiff(com.itextpdf.text.pdf.PdfDictionary)" map="B"/>
  <method class="com.itextpdf.text.pdf.PageResources" name="com.itextpdf.text.pdf.PdfName addProperty(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfIndirectReference)" map="D"/>
  <method class="com.itextpdf.text.pdf.PageResources" name="com.itextpdf.text.pdf.PdfName addPattern(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfIndirectReference)" map="E"/>
  <method class="com.itextpdf.text.pdf.PageResources" name="com.itextpdf.text.pdf.PdfName addXObject(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfIndirectReference)" map="F"/>
  <class name="com.itextpdf.text.pdf.ArrayBasedStringTokenizer" map="SA"/>
  <field class="com.itextpdf.text.pdf.ArrayBasedStringTokenizer" name="regex" map="A"/>
  <method class="com.itextpdf.text.pdf.ArrayBasedStringTokenizer" name="java.lang.String getRegexFromTokens(java.lang.String[])" map="A"/>
  <method class="com.itextpdf.text.pdf.ArrayBasedStringTokenizer" name="java.lang.String[] tokenize(java.lang.String)" map="A"/>
  <class name="com.itextpdf.text.pdf.CFFFontSubset" map="TA"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="NewSubrsIndexNonCID" map="R"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="hSubrsUsed" map="S"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="hSubrsUsedNonCID" map="T"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="GBias" map="U"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="OutputList" map="V"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="GlyphsUsed" map="W"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="NewCharStringsIndex" map="X"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="NewGSubrsIndex" map="Y"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="NumOfHints" map="Z"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="glyphsInList" map="_"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="hGSubrsUsed" map="a"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="lSubrsUsed" map="b"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="SubrsEscapeFuncs" map="c"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="lGSubrsUsed" map="d"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="NewLSubrsIndex" map="e"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="SubrsFunctions" map="f"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="lSubrsUsedNonCID" map="g"/>
  <field class="com.itextpdf.text.pdf.CFFFontSubset" name="FDArrayUsed" map="h"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void BuildSubrUsed(int, int, int, int[], java.util.HashMap, java.util.ArrayList)" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void ReconstructFDArray(int, com.itextpdf.text.pdf.CFFFont$OffsetItem[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void BuildIndexHeader(int, int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void CreateCharset(com.itextpdf.text.pdf.CFFFont$OffsetItem, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void PushStack()" map="H"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void HandelStack()" map="I"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void CreateKeys(com.itextpdf.text.pdf.CFFFont$OffsetItem, com.itextpdf.text.pdf.CFFFont$OffsetItem, com.itextpdf.text.pdf.CFFFont$OffsetItem, com.itextpdf.text.pdf.CFFFont$OffsetItem)" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="int CalcBias(int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void ReadASubr(int, int, int, int, java.util.HashMap, java.util.ArrayList, int[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="int CountCharset(int, int)" map="B"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void BuildNewCharString(int)" map="E"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void EmptyStack()" map="J"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="byte[] BuildNewIndex(int[], java.util.HashMap, byte)" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void CreateNonCIDSubrs(int, com.itextpdf.text.pdf.CFFFont$IndexBaseItem, com.itextpdf.text.pdf.CFFFont$OffsetItem)" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="int CalcHints(int, int, int, int, int[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void CopyHeader()" map="K"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void PopStack()" map="L"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void ReconstructPrivateSubrs(int, com.itextpdf.text.pdf.CFFFont$IndexBaseItem[], com.itextpdf.text.pdf.CFFFont$OffsetItem[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void CreateNonCIDPrivate(int, com.itextpdf.text.pdf.CFFFont$OffsetItem)" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void readFDSelect(int)" map="F"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void BuildNewLGSubrs(int)" map="G"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void Reconstruct(int)" map="H"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void BuildFDArrayUsed(int)" map="I"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="int CountRange(int, int)" map="C"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void ReadCommand()" map="M"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void ReconstructPrivateDict(int, com.itextpdf.text.pdf.CFFFont$OffsetItem[], com.itextpdf.text.pdf.CFFFont$IndexBaseItem[], com.itextpdf.text.pdf.CFFFont$OffsetItem[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void CreateNewStringIndex(int)" map="J"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="byte[] AssembleIndex(int[], byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="byte[] BuildNewFile(int)" map="K"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void BuildFDSubrsOffsets(int, int)" map="D"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void CreateFDSelect(com.itextpdf.text.pdf.CFFFont$OffsetItem, int)" map="B"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="byte[] Process(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void BuildGSubrsUsed(int)" map="L"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void ReadFDArray(int)" map="M"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="void CreateFDArray(com.itextpdf.text.pdf.CFFFont$OffsetItem, com.itextpdf.text.pdf.CFFFont$OffsetItem, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="int CalcSubrOffsetSize(int, int)" map="E"/>
  <method class="com.itextpdf.text.pdf.CFFFontSubset" name="int StackOpp()" map="N"/>
  <class name="com.itextpdf.text.pdf.PdfFileSpecification" map="UA"/>
  <field class="com.itextpdf.text.pdf.PdfFileSpecification" name="ref" map="&#x0637;"/>
  <field class="com.itextpdf.text.pdf.PdfFileSpecification" name="writer" map="&#x0638;"/>
  <method class="com.itextpdf.text.pdf.PdfFileSpecification" name="com.itextpdf.text.pdf.PdfFileSpecification fileEmbedded(com.itextpdf.text.pdf.PdfWriter, java.lang.String, java.lang.String, byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfFileSpecification" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfFileSpecification" name="com.itextpdf.text.pdf.PdfFileSpecification fileEmbedded(com.itextpdf.text.pdf.PdfWriter, java.lang.String, java.lang.String, byte[], java.lang.String, com.itextpdf.text.pdf.PdfDictionary, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfFileSpecification" name="void setUnicodeFileName(java.lang.String, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfFileSpecification" name="com.itextpdf.text.pdf.PdfIndirectReference getReference()" map="&#x0159;"/>
  <method class="com.itextpdf.text.pdf.PdfFileSpecification" name="com.itextpdf.text.pdf.PdfFileSpecification fileExtern(com.itextpdf.text.pdf.PdfWriter, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfFileSpecification" name="com.itextpdf.text.pdf.PdfFileSpecification fileEmbedded(com.itextpdf.text.pdf.PdfWriter, java.lang.String, java.lang.String, byte[], int)" map="A"/>
  <class name="com.itextpdf.text.pdf.ICachedColorSpace" map="VA"/>
  <method class="com.itextpdf.text.pdf.ICachedColorSpace" name="com.itextpdf.text.pdf.PdfObject getPdfObject(com.itextpdf.text.pdf.PdfWriter)" map="A"/>
  <class name="com.itextpdf.text.pdf.PRIndirectReference" map="WA"/>
  <method class="com.itextpdf.text.pdf.PRIndirectReference" name="com.itextpdf.text.pdf.PdfReader getReader()" map="&#x013a;"/>
  <class name="com.itextpdf.text.pdf.PdfXConformanceException" map="XA"/>
  <class name="com.itextpdf.text.pdf.PdfPages" map="YA"/>
  <field class="com.itextpdf.text.pdf.PdfPages" name="topParent" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfPages" name="pages" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfPages" name="leafSize" map="C"/>
  <field class="com.itextpdf.text.pdf.PdfPages" name="parents" map="D"/>
  <field class="com.itextpdf.text.pdf.PdfPages" name="writer" map="E"/>
  <method class="com.itextpdf.text.pdf.PdfPages" name="void addPage(com.itextpdf.text.pdf.PdfDictionary)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPages" name="com.itextpdf.text.pdf.PdfIndirectReference writePageTree()" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfAction" map="ZA"/>
  <method class="com.itextpdf.text.pdf.PdfAction" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfAction" name="com.itextpdf.text.pdf.PdfAction rendition(java.lang.String, com.itextpdf.text.pdf.PdfFileSpecification, java.lang.String, com.itextpdf.text.pdf.PdfIndirectReference)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfAction" name="com.itextpdf.text.pdf.PdfAction javaScript(java.lang.String, com.itextpdf.text.pdf.PdfWriter, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfAction" name="com.itextpdf.text.pdf.PdfAction javaScript(java.lang.String, com.itextpdf.text.pdf.PdfWriter)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfPTableEventAfterSplit" map="_A"/>
  <method class="com.itextpdf.text.pdf.PdfPTableEventAfterSplit" name="void afterSplitTable(com.itextpdf.text.pdf.PdfPTable, com.itextpdf.text.pdf.PdfPRow, int)" map="A"/>
  <class name="com.itextpdf.text.pdf.LabColor" map="aA"/>
  <field class="com.itextpdf.text.pdf.LabColor" name="b" map="Y"/>
  <field class="com.itextpdf.text.pdf.LabColor" name="a" map="Z"/>
  <field class="com.itextpdf.text.pdf.LabColor" name="l" map="_"/>
  <field class="com.itextpdf.text.pdf.LabColor" name="labColorSpace" map="a"/>
  <method class="com.itextpdf.text.pdf.LabColor" name="float getB()" map="N"/>
  <method class="com.itextpdf.text.pdf.LabColor" name="float getA()" map="O"/>
  <method class="com.itextpdf.text.pdf.LabColor" name="float getL()" map="P"/>
  <method class="com.itextpdf.text.pdf.LabColor" name="com.itextpdf.text.pdf.PdfLabColor getLabColorSpace()" map="Q"/>
  <class name="com.itextpdf.text.pdf.PdfBoolean" map="bA"/>
  <field class="com.itextpdf.text.pdf.PdfBoolean" name="value" map="&#x00e6;"/>
  <field class="com.itextpdf.text.pdf.PdfBoolean" name="PDFFALSE" map="&#x00e7;"/>
  <field class="com.itextpdf.text.pdf.PdfBoolean" name="PDFTRUE" map="&#x00e8;"/>
  <method class="com.itextpdf.text.pdf.PdfBoolean" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.pdf.PdfBoolean" name="boolean booleanValue()" map="&#x0137;"/>
  <class name="com.itextpdf.text.pdf.CFFFont$SubrMarkerItem" map="_A"/>
  <field class="com.itextpdf.text.pdf.CFFFont$SubrMarkerItem" name="indexBase" map="R"/>
  <field class="com.itextpdf.text.pdf.CFFFont$SubrMarkerItem" name="offItem" map="S"/>
  <method class="com.itextpdf.text.pdf.CFFFont$SubrMarkerItem" name="void xref()" map="A"/>
  <class name="com.itextpdf.text.pdf.CFFFont$IndexMarkerItem" map="_B"/>
  <field class="com.itextpdf.text.pdf.CFFFont$IndexMarkerItem" name="indexBase" map="B"/>
  <field class="com.itextpdf.text.pdf.CFFFont$IndexMarkerItem" name="offItem" map="C"/>
  <method class="com.itextpdf.text.pdf.CFFFont$IndexMarkerItem" name="void xref()" map="A"/>
  <class name="com.itextpdf.text.pdf.CFFFont$UInt32Item" map="_C"/>
  <field class="com.itextpdf.text.pdf.CFFFont$UInt32Item" name="value" map="D"/>
  <method class="com.itextpdf.text.pdf.CFFFont$UInt32Item" name="void emit(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFont$UInt32Item" name="void increment(int[])" map="A"/>
  <class name="com.itextpdf.text.pdf.CFFFont$UInt16Item" map="_D"/>
  <field class="com.itextpdf.text.pdf.CFFFont$UInt16Item" name="value" map="E"/>
  <method class="com.itextpdf.text.pdf.CFFFont$UInt16Item" name="void emit(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFont$UInt16Item" name="void increment(int[])" map="A"/>
  <class name="com.itextpdf.text.pdf.CFFFont$UInt8Item" map="_E"/>
  <field class="com.itextpdf.text.pdf.CFFFont$UInt8Item" name="value" map="F"/>
  <method class="com.itextpdf.text.pdf.CFFFont$UInt8Item" name="void emit(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFont$UInt8Item" name="void increment(int[])" map="A"/>
  <class name="com.itextpdf.text.pdf.CFFFont$Item" map="_F"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Item" name="myOffset" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFont$Item" name="void xref()" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFont$Item" name="void emit(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFont$Item" name="void increment(int[])" map="A"/>
  <class name="com.itextpdf.text.pdf.CFFFont$IndexBaseItem" map="_G"/>
  <class name="com.itextpdf.text.pdf.CFFFont$IndexOffsetItem" map="_H"/>
  <field class="com.itextpdf.text.pdf.CFFFont$IndexOffsetItem" name="size" map="L"/>
  <method class="com.itextpdf.text.pdf.CFFFont$IndexOffsetItem" name="void emit(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFont$IndexOffsetItem" name="void increment(int[])" map="A"/>
  <class name="com.itextpdf.text.pdf.CFFFont$DictNumberItem" map="_I"/>
  <field class="com.itextpdf.text.pdf.CFFFont$DictNumberItem" name="size" map="G"/>
  <field class="com.itextpdf.text.pdf.CFFFont$DictNumberItem" name="value" map="H"/>
  <method class="com.itextpdf.text.pdf.CFFFont$DictNumberItem" name="void emit(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFont$DictNumberItem" name="void increment(int[])" map="A"/>
  <class name="com.itextpdf.text.pdf.CFFFont$MarkerItem" map="_J"/>
  <field class="com.itextpdf.text.pdf.CFFFont$MarkerItem" name="p" map="I"/>
  <method class="com.itextpdf.text.pdf.CFFFont$MarkerItem" name="void xref()" map="A"/>
  <class name="com.itextpdf.text.pdf.CFFFont$Font" map="_K"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="fdselectOffset" map="A"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="FDArrayOffsize" map="B"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="privateLength" map="C"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="privateOffset" map="D"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="fdprivateLengths" map="E"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="charsetOffset" map="F"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="fdarrayOffset" map="G"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="charstringsOffset" map="H"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="isCID" map="I"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="FDSelectFormat" map="J"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="FDArrayOffsets" map="K"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="PrivateSubrsOffset" map="L"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="CharsetLength" map="M"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="CharstringType" map="N"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="charstringsOffsets" map="O"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="nglyphs" map="P"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="FDSelect" map="Q"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="FDArrayCount" map="R"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="nstrings" map="S"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="privateSubrs" map="T"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="fdprivateOffsets" map="U"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="PrivateSubrsOffsetsArray" map="V"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="FDSelectLength" map="W"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="this$0" map="X"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="SubrsOffsets" map="Y"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="encodingOffset" map="Z"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="fullName" map="_"/>
  <field class="com.itextpdf.text.pdf.CFFFont$Font" name="name" map="a"/>
  <class name="com.itextpdf.text.pdf.CFFFont$UInt24Item" map="_L"/>
  <field class="com.itextpdf.text.pdf.CFFFont$UInt24Item" name="value" map="J"/>
  <method class="com.itextpdf.text.pdf.CFFFont$UInt24Item" name="void emit(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFont$UInt24Item" name="void increment(int[])" map="A"/>
  <class name="com.itextpdf.text.pdf.CFFFont$DictOffsetItem" map="_M"/>
  <field class="com.itextpdf.text.pdf.CFFFont$DictOffsetItem" name="size" map="M"/>
  <method class="com.itextpdf.text.pdf.CFFFont$DictOffsetItem" name="void emit(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFont$DictOffsetItem" name="void increment(int[])" map="A"/>
  <class name="com.itextpdf.text.pdf.CFFFont$OffsetItem" map="_N"/>
  <field class="com.itextpdf.text.pdf.CFFFont$OffsetItem" name="value" map="K"/>
  <method class="com.itextpdf.text.pdf.CFFFont$OffsetItem" name="void set(int)" map="A"/>
  <class name="com.itextpdf.text.pdf.CFFFont$RangeItem" map="_O"/>
  <field class="com.itextpdf.text.pdf.CFFFont$RangeItem" name="buf" map="N"/>
  <field class="com.itextpdf.text.pdf.CFFFont$RangeItem" name="length" map="O"/>
  <field class="com.itextpdf.text.pdf.CFFFont$RangeItem" name="offset" map="P"/>
  <method class="com.itextpdf.text.pdf.CFFFont$RangeItem" name="void emit(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFont$RangeItem" name="void increment(int[])" map="A"/>
  <class name="com.itextpdf.text.pdf.CFFFont$StringItem" map="_P"/>
  <field class="com.itextpdf.text.pdf.CFFFont$StringItem" name="s" map="Q"/>
  <method class="com.itextpdf.text.pdf.CFFFont$StringItem" name="void emit(byte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFont$StringItem" name="void increment(int[])" map="A"/>
  <class name="com.itextpdf.text.pdf.CFFFont" map="cA"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="offSize" map="A"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="buf" map="B"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="operatorNames" map="C"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="standardStrings" map="D"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="gsubrIndexOffset" map="E"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="topdictIndexOffset" map="F"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="nameIndexOffset" map="G"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="args" map="H"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="topdictOffsets" map="I"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="fonts" map="J"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="nextIndexOffset" map="K"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="key" map="L"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="stringOffsets" map="M"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="stringIndexOffset" map="N"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="gsubrOffsets" map="O"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="nameOffsets" map="P"/>
  <field class="com.itextpdf.text.pdf.CFFFont" name="arg_count" map="Q"/>
  <method class="com.itextpdf.text.pdf.CFFFont" name="int getOffset(int)" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFont" name="int getInt()" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFont" name="java.lang.String getString(char)" map="A"/>
  <method class="com.itextpdf.text.pdf.CFFFont" name="int getPosition()" map="B"/>
  <method class="com.itextpdf.text.pdf.CFFFont" name="void seek(int)" map="B"/>
  <method class="com.itextpdf.text.pdf.CFFFont" name="char getCard8()" map="C"/>
  <method class="com.itextpdf.text.pdf.CFFFont" name="java.lang.String[] getNames()" map="D"/>
  <method class="com.itextpdf.text.pdf.CFFFont" name="int[] getIndex(int)" map="C"/>
  <method class="com.itextpdf.text.pdf.CFFFont" name="void getDictItem()" map="E"/>
  <method class="com.itextpdf.text.pdf.CFFFont" name="char getCard16()" map="F"/>
  <method class="com.itextpdf.text.pdf.CFFFont" name="com.itextpdf.text.pdf.CFFFont$RangeItem getEntireIndexRange(int)" map="D"/>
  <method class="com.itextpdf.text.pdf.CFFFont" name="short getShort()" map="G"/>
  <class name="com.itextpdf.text.pdf.PdfColor" map="dA"/>
  <class name="com.itextpdf.text.pdf.IPdfSpecialColorSpace" map="eA"/>
  <method class="com.itextpdf.text.pdf.IPdfSpecialColorSpace" name="com.itextpdf.text.pdf.ColorDetails[] getColorantDetails(com.itextpdf.text.pdf.PdfWriter)" map="B"/>
  <class name="com.itextpdf.text.pdf.PdfObject" map="fA"/>
  <field class="com.itextpdf.text.pdf.PdfObject" name="bytes" map="&#x00d3;"/>
  <field class="com.itextpdf.text.pdf.PdfObject" name="type" map="&#x00d4;"/>
  <field class="com.itextpdf.text.pdf.PdfObject" name="indRef" map="&#x00d5;"/>
  <method class="com.itextpdf.text.pdf.PdfObject" name="void setContent(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfObject" name="boolean isIndirect()" map="&#x0120;"/>
  <method class="com.itextpdf.text.pdf.PdfObject" name="boolean isDictionary()" map="&#x0121;"/>
  <method class="com.itextpdf.text.pdf.PdfObject" name="byte[] getBytes()" map="&#x0122;"/>
  <method class="com.itextpdf.text.pdf.PdfObject" name="int type()" map="&#x0123;"/>
  <method class="com.itextpdf.text.pdf.PdfObject" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfObject" name="com.itextpdf.text.pdf.PRIndirectReference getIndRef()" map="&#x0124;"/>
  <method class="com.itextpdf.text.pdf.PdfObject" name="void setIndRef(com.itextpdf.text.pdf.PRIndirectReference)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfObject" name="boolean isName()" map="&#x0125;"/>
  <method class="com.itextpdf.text.pdf.PdfObject" name="boolean isArray()" map="&#x0126;"/>
  <method class="com.itextpdf.text.pdf.PdfObject" name="boolean isNumber()" map="&#x0127;"/>
  <method class="com.itextpdf.text.pdf.PdfObject" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.pdf.PdfObject" name="boolean isNull()" map="&#x0128;"/>
  <method class="com.itextpdf.text.pdf.PdfObject" name="boolean canBeInObjStm()" map="&#x0129;"/>
  <method class="com.itextpdf.text.pdf.PdfObject" name="boolean isString()" map="&#x012a;"/>
  <class name="com.itextpdf.text.pdf.PdfDeviceNColor" map="gA"/>
  <method class="com.itextpdf.text.pdf.PdfDeviceNColor" name="com.itextpdf.text.pdf.PdfObject getPdfObject(com.itextpdf.text.pdf.PdfWriter)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDeviceNColor" name="int hashCode()" map="hashCode"/>
  <method class="com.itextpdf.text.pdf.PdfDeviceNColor" name="com.itextpdf.text.pdf.ColorDetails[] getColorantDetails(com.itextpdf.text.pdf.PdfWriter)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfDeviceNColor" name="com.itextpdf.text.pdf.PdfSpotColor[] getSpotColors()" map="B"/>
  <class name="com.itextpdf.text.pdf.PdfNumberTree" map="hA"/>
  <method class="com.itextpdf.text.pdf.PdfNumberTree" name="com.itextpdf.text.pdf.PdfDictionary writeTree(java.util.HashMap, com.itextpdf.text.pdf.PdfWriter)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfReaderInstance" map="iA"/>
  <field class="com.itextpdf.text.pdf.PdfReaderInstance" name="ONE" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfReaderInstance" name="IDENTITYMATRIX" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfReaderInstance" name="com.itextpdf.text.pdf.PdfReader getReader()" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfReaderInstance" name="void writeAllPages()" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfReaderInstance" name="int getNewObjectNumber(int, int)" map="A"/>
  <class name="com.itextpdf.text.pdf.SpotColor" map="jA"/>
  <field class="com.itextpdf.text.pdf.SpotColor" name="spot" map="b"/>
  <field class="com.itextpdf.text.pdf.SpotColor" name="tint" map="c"/>
  <method class="com.itextpdf.text.pdf.SpotColor" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="com.itextpdf.text.pdf.SpotColor" name="int hashCode()" map="hashCode"/>
  <method class="com.itextpdf.text.pdf.SpotColor" name="float getTint()" map="R"/>
  <method class="com.itextpdf.text.pdf.SpotColor" name="com.itextpdf.text.pdf.PdfSpotColor getPdfSpotColor()" map="S"/>
  <class name="com.itextpdf.text.pdf.ShadingColor" map="kA"/>
  <field class="com.itextpdf.text.pdf.ShadingColor" name="shadingPattern" map="d"/>
  <method class="com.itextpdf.text.pdf.ShadingColor" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="com.itextpdf.text.pdf.ShadingColor" name="int hashCode()" map="hashCode"/>
  <method class="com.itextpdf.text.pdf.ShadingColor" name="com.itextpdf.text.pdf.PdfShadingPattern getPdfShadingPattern()" map="T"/>
  <class name="com.itextpdf.text.pdf.PdfAnnotation" map="lA"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="AA_FOCUS" map="&#x0646;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="form" map="&#x0647;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="HIGHLIGHT_INVERT" map="&#x0648;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="templates" map="&#x0649;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="APPEARANCE_DOWN" map="&#x064a;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="AA_EXIT" map="&#x0671;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="annotation" map="&#x0672;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="HIGHLIGHT_TOGGLE" map="&#x0673;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="AA_BLUR" map="&#x0674;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="AA_ENTER" map="&#x0675;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="used" map="&#x0676;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="AA_JS_FORMAT" map="&#x0677;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="HIGHLIGHT_OUTLINE" map="&#x0678;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="reference" map="&#x0679;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="HIGHLIGHT_NONE" map="&#x067a;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="accessibleAttributes" map="&#x067b;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="placeInPage" map="&#x067c;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="AA_JS_KEY" map="&#x067d;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="AA_JS_OTHER_CHANGE" map="&#x067e;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="AA_UP" map="&#x067f;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="HIGHLIGHT_PUSH" map="&#x0680;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="id" map="&#x0681;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="writer" map="&#x0682;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="APPEARANCE_ROLLOVER" map="&#x0683;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="APPEARANCE_NORMAL" map="&#x0684;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="AA_JS_CHANGE" map="&#x0685;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="role" map="&#x0686;"/>
  <field class="com.itextpdf.text.pdf.PdfAnnotation" name="AA_DOWN" map="&#x0687;"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="com.itextpdf.text.pdf.PdfIndirectReference getIndirectReference()" map="&#x0161;"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="java.util.HashSet getTemplates()" map="&#x0162;"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="void setUsed()" map="&#x0163;"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="com.itextpdf.text.pdf.PdfAnnotation createScreen(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Rectangle, java.lang.String, com.itextpdf.text.pdf.PdfFileSpecification, java.lang.String, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="boolean isAnnotation()" map="&#x0164;"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="void applyCTM(com.itextpdf.awt.geom.AffineTransform)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="void setPage()" map="&#x0165;"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="boolean isForm()" map="&#x0166;"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="int getPlaceInPage()" map="&#x0167;"/>
  <method class="com.itextpdf.text.pdf.PdfAnnotation" name="boolean isUsed()" map="&#x0168;"/>
  <class name="com.itextpdf.text.pdf.PdfTemplate" map="mA"/>
  <field class="com.itextpdf.text.pdf.PdfTemplate" name="contentTagged" map="&#x069f;"/>
  <field class="com.itextpdf.text.pdf.PdfTemplate" name="id" map="&#x06a0;"/>
  <field class="com.itextpdf.text.pdf.PdfTemplate" name="additional" map="&#x06a1;"/>
  <field class="com.itextpdf.text.pdf.PdfTemplate" name="accessibleAttributes" map="&#x06a2;"/>
  <field class="com.itextpdf.text.pdf.PdfTemplate" name="pageResources" map="&#x06a3;"/>
  <field class="com.itextpdf.text.pdf.PdfTemplate" name="role" map="&#x06a4;"/>
  <field class="com.itextpdf.text.pdf.PdfTemplate" name="pageReference" map="&#x06a5;"/>
  <field class="com.itextpdf.text.pdf.PdfTemplate" name="layer" map="&#x06a6;"/>
  <field class="com.itextpdf.text.pdf.PdfTemplate" name="thisReference" map="&#x06a7;"/>
  <field class="com.itextpdf.text.pdf.PdfTemplate" name="type" map="&#x06a8;"/>
  <field class="com.itextpdf.text.pdf.PdfTemplate" name="matrix" map="&#x06a9;"/>
  <field class="com.itextpdf.text.pdf.PdfTemplate" name="group" map="&#x06aa;"/>
  <field class="com.itextpdf.text.pdf.PdfTemplate" name="bBox" map="&#x06ab;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.Rectangle getBoundingBox()" map="&#x018e;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.pdf.PdfIndirectReference getIndirectReference()" map="&#x018f;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="float getHeight()" map="&#x0190;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.pdf.PdfTemplate createTemplate(com.itextpdf.text.pdf.PdfWriter, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.pdf.PdfStream getFormXObject(int)" map="Z"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="void setWidth(float)" map="f"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.pdf.PdfArray getMatrix()" map="&#x0191;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.pdf.PdfIndirectReference getPageReference()" map="&#x0192;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.pdf.PdfObject getResources()" map="&#x0193;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="boolean isTagged()" map="&#x0184;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.pdf.PageResources getPageResources()" map="&#x018c;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="boolean isContentTagged()" map="&#x0194;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.pdf.PdfTransparencyGroup getGroup()" map="&#x0195;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.pdf.PdfIndirectReference getCurrentPage()" map="&#x0186;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.pdf.PdfTemplate createTemplate(com.itextpdf.text.pdf.PdfWriter, float, float, com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.pdf.PdfDictionary getAdditional()" map="&#x0196;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.pdf.PdfOCG getLayer()" map="&#x0197;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="void setContentTagged(boolean)" map="R"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="int getType()" map="&#x0198;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="void setPageReference(com.itextpdf.text.pdf.PdfIndirectReference)" map="F"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="com.itextpdf.text.pdf.PdfContentByte getDuplicate()" map="&#x0180;"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="void setHeight(float)" map="g"/>
  <method class="com.itextpdf.text.pdf.PdfTemplate" name="float getWidth()" map="&#x0199;"/>
  <class name="com.itextpdf.text.pdf.PdfResources" map="nA"/>
  <method class="com.itextpdf.text.pdf.PdfResources" name="void add(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfDictionary)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfPHeaderCell" map="oA"/>
  <field class="com.itextpdf.text.pdf.PdfPHeaderCell" name="name" map="&#x000a9e;"/>
  <field class="com.itextpdf.text.pdf.PdfPHeaderCell" name="scope" map="&#x000a9f;"/>
  <method class="com.itextpdf.text.pdf.PdfPHeaderCell" name="java.lang.String getName()" map="&#x0211;"/>
  <method class="com.itextpdf.text.pdf.PdfPHeaderCell" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPHeaderCell" name="int getScope()" map="&#x0212;"/>
  <method class="com.itextpdf.text.pdf.PdfPHeaderCell" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <class name="com.itextpdf.text.pdf.PdfIndirectObject" map="pA"/>
  <field class="com.itextpdf.text.pdf.PdfIndirectObject" name="STARTOBJ" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfIndirectObject" name="ENDOBJ" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfIndirectObject" name="object" map="C"/>
  <field class="com.itextpdf.text.pdf.PdfIndirectObject" name="SIZEOBJ" map="D"/>
  <field class="com.itextpdf.text.pdf.PdfIndirectObject" name="number" map="E"/>
  <field class="com.itextpdf.text.pdf.PdfIndirectObject" name="writer" map="F"/>
  <field class="com.itextpdf.text.pdf.PdfIndirectObject" name="generation" map="G"/>
  <method class="com.itextpdf.text.pdf.PdfIndirectObject" name="void writeTo(java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfIndirectObject" name="com.itextpdf.text.pdf.PdfIndirectReference getIndirectReference()" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfIndirectObject" name="java.lang.String toString()" map="toString"/>
  <class name="com.itextpdf.text.pdf.PdfShading" map="qA"/>
  <method class="com.itextpdf.text.pdf.PdfShading" name="com.itextpdf.text.BaseColor getColorSpace()" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfShading" name="void addToBody()" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfShading" name="void setName(int)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfPTableEvent" map="rA"/>
  <method class="com.itextpdf.text.pdf.PdfPTableEvent" name="void tableLayout(com.itextpdf.text.pdf.PdfPTable, float[][], float[], int, int, com.itextpdf.text.pdf.PdfContentByte[])" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfIndirectReference" map="sA"/>
  <field class="com.itextpdf.text.pdf.PdfIndirectReference" name="number" map="&#x00e9;"/>
  <field class="com.itextpdf.text.pdf.PdfIndirectReference" name="generation" map="&#x00ea;"/>
  <method class="com.itextpdf.text.pdf.PdfIndirectReference" name="int getGeneration()" map="&#x0138;"/>
  <method class="com.itextpdf.text.pdf.PdfIndirectReference" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfIndirectReference" name="int getNumber()" map="&#x0139;"/>
  <method class="com.itextpdf.text.pdf.PdfIndirectReference" name="java.lang.String toString()" map="toString"/>
  <class name="com.itextpdf.text.pdf.ExtraEncoding" map="tA"/>
  <method class="com.itextpdf.text.pdf.ExtraEncoding" name="byte[] charToByte(char, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.ExtraEncoding" name="byte[] charToByte(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.ExtraEncoding" name="java.lang.String byteToChar(byte[], java.lang.String)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfDocument$PdfCatalog" map="_A"/>
  <field class="com.itextpdf.text.pdf.PdfDocument$PdfCatalog" name="writer" map="&#x0639;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument$PdfCatalog" name="void setAdditionalActions(com.itextpdf.text.pdf.PdfDictionary)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfDocument$PdfCatalog" name="void addNames(java.util.TreeMap, java.util.HashMap, java.util.HashMap, com.itextpdf.text.pdf.PdfWriter)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDocument$PdfCatalog" name="void setOpenAction(com.itextpdf.text.pdf.PdfAction)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfDocument$Destination" map="_B"/>
  <field class="com.itextpdf.text.pdf.PdfDocument$Destination" name="this$0" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfDocument$Destination" name="destination" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfDocument$Destination" name="reference" map="C"/>
  <field class="com.itextpdf.text.pdf.PdfDocument$Destination" name="action" map="D"/>
  <class name="com.itextpdf.text.pdf.PdfDocument$Indentation" map="_C"/>
  <field class="com.itextpdf.text.pdf.PdfDocument$Indentation" name="imageIndentRight" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfDocument$Indentation" name="indentBottom" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfDocument$Indentation" name="imageIndentLeft" map="C"/>
  <field class="com.itextpdf.text.pdf.PdfDocument$Indentation" name="listIndentLeft" map="D"/>
  <field class="com.itextpdf.text.pdf.PdfDocument$Indentation" name="sectionIndentLeft" map="E"/>
  <field class="com.itextpdf.text.pdf.PdfDocument$Indentation" name="indentRight" map="F"/>
  <field class="com.itextpdf.text.pdf.PdfDocument$Indentation" name="indentTop" map="G"/>
  <field class="com.itextpdf.text.pdf.PdfDocument$Indentation" name="sectionIndentRight" map="H"/>
  <field class="com.itextpdf.text.pdf.PdfDocument$Indentation" name="indentLeft" map="I"/>
  <class name="com.itextpdf.text.pdf.PdfDocument$PdfInfo" map="_D"/>
  <method class="com.itextpdf.text.pdf.PdfDocument$PdfInfo" name="void addkey(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDocument$PdfInfo" name="void addProducer()" map="&#x015a;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument$PdfInfo" name="void addKeywords(java.lang.String)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfDocument$PdfInfo" name="void addCreationDate()" map="&#x015b;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument$PdfInfo" name="void addSubject(java.lang.String)" map="E"/>
  <method class="com.itextpdf.text.pdf.PdfDocument$PdfInfo" name="void addCreator(java.lang.String)" map="F"/>
  <method class="com.itextpdf.text.pdf.PdfDocument$PdfInfo" name="void addAuthor(java.lang.String)" map="G"/>
  <method class="com.itextpdf.text.pdf.PdfDocument$PdfInfo" name="void addTitle(java.lang.String)" map="H"/>
  <class name="com.itextpdf.text.pdf.PdfDocument" map="uA"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="imageWait" map="&#x0009af;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="alignment" map="&#x0009b0;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="documentLevelJS" map="&#x0009b2;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="openMCDocument" map="&#x0009b6;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="nextMarginTop" map="&#x0009b7;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="elementsParents" map="&#x0009b8;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="strictImageSequence" map="&#x0009b9;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="lastElementType" map="&#x0009dc;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="textEmptySize" map="&#x0009dd;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="line" map="&#x0009df;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="externalCache" map="&#x0009e0;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="rootOutline" map="&#x0009e1;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="openActionName" map="&#x0009f0;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="pageResources" map="&#x0009f1;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="viewerPreferences" map="&#x0009f2;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="structElements" map="&#x0009f3;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="currentHeight" map="&#x000a05;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="markPoints" map="&#x000a06;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="SIXTEEN_DIGITS" map="&#x000a07;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="currentOutline" map="&#x000a08;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="language" map="&#x000a09;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="pageEmpty" map="&#x000a0a;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="isToUseExternalCache" map="&#x000a0f;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="body" map="&#x000a10;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="openActionAction" map="&#x000a13;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="firstPageEvent" map="&#x000a14;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="annotationsImp" map="&#x000a15;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="text" map="&#x000a16;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="nextMarginRight" map="&#x000a17;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="isSectionTitle" map="&#x000a18;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="lines" map="&#x000a19;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="thisBoxSize" map="&#x000a1a;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="pageLabels" map="&#x000a1b;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="anchorAction" map="&#x000a1c;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="collection" map="&#x000a1d;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="nextMarginBottom" map="&#x000a1e;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="structParentIndices" map="&#x000a1f;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="floatingElements" map="&#x000a20;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="writer" map="&#x000a21;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="boxSize" map="&#x000a22;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="nextPageSize" map="&#x000a23;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="leading" map="&#x000a24;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="graphics" map="&#x000a25;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="localDestinations" map="&#x000a26;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="documentFileAttachment" map="&#x000a27;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="indentation" map="&#x000a28;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="imageEnd" map="&#x000a2a;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="externallyStoredStructElements" map="&#x000a2b;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="info" map="&#x000a2c;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="nextMarginLeft" map="&#x000a2d;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="additionalActions" map="&#x000a2e;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="pageAA" map="&#x000a2f;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="leadingStack" map="&#x000a30;"/>
  <field class="com.itextpdf.text.pdf.PdfDocument" name="tabSettings" map="&#x000a32;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="com.itextpdf.text.pdf.PdfStructureElement getStructElement(com.itextpdf.text.AccessibleElementId)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void newLine()" map="&#x01d4;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="com.itextpdf.text.pdf.PdfAction getLocalGotoAction(java.lang.String)" map="P"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void remoteGoto(java.lang.String, int, float, float, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void setNewPageSizeAndMargins()" map="&#x01d5;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void addSpacing(float, float, com.itextpdf.text.Font)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void ensureNewLine()" map="&#x01d6;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void initPage()" map="&#x01d7;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="java.util.Set getStructElements()" map="&#x01d8;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="boolean setPageSize(com.itextpdf.text.Rectangle)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="float writeLineToContent(com.itextpdf.text.pdf.PdfLine, com.itextpdf.text.pdf.PdfContentByte, com.itextpdf.text.pdf.PdfContentByte, java.lang.Object[], float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="float indentRight()" map="&#x01d9;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void pushLeading()" map="&#x01da;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void addSpacing(float, float, com.itextpdf.text.Font, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="boolean setMargins(float, float, float, float)" map="E"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="int getStructParentIndex(java.lang.Object)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="boolean isTagged(com.itextpdf.text.pdf.PdfWriter)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void addPTable(com.itextpdf.text.pdf.PdfPTable)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void popLeading()" map="&#x01db;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="com.itextpdf.text.pdf.PageResources getPageResources()" map="&#x01dc;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="boolean add(com.itextpdf.text.Element)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void traverseOutlineCount(com.itextpdf.text.pdf.PdfOutline)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void close()" map="&#x01a6;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="float calculateLineHeight()" map="&#x01dd;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void addDiv(com.itextpdf.text.pdf.PdfDiv)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="com.itextpdf.text.pdf.PdfDocument$PdfInfo getInfo()" map="&#x01de;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="java.util.HashMap getDocumentLevelJS()" map="&#x01df;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void saveStructElement(com.itextpdf.text.AccessibleElementId, com.itextpdf.text.pdf.PdfStructureElement)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void remoteGoto(java.lang.String, java.lang.String, float, float, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="float indentTop()" map="&#x01e0;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void carriageReturn()" map="&#x01e1;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="boolean isPageEmpty()" map="&#x01e2;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="java.util.ArrayList endPage()" map="&#x01e3;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void add(com.itextpdf.text.Image)" map="F"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="int[] getStructParentIndexAndNextMarkPoint(java.lang.Object)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="com.itextpdf.text.pdf.PdfStructureElement getStructElement(com.itextpdf.text.AccessibleElementId, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="com.itextpdf.text.pdf.PdfDocument$PdfCatalog getCatalog(com.itextpdf.text.pdf.PdfIndirectReference)" map="H"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void localGoto(java.lang.String, float, float, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void addAnnotation(com.itextpdf.text.pdf.PdfAnnotation)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="float indentBottom()" map="&#x01e4;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void open()" map="&#x01a7;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="boolean localDestination(java.lang.String, com.itextpdf.text.pdf.PdfDestination)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="float indentLeft()" map="&#x01e5;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void addWriter(com.itextpdf.text.pdf.PdfWriter)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void writeOutlines()" map="&#x01e6;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="boolean newPage()" map="&#x01a8;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="float flushLines()" map="&#x01e7;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void calculateOutlineCount()" map="&#x01e8;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void setLanguage(java.lang.String)" map="Q"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="boolean fitsPage(com.itextpdf.text.pdf.PdfPTable, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void flushFloatingElements()" map="&#x01e9;"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void outlineTree(com.itextpdf.text.pdf.PdfOutline)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfDocument" name="void flushStructureElementsOnNewPage()" map="&#x01ea;"/>
  <class name="com.itextpdf.text.pdf.PdfMediaClipData" map="vA"/>
  <class name="com.itextpdf.text.pdf.PdfRectangle" map="wA"/>
  <field class="com.itextpdf.text.pdf.PdfRectangle" name="ury" map="&#x00d9;"/>
  <field class="com.itextpdf.text.pdf.PdfRectangle" name="urx" map="&#x00da;"/>
  <field class="com.itextpdf.text.pdf.PdfRectangle" name="lly" map="&#x00db;"/>
  <field class="com.itextpdf.text.pdf.PdfRectangle" name="llx" map="&#x00dc;"/>
  <method class="com.itextpdf.text.pdf.PdfRectangle" name="float top()" map="&#x012f;"/>
  <method class="com.itextpdf.text.pdf.PdfRectangle" name="boolean add(com.itextpdf.text.pdf.PdfObject)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfRectangle" name="float right()" map="&#x0130;"/>
  <method class="com.itextpdf.text.pdf.PdfRectangle" name="boolean add(float[])" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfRectangle" name="com.itextpdf.text.pdf.PdfRectangle transform(com.itextpdf.awt.geom.AffineTransform)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfRectangle" name="float bottom()" map="&#x0131;"/>
  <method class="com.itextpdf.text.pdf.PdfRectangle" name="float width()" map="&#x0132;"/>
  <method class="com.itextpdf.text.pdf.PdfRectangle" name="float height()" map="&#x0133;"/>
  <method class="com.itextpdf.text.pdf.PdfRectangle" name="float left()" map="&#x0134;"/>
  <method class="com.itextpdf.text.pdf.PdfRectangle" name="boolean add(int[])" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfNumber" map="xA"/>
  <field class="com.itextpdf.text.pdf.PdfNumber" name="value" map="&#x00eb;"/>
  <method class="com.itextpdf.text.pdf.PdfNumber" name="double doubleValue()" map="&#x013b;"/>
  <method class="com.itextpdf.text.pdf.PdfNumber" name="float floatValue()" map="&#x013c;"/>
  <method class="com.itextpdf.text.pdf.PdfNumber" name="int intValue()" map="&#x013d;"/>
  <class name="com.itextpdf.text.pdf.PdfContents" map="yA"/>
  <field class="com.itextpdf.text.pdf.PdfContents" name="SAVESTATE" map="&#x0631;"/>
  <field class="com.itextpdf.text.pdf.PdfContents" name="ROTATEFINAL" map="&#x0632;"/>
  <field class="com.itextpdf.text.pdf.PdfContents" name="ROTATE270" map="&#x0633;"/>
  <field class="com.itextpdf.text.pdf.PdfContents" name="RESTORESTATE" map="&#x0634;"/>
  <field class="com.itextpdf.text.pdf.PdfContents" name="ROTATE90" map="&#x0635;"/>
  <field class="com.itextpdf.text.pdf.PdfContents" name="ROTATE180" map="&#x0636;"/>
  <class name="com.itextpdf.text.pdf.PdfPCell" map="zA"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="paddingRight" map="&#x000a73;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="headers" map="&#x000a74;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="colspan" map="&#x000a85;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="column" map="&#x000a86;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="verticalAlignment" map="&#x000a87;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="minimumHeight" map="&#x000a88;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="useBorderPadding" map="&#x000a89;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="paddingBottom" map="&#x000a8a;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="accessibleAttributes" map="&#x000a8b;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="cachedMaxHeight" map="&#x000a8d;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="phrase" map="&#x000a8f;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="image" map="&#x000a90;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="id" map="&#x000a91;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="noWrap" map="&#x000a93;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="useDescender" map="&#x000a94;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="rotation" map="&#x000a95;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="fixedHeight" map="&#x000a96;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="cellEvent" map="&#x000a97;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="table" map="&#x000a98;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="paddingTop" map="&#x000a99;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="paddingLeft" map="&#x000a9a;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="calculatedHeight" map="&#x000a9b;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="rowspan" map="&#x000a9c;"/>
  <field class="com.itextpdf.text.pdf.PdfPCell" name="role" map="&#x000a9d;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="float getMinimumHeight()" map="&#x01f4;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="void setColumn(com.itextpdf.text.pdf.ColumnText)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="boolean hasCachedMaxHeight()" map="&#x01f5;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="float getMaxHeight()" map="&#x01fa;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="boolean isNoWrap()" map="&#x01fb;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="void setCalculatedHeight(float)" map="o"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="int getRunDirection()" map="&#x01fc;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="boolean isUseBorderPadding()" map="&#x01fd;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="void setMinimumHeight(float)" map="p"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="com.itextpdf.text.Image getImage()" map="&#x01fe;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="com.itextpdf.text.pdf.ColumnText getColumn()" map="&#x01ff;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="void setColspan(int)" map="c"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="void setFixedHeight(float)" map="q"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="void addElement(com.itextpdf.text.Element)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="float getEffectivePaddingLeft()" map="&#x0200;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="int getHorizontalAlignment()" map="&#x0201;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="float getEffectivePaddingRight()" map="&#x0202;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="void setPadding(float)" map="r"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="void setRotation(int)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="void setRowspan(int)" map="d"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="boolean hasCalculatedHeight()" map="&#x0203;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="com.itextpdf.text.pdf.PdfPCellEvent getCellEvent()" map="&#x0204;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="boolean isUseDescender()" map="&#x0205;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="int getRotation()" map="V"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="float getEffectivePaddingBottom()" map="&#x0206;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="float getFixedHeight()" map="&#x0207;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="float getEffectivePaddingTop()" map="&#x0208;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="int getVerticalAlignment()" map="&#x0209;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="int getRowspan()" map="&#x020a;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="boolean hasMinimumHeight()" map="&#x020b;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="int getColspan()" map="&#x020c;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="float getCalculatedHeight()" map="&#x020d;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="float getCachedMaxHeight()" map="&#x020e;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="java.util.ArrayList getHeaders()" map="&#x020f;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="boolean hasFixedHeight()" map="&#x0210;"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="void setPhrase(com.itextpdf.text.Phrase)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPCell" name="void setRunDirection(int)" map="e"/>
  <class name="com.itextpdf.text.pdf.PdfPTableHeader" map="$B"/>
  <field class="com.itextpdf.text.pdf.PdfPTableHeader" name="role" map="&#x06ae;"/>
  <method class="com.itextpdf.text.pdf.PdfPTableHeader" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTableHeader" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <class name="com.itextpdf.text.pdf.PdfLayer" map="AB"/>
  <method class="com.itextpdf.text.pdf.PdfLayer" name="boolean isOn()" map="&#x0151;"/>
  <method class="com.itextpdf.text.pdf.PdfLayer" name="java.util.ArrayList getChildren()" map="&#x0152;"/>
  <method class="com.itextpdf.text.pdf.PdfLayer" name="com.itextpdf.text.pdf.PdfObject getPdfObject()" map="&#x014f;"/>
  <method class="com.itextpdf.text.pdf.PdfLayer" name="boolean isOnPanel()" map="&#x0153;"/>
  <method class="com.itextpdf.text.pdf.PdfLayer" name="java.lang.String getTitle()" map="&#x0154;"/>
  <method class="com.itextpdf.text.pdf.PdfLayer" name="com.itextpdf.text.pdf.PdfIndirectReference getRef()" map="&#x0150;"/>
  <method class="com.itextpdf.text.pdf.PdfLayer" name="com.itextpdf.text.pdf.PdfLayer getParent()" map="&#x0155;"/>
  <class name="com.itextpdf.text.pdf.ICC_Profile" map="BB"/>
  <field class="com.itextpdf.text.pdf.ICC_Profile" name="cstags" map="A"/>
  <method class="com.itextpdf.text.pdf.ICC_Profile" name="byte[] getData()" map="A"/>
  <method class="com.itextpdf.text.pdf.ICC_Profile" name="int getNumComponents()" map="B"/>
  <class name="com.itextpdf.text.pdf.PdfName" map="CB"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FITR" map="&#x00ec;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COURIER_BOLD" map="&#x00ed;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PRINTAREA" map="&#x00ee;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MAX_CAMEL_CASE" map="&#x00ef;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ICCBASED" map="&#x00f0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ENDOFLINE" map="&#x00f1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FITH" map="&#x00f2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WIN" map="&#x00f3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ROW" map="&#x00f4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OSCILLATING" map="&#x00f5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FITB" map="&#x00f6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PTDATA" map="&#x00f8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PATTERNTYPE" map="&#x00f9;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RICHMEDIAPARAMS" map="&#x00fa;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="IMPORTDATA" map="&#x00fb;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TRAPNET" map="&#x00fc;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BYTERANGE" map="&#x00fd;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DCS" map="&#x00fe;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WIDTHS" map="&#x00ff;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="START" map="&#x0100;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DEVICECMYK" map="&#x0101;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LISTNUMBERING" map="&#x0102;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BOX" map="&#x0103;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RICHMEDIAEXECUTE" map="&#x0104;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WIDTH" map="&#x0105;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ACTION" map="&#x0106;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="POSITION" map="&#x0107;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LIMITS" map="&#x0108;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LBL" map="&#x0109;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FREETEXT" map="&#x010a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WIN_ANSI_ENCODING" map="&#x010b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TEXTDECORATIONTYPE" map="&#x010c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ASCIIHEXDECODE" map="&#x010d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="staticNames" map="&#x010e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SATURATION" map="&#x010f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="GLITTER" map="&#x0110;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="GTS_PDFA1" map="&#x0111;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DEFAULTCRYPTFILTER" map="&#x0112;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FITWINDOW" map="&#x0113;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="XYZ" map="&#x0114;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COLUMNS" map="&#x0115;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EXCLUDE" map="&#x0116;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VOFFSET" map="&#x0117;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SUBJECT" map="&#x0118;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SEPARATION" map="&#x0119;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EPSG" map="&#x011a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HIDETOOLBAR" map="&#x011b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HELVETICA" map="&#x011c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NEXTPAGE" map="&#x011d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TILINGTYPE" map="&#x011e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RUNLENGTHDECODE" map="&#x011f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LAB" map="&#x0120;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SIMPLEX" map="&#x0121;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HELVETICA_BOLDOBLIQUE" map="&#x0122;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BLACKPOINT" map="&#x0123;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FIELDS" map="&#x0124;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DEFAULT" map="&#x0125;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FONTFILE3" map="&#x0126;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FONTFILE2" map="&#x0127;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="URL" map="&#x0128;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="URI" map="&#x0129;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="GAMMA" map="&#x012a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OFF" map="&#x012b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MMTYPE1" map="&#x012c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BOUNDS" map="&#x012d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="AUTHOR" map="&#x012e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="UR3" map="&#x012f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RICHMEDIACONTENT" map="&#x0130;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VIEWCLIP" map="&#x0131;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ENDINDENT" map="&#x0132;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MARKINFO" map="&#x0133;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TITLE" map="&#x0134;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FONTNAME" map="&#x0135;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PAINTTYPE" map="&#x0136;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="GEO" map="&#x0137;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="QUOTE" map="&#x0138;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PAGEMODE" map="&#x0139;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RICHMEDIACOMMAND" map="&#x013a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OCSP" map="&#x013b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PARENT" map="&#x013c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BBOX" map="&#x013d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NONE" map="&#x013e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PRESSTEPS" map="&#x013f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COORDS" map="&#x0140;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="THEAD" map="&#x0141;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="JBIG2GLOBALS" map="&#x0142;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PRINTPAGERANGE" map="&#x0143;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TRANSFORMMETHOD" map="&#x0144;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="STAMP" map="&#x0145;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="STRUCTTREEROOT" map="&#x0146;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TRANSPARENT" map="&#x0147;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="STYLE" map="&#x0148;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TIMES_ROMAN" map="&#x0149;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SIGFLAGS" map="&#x014a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CRYPT" map="&#x014b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LAUNCH" map="&#x014c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MCID" map="&#x014d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="A85" map="&#x014e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CATEGORY" map="&#x014f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OCG" map="&#x0150;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="GCS" map="&#x0151;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RICHMEDIASETTINGS" map="&#x0152;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LOCK" map="&#x0153;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="QUADPOINTS" map="&#x0154;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RELATIVECOLORIMETRIC" map="&#x0155;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="REDACT" map="&#x0156;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CAPTION" map="&#x0157;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WIPE" map="&#x0158;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NEXT" map="&#x0159;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OBJ" map="&#x015a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CIDFONTTYPE2" map="&#x015b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CIDFONTTYPE0" map="&#x015c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CONTENTS" map="&#x015d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="GBK" map="&#x015e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LPTS" map="&#x015f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TRANSPARENCY" map="&#x0160;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SETOCGSTATE" map="&#x0161;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="REGISTRYNAME" map="&#x0162;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HTP" map="&#x0163;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="STARTINDENT" map="&#x0164;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="XD" map="&#x0165;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MASK" map="&#x0166;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MODDATE" map="&#x0167;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="XA" map="&#x0168;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COURIER" map="&#x0169;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TWOPAGELEFT" map="&#x016a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CONTENT" map="&#x016b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="END" map="&#x016c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="USETHUMBS" map="&#x016d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BLOCKQUOTE" map="&#x016e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ZADB" map="&#x016f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TRANSFORMPARAMS" map="&#x0170;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WT" map="&#x0171;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WS" map="&#x0172;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FILTER" map="&#x0173;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WP" map="&#x0174;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PRESENTATION" map="&#x0175;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FOREGROUND" map="&#x0176;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ZOOM" map="&#x0177;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FIRST" map="&#x0178;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LOWERROMAN" map="&#x0179;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SCHEMA" map="&#x017a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RICHMEDIAWINDOW" map="&#x017b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WC" map="&#x017c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CYX" map="&#x017d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SUBTYPE" map="&#x017e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COLLECTIONSUBITEM" map="&#x017f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PAGE" map="&#x0180;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MAXLEN" map="&#x0181;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FUNCTION" map="&#x0182;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="STRUCTPARENTS" map="&#x0183;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PAGES" map="&#x0184;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ASCENT" map="&#x0185;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="GPTS" map="&#x0186;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="W2" map="&#x0187;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VP" map="&#x0188;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COLORANTS" map="&#x0189;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CAPHEIGHT" map="&#x018a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OPENACTION" map="&#x018b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PUBSEC" map="&#x018c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COLLECTION" map="&#x018d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PLAYCOUNT" map="&#x018e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VE" map="&#x018f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BITSPERCOMPONENT" map="&#x0190;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="XREFSTM" map="&#x0191;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WINDOWED" map="&#x0192;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WIDGET" map="&#x0193;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PROCSET" map="&#x0194;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="UR" map="&#x0195;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COLORSPACE" map="&#x0196;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="V2" map="&#x0197;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="POLYGON" map="&#x0198;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VERSION" map="&#x0199;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HIDEWINDOWUI" map="&#x019a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HEIGHT" map="&#x019b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DOCMDP" map="&#x019c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TYPE3" map="&#x019d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TYPE1" map="&#x019e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TBODY" map="&#x019f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OCMD" map="&#x01a0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="UF" map="&#x01a1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TYPE0" map="&#x01a2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="UE" map="&#x01a3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MAC_ROMAN_ENCODING" map="&#x01a4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SCOPE" map="&#x01a5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TX" map="&#x01a6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="GOTO3DVIEW" map="&#x01a7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SUBMITFORM" map="&#x01a8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TV" map="&#x01a9;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TU" map="&#x01aa;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NEWWINDOW" map="&#x01ab;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TS" map="&#x01ac;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TR" map="&#x01ad;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VIEWAREA" map="&#x01ae;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ITALICANGLE" map="&#x01af;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TP" map="&#x01b0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TM" map="&#x01b1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OPEN" map="&#x01b2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TK" map="&#x01b3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COLSPAN" map="&#x01b4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TI" map="&#x01b5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TH" map="&#x01b6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TD" map="&#x01b7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TA" map="&#x01b8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PICKTRAYBYPDFSIZE" map="&#x01b9;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TIMES_BOLDITALIC" map="&#x01ba;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SW" map="&#x01bb;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SINGLEPAGE" map="&#x01bc;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SV" map="&#x01bd;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ST" map="&#x01be;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SS" map="&#x01bf;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SCREEN" map="&#x01c0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DEFAULTGRAY" map="&#x01c1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HOFFSET" map="&#x01c2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="INDEX" map="&#x01c3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="XPTS" map="&#x01c4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HIGHLIGHT" map="&#x01c5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TRANS" map="&#x01c6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="KIDS" map="&#x01c7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RBGROUPS" map="&#x01c8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MARKED" map="&#x01c9;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EMBEDDEDFILE" map="&#x01ca;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FULLSCREEN" map="&#x01cb;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="UHC" map="&#x01cc;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FITBV" map="&#x01cd;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RV" map="&#x01ce;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FORM" map="&#x01cf;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DISPLAYDOCTITLE" map="&#x01d0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CROPBOX" map="&#x01d1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COLUMN" map="&#x01d2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CALRGB" map="&#x01d3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RT" map="&#x01d4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ROWS" map="&#x01d5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SHADING" map="&#x01d6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RP" map="&#x01d7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RO" map="&#x01d8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RL" map="&#x01d9;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FITBH" map="&#x01da;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RI" map="&#x01db;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LZWDECODE" map="&#x01dc;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OCSPS" map="&#x01dd;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RD" map="&#x01de;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RC" map="&#x01df;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="INCLUDE" map="&#x01e0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RB" map="&#x01e1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ACTUALTEXT" map="&#x01e2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="XML" map="&#x01e3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PDFDOCENCODING" map="&#x01e4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SQUARE" map="&#x01e5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PRIVATE" map="&#x01e6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FILEATTACHMENT" map="&#x01e7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TRUETYPE" map="&#x01e8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FUNCTIONS" map="&#x01e9;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FIRSTPAGE" map="&#x01ea;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NEEDAPPEARANCES" map="&#x01eb;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EFOPEN" map="&#x01ec;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LENGTH1" map="&#x01ed;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CHECKSUM" map="&#x01ee;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FONTBBOX" map="&#x01ef;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LOCKED" map="&#x01f0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ROLEMAP" map="&#x01f1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PV" map="&#x01f2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LOWERALPHA" map="&#x01f3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PAGEELEMENT" map="&#x01f4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PS" map="&#x01f5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MIN_LOWER_CASE" map="&#x01fa;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PO" map="&#x01fb;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="INTENT" map="&#x01fc;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="XREF" map="&#x01fd;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PI" map="&#x01fe;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PG" map="&#x01ff;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DEST" map="&#x0200;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PC" map="&#x0201;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PB" map="&#x0202;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FIRSTCHAR" map="&#x0203;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EFF" map="&#x0204;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OCGS" map="&#x0205;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CRL" map="&#x0206;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FIGURE" map="&#x0207;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DESC" map="&#x0208;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CREATORINFO" map="&#x0209;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OR" map="&#x020a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HALIGN" map="&#x020b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PAGELABELS" map="&#x020c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OP" map="&#x020d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PRINTFIELD" map="&#x020e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ON" map="&#x020f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CCITTFAXDECODE" map="&#x0210;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="L2R" map="&#x0211;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="XOBJECT" map="&#x0212;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OE" map="&#x0213;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OC" map="&#x0214;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CUEPOINTS" map="&#x0215;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="INKLIST" map="&#x0216;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TYPE" map="&#x0217;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FONT" map="&#x0250;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="UTF_8" map="&#x0251;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NUMS" map="&#x0252;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NM" map="&#x0253;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="AESV3" map="&#x0254;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="AESV2" map="&#x0255;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LBODY" map="&#x0256;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NAVIGATION" map="&#x0257;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FONTFILE" map="&#x0258;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="USAGE" map="&#x0259;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BACKGROUNDCOLOR" map="&#x025a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ESIC" map="&#x025b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SCRIPTS" map="&#x025c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SETTINGS" map="&#x025d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RICHMEDIACONFIGURATION" map="&#x025e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TFOOT" map="&#x025f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MCR" map="&#x0260;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PANOSE" map="&#x0261;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="N4" map="&#x0262;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="N3" map="&#x0263;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="N2" map="&#x0264;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="N1" map="&#x0265;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="N0" map="&#x0266;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="JBIG2DECODE" map="&#x0267;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MK" map="&#x0268;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HID" map="&#x0269;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ADBE_PKCS7_DETACHED" map="&#x026a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WATERMARK" map="&#x026b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="USENONE" map="&#x026c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COLLECTIONFIELD" map="&#x026d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TRIMBOX" map="&#x026e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DECODE" map="&#x026f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="Off" map="&#x0270;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BASEENCODING" map="&#x0271;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FORMTYPE" map="&#x0272;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ADBE_PKCS7_S5" map="&#x0273;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LI" map="&#x0274;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ADBE_PKCS7_S4" map="&#x0275;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RESETFORM" map="&#x0276;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EXTEND" map="&#x0277;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SPEED" map="&#x0278;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CIDSYSTEMINFO" map="&#x0279;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RICHMEDIAINSTANCE" map="&#x027a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DUPLEXFLIPSHORTEDGE" map="&#x027b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="REGISTRY" map="&#x027c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="POLYLINE" map="&#x027d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MAC" map="&#x027e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BLACKIS1" map="&#x027f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TIME" map="&#x0280;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DOCOPEN" map="&#x0281;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ETSI_RFC3161" map="&#x0282;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="REQUIREMENTS" map="&#x0283;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ROOT" map="&#x0284;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ARTIFACT" map="&#x0285;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="_3D" map="&#x0286;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PRESERVERB" map="&#x0287;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="XFA" map="&#x0288;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="JS" map="&#x0289;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ENCRYPTMETADATA" map="&#x028a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CMD" map="&#x028b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VRI" map="&#x028c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VERTICES" map="&#x028d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="STDCF" map="&#x028e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LENGTH" map="&#x028f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CATALOG" map="&#x0290;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TABLEROW" map="&#x0291;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HALFTONENAME" map="&#x0292;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DESTS" map="&#x0293;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="IX" map="&#x0294;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RICHMEDIA" map="&#x0295;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="hash" map="&#x0296;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="INTERPOLATE" map="&#x0297;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FRM" map="&#x0298;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="STRUCTELEM" map="&#x0299;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LISTMODE" map="&#x029a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="IM" map="&#x029b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DESCENDANTFONTS" map="&#x029c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COURIER_BOLDOBLIQUE" map="&#x029d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="IF" map="&#x029e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OCPROPERTIES" map="&#x029f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ID" map="&#x02a0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="IC" map="&#x02a1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PDU" map="&#x02a2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WHITEPOINT" map="&#x02a3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ENCODEDBYTEALIGN" map="&#x02a4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HT" map="&#x02a5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FLATEDECODE" map="&#x02a6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EARLYCHANGE" map="&#x02a7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PDF" map="&#x02a8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CIDTOGIDMAP" map="&#x02b0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HF" map="&#x02b1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BIGFIVE" map="&#x02b2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LAYOUT" map="&#x02b3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="USEOUTLINES" map="&#x02b4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PROJCS" map="&#x02b5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TOUNICODE" map="&#x02b6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RANGE" map="&#x02b7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SPACEBEFORE" map="&#x02b8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="H6" map="&#x02bb;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="H5" map="&#x02bc;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="H4" map="&#x02bd;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="H3" map="&#x02be;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="H2" map="&#x02bf;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="H1" map="&#x02c0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FIELDMDP" map="&#x02c1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COLOR" map="&#x02d0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TEXTDECORATIONTHICKNESS" map="&#x02d1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SIG" map="&#x02e0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HIDE" map="&#x02e1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NOT" map="&#x02e2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LINEAR" map="&#x02e3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ROLE" map="&#x02e4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="IDENTITY" map="&#x037a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ADBE_X509_RSA_SHA1" map="&#x0386;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SPACEAFTER" map="&#x0388;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TEXTALIGN" map="&#x0389;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DISSOLVE" map="&#x038a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="JAVASCRIPT" map="&#x038c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PERMS" map="&#x038e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="STRUCTPARENT" map="&#x038f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PAGELAYOUT" map="&#x0390;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CONFIGS" map="&#x0391;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RESOURCES" map="&#x0392;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NEEDRENDERING" map="&#x0393;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FT" map="&#x0394;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FS" map="&#x0395;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="IMAGE" map="&#x0396;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FO" map="&#x0397;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CENTERWINDOW" map="&#x0398;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FL" map="&#x0399;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="JUSTIFY" map="&#x039a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PREVPAGE" map="&#x039b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OUTPUTINTENTS" map="&#x039c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FG" map="&#x039d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FF" map="&#x039e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="POPUP" map="&#x039f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ADBE" map="&#x03a0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FD" map="&#x03a1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FB" map="&#x03a3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SECT" map="&#x03a4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SUBFILTER" map="&#x03a5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ZAPFDINGBATS" map="&#x03a6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ANNOTS" map="&#x03a7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FONTDESCRIPTOR" map="&#x03a8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BORDER" map="&#x03a9;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CLASSMAP" map="&#x03aa;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="GTS_PDFX" map="&#x03ab;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EF" map="&#x03ac;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WARICHU" map="&#x03ad;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DEFAULTCMYK" map="&#x03ae;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ASSETS" map="&#x03af;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CREATOR" map="&#x03b0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VISIBLEPAGES" map="&#x03b1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CHARPROCS" map="&#x03b2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="KEYWORDS" map="&#x03b3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="STATUS" map="&#x03b4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DOMAIN" map="&#x03b5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ENDOFBLOCK" map="&#x03b6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DW" map="&#x03b7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RICHMEDIAPRESENTATION" map="&#x03b8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DV" map="&#x03b9;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LIST" map="&#x03ba;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DS" map="&#x03bb;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="UNDERLINE" map="&#x03bc;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DR" map="&#x03bd;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DP" map="&#x03be;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DM" map="&#x03bf;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DL" map="&#x03c0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TEXTDECORATIONCOLOR" map="&#x03c1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DI" map="&#x03c2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BINDINGMATERIALNAME" map="&#x03c3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ALTERNATE" map="&#x03c4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NONFULLSCREENPAGEMODE" map="&#x03c5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ORDERING" map="&#x03c6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LAST" map="&#x03c7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DC" map="&#x03c8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DA" map="&#x03c9;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OUTPUTCONDITIONIDENTIFIER" map="&#x03ca;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SIZE" map="&#x03cb;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="IRT" map="&#x03cc;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PREV" map="&#x03cd;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="XSTEP" map="&#x03ce;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CFM" map="&#x03d0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ADOBE_PPKLITE" map="&#x03d1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DEFAULTRGB" map="&#x03d2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="APPDEFAULT" map="&#x03d3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CS" map="&#x03d4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CO" map="&#x03d5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ART" map="&#x03d6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ABSOLUTECOLORIMETRIC" map="&#x03da;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CI" map="&#x03dc;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CH" map="&#x03de;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CF" map="&#x03e0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FONTWEIGHT" map="&#x03e2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BACKGROUND" map="&#x03e3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PARENTTREENEXTKEY" map="&#x03e4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CB" map="&#x03e5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="R2L" map="&#x03e6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CA" map="&#x03e7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MAC_EXPERT_ENCODING" map="&#x03e8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COLLECTIONSORT" map="&#x03e9;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COLLECTIONSCHEMA" map="&#x03ea;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OUTLINES" map="&#x03eb;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BS" map="&#x03ec;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TIMES_BOLD" map="&#x03ed;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COURIER_OBLIQUE" map="&#x03ee;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FLASHVARS" map="&#x03ef;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="C1" map="&#x03f0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="INDEXED" map="&#x03f1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="C0" map="&#x03f2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DEACTIVATION" map="&#x03f3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BM" map="&#x0401;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BL" map="&#x0402;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="STEMV" map="&#x0403;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BG" map="&#x0404;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EXPORTSTATE" map="&#x0405;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BC" map="&#x0406;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DECODEPARMS" map="&#x0407;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FLASH" map="&#x0408;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DCTDECODE" map="&#x0409;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NEAR" map="&#x040a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PERCEPTUAL" map="&#x040b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VIEWSTATE" map="&#x040c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SOUND" map="&#x040e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="AS" map="&#x040f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="rb" map="&#x0410;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TABLE" map="&#x0411;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LOCATION" map="&#x0412;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="AP" map="&#x0413;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PARAMS" map="&#x0414;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MEASURE" map="&#x0415;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="APP" map="&#x0416;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RECIPIENTS" map="&#x0417;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="AF" map="&#x0418;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="AC" map="&#x0419;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="AUTHEVENT" map="&#x041a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="AA" map="&#x041b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FIT" map="&#x041c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="UPPERROMAN" map="&#x041d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OUTPUTINTENT" map="&#x041e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EMBEDDEDFILES" map="&#x041f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="USEATTACHMENTS" map="&#x0420;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CUEPOINT" map="&#x0421;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DUR" map="&#x0422;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PIECEINFO" map="&#x0423;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="IMAGEI" map="&#x0424;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TABS" map="&#x0425;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MIN_CAMEL_CASE" map="&#x0426;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TTL" map="&#x0427;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="IMAGEC" map="&#x0428;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="IMAGEB" map="&#x0429;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CALGRAY" map="&#x042a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SHADINGTYPE" map="&#x042b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CARET" map="&#x042c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EMBEDDED" map="&#x042d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MAX_LOWER_CASE" map="&#x042e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ROWSPAN" map="&#x042f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="INK" map="&#x0430;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ANTIALIAS" map="&#x0431;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PROPERTIES" map="&#x0432;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ADBE_PKCS7_SHA1" map="&#x0433;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="IND" map="&#x0434;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RENDITION" map="&#x0435;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LINK" map="&#x0436;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DUPLEX" map="&#x0437;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TEXTINDENT" map="&#x0438;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CENTER" map="&#x0439;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LINE" map="&#x043a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="op" map="&#x043b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PASSCONTEXTCLICK" map="&#x043c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PRINTERMARK" map="&#x043d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="AND" map="&#x043e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ISMAP" map="&#x043f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TWOPAGERIGHT" map="&#x0440;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LANG" map="&#x0441;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MATERIAL" map="&#x0442;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DSS" map="&#x0443;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BITSPERSAMPLE" map="&#x0444;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="USERUNIT" map="&#x0445;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="STRIKEOUT" map="&#x0446;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EXPORT" map="&#x0447;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SPAN" map="&#x0448;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TWOCOLUMNLEFT" map="&#x0449;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TEXT" map="&#x044a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PRODUCER" map="&#x044b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="USEOC" map="&#x044c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ALT" map="&#x044d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ENCODE" map="&#x044e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CONFIGURATION" map="&#x044f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FONTFAMILY" map="&#x0451;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DESTOUTPUTPROFILE" map="&#x0452;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ALL" map="&#x0453;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VALIGN" map="&#x0454;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TR2" map="&#x0455;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BASEFONT" map="&#x0456;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="GROUP" map="&#x0457;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MEDIABOX" map="&#x0458;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DOCTIMESTAMP" map="&#x0459;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="METADATA" map="&#x045a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ALTERNATEPRESENTATION" map="&#x045b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DOCUMENT" map="&#x045c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LANGUAGE" map="&#x045e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NAMES" map="&#x045f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CERTS" map="&#x0460;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VIEWPORT" map="&#x0461;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DEVICEGRAY" map="&#x0462;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ALTERNATES" map="&#x0463;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NAMED" map="&#x0464;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="GTS_PDFXVERSION" map="&#x0465;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PARENTTREE" map="&#x0466;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CLOUD" map="&#x0467;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OVERLAYTEXT" map="&#x0468;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CRLS" map="&#x0469;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TOGGLE" map="&#x046a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="REVERSEDCHARS" map="&#x046b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FDF" map="&#x046c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OBJSTM" map="&#x046d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FILESPEC" map="&#x046e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HIDEMENUBAR" map="&#x046f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EXTENSIONLEVEL" map="&#x0470;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CERT" map="&#x0471;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CONFIGURATIONS" map="&#x0472;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VIEWERPREFERENCES" map="&#x0473;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TOC" map="&#x0474;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SIGREF" map="&#x0475;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ARTBOX" map="&#x0476;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VIEW" map="&#x0477;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TRAPPED" map="&#x0478;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="AIS" map="&#x0479;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EVENT" map="&#x047a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DOS" map="&#x047b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="UPPERALPHA" map="&#x047c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LINEHEIGHT" map="&#x047d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NONSTRUCT" map="&#x047e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PREDICTOR" map="&#x047f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="REPEAT" map="&#x0480;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="AHX" map="&#x0481;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ORDER" map="&#x0490;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BLEEDBOX" map="&#x0491;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CODE" map="&#x0492;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="GEOGCS" map="&#x0493;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DEVICERGB" map="&#x0494;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PRINTSCALING" map="&#x0495;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SMASKINDATA" map="&#x0496;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ETSI_CADES_DETACHED" map="&#x0497;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NUMBERFORMAT" map="&#x0498;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ITXT" map="&#x0499;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="IDTREE" map="&#x049a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FAR" map="&#x049b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ACTIVATION" map="&#x049c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CIDSET" map="&#x049d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FUNCTIONTYPE" map="&#x049e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OUTPUTCONDITION" map="&#x049f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WINDOW" map="&#x04a0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TIMES_ITALIC" map="&#x04a1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="IMAGEMASK" map="&#x04a2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COLLECTIONITEM" map="&#x04a3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DIRECTION" map="&#x04a4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VERISIGN_PPKVS" map="&#x04a5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DIFFERENCES" map="&#x04a6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PROP_BUILD" map="&#x04a7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DATA" map="&#x04a8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="GOTO" map="&#x04a9;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PRINT" map="&#x04aa;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ORG" map="&#x04ab;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ONECOLUMN" map="&#x04ac;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="JPXDECODE" map="&#x04ad;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="USERPROPERTIES" map="&#x04ae;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SQUIGGLY" map="&#x04af;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HELV" map="&#x04b0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HELVETICA_BOLD" map="&#x04b1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RICHMEDIAACTIVATION" map="&#x04b2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PRINTCLIP" map="&#x04b3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EXTGSTATE" map="&#x04b4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LASTPAGE" map="&#x04b5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BIBENTRY" map="&#x04b6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PRINTSTATE" map="&#x04b7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SYMBOL" map="&#x04b8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FDECODEPARMS" map="&#x04b9;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FLAGS" map="&#x04ba;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="STRF" map="&#x04bb;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="EXTENSIONS" map="&#x04bc;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ADOBE_PPKMS" map="&#x04bd;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="INSTANCES" map="&#x04be;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SMASK" map="&#x04bf;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="THUMB" map="&#x04c0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="REASON" map="&#x04c1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ROTATE" map="&#x04c2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="THREADS" map="&#x04c3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OPT" map="&#x04c4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NCHANNEL" map="&#x04c7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ACROFORM" map="&#x04c8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ENCODING" map="&#x04cb;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OPM" map="&#x04cc;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OPI" map="&#x04d0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="STANDARD" map="&#x04d1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BOTH" map="&#x04d2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PREFERRED" map="&#x04d3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TOCI" map="&#x04d4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DESCENT" map="&#x04d5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="LASTCHAR" map="&#x04d6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NAME" map="&#x04d7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DIV" map="&#x04d8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DUPLEXFLIPLONGEDGE" map="&#x04d9;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COUNT" map="&#x04da;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SHIFT_JIS" map="&#x04db;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FONTMATRIX" map="&#x04dc;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HELVETICA_OBLIQUE" map="&#x04dd;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ASCII85DECODE" map="&#x04de;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BLINDS" map="&#x04df;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="OBJR" map="&#x04e0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FORMULA" map="&#x04e1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="USER" map="&#x04e2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CONDITION" map="&#x04e3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FFILTER" map="&#x04e4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CREATIONDATE" map="&#x04e5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="INFO" map="&#x04e6;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="AFRELATIONSHIP" map="&#x04e7;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NAVIGATIONPANE" map="&#x04e8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BTN" map="&#x04e9;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HEADERS" map="&#x04ea;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="HALFTONETYPE" map="&#x04eb;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RICHMEDIAANIMATION" map="&#x04ee;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ca" map="&#x04ef;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="GOTOR" map="&#x04f0;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COLORS" map="&#x04f1;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="X" map="&#x04f2;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="W" map="&#x04f3;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="V" map="&#x04f4;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RICHMEDIAPOSITION" map="&#x04f5;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="U" map="&#x04f8;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="T" map="&#x04f9;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="S" map="&#x0531;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="R" map="&#x0532;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="GOTOE" map="&#x0533;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="Q" map="&#x0534;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="YSTEP" map="&#x0535;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="P" map="&#x0536;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="O" map="&#x0537;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="N" map="&#x0538;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DEVICEN" map="&#x0539;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="M" map="&#x053a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SPLIT" map="&#x053b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="L" map="&#x053c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="K" map="&#x053d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PATTERN" map="&#x053e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="I" map="&#x053f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RUBY" map="&#x0540;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="H" map="&#x0541;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RECT" map="&#x0542;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="F" map="&#x0543;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="E" map="&#x0544;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ANNOT" map="&#x0545;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CONTACTINFO" map="&#x0546;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="D" map="&#x0547;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="C" map="&#x0548;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="B" map="&#x0549;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="A" map="&#x054a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ATTACHED" map="&#x054b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="STMF" map="&#x054c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SIGFIELDLOCK" map="&#x054d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MOVIE" map="&#x054e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SUMMARY" map="&#x054f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="WKT" map="&#x0550;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ALLPAGES" map="&#x0551;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SUPPLEMENT" map="&#x0552;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="PART" map="&#x0553;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NUMCOPIES" map="&#x0554;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VIDEO" map="&#x0555;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="UNIX" map="&#x0556;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ANIMATION" map="&#x0559;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="DECIMAL" map="&#x0561;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ENCRYPT" map="&#x0562;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="REFERENCE" map="&#x0563;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="VIEWS" map="&#x0564;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="SORT" map="&#x0565;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BINDING" map="&#x0566;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="ASSET" map="&#x0567;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TOOLBAR" map="&#x0568;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="NOTE" map="&#x0569;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="CIRCLE" map="&#x056a;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="MATRIX" map="&#x056b;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="STATE" map="&#x056c;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="RICHMEDIADEACTIVATION" map="&#x056d;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="BASEVERSION" map="&#x056e;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="FITV" map="&#x056f;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="COLORTRANSFORM" map="&#x0570;"/>
  <field class="com.itextpdf.text.pdf.PdfName" name="TWOCOLUMNRIGHT" map="&#x0571;"/>
  <method class="com.itextpdf.text.pdf.PdfName" name="java.lang.String decodeName(java.lang.String)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfName" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="com.itextpdf.text.pdf.PdfName" name="int hashCode()" map="hashCode"/>
  <method class="com.itextpdf.text.pdf.PdfName" name="byte[] encodeName(java.lang.String)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfName" name="int compareTo(com.itextpdf.text.pdf.PdfName)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfName" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <class name="com.itextpdf.text.pdf.BadPdfFormatException" map="DB"/>
  <class name="com.itextpdf.text.pdf.DefaultSplitCharacter" map="EB"/>
  <field class="com.itextpdf.text.pdf.DefaultSplitCharacter" name="characters" map="B"/>
  <field class="com.itextpdf.text.pdf.DefaultSplitCharacter" name="DEFAULT" map="C"/>
  <method class="com.itextpdf.text.pdf.DefaultSplitCharacter" name="boolean isSplitCharacter(int, int, int, char[], com.itextpdf.text.pdf.PdfChunk[])" map="A"/>
  <method class="com.itextpdf.text.pdf.DefaultSplitCharacter" name="char getCurrentCharacter(int, char[], com.itextpdf.text.pdf.PdfChunk[])" map="A"/>
  <class name="com.itextpdf.text.pdf.FontDetails$1" map="1"/>
  <field class="com.itextpdf.text.pdf.FontDetails$1" name="$SwitchMap$com$itextpdf$text$pdf$fonts$otf$Language" map="A"/>
  <class name="com.itextpdf.text.pdf.FontDetails" map="FB"/>
  <field class="com.itextpdf.text.pdf.FontDetails" name="fontName" map="A"/>
  <field class="com.itextpdf.text.pdf.FontDetails" name="baseFont" map="B"/>
  <field class="com.itextpdf.text.pdf.FontDetails" name="cjkTag" map="C"/>
  <field class="com.itextpdf.text.pdf.FontDetails" name="subset" map="D"/>
  <field class="com.itextpdf.text.pdf.FontDetails" name="longTag" map="E"/>
  <field class="com.itextpdf.text.pdf.FontDetails" name="symbolic" map="F"/>
  <field class="com.itextpdf.text.pdf.FontDetails" name="cjkFont" map="G"/>
  <field class="com.itextpdf.text.pdf.FontDetails" name="shortTag" map="H"/>
  <field class="com.itextpdf.text.pdf.FontDetails" name="fontType" map="I"/>
  <field class="com.itextpdf.text.pdf.FontDetails" name="ttu" map="J"/>
  <field class="com.itextpdf.text.pdf.FontDetails" name="indirectReference" map="K"/>
  <method class="com.itextpdf.text.pdf.FontDetails" name="com.itextpdf.text.pdf.PdfIndirectReference getIndirectReference()" map="A"/>
  <method class="com.itextpdf.text.pdf.FontDetails" name="void setSubset(boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.FontDetails" name="boolean canApplyGlyphSubstitution()" map="B"/>
  <method class="com.itextpdf.text.pdf.FontDetails" name="byte[] convertToBytesAfterGlyphSubstitution(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.FontDetails" name="com.itextpdf.text.pdf.languages.GlyphRepositioner getGlyphRepositioner()" map="C"/>
  <method class="com.itextpdf.text.pdf.FontDetails" name="void writeFont(com.itextpdf.text.pdf.PdfWriter)" map="A"/>
  <method class="com.itextpdf.text.pdf.FontDetails" name="com.itextpdf.text.pdf.PdfName getFontName()" map="D"/>
  <method class="com.itextpdf.text.pdf.FontDetails" name="byte[] convertToBytes(java.lang.String)" map="B"/>
  <method class="com.itextpdf.text.pdf.FontDetails" name="com.itextpdf.text.pdf.BaseFont getBaseFont()" map="E"/>
  <class name="com.itextpdf.text.pdf.PdfShadingPattern" map="GB"/>
  <method class="com.itextpdf.text.pdf.PdfShadingPattern" name="com.itextpdf.text.pdf.PdfShading getShading()" map="&#x015c;"/>
  <method class="com.itextpdf.text.pdf.PdfShadingPattern" name="com.itextpdf.text.pdf.ColorDetails getColorDetails()" map="&#x015d;"/>
  <method class="com.itextpdf.text.pdf.PdfShadingPattern" name="com.itextpdf.text.pdf.PdfName getPatternName()" map="&#x015e;"/>
  <method class="com.itextpdf.text.pdf.PdfShadingPattern" name="void addToBody()" map="&#x015f;"/>
  <method class="com.itextpdf.text.pdf.PdfShadingPattern" name="com.itextpdf.text.pdf.PdfIndirectReference getPatternReference()" map="&#x0160;"/>
  <method class="com.itextpdf.text.pdf.PdfShadingPattern" name="void setName(int)" map="U"/>
  <class name="com.itextpdf.text.pdf.PdfPage" map="HB"/>
  <field class="com.itextpdf.text.pdf.PdfPage" name="mediaBox" map="&#x063a;"/>
  <field class="com.itextpdf.text.pdf.PdfPage" name="LANDSCAPE" map="&#x0640;"/>
  <field class="com.itextpdf.text.pdf.PdfPage" name="SEASCAPE" map="&#x0641;"/>
  <field class="com.itextpdf.text.pdf.PdfPage" name="PORTRAIT" map="&#x0642;"/>
  <field class="com.itextpdf.text.pdf.PdfPage" name="INVERTEDPORTRAIT" map="&#x0643;"/>
  <field class="com.itextpdf.text.pdf.PdfPage" name="boxNames" map="&#x0644;"/>
  <field class="com.itextpdf.text.pdf.PdfPage" name="boxStrings" map="&#x0645;"/>
  <method class="com.itextpdf.text.pdf.PdfPage" name="void add(com.itextpdf.text.pdf.PdfIndirectReference)" map="E"/>
  <class name="com.itextpdf.text.pdf.PdfPageLabels" map="IB"/>
  <field class="com.itextpdf.text.pdf.PdfPageLabels" name="numberingStyle" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPageLabels" name="com.itextpdf.text.pdf.PdfDictionary getDictionary(com.itextpdf.text.pdf.PdfWriter)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfPTableBody" map="JB"/>
  <field class="com.itextpdf.text.pdf.PdfPTableBody" name="accessibleAttributes" map="&#x06ac;"/>
  <field class="com.itextpdf.text.pdf.PdfPTableBody" name="rows" map="&#x06ad;"/>
  <field class="com.itextpdf.text.pdf.PdfPTableBody" name="role" map="&#x06ae;"/>
  <field class="com.itextpdf.text.pdf.PdfPTableBody" name="id" map="&#x06af;"/>
  <method class="com.itextpdf.text.pdf.PdfPTableBody" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTableBody" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.pdf.PdfPTableBody" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTableBody" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTableBody" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.pdf.PdfPTableBody" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.pdf.PdfPTableBody" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.pdf.PdfPTableBody" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <class name="com.itextpdf.text.pdf.Glyph" map="KB"/>
  <field class="com.itextpdf.text.pdf.Glyph" name="width" map="A"/>
  <field class="com.itextpdf.text.pdf.Glyph" name="chars" map="B"/>
  <field class="com.itextpdf.text.pdf.Glyph" name="code" map="C"/>
  <method class="com.itextpdf.text.pdf.Glyph" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="com.itextpdf.text.pdf.Glyph" name="int hashCode()" map="hashCode"/>
  <method class="com.itextpdf.text.pdf.Glyph" name="java.lang.String toString()" map="toString"/>
  <class name="com.itextpdf.text.pdf.EnumerateTTC" map="LB"/>
  <field class="com.itextpdf.text.pdf.EnumerateTTC" name="names" map="&#x00e6;"/>
  <method class="com.itextpdf.text.pdf.EnumerateTTC" name="void findNames()" map="f"/>
  <method class="com.itextpdf.text.pdf.EnumerateTTC" name="java.lang.String[] getNames()" map="g"/>
  <class name="com.itextpdf.text.pdf.PdfPatternPainter" map="MB"/>
  <method class="com.itextpdf.text.pdf.PdfPatternPainter" name="com.itextpdf.text.BaseColor getDefaultColor()" map="&#x019b;"/>
  <method class="com.itextpdf.text.pdf.PdfPatternPainter" name="boolean isStencil()" map="&#x019c;"/>
  <method class="com.itextpdf.text.pdf.PdfPatternPainter" name="com.itextpdf.text.pdf.PdfPattern getPattern(int)" map="_"/>
  <class name="com.itextpdf.text.pdf.PdfStructureElement" map="NB"/>
  <field class="com.itextpdf.text.pdf.PdfStructureElement" name="reference" map="&#x05de;"/>
  <field class="com.itextpdf.text.pdf.PdfStructureElement" name="elementId" map="&#x05df;"/>
  <field class="com.itextpdf.text.pdf.PdfStructureElement" name="parent" map="&#x05e0;"/>
  <field class="com.itextpdf.text.pdf.PdfStructureElement" name="top" map="&#x05e1;"/>
  <field class="com.itextpdf.text.pdf.PdfStructureElement" name="structureType" map="&#x05e2;"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.pdf.PdfTemplate)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.pdf.PdfDiv)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.Paragraph)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="com.itextpdf.text.pdf.PdfIndirectReference getReference()" map="&#x0147;"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="com.itextpdf.text.AccessibleElementId getElementId()" map="&#x0148;"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void toPdf(com.itextpdf.text.pdf.PdfWriter, java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void setPageMark(int, int)" map="G"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="com.itextpdf.text.pdf.PdfObject getParentAttribute(com.itextpdf.text.pdf.interfaces.IPdfStructureElement, com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="boolean colorsEqual(com.itextpdf.text.pdf.PdfArray, float[])" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.pdf.PdfPHeaderCell)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void setColorAttribute(com.itextpdf.text.BaseColor, com.itextpdf.text.pdf.PdfObject, com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.pdf.PdfPTableBody)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void setAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void setTextAlignAttribute(int)" map="S"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.ListItem)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.pdf.interfaces.IAccessibleElement)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void setAnnotation(com.itextpdf.text.pdf.PdfAnnotation, com.itextpdf.text.pdf.PdfIndirectReference)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="com.itextpdf.text.pdf.PdfDictionary getParent(boolean)" map="M"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void setStructureElementParent(com.itextpdf.text.pdf.PdfStructureElement)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="com.itextpdf.text.pdf.PdfObject getAttribute(com.itextpdf.text.pdf.PdfName)" map="L"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.List)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="com.itextpdf.text.pdf.PdfDictionary getParent()" map="&#x0149;"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.Document)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.Image)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.Chunk)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="com.itextpdf.text.pdf.PdfName getStructureType()" map="&#x014a;"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void init(com.itextpdf.text.pdf.PdfDictionary, com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void setStructureTreeRoot(com.itextpdf.text.pdf.PdfStructureTreeRoot)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.ListBody)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.pdf.PdfPRow)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.pdf.PdfPTableHeader)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.pdf.PdfPCell)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.pdf.PdfPTableFooter)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.pdf.PdfPTable)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfStructureElement" name="void writeAttributes(com.itextpdf.text.ListLabel)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfLabColor" map="OB"/>
  <method class="com.itextpdf.text.pdf.PdfLabColor" name="com.itextpdf.text.pdf.PdfObject getPdfObject(com.itextpdf.text.pdf.PdfWriter)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfLabColor" name="com.itextpdf.text.BaseColor lab2Rgb(float, float, float)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfPRow" map="PB"/>
  <field class="com.itextpdf.text.pdf.PdfPRow" name="$assertionsDisabled" map="&#x06b0;"/>
  <field class="com.itextpdf.text.pdf.PdfPRow" name="id" map="&#x06b1;"/>
  <field class="com.itextpdf.text.pdf.PdfPRow" name="accessibleAttributes" map="&#x06b2;"/>
  <field class="com.itextpdf.text.pdf.PdfPRow" name="widths" map="&#x06b3;"/>
  <field class="com.itextpdf.text.pdf.PdfPRow" name="canvasesPos" map="&#x06b4;"/>
  <field class="com.itextpdf.text.pdf.PdfPRow" name="role" map="&#x06b5;"/>
  <field class="com.itextpdf.text.pdf.PdfPRow" name="mayNotBreak" map="&#x06b6;"/>
  <field class="com.itextpdf.text.pdf.PdfPRow" name="extraHeights" map="&#x06b7;"/>
  <field class="com.itextpdf.text.pdf.PdfPRow" name="maxHeight" map="&#x06ba;"/>
  <field class="com.itextpdf.text.pdf.PdfPRow" name="LOGGER" map="&#x06bb;"/>
  <field class="com.itextpdf.text.pdf.PdfPRow" name="adjusted" map="&#x06bc;"/>
  <field class="com.itextpdf.text.pdf.PdfPRow" name="calculated" map="&#x06bd;"/>
  <field class="com.itextpdf.text.pdf.PdfPRow" name="cells" map="&#x06be;"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="void setExtraHeight(int, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="void writeCells(int, int, float, float, com.itextpdf.text.pdf.PdfContentByte[], boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="void splitRowspans(com.itextpdf.text.pdf.PdfPTable, int, com.itextpdf.text.pdf.PdfPTable, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="void calculateHeights()" map="&#x019d;"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="void setAdjusted(boolean)" map="S"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="float[] getEventWidth(float, float[])" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="void copyRowContent(com.itextpdf.text.pdf.PdfPTable, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="void setMaxHeights(float)" map="h"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="float getMaxHeights()" map="&#x019e;"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="boolean isTagged(com.itextpdf.text.pdf.PdfContentByte)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="boolean isAdjusted()" map="&#x019f;"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="boolean setWidths(float[])" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="void writeBorderAndBackground(float, float, float, com.itextpdf.text.pdf.PdfPCell, com.itextpdf.text.pdf.PdfContentByte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="com.itextpdf.text.pdf.PdfPCell[] getCells()" map="&#x01a0;"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="float getMaxRowHeightsWithoutCalculating()" map="&#x01a1;"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="com.itextpdf.text.pdf.PdfPRow splitRow(com.itextpdf.text.pdf.PdfPTable, int, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="void restoreCanvases(com.itextpdf.text.pdf.PdfContentByte[])" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="void initExtraHeights()" map="&#x01a2;"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="void setFinalMaxHeights(float)" map="i"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="boolean hasRowspan()" map="&#x01a3;"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="boolean isMayNotBreak()" map="&#x01a4;"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="float setColumn(com.itextpdf.text.pdf.ColumnText, float, float, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPRow" name="void saveAndRotateCanvases(com.itextpdf.text.pdf.PdfContentByte[], float, float, float, float, float, float)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfPTableEventSplit" map="QB"/>
  <method class="com.itextpdf.text.pdf.PdfPTableEventSplit" name="void splitTable(com.itextpdf.text.pdf.PdfPTable)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfPTable$ColumnMeasurementState" map="_A"/>
  <field class="com.itextpdf.text.pdf.PdfPTable$ColumnMeasurementState" name="height" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfPTable$ColumnMeasurementState" name="rowspan" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfPTable$ColumnMeasurementState" name="colspan" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfPTable$ColumnMeasurementState" name="void beginCell(com.itextpdf.text.pdf.PdfPCell, float, float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable$ColumnMeasurementState" name="boolean cellEnds()" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable$ColumnMeasurementState" name="void consumeRowspan(float, float)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfPTable$FittingRows" map="_B"/>
  <field class="com.itextpdf.text.pdf.PdfPTable$FittingRows" name="height" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfPTable$FittingRows" name="completedRowsHeight" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfPTable$FittingRows" name="correctedHeightsForLastRow" map="C"/>
  <field class="com.itextpdf.text.pdf.PdfPTable$FittingRows" name="lastRow" map="D"/>
  <field class="com.itextpdf.text.pdf.PdfPTable$FittingRows" name="firstRow" map="E"/>
  <method class="com.itextpdf.text.pdf.PdfPTable$FittingRows" name="void correctLastRowChosen(com.itextpdf.text.pdf.PdfPTable, int)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfPTable" map="RB"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="loopCheck" map="j"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="isColspan" map="k"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="header" map="l"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="absoluteWidths" map="m"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="footerRows" map="n"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="headerRows" map="o"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="LOGGER" map="p"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="skipFirstHeader" map="q"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="extendLastRow" map="r"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="totalWidth" map="s"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="keepTogether" map="t"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="tableEvent" map="u"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="footer" map="v"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="splitRows" map="w"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="currentRow" map="x"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="rowsNotChecked" map="y"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="complete" map="z"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="spacingAfter" map="&#x00a2;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="rowCompleted" map="&#x00a3;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="defaultCell" map="&#x00a4;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="lockedWidth" map="&#x00a5;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="relativeWidths" map="&#x00aa;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="body" map="&#x00b5;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="skipLastFooter" map="&#x00ba;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="totalHeight" map="&#x00c0;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="splitLate" map="&#x00c1;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="$assertionsDisabled" map="&#x00c2;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="numberOfWrittenRows" map="&#x00c3;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="role" map="&#x00c4;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="spacingBefore" map="&#x00c5;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="id" map="&#x00c6;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="horizontalAlignment" map="&#x00c7;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="accessibleAttributes" map="&#x00c8;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="headersInEvent" map="&#x00c9;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="rows" map="&#x00ca;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="paddingTop" map="&#x00cb;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="widthPercentage" map="&#x00cc;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="runDirection" map="&#x00cd;"/>
  <field class="com.itextpdf.text.pdf.PdfPTable" name="currentColIdx" map="&#x00ce;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float getTotalWidth()" map="&#x00f5;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float getHeaderHeight()" map="&#x00f6;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="int getFooterRows()" map="&#x00f8;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean isExtendLastRow()" map="&#x00f9;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean isExtendLastRow(boolean)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.pdf.PdfContentByte[] beginWritingRows(com.itextpdf.text.pdf.PdfContentByte)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setWidthPercentage(float)" map="U"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setSpacingAfter(float)" map="V"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.pdf.PdfPTableHeader getHeader()" map="&#x00fa;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.pdf.PdfPTableBody closeTableBlock(com.itextpdf.text.pdf.PdfPTableBody, com.itextpdf.text.pdf.PdfContentByte)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="int getHorizontalAlignment()" map="&#x00fb;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean isContent()" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="int getRunDirection()" map="&#x00fc;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="int size()" map="&#x00fd;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setLoopCheck(boolean)" map="E"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float writeSelectedRows(int, int, int, int, float, float, com.itextpdf.text.pdf.PdfContentByte, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.pdf.PdfPTableFooter getFooter()" map="&#x00fe;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean isComplete()" map="e"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void init()" map="&#x00ff;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean isSplitRows()" map="&#x0100;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float getRowHeight(int, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean isSkipLastFooter()" map="&#x0101;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float calculateHeights()" map="&#x0102;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean isLoopCheck()" map="&#x0103;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="int type()" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setComplete(boolean)" map="F"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void copyFormat(com.itextpdf.text.pdf.PdfPTable)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void addNumberOfRowsWritten(int)" map="F"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.pdf.PdfPTableBody openTableBlock(com.itextpdf.text.pdf.PdfPTableBody, com.itextpdf.text.pdf.PdfContentByte)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setLockedWidth(boolean)" map="G"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean isSplitLate()" map="&#x0104;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.pdf.PdfPTableEvent getTableEvent()" map="&#x0105;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float getRowHeight(int)" map="G"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float getWidthPercentage()" map="&#x0106;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean rowSpanAbove(int, int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float spacingAfter()" map="&#x0107;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setSkipFirstHeader(boolean)" map="H"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="int getHeaderRows()" map="&#x0108;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float getPaddingTop()" map="c"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="java.util.ArrayList getRows()" map="&#x0109;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="java.util.List getChunks()" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="java.util.ArrayList getRows(int, int)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void normalizeHeadersFooters()" map="&#x010a;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void flushContent()" map="f"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean isHeadersInEvent()" map="&#x010b;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean hasRowspan(int)" map="H"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="int getNumberOfColumns()" map="&#x010c;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean isSkipFirstHeader()" map="&#x010d;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="int getCellStartRowIndex(int, int)" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.pdf.PdfPCell addCell(com.itextpdf.text.pdf.PdfPCell)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setHorizontalAlignment(int)" map="I"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setKeepTogether(boolean)" map="I"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.pdf.PdfPCell cellAt(int, int)" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean isLockedWidth()" map="&#x010e;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.pdf.PdfPRow getRow(int)" map="J"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void endWritingRows(com.itextpdf.text.pdf.PdfContentByte[])" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float getSpacingAfter()" map="&#x010f;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setTotalWidth(float)" map="W"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setSpacingBefore(float)" map="X"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.pdf.PdfPRow adjustCellsInRow(int, int)" map="E"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.pdf.PdfPTableBody getBody()" map="&#x0110;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float[][] getEventWidths(float, int, int, boolean)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setSplitLate(boolean)" map="J"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void skipColsWithRowspanAbove()" map="&#x0111;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float getTotalHeight()" map="&#x0112;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float getSpacingBefore()" map="d"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float getFooterHeight()" map="&#x0113;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setHeadersInEvent(boolean)" map="K"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.pdf.PdfPTable shallowCopy(com.itextpdf.text.pdf.PdfPTable)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void deleteBodyRows()" map="&#x0114;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.pdf.PdfPTable$FittingRows getFittingRows(float, int)" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float spacingBefore()" map="&#x0115;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean process(com.itextpdf.text.ElementListener)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void setHeaderRows(int)" map="K"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="void calculateWidths()" map="&#x0116;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="boolean getKeepTogether()" map="&#x0117;"/>
  <method class="com.itextpdf.text.pdf.PdfPTable" name="float writeSelectedRows(int, int, int, int, float, float, com.itextpdf.text.pdf.PdfContentByte[], boolean)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfFont" map="SB"/>
  <field class="com.itextpdf.text.pdf.PdfFont" name="hScale" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfFont" name="font" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfFont" name="size" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfFont" name="float width(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfFont" name="float width(int)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfFont" name="void setHorizontalScaling(float)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfFont" name="float width()" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfFont" name="float getHorizontalScaling()" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfFont" name="int compareTo(com.itextpdf.text.pdf.PdfFont)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfFont" name="com.itextpdf.text.pdf.PdfFont getDefaultFont()" map="C"/>
  <method class="com.itextpdf.text.pdf.PdfFont" name="float size()" map="D"/>
  <method class="com.itextpdf.text.pdf.PdfFont" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <method class="com.itextpdf.text.pdf.PdfFont" name="com.itextpdf.text.pdf.BaseFont getFont()" map="E"/>
  <class name="com.itextpdf.text.pdf.NumberArray" map="TB"/>
  <class name="com.itextpdf.text.pdf.PdfEncodings$Cp437Conversion" map="_A"/>
  <field class="com.itextpdf.text.pdf.PdfEncodings$Cp437Conversion" name="c2b" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfEncodings$Cp437Conversion" name="table" map="B"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings$Cp437Conversion" name="byte[] charToByte(char, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings$Cp437Conversion" name="byte[] charToByte(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings$Cp437Conversion" name="java.lang.String byteToChar(byte[], java.lang.String)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfEncodings$SymbolConversion" map="_B"/>
  <field class="com.itextpdf.text.pdf.PdfEncodings$SymbolConversion" name="table2" map="C"/>
  <field class="com.itextpdf.text.pdf.PdfEncodings$SymbolConversion" name="table1" map="D"/>
  <field class="com.itextpdf.text.pdf.PdfEncodings$SymbolConversion" name="t2" map="E"/>
  <field class="com.itextpdf.text.pdf.PdfEncodings$SymbolConversion" name="t1" map="F"/>
  <field class="com.itextpdf.text.pdf.PdfEncodings$SymbolConversion" name="byteToChar" map="G"/>
  <field class="com.itextpdf.text.pdf.PdfEncodings$SymbolConversion" name="translation" map="H"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings$SymbolConversion" name="byte[] charToByte(char, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings$SymbolConversion" name="byte[] charToByte(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings$SymbolConversion" name="java.lang.String byteToChar(byte[], java.lang.String)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfEncodings$1" map="1"/>
  <class name="com.itextpdf.text.pdf.PdfEncodings$WingdingsConversion" map="_C"/>
  <field class="com.itextpdf.text.pdf.PdfEncodings$WingdingsConversion" name="table" map="I"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings$WingdingsConversion" name="byte[] charToByte(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings$WingdingsConversion" name="byte[] charToByte(char, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings$WingdingsConversion" name="java.lang.String byteToChar(byte[], java.lang.String)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfEncodings$SymbolTTConversion" map="_D"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings$SymbolTTConversion" name="byte[] charToByte(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings$SymbolTTConversion" name="byte[] charToByte(char, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings$SymbolTTConversion" name="java.lang.String byteToChar(byte[], java.lang.String)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfEncodings" map="UB"/>
  <field class="com.itextpdf.text.pdf.PdfEncodings" name="winansi" map="A"/>
  <field class="com.itextpdf.text.pdf.PdfEncodings" name="pdfEncodingByteToChar" map="B"/>
  <field class="com.itextpdf.text.pdf.PdfEncodings" name="winansiByteToChar" map="C"/>
  <field class="com.itextpdf.text.pdf.PdfEncodings" name="pdfEncoding" map="D"/>
  <field class="com.itextpdf.text.pdf.PdfEncodings" name="extraEncodings" map="E"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings" name="java.lang.String convertToString(byte[], java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings" name="byte[] convertToBytes(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings" name="void addExtraEncoding(java.lang.String, com.itextpdf.text.pdf.ExtraEncoding)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings" name="boolean isPdfDocEncoding(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.pdf.PdfEncodings" name="byte[] convertToBytes(char, java.lang.String)" map="A"/>
  <class name="com.itextpdf.text.pdf.PdfDashPattern" map="VB"/>
  <package name="com.itextpdf.text.xml" map="B"/>
  <package name="com.itextpdf.text.xml.simpleparser" map="A"/>
  <class name="com.itextpdf.text.xml.simpleparser.EntitiesToUnicode" map="A"/>
  <field class="com.itextpdf.text.xml.simpleparser.EntitiesToUnicode" name="MAP" map="A"/>
  <method class="com.itextpdf.text.xml.simpleparser.EntitiesToUnicode" name="char decodeEntity(java.lang.String)" map="A"/>
  <class name="com.itextpdf.text.xml.simpleparser.SimpleXMLDocHandler" map="B"/>
  <package name="com.itextpdf.text.xml.xmp" map="B"/>
  <class name="com.itextpdf.text.xml.xmp.XmpWriter" map="A"/>
  <method class="com.itextpdf.text.xml.xmp.XmpWriter" name="void serialize(java.io.OutputStream)" map="A"/>
  <method class="com.itextpdf.text.xml.xmp.XmpWriter" name="void close()" map="A"/>
  <package name="com.itextpdf.text.html" map="C"/>
  <class name="com.itextpdf.text.html.WebColors" map="A"/>
  <field class="com.itextpdf.text.html.WebColors" name="NAMES" map="A"/>
  <package name="com.itextpdf.text.exceptions" map="D"/>
  <class name="com.itextpdf.text.exceptions.InvalidPdfException" map="A"/>
  <field class="com.itextpdf.text.exceptions.InvalidPdfException" name="cause" map="A"/>
  <method class="com.itextpdf.text.exceptions.InvalidPdfException" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="com.itextpdf.text.exceptions.IllegalPdfSyntaxException" map="B"/>
  <package name="com.itextpdf.text.log" map="E"/>
  <class name="com.itextpdf.text.log.NoOpLogger" map="A"/>
  <method class="com.itextpdf.text.log.NoOpLogger" name="com.itextpdf.text.log.Logger getLogger(java.lang.Class)" map="A"/>
  <method class="com.itextpdf.text.log.NoOpLogger" name="void debug(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.log.NoOpLogger" name="void error(java.lang.String, java.lang.Exception)" map="A"/>
  <method class="com.itextpdf.text.log.NoOpLogger" name="boolean isLogging(com.itextpdf.text.log.Level)" map="A"/>
  <method class="com.itextpdf.text.log.NoOpLogger" name="void info(java.lang.String)" map="B"/>
  <method class="com.itextpdf.text.log.NoOpLogger" name="void trace(java.lang.String)" map="C"/>
  <method class="com.itextpdf.text.log.NoOpLogger" name="void error(java.lang.String)" map="D"/>
  <class name="com.itextpdf.text.log.Logger" map="B"/>
  <method class="com.itextpdf.text.log.Logger" name="com.itextpdf.text.log.Logger getLogger(java.lang.Class)" map="A"/>
  <method class="com.itextpdf.text.log.Logger" name="void debug(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.log.Logger" name="void error(java.lang.String, java.lang.Exception)" map="A"/>
  <method class="com.itextpdf.text.log.Logger" name="boolean isLogging(com.itextpdf.text.log.Level)" map="A"/>
  <method class="com.itextpdf.text.log.Logger" name="void info(java.lang.String)" map="B"/>
  <method class="com.itextpdf.text.log.Logger" name="void trace(java.lang.String)" map="C"/>
  <method class="com.itextpdf.text.log.Logger" name="void error(java.lang.String)" map="D"/>
  <class name="com.itextpdf.text.log.DefaultCounter" map="C"/>
  <field class="com.itextpdf.text.log.DefaultCounter" name="repeat_level" map="A"/>
  <field class="com.itextpdf.text.log.DefaultCounter" name="message" map="B"/>
  <field class="com.itextpdf.text.log.DefaultCounter" name="count" map="C"/>
  <field class="com.itextpdf.text.log.DefaultCounter" name="repeat" map="D"/>
  <field class="com.itextpdf.text.log.DefaultCounter" name="level" map="E"/>
  <method class="com.itextpdf.text.log.DefaultCounter" name="void plusOne()" map="A"/>
  <method class="com.itextpdf.text.log.DefaultCounter" name="void written(long)" map="A"/>
  <method class="com.itextpdf.text.log.DefaultCounter" name="com.itextpdf.text.log.Counter getCounter(java.lang.Class)" map="A"/>
  <class name="com.itextpdf.text.log.Level" map="D"/>
  <field class="com.itextpdf.text.log.Level" name="DEBUG" map="A"/>
  <field class="com.itextpdf.text.log.Level" name="INFO" map="B"/>
  <field class="com.itextpdf.text.log.Level" name="ERROR" map="C"/>
  <field class="com.itextpdf.text.log.Level" name="$VALUES" map="D"/>
  <field class="com.itextpdf.text.log.Level" name="WARN" map="E"/>
  <field class="com.itextpdf.text.log.Level" name="TRACE" map="F"/>
  <method class="com.itextpdf.text.log.Level" name="com.itextpdf.text.log.Level[] values()" map="values"/>
  <method class="com.itextpdf.text.log.Level" name="com.itextpdf.text.log.Level valueOf(java.lang.String)" map="valueOf"/>
  <class name="com.itextpdf.text.log.CounterFactory" map="E"/>
  <field class="com.itextpdf.text.log.CounterFactory" name="counter" map="A"/>
  <field class="com.itextpdf.text.log.CounterFactory" name="myself" map="B"/>
  <method class="com.itextpdf.text.log.CounterFactory" name="com.itextpdf.text.log.Counter getCounter(java.lang.Class)" map="A"/>
  <class name="com.itextpdf.text.log.LoggerFactory" map="F"/>
  <field class="com.itextpdf.text.log.LoggerFactory" name="logger" map="A"/>
  <field class="com.itextpdf.text.log.LoggerFactory" name="myself" map="B"/>
  <method class="com.itextpdf.text.log.LoggerFactory" name="com.itextpdf.text.log.Logger getLogger(java.lang.Class)" map="A"/>
  <class name="com.itextpdf.text.log.Counter" map="G"/>
  <method class="com.itextpdf.text.log.Counter" name="void written(long)" map="A"/>
  <method class="com.itextpdf.text.log.Counter" name="com.itextpdf.text.log.Counter getCounter(java.lang.Class)" map="A"/>
  <package name="com.itextpdf.text.api" map="F"/>
  <class name="com.itextpdf.text.api.package-info" map="package-info"/>
  <class name="com.itextpdf.text.api.Spaceable" map="A"/>
  <method class="com.itextpdf.text.api.Spaceable" name="float getPaddingTop()" map="c"/>
  <method class="com.itextpdf.text.api.Spaceable" name="float getSpacingBefore()" map="d"/>
  <class name="com.itextpdf.text.api.WriterOperation" map="B"/>
  <method class="com.itextpdf.text.api.WriterOperation" name="void write(com.itextpdf.text.pdf.PdfWriter, com.itextpdf.text.Document)" map="A"/>
  <class name="com.itextpdf.text.api.Indentable" map="C"/>
  <package name="com.itextpdf.text.io" map="G"/>
  <class name="com.itextpdf.text.io.PagedChannelRandomAccessSource$MRU" map="_A"/>
  <field class="com.itextpdf.text.io.PagedChannelRandomAccessSource$MRU" name="queue" map="A"/>
  <field class="com.itextpdf.text.io.PagedChannelRandomAccessSource$MRU" name="limit" map="B"/>
  <method class="com.itextpdf.text.io.PagedChannelRandomAccessSource$MRU" name="java.lang.Object enqueue(java.lang.Object)" map="A"/>
  <class name="com.itextpdf.text.io.PagedChannelRandomAccessSource" map="A"/>
  <field class="com.itextpdf.text.io.PagedChannelRandomAccessSource" name="mru" map="D"/>
  <field class="com.itextpdf.text.io.PagedChannelRandomAccessSource" name="channel" map="E"/>
  <field class="com.itextpdf.text.io.PagedChannelRandomAccessSource" name="bufferSize" map="F"/>
  <method class="com.itextpdf.text.io.PagedChannelRandomAccessSource" name="int getStartingSourceIndex(long)" map="C"/>
  <method class="com.itextpdf.text.io.PagedChannelRandomAccessSource" name="com.itextpdf.text.io.RandomAccessSource[] buildSources(java.nio.channels.FileChannel, int)" map="A"/>
  <method class="com.itextpdf.text.io.PagedChannelRandomAccessSource" name="void sourceReleased(com.itextpdf.text.io.RandomAccessSource)" map="A"/>
  <method class="com.itextpdf.text.io.PagedChannelRandomAccessSource" name="void close()" map="A"/>
  <method class="com.itextpdf.text.io.PagedChannelRandomAccessSource" name="void sourceInUse(com.itextpdf.text.io.RandomAccessSource)" map="B"/>
  <class name="com.itextpdf.text.io.MapFailedException" map="B"/>
  <class name="com.itextpdf.text.io.RandomAccessSourceFactory" map="C"/>
  <field class="com.itextpdf.text.io.RandomAccessSourceFactory" name="exclusivelyLockFile" map="A"/>
  <field class="com.itextpdf.text.io.RandomAccessSourceFactory" name="usePlainRandomAccess" map="B"/>
  <field class="com.itextpdf.text.io.RandomAccessSourceFactory" name="forceRead" map="C"/>
  <method class="com.itextpdf.text.io.RandomAccessSourceFactory" name="com.itextpdf.text.io.RandomAccessSource createSource(java.net.URL)" map="A"/>
  <method class="com.itextpdf.text.io.RandomAccessSourceFactory" name="com.itextpdf.text.io.RandomAccessSource createSource(byte[])" map="A"/>
  <method class="com.itextpdf.text.io.RandomAccessSourceFactory" name="com.itextpdf.text.io.RandomAccessSource createByReadingToMemory(java.io.InputStream)" map="A"/>
  <method class="com.itextpdf.text.io.RandomAccessSourceFactory" name="com.itextpdf.text.io.RandomAccessSource createSource(java.io.InputStream)" map="B"/>
  <method class="com.itextpdf.text.io.RandomAccessSourceFactory" name="com.itextpdf.text.io.RandomAccessSource createBestSource(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.io.RandomAccessSourceFactory" name="com.itextpdf.text.io.RandomAccessSourceFactory setForceRead(boolean)" map="A"/>
  <method class="com.itextpdf.text.io.RandomAccessSourceFactory" name="com.itextpdf.text.io.RandomAccessSourceFactory setUsePlainRandomAccess(boolean)" map="B"/>
  <method class="com.itextpdf.text.io.RandomAccessSourceFactory" name="com.itextpdf.text.io.RandomAccessSource createByReadingToMemory(java.lang.String)" map="B"/>
  <method class="com.itextpdf.text.io.RandomAccessSourceFactory" name="com.itextpdf.text.io.RandomAccessSource createBestSource(java.nio.channels.FileChannel)" map="A"/>
  <method class="com.itextpdf.text.io.RandomAccessSourceFactory" name="com.itextpdf.text.io.RandomAccessSource createBestSource(java.io.RandomAccessFile)" map="A"/>
  <class name="com.itextpdf.text.io.ByteBufferRandomAccessSource$1" map="1"/>
  <field class="com.itextpdf.text.io.ByteBufferRandomAccessSource$1" name="val$buffer" map="A"/>
  <method class="com.itextpdf.text.io.ByteBufferRandomAccessSource$1" name="java.lang.Object run()" map="run"/>
  <method class="com.itextpdf.text.io.ByteBufferRandomAccessSource$1" name="java.lang.Boolean run()" map="A"/>
  <class name="com.itextpdf.text.io.ByteBufferRandomAccessSource" map="D"/>
  <field class="com.itextpdf.text.io.ByteBufferRandomAccessSource" name="byteBuffer" map="G"/>
  <method class="com.itextpdf.text.io.ByteBufferRandomAccessSource" name="boolean clean(java.nio.ByteBuffer)" map="A"/>
  <method class="com.itextpdf.text.io.ByteBufferRandomAccessSource" name="int get(long, byte[], int, int)" map="A"/>
  <method class="com.itextpdf.text.io.ByteBufferRandomAccessSource" name="int get(long)" map="A"/>
  <method class="com.itextpdf.text.io.ByteBufferRandomAccessSource" name="void close()" map="A"/>
  <method class="com.itextpdf.text.io.ByteBufferRandomAccessSource" name="long length()" map="B"/>
  <class name="com.itextpdf.text.io.GroupedRandomAccessSource$SourceEntry" map="_A"/>
  <field class="com.itextpdf.text.io.GroupedRandomAccessSource$SourceEntry" name="lastByte" map="A"/>
  <field class="com.itextpdf.text.io.GroupedRandomAccessSource$SourceEntry" name="index" map="B"/>
  <field class="com.itextpdf.text.io.GroupedRandomAccessSource$SourceEntry" name="firstByte" map="C"/>
  <field class="com.itextpdf.text.io.GroupedRandomAccessSource$SourceEntry" name="source" map="D"/>
  <method class="com.itextpdf.text.io.GroupedRandomAccessSource$SourceEntry" name="long offsetN(long)" map="A"/>
  <class name="com.itextpdf.text.io.GroupedRandomAccessSource" map="E"/>
  <field class="com.itextpdf.text.io.GroupedRandomAccessSource" name="sources" map="A"/>
  <field class="com.itextpdf.text.io.GroupedRandomAccessSource" name="size" map="B"/>
  <field class="com.itextpdf.text.io.GroupedRandomAccessSource" name="currentSourceEntry" map="C"/>
  <method class="com.itextpdf.text.io.GroupedRandomAccessSource" name="com.itextpdf.text.io.GroupedRandomAccessSource$SourceEntry getSourceEntryForOffset(long)" map="B"/>
  <method class="com.itextpdf.text.io.GroupedRandomAccessSource" name="int getStartingSourceIndex(long)" map="C"/>
  <method class="com.itextpdf.text.io.GroupedRandomAccessSource" name="int get(long, byte[], int, int)" map="A"/>
  <method class="com.itextpdf.text.io.GroupedRandomAccessSource" name="void sourceReleased(com.itextpdf.text.io.RandomAccessSource)" map="A"/>
  <method class="com.itextpdf.text.io.GroupedRandomAccessSource" name="int get(long)" map="A"/>
  <method class="com.itextpdf.text.io.GroupedRandomAccessSource" name="void close()" map="A"/>
  <method class="com.itextpdf.text.io.GroupedRandomAccessSource" name="long length()" map="B"/>
  <method class="com.itextpdf.text.io.GroupedRandomAccessSource" name="void sourceInUse(com.itextpdf.text.io.RandomAccessSource)" map="B"/>
  <class name="com.itextpdf.text.io.IndependentRandomAccessSource" map="F"/>
  <field class="com.itextpdf.text.io.IndependentRandomAccessSource" name="source" map="H"/>
  <method class="com.itextpdf.text.io.IndependentRandomAccessSource" name="int get(long, byte[], int, int)" map="A"/>
  <method class="com.itextpdf.text.io.IndependentRandomAccessSource" name="int get(long)" map="A"/>
  <method class="com.itextpdf.text.io.IndependentRandomAccessSource" name="void close()" map="A"/>
  <method class="com.itextpdf.text.io.IndependentRandomAccessSource" name="long length()" map="B"/>
  <class name="com.itextpdf.text.io.FileChannelRandomAccessSource" map="G"/>
  <field class="com.itextpdf.text.io.FileChannelRandomAccessSource" name="channel" map="I"/>
  <field class="com.itextpdf.text.io.FileChannelRandomAccessSource" name="source" map="J"/>
  <method class="com.itextpdf.text.io.FileChannelRandomAccessSource" name="int get(long, byte[], int, int)" map="A"/>
  <method class="com.itextpdf.text.io.FileChannelRandomAccessSource" name="int get(long)" map="A"/>
  <method class="com.itextpdf.text.io.FileChannelRandomAccessSource" name="void close()" map="A"/>
  <method class="com.itextpdf.text.io.FileChannelRandomAccessSource" name="long length()" map="B"/>
  <class name="com.itextpdf.text.io.ArrayRandomAccessSource" map="H"/>
  <field class="com.itextpdf.text.io.ArrayRandomAccessSource" name="array" map="K"/>
  <method class="com.itextpdf.text.io.ArrayRandomAccessSource" name="int get(long, byte[], int, int)" map="A"/>
  <method class="com.itextpdf.text.io.ArrayRandomAccessSource" name="int get(long)" map="A"/>
  <method class="com.itextpdf.text.io.ArrayRandomAccessSource" name="void close()" map="A"/>
  <method class="com.itextpdf.text.io.ArrayRandomAccessSource" name="long length()" map="B"/>
  <class name="com.itextpdf.text.io.RandomAccessSource" map="I"/>
  <method class="com.itextpdf.text.io.RandomAccessSource" name="int get(long, byte[], int, int)" map="A"/>
  <method class="com.itextpdf.text.io.RandomAccessSource" name="int get(long)" map="A"/>
  <method class="com.itextpdf.text.io.RandomAccessSource" name="void close()" map="A"/>
  <method class="com.itextpdf.text.io.RandomAccessSource" name="long length()" map="B"/>
  <class name="com.itextpdf.text.io.StreamUtil" map="J"/>
  <method class="com.itextpdf.text.io.StreamUtil" name="java.io.InputStream getResourceStream(java.lang.String, java.lang.ClassLoader)" map="A"/>
  <method class="com.itextpdf.text.io.StreamUtil" name="java.io.InputStream getResourceStream(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.io.StreamUtil" name="byte[] inputStreamToArray(java.io.InputStream)" map="A"/>
  <class name="com.itextpdf.text.io.RAFRandomAccessSource" map="K"/>
  <field class="com.itextpdf.text.io.RAFRandomAccessSource" name="length" map="L"/>
  <field class="com.itextpdf.text.io.RAFRandomAccessSource" name="raf" map="M"/>
  <method class="com.itextpdf.text.io.RAFRandomAccessSource" name="int get(long, byte[], int, int)" map="A"/>
  <method class="com.itextpdf.text.io.RAFRandomAccessSource" name="int get(long)" map="A"/>
  <method class="com.itextpdf.text.io.RAFRandomAccessSource" name="void close()" map="A"/>
  <method class="com.itextpdf.text.io.RAFRandomAccessSource" name="long length()" map="B"/>
  <class name="com.itextpdf.text.io.MappedChannelRandomAccessSource" map="L"/>
  <field class="com.itextpdf.text.io.MappedChannelRandomAccessSource" name="length" map="N"/>
  <field class="com.itextpdf.text.io.MappedChannelRandomAccessSource" name="channel" map="O"/>
  <field class="com.itextpdf.text.io.MappedChannelRandomAccessSource" name="source" map="P"/>
  <field class="com.itextpdf.text.io.MappedChannelRandomAccessSource" name="offset" map="Q"/>
  <method class="com.itextpdf.text.io.MappedChannelRandomAccessSource" name="boolean exceptionIsMapFailureException(java.io.IOException)" map="A"/>
  <method class="com.itextpdf.text.io.MappedChannelRandomAccessSource" name="int get(long, byte[], int, int)" map="A"/>
  <method class="com.itextpdf.text.io.MappedChannelRandomAccessSource" name="int get(long)" map="A"/>
  <method class="com.itextpdf.text.io.MappedChannelRandomAccessSource" name="void close()" map="A"/>
  <method class="com.itextpdf.text.io.MappedChannelRandomAccessSource" name="void open()" map="C"/>
  <method class="com.itextpdf.text.io.MappedChannelRandomAccessSource" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.io.MappedChannelRandomAccessSource" name="long length()" map="B"/>
  <class name="com.itextpdf.text.io.GetBufferedRandomAccessSource" map="M"/>
  <field class="com.itextpdf.text.io.GetBufferedRandomAccessSource" name="getBufferEnd" map="R"/>
  <field class="com.itextpdf.text.io.GetBufferedRandomAccessSource" name="source" map="S"/>
  <field class="com.itextpdf.text.io.GetBufferedRandomAccessSource" name="getBufferStart" map="T"/>
  <field class="com.itextpdf.text.io.GetBufferedRandomAccessSource" name="getBuffer" map="U"/>
  <method class="com.itextpdf.text.io.GetBufferedRandomAccessSource" name="int get(long, byte[], int, int)" map="A"/>
  <method class="com.itextpdf.text.io.GetBufferedRandomAccessSource" name="int get(long)" map="A"/>
  <method class="com.itextpdf.text.io.GetBufferedRandomAccessSource" name="void close()" map="A"/>
  <method class="com.itextpdf.text.io.GetBufferedRandomAccessSource" name="long length()" map="B"/>
  <class name="com.itextpdf.text.io.TempFileCache$ObjectPosition" map="_A"/>
  <class name="com.itextpdf.text.io.TempFileCache" map="N"/>
  <method class="com.itextpdf.text.io.TempFileCache" name="com.itextpdf.text.pdf.PdfObject get(com.itextpdf.text.io.TempFileCache$ObjectPosition)" map="A"/>
  <method class="com.itextpdf.text.io.TempFileCache" name="com.itextpdf.text.io.TempFileCache$ObjectPosition put(com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <package name="com.itextpdf.text.error_messages" map="H"/>
  <class name="com.itextpdf.text.error_messages.MessageLocalization" map="A"/>
  <field class="com.itextpdf.text.error_messages.MessageLocalization" name="currentLanguage" map="A"/>
  <field class="com.itextpdf.text.error_messages.MessageLocalization" name="defaultLanguage" map="B"/>
  <method class="com.itextpdf.text.error_messages.MessageLocalization" name="java.lang.String getComposedMessage(java.lang.String, java.lang.Object[])" map="A"/>
  <method class="com.itextpdf.text.error_messages.MessageLocalization" name="java.util.HashMap readLanguageStream(java.io.InputStream)" map="A"/>
  <method class="com.itextpdf.text.error_messages.MessageLocalization" name="java.util.HashMap getLanguageMessages(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.error_messages.MessageLocalization" name="java.lang.String getMessage(java.lang.String, boolean)" map="A"/>
  <method class="com.itextpdf.text.error_messages.MessageLocalization" name="java.lang.String getMessage(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.error_messages.MessageLocalization" name="java.util.HashMap readLanguageStream(java.io.Reader)" map="A"/>
  <method class="com.itextpdf.text.error_messages.MessageLocalization" name="java.lang.String getComposedMessage(java.lang.String, int)" map="A"/>
  <class name="com.itextpdf.text.TextElementArray" map="A"/>
  <class name="com.itextpdf.text.TabSettings" map="B"/>
  <method class="com.itextpdf.text.TabSettings" name="com.itextpdf.text.TabStop getTabStopNewInstance(float)" map="A"/>
  <method class="com.itextpdf.text.TabSettings" name="com.itextpdf.text.TabStop getTabStopNewInstance(float, com.itextpdf.text.TabSettings)" map="A"/>
  <class name="com.itextpdf.text.FontFactory" map="C"/>
  <field class="com.itextpdf.text.FontFactory" name="defaultEmbedding" map="A"/>
  <field class="com.itextpdf.text.FontFactory" name="defaultEncoding" map="B"/>
  <field class="com.itextpdf.text.FontFactory" name="fontImp" map="C"/>
  <method class="com.itextpdf.text.FontFactory" name="com.itextpdf.text.Font getFont(java.lang.String, float, int, com.itextpdf.text.BaseColor)" map="A"/>
  <method class="com.itextpdf.text.FontFactory" name="com.itextpdf.text.Font getFont(java.lang.String, java.lang.String, boolean, float, int, com.itextpdf.text.BaseColor)" map="A"/>
  <class name="com.itextpdf.text.Meta" map="D"/>
  <field class="com.itextpdf.text.Meta" name="type" map="&#x000aa0;"/>
  <field class="com.itextpdf.text.Meta" name="content" map="&#x000aa1;"/>
  <method class="com.itextpdf.text.Meta" name="boolean isContent()" map="A"/>
  <method class="com.itextpdf.text.Meta" name="java.lang.String getName()" map="&#x0214;"/>
  <method class="com.itextpdf.text.Meta" name="java.lang.String getContent()" map="&#x0215;"/>
  <method class="com.itextpdf.text.Meta" name="java.util.List getChunks()" map="B"/>
  <method class="com.itextpdf.text.Meta" name="int type()" map="C"/>
  <method class="com.itextpdf.text.Meta" name="boolean process(com.itextpdf.text.ElementListener)" map="A"/>
  <class name="com.itextpdf.text.PageSize" map="E"/>
  <field class="com.itextpdf.text.PageSize" name="FLSE" map="A"/>
  <field class="com.itextpdf.text.PageSize" name="FLSA" map="B"/>
  <field class="com.itextpdf.text.PageSize" name="A9" map="C"/>
  <field class="com.itextpdf.text.PageSize" name="CROWN_QUARTO" map="D"/>
  <field class="com.itextpdf.text.PageSize" name="A8" map="E"/>
  <field class="com.itextpdf.text.PageSize" name="TABLOID" map="F"/>
  <field class="com.itextpdf.text.PageSize" name="CROWN_OCTAVO" map="G"/>
  <field class="com.itextpdf.text.PageSize" name="A7" map="H"/>
  <field class="com.itextpdf.text.PageSize" name="A6" map="I"/>
  <field class="com.itextpdf.text.PageSize" name="A5" map="J"/>
  <field class="com.itextpdf.text.PageSize" name="A4" map="K"/>
  <field class="com.itextpdf.text.PageSize" name="A3" map="L"/>
  <field class="com.itextpdf.text.PageSize" name="LETTER_LANDSCAPE" map="M"/>
  <field class="com.itextpdf.text.PageSize" name="A2" map="N"/>
  <field class="com.itextpdf.text.PageSize" name="A1" map="O"/>
  <field class="com.itextpdf.text.PageSize" name="A0" map="P"/>
  <field class="com.itextpdf.text.PageSize" name="LEGAL" map="Q"/>
  <field class="com.itextpdf.text.PageSize" name="HALFLETTER" map="R"/>
  <field class="com.itextpdf.text.PageSize" name="ROYAL_OCTAVO" map="S"/>
  <field class="com.itextpdf.text.PageSize" name="DEMY_QUARTO" map="T"/>
  <field class="com.itextpdf.text.PageSize" name="DEMY_OCTAVO" map="U"/>
  <field class="com.itextpdf.text.PageSize" name="ARCH_E" map="V"/>
  <field class="com.itextpdf.text.PageSize" name="ROYAL_QUARTO" map="W"/>
  <field class="com.itextpdf.text.PageSize" name="ARCH_D" map="X"/>
  <field class="com.itextpdf.text.PageSize" name="ARCH_C" map="Y"/>
  <field class="com.itextpdf.text.PageSize" name="ID_3" map="Z"/>
  <field class="com.itextpdf.text.PageSize" name="ARCH_B" map="_"/>
  <field class="com.itextpdf.text.PageSize" name="ID_2" map="a"/>
  <field class="com.itextpdf.text.PageSize" name="ARCH_A" map="b"/>
  <field class="com.itextpdf.text.PageSize" name="ID_1" map="c"/>
  <field class="com.itextpdf.text.PageSize" name="A4_LANDSCAPE" map="d"/>
  <field class="com.itextpdf.text.PageSize" name="LEDGER" map="e"/>
  <field class="com.itextpdf.text.PageSize" name="LEGAL_LANDSCAPE" map="f"/>
  <field class="com.itextpdf.text.PageSize" name="LETTER" map="g"/>
  <field class="com.itextpdf.text.PageSize" name="PENGUIN_SMALL_PAPERBACK" map="h"/>
  <field class="com.itextpdf.text.PageSize" name="NOTE" map="i"/>
  <field class="com.itextpdf.text.PageSize" name="SMALL_PAPERBACK" map="j"/>
  <field class="com.itextpdf.text.PageSize" name="POSTCARD" map="k"/>
  <field class="com.itextpdf.text.PageSize" name="PENGUIN_LARGE_PAPERBACK" map="l"/>
  <field class="com.itextpdf.text.PageSize" name="B9" map="m"/>
  <field class="com.itextpdf.text.PageSize" name="B10" map="n"/>
  <field class="com.itextpdf.text.PageSize" name="LARGE_CROWN_QUARTO" map="o"/>
  <field class="com.itextpdf.text.PageSize" name="B8" map="p"/>
  <field class="com.itextpdf.text.PageSize" name="LARGE_CROWN_OCTAVO" map="q"/>
  <field class="com.itextpdf.text.PageSize" name="B7" map="r"/>
  <field class="com.itextpdf.text.PageSize" name="B6" map="s"/>
  <field class="com.itextpdf.text.PageSize" name="B5" map="t"/>
  <field class="com.itextpdf.text.PageSize" name="B4" map="u"/>
  <field class="com.itextpdf.text.PageSize" name="B3" map="v"/>
  <field class="com.itextpdf.text.PageSize" name="B2" map="w"/>
  <field class="com.itextpdf.text.PageSize" name="B1" map="x"/>
  <field class="com.itextpdf.text.PageSize" name="B0" map="y"/>
  <field class="com.itextpdf.text.PageSize" name="_11X17" map="z"/>
  <field class="com.itextpdf.text.PageSize" name="A10" map="&#x00a2;"/>
  <field class="com.itextpdf.text.PageSize" name="EXECUTIVE" map="&#x00a3;"/>
  <class name="com.itextpdf.text.RectangleReadOnly" map="F"/>
  <method class="com.itextpdf.text.RectangleReadOnly" name="void throwReadOnlyError()" map="&#x0213;"/>
  <method class="com.itextpdf.text.RectangleReadOnly" name="void setRotation(int)" map="C"/>
  <method class="com.itextpdf.text.RectangleReadOnly" name="void setBackgroundColor(com.itextpdf.text.BaseColor)" map="B"/>
  <method class="com.itextpdf.text.RectangleReadOnly" name="void setBottom(float)" map="F"/>
  <method class="com.itextpdf.text.RectangleReadOnly" name="void setLeft(float)" map="H"/>
  <method class="com.itextpdf.text.RectangleReadOnly" name="void setTop(float)" map="I"/>
  <method class="com.itextpdf.text.RectangleReadOnly" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.RectangleReadOnly" name="void cloneNonPositionParameters(com.itextpdf.text.Rectangle)" map="A"/>
  <method class="com.itextpdf.text.RectangleReadOnly" name="void setRight(float)" map="D"/>
  <class name="com.itextpdf.text.DocWriter" map="G"/>
  <field class="com.itextpdf.text.DocWriter" name="document" map="&#x06c0;"/>
  <field class="com.itextpdf.text.DocWriter" name="pageSize" map="&#x06c1;"/>
  <field class="com.itextpdf.text.DocWriter" name="open" map="&#x06c2;"/>
  <field class="com.itextpdf.text.DocWriter" name="os" map="&#x06c3;"/>
  <field class="com.itextpdf.text.DocWriter" name="pause" map="&#x06c4;"/>
  <field class="com.itextpdf.text.DocWriter" name="closeStream" map="&#x06c5;"/>
  <method class="com.itextpdf.text.DocWriter" name="boolean setMargins(float, float, float, float)" map="E"/>
  <method class="com.itextpdf.text.DocWriter" name="boolean isPaused()" map="&#x01a9;"/>
  <method class="com.itextpdf.text.DocWriter" name="byte[] getISOBytes(java.lang.String)" map="K"/>
  <method class="com.itextpdf.text.DocWriter" name="void close()" map="&#x01a6;"/>
  <method class="com.itextpdf.text.DocWriter" name="void open()" map="&#x01a7;"/>
  <method class="com.itextpdf.text.DocWriter" name="boolean setPageSize(com.itextpdf.text.Rectangle)" map="D"/>
  <method class="com.itextpdf.text.DocWriter" name="boolean add(com.itextpdf.text.Element)" map="C"/>
  <method class="com.itextpdf.text.DocWriter" name="boolean newPage()" map="&#x01a8;"/>
  <class name="com.itextpdf.text.ListBody" map="H"/>
  <method class="com.itextpdf.text.ListBody" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.ListBody" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.ListBody" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.ListBody" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.ListBody" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.ListBody" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.ListBody" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.ListBody" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <class name="com.itextpdf.text.ImgWMF" map="I"/>
  <method class="com.itextpdf.text.ImgWMF" name="void readWMF(com.itextpdf.text.pdf.PdfTemplate)" map="A"/>
  <class name="com.itextpdf.text.Element" map="J"/>
  <method class="com.itextpdf.text.Element" name="boolean isContent()" map="A"/>
  <method class="com.itextpdf.text.Element" name="java.util.List getChunks()" map="B"/>
  <method class="com.itextpdf.text.Element" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.Element" name="int type()" map="C"/>
  <method class="com.itextpdf.text.Element" name="boolean process(com.itextpdf.text.ElementListener)" map="A"/>
  <class name="com.itextpdf.text.FontFactoryImp" map="K"/>
  <field class="com.itextpdf.text.FontFactoryImp" name="LOGGER" map="A"/>
  <field class="com.itextpdf.text.FontFactoryImp" name="TTFamilyOrder" map="B"/>
  <field class="com.itextpdf.text.FontFactoryImp" name="defaultEmbedding" map="C"/>
  <field class="com.itextpdf.text.FontFactoryImp" name="trueTypeFonts" map="D"/>
  <field class="com.itextpdf.text.FontFactoryImp" name="defaultEncoding" map="E"/>
  <field class="com.itextpdf.text.FontFactoryImp" name="fontFamilies" map="F"/>
  <method class="com.itextpdf.text.FontFactoryImp" name="boolean saveCopyOfRegularFont(java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.FontFactoryImp" name="com.itextpdf.text.Font getFont(java.lang.String, java.lang.String, boolean, float, int, com.itextpdf.text.BaseColor)" map="A"/>
  <method class="com.itextpdf.text.FontFactoryImp" name="void register(java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.FontFactoryImp" name="int registerDirectory(java.lang.String, boolean)" map="A"/>
  <method class="com.itextpdf.text.FontFactoryImp" name="com.itextpdf.text.Font getFont(java.lang.String, java.lang.String, boolean, float, int, com.itextpdf.text.BaseColor, boolean)" map="A"/>
  <method class="com.itextpdf.text.FontFactoryImp" name="com.itextpdf.text.pdf.BaseFont getBaseFont(java.lang.String, java.lang.String, boolean, boolean)" map="A"/>
  <method class="com.itextpdf.text.FontFactoryImp" name="int registerDirectories()" map="A"/>
  <method class="com.itextpdf.text.FontFactoryImp" name="int registerDirectory(java.lang.String)" map="B"/>
  <method class="com.itextpdf.text.FontFactoryImp" name="void registerFamily(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="com.itextpdf.text.FontFactoryImp" name="void register(java.lang.String, java.lang.String)" map="B"/>
  <class name="com.itextpdf.text.ListItem" map="L"/>
  <method class="com.itextpdf.text.ListItem" name="com.itextpdf.text.ListLabel getListLabel()" map="&#x00ba;"/>
  <method class="com.itextpdf.text.ListItem" name="com.itextpdf.text.ListBody getListBody()" map="&#x00c0;"/>
  <method class="com.itextpdf.text.ListItem" name="com.itextpdf.text.Chunk getListSymbol()" map="&#x00c1;"/>
  <class name="com.itextpdf.text.ElementListener" map="M"/>
  <method class="com.itextpdf.text.ElementListener" name="boolean add(com.itextpdf.text.Element)" map="C"/>
  <class name="com.itextpdf.text.AccessibleElementId" map="N"/>
  <field class="com.itextpdf.text.AccessibleElementId" name="id_counter" map="A"/>
  <field class="com.itextpdf.text.AccessibleElementId" name="id" map="B"/>
  <method class="com.itextpdf.text.AccessibleElementId" name="int compareTo(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.AccessibleElementId" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="com.itextpdf.text.AccessibleElementId" name="int hashCode()" map="hashCode"/>
  <method class="com.itextpdf.text.AccessibleElementId" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.AccessibleElementId" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <class name="com.itextpdf.text.List" map="O"/>
  <method class="com.itextpdf.text.List" name="com.itextpdf.text.ListItem getFirstItem()" map="&#x00ea;"/>
  <method class="com.itextpdf.text.List" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.List" name="int type()" map="C"/>
  <method class="com.itextpdf.text.List" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.List" name="boolean isAutoindent()" map="&#x00eb;"/>
  <method class="com.itextpdf.text.List" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.List" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <method class="com.itextpdf.text.List" name="boolean isLowercase()" map="&#x00ec;"/>
  <method class="com.itextpdf.text.List" name="java.util.ArrayList getItems()" map="&#x00ed;"/>
  <method class="com.itextpdf.text.List" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.List" name="void normalizeIndentation()" map="&#x00ee;"/>
  <method class="com.itextpdf.text.List" name="boolean isContent()" map="A"/>
  <method class="com.itextpdf.text.List" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.List" name="float getIndentationRight()" map="&#x00ef;"/>
  <method class="com.itextpdf.text.List" name="com.itextpdf.text.ListItem getLastItem()" map="&#x00f0;"/>
  <method class="com.itextpdf.text.List" name="void setIndentationRight(float)" map="S"/>
  <method class="com.itextpdf.text.List" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.List" name="boolean isAlignindent()" map="&#x00f1;"/>
  <method class="com.itextpdf.text.List" name="boolean isLettered()" map="&#x00f2;"/>
  <method class="com.itextpdf.text.List" name="boolean isNumbered()" map="&#x00f3;"/>
  <method class="com.itextpdf.text.List" name="float getIndentationLeft()" map="&#x00f4;"/>
  <method class="com.itextpdf.text.List" name="void setIndentationLeft(float)" map="T"/>
  <method class="com.itextpdf.text.List" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.List" name="java.util.List getChunks()" map="B"/>
  <method class="com.itextpdf.text.List" name="boolean process(com.itextpdf.text.ElementListener)" map="A"/>
  <class name="com.itextpdf.text.Section" map="P"/>
  <method class="com.itextpdf.text.Section" name="boolean isComplete()" map="e"/>
  <method class="com.itextpdf.text.Section" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.Section" name="int type()" map="C"/>
  <method class="com.itextpdf.text.Section" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.Section" name="int getDepth()" map="g"/>
  <method class="com.itextpdf.text.Section" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.Section" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <method class="com.itextpdf.text.Section" name="com.itextpdf.text.Paragraph getTitle()" map="h"/>
  <method class="com.itextpdf.text.Section" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.Section" name="boolean isContent()" map="A"/>
  <method class="com.itextpdf.text.Section" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.Section" name="float getIndentationRight()" map="i"/>
  <method class="com.itextpdf.text.Section" name="float getIndentation()" map="j"/>
  <method class="com.itextpdf.text.Section" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.Section" name="void flushContent()" map="f"/>
  <method class="com.itextpdf.text.Section" name="float getIndentationLeft()" map="k"/>
  <method class="com.itextpdf.text.Section" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.Section" name="java.util.List getChunks()" map="B"/>
  <method class="com.itextpdf.text.Section" name="boolean process(com.itextpdf.text.ElementListener)" map="A"/>
  <method class="com.itextpdf.text.Section" name="boolean isBookmarkOpen()" map="l"/>
  <method class="com.itextpdf.text.Section" name="boolean isNotAddedYet()" map="m"/>
  <method class="com.itextpdf.text.Section" name="boolean isTriggerNewPage()" map="n"/>
  <method class="com.itextpdf.text.Section" name="com.itextpdf.text.Paragraph getBookmarkTitle()" map="o"/>
  <class name="com.itextpdf.text.DocListener" map="Q"/>
  <method class="com.itextpdf.text.DocListener" name="boolean setMargins(float, float, float, float)" map="E"/>
  <method class="com.itextpdf.text.DocListener" name="void close()" map="&#x01a6;"/>
  <method class="com.itextpdf.text.DocListener" name="void open()" map="&#x01a7;"/>
  <method class="com.itextpdf.text.DocListener" name="boolean setPageSize(com.itextpdf.text.Rectangle)" map="D"/>
  <method class="com.itextpdf.text.DocListener" name="boolean newPage()" map="&#x01a8;"/>
  <class name="com.itextpdf.text.ListLabel" map="R"/>
  <method class="com.itextpdf.text.ListLabel" name="void setIndentation(float)" map="j"/>
  <method class="com.itextpdf.text.ListLabel" name="float getIndentation()" map="&#x01a5;"/>
  <class name="com.itextpdf.text.Rectangle" map="S"/>
  <field class="com.itextpdf.text.Rectangle" name="borderColor" map="A"/>
  <field class="com.itextpdf.text.Rectangle" name="useVariableBorders" map="B"/>
  <field class="com.itextpdf.text.Rectangle" name="borderWidthBottom" map="C"/>
  <field class="com.itextpdf.text.Rectangle" name="backgroundColor" map="D"/>
  <field class="com.itextpdf.text.Rectangle" name="borderWidthRight" map="E"/>
  <field class="com.itextpdf.text.Rectangle" name="borderColorLeft" map="F"/>
  <field class="com.itextpdf.text.Rectangle" name="borderColorBottom" map="G"/>
  <field class="com.itextpdf.text.Rectangle" name="borderWidthLeft" map="H"/>
  <field class="com.itextpdf.text.Rectangle" name="borderWidthTop" map="I"/>
  <field class="com.itextpdf.text.Rectangle" name="rotation" map="J"/>
  <field class="com.itextpdf.text.Rectangle" name="border" map="K"/>
  <field class="com.itextpdf.text.Rectangle" name="borderColorTop" map="L"/>
  <field class="com.itextpdf.text.Rectangle" name="borderColorRight" map="M"/>
  <field class="com.itextpdf.text.Rectangle" name="lly" map="N"/>
  <field class="com.itextpdf.text.Rectangle" name="llx" map="O"/>
  <field class="com.itextpdf.text.Rectangle" name="ury" map="P"/>
  <field class="com.itextpdf.text.Rectangle" name="urx" map="Q"/>
  <field class="com.itextpdf.text.Rectangle" name="borderWidth" map="R"/>
  <method class="com.itextpdf.text.Rectangle" name="float getHeight()" map="D"/>
  <method class="com.itextpdf.text.Rectangle" name="void cloneNonPositionParameters(com.itextpdf.text.Rectangle)" map="A"/>
  <method class="com.itextpdf.text.Rectangle" name="boolean hasBorder(int)" map="A"/>
  <method class="com.itextpdf.text.Rectangle" name="float getBorderWidthTop()" map="E"/>
  <method class="com.itextpdf.text.Rectangle" name="com.itextpdf.text.BaseColor getBorderColorBottom()" map="F"/>
  <method class="com.itextpdf.text.Rectangle" name="float getBorderWidthBottom()" map="G"/>
  <method class="com.itextpdf.text.Rectangle" name="com.itextpdf.text.BaseColor getBorderColorRight()" map="H"/>
  <method class="com.itextpdf.text.Rectangle" name="float getRight(float)" map="A"/>
  <method class="com.itextpdf.text.Rectangle" name="float getWidth()" map="I"/>
  <method class="com.itextpdf.text.Rectangle" name="float getTop()" map="J"/>
  <method class="com.itextpdf.text.Rectangle" name="float getBottom()" map="K"/>
  <method class="com.itextpdf.text.Rectangle" name="float getBottom(float)" map="B"/>
  <method class="com.itextpdf.text.Rectangle" name="float getVariableBorderWidth(float, int)" map="A"/>
  <method class="com.itextpdf.text.Rectangle" name="void setBorderWidth(float)" map="C"/>
  <method class="com.itextpdf.text.Rectangle" name="com.itextpdf.text.BaseColor getBorderColorTop()" map="L"/>
  <method class="com.itextpdf.text.Rectangle" name="void setBorderColor(com.itextpdf.text.BaseColor)" map="A"/>
  <method class="com.itextpdf.text.Rectangle" name="com.itextpdf.text.BaseColor getBackgroundColor()" map="M"/>
  <method class="com.itextpdf.text.Rectangle" name="float getBorderWidthLeft()" map="N"/>
  <method class="com.itextpdf.text.Rectangle" name="void setBorder(int)" map="B"/>
  <method class="com.itextpdf.text.Rectangle" name="com.itextpdf.text.BaseColor getBorderColor()" map="O"/>
  <method class="com.itextpdf.text.Rectangle" name="com.itextpdf.text.Rectangle rotate()" map="P"/>
  <method class="com.itextpdf.text.Rectangle" name="void setRight(float)" map="D"/>
  <method class="com.itextpdf.text.Rectangle" name="boolean isUseVariableBorders()" map="Q"/>
  <method class="com.itextpdf.text.Rectangle" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.Rectangle" name="float getTop(float)" map="E"/>
  <method class="com.itextpdf.text.Rectangle" name="void setBottom(float)" map="F"/>
  <method class="com.itextpdf.text.Rectangle" name="void setBackgroundColor(com.itextpdf.text.BaseColor)" map="B"/>
  <method class="com.itextpdf.text.Rectangle" name="void setRotation(int)" map="C"/>
  <method class="com.itextpdf.text.Rectangle" name="boolean isContent()" map="A"/>
  <method class="com.itextpdf.text.Rectangle" name="float getRight()" map="R"/>
  <method class="com.itextpdf.text.Rectangle" name="float getBorderWidth()" map="S"/>
  <method class="com.itextpdf.text.Rectangle" name="float getLeft(float)" map="G"/>
  <method class="com.itextpdf.text.Rectangle" name="void setLeft(float)" map="H"/>
  <method class="com.itextpdf.text.Rectangle" name="boolean hasBorders()" map="T"/>
  <method class="com.itextpdf.text.Rectangle" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="com.itextpdf.text.Rectangle" name="float getLeft()" map="U"/>
  <method class="com.itextpdf.text.Rectangle" name="int getRotation()" map="V"/>
  <method class="com.itextpdf.text.Rectangle" name="int type()" map="C"/>
  <method class="com.itextpdf.text.Rectangle" name="int getBorder()" map="W"/>
  <method class="com.itextpdf.text.Rectangle" name="float getBorderWidthRight()" map="X"/>
  <method class="com.itextpdf.text.Rectangle" name="boolean process(com.itextpdf.text.ElementListener)" map="A"/>
  <method class="com.itextpdf.text.Rectangle" name="void setTop(float)" map="I"/>
  <method class="com.itextpdf.text.Rectangle" name="java.util.List getChunks()" map="B"/>
  <method class="com.itextpdf.text.Rectangle" name="com.itextpdf.text.BaseColor getBorderColorLeft()" map="Y"/>
  <class name="com.itextpdf.text.FontProvider" map="T"/>
  <class name="com.itextpdf.text.MarkedSection" map="U"/>
  <method class="com.itextpdf.text.MarkedSection" name="com.itextpdf.text.MarkedObject getTitle()" map="p"/>
  <class name="com.itextpdf.text.WritableDirectElement" map="V"/>
  <method class="com.itextpdf.text.WritableDirectElement" name="boolean isContent()" map="A"/>
  <method class="com.itextpdf.text.WritableDirectElement" name="java.util.List getChunks()" map="B"/>
  <method class="com.itextpdf.text.WritableDirectElement" name="int type()" map="C"/>
  <method class="com.itextpdf.text.WritableDirectElement" name="int getDirectElementType()" map="&#x0216;"/>
  <method class="com.itextpdf.text.WritableDirectElement" name="boolean process(com.itextpdf.text.ElementListener)" map="A"/>
  <class name="com.itextpdf.text.SplitCharacter" map="W"/>
  <method class="com.itextpdf.text.SplitCharacter" name="boolean isSplitCharacter(int, int, int, char[], com.itextpdf.text.pdf.PdfChunk[])" map="A"/>
  <class name="com.itextpdf.text.BaseColor" map="X"/>
  <field class="com.itextpdf.text.BaseColor" name="GREEN" map="A"/>
  <field class="com.itextpdf.text.BaseColor" name="WHITE" map="B"/>
  <field class="com.itextpdf.text.BaseColor" name="MAGENTA" map="C"/>
  <field class="com.itextpdf.text.BaseColor" name="ORANGE" map="D"/>
  <field class="com.itextpdf.text.BaseColor" name="LIGHT_GRAY" map="E"/>
  <field class="com.itextpdf.text.BaseColor" name="PINK" map="F"/>
  <field class="com.itextpdf.text.BaseColor" name="BLUE" map="G"/>
  <field class="com.itextpdf.text.BaseColor" name="YELLOW" map="H"/>
  <field class="com.itextpdf.text.BaseColor" name="DARK_GRAY" map="I"/>
  <field class="com.itextpdf.text.BaseColor" name="value" map="J"/>
  <field class="com.itextpdf.text.BaseColor" name="GRAY" map="K"/>
  <field class="com.itextpdf.text.BaseColor" name="CYAN" map="L"/>
  <field class="com.itextpdf.text.BaseColor" name="RED" map="M"/>
  <field class="com.itextpdf.text.BaseColor" name="BLACK" map="N"/>
  <method class="com.itextpdf.text.BaseColor" name="int hashCode()" map="hashCode"/>
  <method class="com.itextpdf.text.BaseColor" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="com.itextpdf.text.BaseColor" name="int getRGB()" map="A"/>
  <method class="com.itextpdf.text.BaseColor" name="void setValue(int, int, int, int)" map="A"/>
  <method class="com.itextpdf.text.BaseColor" name="int getGreen()" map="B"/>
  <method class="com.itextpdf.text.BaseColor" name="void validate(int)" map="A"/>
  <method class="com.itextpdf.text.BaseColor" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.BaseColor" name="int getAlpha()" map="C"/>
  <method class="com.itextpdf.text.BaseColor" name="int getBlue()" map="D"/>
  <method class="com.itextpdf.text.BaseColor" name="int getRed()" map="E"/>
  <class name="com.itextpdf.text.ChapterAutoNumber" map="Y"/>
  <method class="com.itextpdf.text.ChapterAutoNumber" name="int setAutomaticNumber(int)" map="D"/>
  <class name="com.itextpdf.text.MarkedObject" map="Z"/>
  <method class="com.itextpdf.text.MarkedObject" name="boolean isContent()" map="A"/>
  <method class="com.itextpdf.text.MarkedObject" name="java.util.List getChunks()" map="B"/>
  <method class="com.itextpdf.text.MarkedObject" name="int type()" map="C"/>
  <method class="com.itextpdf.text.MarkedObject" name="boolean process(com.itextpdf.text.ElementListener)" map="A"/>
  <class name="com.itextpdf.text.ExceptionConverter" map="_"/>
  <field class="com.itextpdf.text.ExceptionConverter" name="ex" map="A"/>
  <field class="com.itextpdf.text.ExceptionConverter" name="prefix" map="B"/>
  <method class="com.itextpdf.text.ExceptionConverter" name="java.lang.Throwable fillInStackTrace()" map="fillInStackTrace"/>
  <method class="com.itextpdf.text.ExceptionConverter" name="java.lang.RuntimeException convertException(java.lang.Exception)" map="A"/>
  <method class="com.itextpdf.text.ExceptionConverter" name="void printStackTrace()" map="printStackTrace"/>
  <method class="com.itextpdf.text.ExceptionConverter" name="java.lang.String getLocalizedMessage()" map="getLocalizedMessage"/>
  <method class="com.itextpdf.text.ExceptionConverter" name="java.lang.String getMessage()" map="getMessage"/>
  <method class="com.itextpdf.text.ExceptionConverter" name="void printStackTrace(java.io.PrintWriter)" map="printStackTrace"/>
  <method class="com.itextpdf.text.ExceptionConverter" name="void printStackTrace(java.io.PrintStream)" map="printStackTrace"/>
  <method class="com.itextpdf.text.ExceptionConverter" name="java.lang.String toString()" map="toString"/>
  <class name="com.itextpdf.text.Anchor" map="a"/>
  <method class="com.itextpdf.text.Anchor" name="java.lang.String getReference()" map="x"/>
  <class name="com.itextpdf.text.Document" map="b"/>
  <field class="com.itextpdf.text.Document" name="htmlStyleClass" map="&#x000999;"/>
  <field class="com.itextpdf.text.Document" name="marginTop" map="&#x00099a;"/>
  <field class="com.itextpdf.text.Document" name="marginRight" map="&#x00099b;"/>
  <field class="com.itextpdf.text.Document" name="javaScript_onUnLoad" map="&#x00099c;"/>
  <field class="com.itextpdf.text.Document" name="pageN" map="&#x00099d;"/>
  <field class="com.itextpdf.text.Document" name="marginBottom" map="&#x00099e;"/>
  <field class="com.itextpdf.text.Document" name="wmfFontCorrection" map="&#x00099f;"/>
  <field class="com.itextpdf.text.Document" name="accessibleAttributes" map="&#x0009a0;"/>
  <field class="com.itextpdf.text.Document" name="javaScript_onLoad" map="&#x0009a1;"/>
  <field class="com.itextpdf.text.Document" name="open" map="&#x0009a2;"/>
  <field class="com.itextpdf.text.Document" name="close" map="&#x0009a3;"/>
  <field class="com.itextpdf.text.Document" name="marginMirroring" map="&#x0009a4;"/>
  <field class="com.itextpdf.text.Document" name="id" map="&#x0009a5;"/>
  <field class="com.itextpdf.text.Document" name="listeners" map="&#x0009a6;"/>
  <field class="com.itextpdf.text.Document" name="plainRandomAccess" map="&#x0009a7;"/>
  <field class="com.itextpdf.text.Document" name="marginLeft" map="&#x0009a8;"/>
  <field class="com.itextpdf.text.Document" name="marginMirroringTopBottom" map="&#x0009aa;"/>
  <field class="com.itextpdf.text.Document" name="compress" map="&#x0009ab;"/>
  <field class="com.itextpdf.text.Document" name="pageSize" map="&#x0009ac;"/>
  <field class="com.itextpdf.text.Document" name="chapternumber" map="&#x0009ad;"/>
  <field class="com.itextpdf.text.Document" name="role" map="&#x0009ae;"/>
  <method class="com.itextpdf.text.Document" name="float top()" map="&#x01cf;"/>
  <method class="com.itextpdf.text.Document" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.Document" name="float left(float)" map="k"/>
  <method class="com.itextpdf.text.Document" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.Document" name="boolean addCreationDate()" map="&#x01d0;"/>
  <method class="com.itextpdf.text.Document" name="boolean addProducer()" map="&#x01d1;"/>
  <method class="com.itextpdf.text.Document" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.Document" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <method class="com.itextpdf.text.Document" name="int getPageNumber()" map="&#x01d2;"/>
  <method class="com.itextpdf.text.Document" name="void close()" map="&#x01a6;"/>
  <method class="com.itextpdf.text.Document" name="float top(float)" map="l"/>
  <method class="com.itextpdf.text.Document" name="boolean addTitle(java.lang.String)" map="L"/>
  <method class="com.itextpdf.text.Document" name="boolean setMargins(float, float, float, float)" map="E"/>
  <method class="com.itextpdf.text.Document" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.Document" name="float bottom(float)" map="m"/>
  <method class="com.itextpdf.text.Document" name="boolean add(com.itextpdf.text.Element)" map="C"/>
  <method class="com.itextpdf.text.Document" name="boolean newPage()" map="&#x01a8;"/>
  <method class="com.itextpdf.text.Document" name="boolean addCreator(java.lang.String)" map="M"/>
  <method class="com.itextpdf.text.Document" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.Document" name="void open()" map="&#x01a7;"/>
  <method class="com.itextpdf.text.Document" name="void addDocListener(com.itextpdf.text.DocListener)" map="A"/>
  <method class="com.itextpdf.text.Document" name="float right(float)" map="n"/>
  <method class="com.itextpdf.text.Document" name="boolean addSubject(java.lang.String)" map="N"/>
  <method class="com.itextpdf.text.Document" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.Document" name="float left()" map="&#x01d3;"/>
  <method class="com.itextpdf.text.Document" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.Document" name="boolean addAuthor(java.lang.String)" map="O"/>
  <method class="com.itextpdf.text.Document" name="boolean setPageSize(com.itextpdf.text.Rectangle)" map="D"/>
  <class name="com.itextpdf.text.Annotation" map="c"/>
  <field class="com.itextpdf.text.Annotation" name="annotationtype" map="&#x000aa2;"/>
  <field class="com.itextpdf.text.Annotation" name="ury" map="&#x000aa3;"/>
  <field class="com.itextpdf.text.Annotation" name="urx" map="&#x000aa4;"/>
  <field class="com.itextpdf.text.Annotation" name="annotationAttributes" map="&#x000aa5;"/>
  <field class="com.itextpdf.text.Annotation" name="lly" map="&#x000aa6;"/>
  <field class="com.itextpdf.text.Annotation" name="llx" map="&#x000aa7;"/>
  <method class="com.itextpdf.text.Annotation" name="float urx()" map="&#x0217;"/>
  <method class="com.itextpdf.text.Annotation" name="int type()" map="C"/>
  <method class="com.itextpdf.text.Annotation" name="java.lang.String title()" map="&#x0250;"/>
  <method class="com.itextpdf.text.Annotation" name="void setDimensions(float, float, float, float)" map="F"/>
  <method class="com.itextpdf.text.Annotation" name="float ury(float)" map="s"/>
  <method class="com.itextpdf.text.Annotation" name="boolean isContent()" map="A"/>
  <method class="com.itextpdf.text.Annotation" name="float urx(float)" map="t"/>
  <method class="com.itextpdf.text.Annotation" name="java.util.HashMap attributes()" map="&#x0251;"/>
  <method class="com.itextpdf.text.Annotation" name="float lly()" map="&#x0252;"/>
  <method class="com.itextpdf.text.Annotation" name="boolean process(com.itextpdf.text.ElementListener)" map="A"/>
  <method class="com.itextpdf.text.Annotation" name="int annotationType()" map="&#x0253;"/>
  <method class="com.itextpdf.text.Annotation" name="float lly(float)" map="u"/>
  <method class="com.itextpdf.text.Annotation" name="float ury()" map="&#x0254;"/>
  <method class="com.itextpdf.text.Annotation" name="java.util.List getChunks()" map="B"/>
  <method class="com.itextpdf.text.Annotation" name="float llx()" map="&#x0255;"/>
  <method class="com.itextpdf.text.Annotation" name="java.lang.String content()" map="&#x0256;"/>
  <method class="com.itextpdf.text.Annotation" name="float llx(float)" map="v"/>
  <class name="com.itextpdf.text.DocumentException" map="d"/>
  <class name="com.itextpdf.text.Chapter" map="e"/>
  <class name="com.itextpdf.text.TabStop$1" map="1"/>
  <field class="com.itextpdf.text.TabStop$1" name="$SwitchMap$com$itextpdf$text$TabStop$Alignment" map="A"/>
  <class name="com.itextpdf.text.TabStop$Alignment" map="_A"/>
  <field class="com.itextpdf.text.TabStop$Alignment" name="ANCHOR" map="A"/>
  <field class="com.itextpdf.text.TabStop$Alignment" name="LEFT" map="B"/>
  <field class="com.itextpdf.text.TabStop$Alignment" name="$VALUES" map="C"/>
  <field class="com.itextpdf.text.TabStop$Alignment" name="RIGHT" map="D"/>
  <field class="com.itextpdf.text.TabStop$Alignment" name="CENTER" map="E"/>
  <method class="com.itextpdf.text.TabStop$Alignment" name="com.itextpdf.text.TabStop$Alignment valueOf(java.lang.String)" map="valueOf"/>
  <method class="com.itextpdf.text.TabStop$Alignment" name="com.itextpdf.text.TabStop$Alignment[] values()" map="values"/>
  <class name="com.itextpdf.text.TabStop" map="f"/>
  <field class="com.itextpdf.text.TabStop" name="position" map="A"/>
  <field class="com.itextpdf.text.TabStop" name="anchorChar" map="B"/>
  <field class="com.itextpdf.text.TabStop" name="leader" map="C"/>
  <field class="com.itextpdf.text.TabStop" name="alignment" map="D"/>
  <method class="com.itextpdf.text.TabStop" name="float getPosition(float, float, float)" map="A"/>
  <method class="com.itextpdf.text.TabStop" name="char getAnchorChar()" map="A"/>
  <method class="com.itextpdf.text.TabStop" name="com.itextpdf.text.pdf.draw.DrawInterface getLeader()" map="B"/>
  <method class="com.itextpdf.text.TabStop" name="com.itextpdf.text.TabStop newInstance(float, float)" map="A"/>
  <method class="com.itextpdf.text.TabStop" name="com.itextpdf.text.TabStop$Alignment getAlignment()" map="C"/>
  <method class="com.itextpdf.text.TabStop" name="void setPosition(float)" map="A"/>
  <method class="com.itextpdf.text.TabStop" name="float getPosition()" map="D"/>
  <class name="com.itextpdf.text.Paragraph" map="g"/>
  <field class="com.itextpdf.text.Paragraph" name="indentationRight" map="X"/>
  <field class="com.itextpdf.text.Paragraph" name="id" map="Y"/>
  <field class="com.itextpdf.text.Paragraph" name="accessibleAttributes" map="Z"/>
  <field class="com.itextpdf.text.Paragraph" name="role" map="_"/>
  <field class="com.itextpdf.text.Paragraph" name="indentationLeft" map="a"/>
  <field class="com.itextpdf.text.Paragraph" name="spacingAfter" map="b"/>
  <field class="com.itextpdf.text.Paragraph" name="extraParagraphSpace" map="c"/>
  <field class="com.itextpdf.text.Paragraph" name="keeptogether" map="d"/>
  <field class="com.itextpdf.text.Paragraph" name="alignment" map="e"/>
  <field class="com.itextpdf.text.Paragraph" name="spacingBefore" map="f"/>
  <field class="com.itextpdf.text.Paragraph" name="paddingTop" map="g"/>
  <field class="com.itextpdf.text.Paragraph" name="firstLineIndent" map="h"/>
  <method class="com.itextpdf.text.Paragraph" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.Paragraph" name="int type()" map="C"/>
  <method class="com.itextpdf.text.Paragraph" name="boolean add(java.lang.Object)" map="add"/>
  <method class="com.itextpdf.text.Paragraph" name="float getExtraParagraphSpace()" map="y"/>
  <method class="com.itextpdf.text.Paragraph" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.Paragraph" name="void setKeepTogether(boolean)" map="A"/>
  <method class="com.itextpdf.text.Paragraph" name="void setSpacingAfter(float)" map="J"/>
  <method class="com.itextpdf.text.Paragraph" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.Paragraph" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <method class="com.itextpdf.text.Paragraph" name="void setExtraParagraphSpace(float)" map="K"/>
  <method class="com.itextpdf.text.Paragraph" name="com.itextpdf.text.Paragraph cloneShallow(boolean)" map="B"/>
  <method class="com.itextpdf.text.Paragraph" name="float getSpacingAfter()" map="z"/>
  <method class="com.itextpdf.text.Paragraph" name="int getAlignment()" map="&#x00a2;"/>
  <method class="com.itextpdf.text.Paragraph" name="void setFirstLineIndent(float)" map="L"/>
  <method class="com.itextpdf.text.Paragraph" name="void setSpacingBefore(float)" map="M"/>
  <method class="com.itextpdf.text.Paragraph" name="java.util.List breakUp()" map="&#x00a3;"/>
  <method class="com.itextpdf.text.Paragraph" name="boolean getKeepTogether()" map="&#x00a4;"/>
  <method class="com.itextpdf.text.Paragraph" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.Paragraph" name="boolean add(com.itextpdf.text.Element)" map="B"/>
  <method class="com.itextpdf.text.Paragraph" name="float getPaddingTop()" map="c"/>
  <method class="com.itextpdf.text.Paragraph" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.Paragraph" name="float getIndentationRight()" map="&#x00a5;"/>
  <method class="com.itextpdf.text.Paragraph" name="float getSpacingBefore()" map="d"/>
  <method class="com.itextpdf.text.Paragraph" name="void setIndentationRight(float)" map="N"/>
  <method class="com.itextpdf.text.Paragraph" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.Paragraph" name="void setAlignment(int)" map="E"/>
  <method class="com.itextpdf.text.Paragraph" name="float getFirstLineIndent()" map="&#x00aa;"/>
  <method class="com.itextpdf.text.Paragraph" name="float getIndentationLeft()" map="&#x00b5;"/>
  <method class="com.itextpdf.text.Paragraph" name="void setIndentationLeft(float)" map="O"/>
  <method class="com.itextpdf.text.Paragraph" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.Paragraph" name="void populateProperties(com.itextpdf.text.Paragraph, boolean)" map="A"/>
  <class name="com.itextpdf.text.Font$1" map="1"/>
  <field class="com.itextpdf.text.Font$1" name="$SwitchMap$com$itextpdf$text$Font$FontFamily" map="A"/>
  <class name="com.itextpdf.text.Font$FontFamily" map="_A"/>
  <field class="com.itextpdf.text.Font$FontFamily" name="ZAPFDINGBATS" map="A"/>
  <field class="com.itextpdf.text.Font$FontFamily" name="TIMES_ROMAN" map="B"/>
  <field class="com.itextpdf.text.Font$FontFamily" name="HELVETICA" map="C"/>
  <field class="com.itextpdf.text.Font$FontFamily" name="$VALUES" map="D"/>
  <field class="com.itextpdf.text.Font$FontFamily" name="UNDEFINED" map="E"/>
  <field class="com.itextpdf.text.Font$FontFamily" name="SYMBOL" map="F"/>
  <field class="com.itextpdf.text.Font$FontFamily" name="COURIER" map="G"/>
  <method class="com.itextpdf.text.Font$FontFamily" name="com.itextpdf.text.Font$FontFamily valueOf(java.lang.String)" map="valueOf"/>
  <method class="com.itextpdf.text.Font$FontFamily" name="com.itextpdf.text.Font$FontFamily[] values()" map="values"/>
  <class name="com.itextpdf.text.Font" map="h"/>
  <field class="com.itextpdf.text.Font" name="color" map="A"/>
  <field class="com.itextpdf.text.Font" name="baseFont" map="B"/>
  <field class="com.itextpdf.text.Font" name="size" map="C"/>
  <field class="com.itextpdf.text.Font" name="style" map="D"/>
  <field class="com.itextpdf.text.Font" name="family" map="E"/>
  <method class="com.itextpdf.text.Font" name="boolean isUnderlined()" map="A"/>
  <method class="com.itextpdf.text.Font" name="com.itextpdf.text.pdf.BaseFont getCalculatedBaseFont(boolean)" map="A"/>
  <method class="com.itextpdf.text.Font" name="boolean isStrikethru()" map="B"/>
  <method class="com.itextpdf.text.Font" name="float getCalculatedSize()" map="C"/>
  <method class="com.itextpdf.text.Font" name="int getStyle()" map="D"/>
  <method class="com.itextpdf.text.Font" name="void setStyle(int)" map="A"/>
  <method class="com.itextpdf.text.Font" name="com.itextpdf.text.BaseColor getColor()" map="E"/>
  <method class="com.itextpdf.text.Font" name="com.itextpdf.text.Font$FontFamily getFamily()" map="F"/>
  <method class="com.itextpdf.text.Font" name="float getCalculatedLeading(float)" map="A"/>
  <method class="com.itextpdf.text.Font" name="java.lang.String getFamilyname()" map="G"/>
  <method class="com.itextpdf.text.Font" name="int compareTo(com.itextpdf.text.Font)" map="A"/>
  <method class="com.itextpdf.text.Font" name="com.itextpdf.text.Font difference(com.itextpdf.text.Font)" map="B"/>
  <method class="com.itextpdf.text.Font" name="void setColor(com.itextpdf.text.BaseColor)" map="A"/>
  <method class="com.itextpdf.text.Font" name="float getSize()" map="H"/>
  <method class="com.itextpdf.text.Font" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <method class="com.itextpdf.text.Font" name="com.itextpdf.text.pdf.BaseFont getBaseFont()" map="I"/>
  <method class="com.itextpdf.text.Font" name="boolean isStandardFont()" map="J"/>
  <class name="com.itextpdf.text.Chunk" map="i"/>
  <field class="com.itextpdf.text.Chunk" name="SPACETABBING" map="&#x000a33;"/>
  <field class="com.itextpdf.text.Chunk" name="id" map="&#x000a35;"/>
  <field class="com.itextpdf.text.Chunk" name="TABBING" map="&#x000a36;"/>
  <field class="com.itextpdf.text.Chunk" name="font" map="&#x000a38;"/>
  <field class="com.itextpdf.text.Chunk" name="contentWithNoTabs" map="&#x000a39;"/>
  <field class="com.itextpdf.text.Chunk" name="accessibleAttributes" map="&#x000a59;"/>
  <field class="com.itextpdf.text.Chunk" name="attributes" map="&#x000a5a;"/>
  <field class="com.itextpdf.text.Chunk" name="role" map="&#x000a5b;"/>
  <field class="com.itextpdf.text.Chunk" name="content" map="&#x000a5c;"/>
  <field class="com.itextpdf.text.Chunk" name="NEXTPAGE" map="&#x000a5e;"/>
  <field class="com.itextpdf.text.Chunk" name="NEWLINE" map="&#x000a72;"/>
  <method class="com.itextpdf.text.Chunk" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.Chunk" name="int type()" map="C"/>
  <method class="com.itextpdf.text.Chunk" name="boolean hasAccessibleAttributes()" map="&#x01eb;"/>
  <method class="com.itextpdf.text.Chunk" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.Chunk" name="com.itextpdf.text.Font getFont()" map="&#x01ec;"/>
  <method class="com.itextpdf.text.Chunk" name="com.itextpdf.text.Chunk setHyphenation(com.itextpdf.text.pdf.HyphenationEvent)" map="B"/>
  <method class="com.itextpdf.text.Chunk" name="boolean hasAttributes()" map="&#x01ed;"/>
  <method class="com.itextpdf.text.Chunk" name="void setAttributes(java.util.HashMap)" map="A"/>
  <method class="com.itextpdf.text.Chunk" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.Chunk" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <method class="com.itextpdf.text.Chunk" name="void setFont(com.itextpdf.text.Font)" map="B"/>
  <method class="com.itextpdf.text.Chunk" name="java.lang.String getContent()" map="&#x01ee;"/>
  <method class="com.itextpdf.text.Chunk" name="java.util.HashMap getAttributes()" map="&#x01ef;"/>
  <method class="com.itextpdf.text.Chunk" name="java.lang.String toString()" map="toString"/>
  <method class="com.itextpdf.text.Chunk" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.Chunk" name="boolean isContent()" map="A"/>
  <method class="com.itextpdf.text.Chunk" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.Chunk" name="com.itextpdf.text.Image getImage()" map="&#x01f0;"/>
  <method class="com.itextpdf.text.Chunk" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.Chunk" name="com.itextpdf.text.pdf.HyphenationEvent getHyphenation()" map="&#x01f1;"/>
  <method class="com.itextpdf.text.Chunk" name="boolean isEmpty()" map="&#x01f2;"/>
  <method class="com.itextpdf.text.Chunk" name="com.itextpdf.text.Chunk setNewPage()" map="&#x01f3;"/>
  <method class="com.itextpdf.text.Chunk" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.Chunk" name="java.lang.StringBuffer append(java.lang.String)" map="R"/>
  <method class="com.itextpdf.text.Chunk" name="com.itextpdf.text.Chunk setAttribute(java.lang.String, java.lang.Object)" map="A"/>
  <method class="com.itextpdf.text.Chunk" name="java.util.List getChunks()" map="B"/>
  <method class="com.itextpdf.text.Chunk" name="boolean process(com.itextpdf.text.ElementListener)" map="A"/>
  <class name="com.itextpdf.text.Version" map="j"/>
  <field class="com.itextpdf.text.Version" name="release" map="A"/>
  <field class="com.itextpdf.text.Version" name="AGPL" map="B"/>
  <field class="com.itextpdf.text.Version" name="version" map="C"/>
  <field class="com.itextpdf.text.Version" name="key" map="D"/>
  <field class="com.itextpdf.text.Version" name="iTextVersion" map="E"/>
  <field class="com.itextpdf.text.Version" name="iText" map="F"/>
  <method class="com.itextpdf.text.Version" name="boolean isAGPLVersion()" map="A"/>
  <method class="com.itextpdf.text.Version" name="java.lang.String getVersion()" map="B"/>
  <method class="com.itextpdf.text.Version" name="com.itextpdf.text.Version getInstance()" map="C"/>
  <method class="com.itextpdf.text.Version" name="java.lang.String getKey()" map="D"/>
  <method class="com.itextpdf.text.Version" name="java.lang.String getRelease()" map="E"/>
  <class name="com.itextpdf.text.TabSplitCharacter" map="k"/>
  <field class="com.itextpdf.text.TabSplitCharacter" name="TAB" map="A"/>
  <method class="com.itextpdf.text.TabSplitCharacter" name="boolean isSplitCharacter(int, int, int, char[], com.itextpdf.text.pdf.PdfChunk[])" map="A"/>
  <class name="com.itextpdf.text.Phrase" map="l"/>
  <field class="com.itextpdf.text.Phrase" name="font" map="S"/>
  <field class="com.itextpdf.text.Phrase" name="multipliedLeading" map="T"/>
  <field class="com.itextpdf.text.Phrase" name="hyphenation" map="U"/>
  <field class="com.itextpdf.text.Phrase" name="tabSettings" map="V"/>
  <field class="com.itextpdf.text.Phrase" name="leading" map="W"/>
  <method class="com.itextpdf.text.Phrase" name="int type()" map="C"/>
  <method class="com.itextpdf.text.Phrase" name="boolean add(java.lang.Object)" map="add"/>
  <method class="com.itextpdf.text.Phrase" name="float getLeading()" map="q"/>
  <method class="com.itextpdf.text.Phrase" name="float getTotalLeading()" map="r"/>
  <method class="com.itextpdf.text.Phrase" name="com.itextpdf.text.Font getFont()" map="s"/>
  <method class="com.itextpdf.text.Phrase" name="void setTabSettings(com.itextpdf.text.TabSettings)" map="A"/>
  <method class="com.itextpdf.text.Phrase" name="void add(int, com.itextpdf.text.Element)" map="A"/>
  <method class="com.itextpdf.text.Phrase" name="void setFont(com.itextpdf.text.Font)" map="A"/>
  <method class="com.itextpdf.text.Phrase" name="void addSpecial(com.itextpdf.text.Element)" map="A"/>
  <method class="com.itextpdf.text.Phrase" name="boolean add(com.itextpdf.text.Element)" map="B"/>
  <method class="com.itextpdf.text.Phrase" name="boolean isContent()" map="A"/>
  <method class="com.itextpdf.text.Phrase" name="void setHyphenation(com.itextpdf.text.pdf.HyphenationEvent)" map="A"/>
  <method class="com.itextpdf.text.Phrase" name="boolean addChunk(com.itextpdf.text.Chunk)" map="A"/>
  <method class="com.itextpdf.text.Phrase" name="com.itextpdf.text.pdf.HyphenationEvent getHyphenation()" map="t"/>
  <method class="com.itextpdf.text.Phrase" name="boolean hasLeading()" map="u"/>
  <method class="com.itextpdf.text.Phrase" name="boolean addAll(java.util.Collection)" map="addAll"/>
  <method class="com.itextpdf.text.Phrase" name="float getMultipliedLeading()" map="v"/>
  <method class="com.itextpdf.text.Phrase" name="boolean isEmpty()" map="isEmpty"/>
  <method class="com.itextpdf.text.Phrase" name="void add(int, java.lang.Object)" map="add"/>
  <method class="com.itextpdf.text.Phrase" name="void setLeading(float, float)" map="A"/>
  <method class="com.itextpdf.text.Phrase" name="java.util.List getChunks()" map="B"/>
  <method class="com.itextpdf.text.Phrase" name="boolean process(com.itextpdf.text.ElementListener)" map="A"/>
  <method class="com.itextpdf.text.Phrase" name="com.itextpdf.text.TabSettings getTabSettings()" map="w"/>
  <class name="com.itextpdf.text.ImgJBIG2" map="m"/>
  <method class="com.itextpdf.text.ImgJBIG2" name="byte[] getGlobalBytes()" map="&#x00e9;"/>
  <class name="com.itextpdf.text.Utilities" map="n"/>
  <method class="com.itextpdf.text.Utilities" name="boolean isSurrogateHigh(char)" map="A"/>
  <method class="com.itextpdf.text.Utilities" name="int convertToUtf32(char, char)" map="A"/>
  <method class="com.itextpdf.text.Utilities" name="java.lang.Object[][] addToArray(java.lang.Object[][], java.lang.Object[])" map="A"/>
  <method class="com.itextpdf.text.Utilities" name="char[] copyOfRange(char[], int, int)" map="A"/>
  <method class="com.itextpdf.text.Utilities" name="int convertToUtf32(java.lang.String, int)" map="A"/>
  <method class="com.itextpdf.text.Utilities" name="int convertToUtf32(char[], int)" map="A"/>
  <method class="com.itextpdf.text.Utilities" name="boolean isSurrogateLow(char)" map="B"/>
  <method class="com.itextpdf.text.Utilities" name="boolean isSurrogatePair(char[], int)" map="B"/>
  <method class="com.itextpdf.text.Utilities" name="boolean isSurrogatePair(java.lang.String, int)" map="B"/>
  <class name="com.itextpdf.text.Image" map="o"/>
  <field class="com.itextpdf.text.Image" name="serialId" map="i"/>
  <method class="com.itextpdf.text.Image" name="com.itextpdf.text.AccessibleElementId getId()" map="a"/>
  <method class="com.itextpdf.text.Image" name="float getScaledWidth()" map="&#x00c2;"/>
  <method class="com.itextpdf.text.Image" name="boolean isInverted()" map="&#x00c3;"/>
  <method class="com.itextpdf.text.Image" name="void setAbsolutePosition(float, float)" map="B"/>
  <method class="com.itextpdf.text.Image" name="void setAccessibleAttribute(com.itextpdf.text.pdf.PdfName, com.itextpdf.text.pdf.PdfObject)" map="A"/>
  <method class="com.itextpdf.text.Image" name="com.itextpdf.text.pdf.PdfDictionary getAdditional()" map="&#x00c4;"/>
  <method class="com.itextpdf.text.Image" name="boolean hasAbsoluteX()" map="&#x00c5;"/>
  <method class="com.itextpdf.text.Image" name="boolean isSmask()" map="&#x00c6;"/>
  <method class="com.itextpdf.text.Image" name="float getSpacingAfter()" map="&#x00c7;"/>
  <method class="com.itextpdf.text.Image" name="boolean isScaleToFitHeight()" map="&#x00c8;"/>
  <method class="com.itextpdf.text.Image" name="byte[] getRawData()" map="&#x00c9;"/>
  <method class="com.itextpdf.text.Image" name="boolean isImgRaw()" map="&#x00ca;"/>
  <method class="com.itextpdf.text.Image" name="boolean isInline()" map="Z"/>
  <method class="com.itextpdf.text.Image" name="com.itextpdf.text.pdf.ICC_Profile getICCProfile()" map="&#x00cb;"/>
  <method class="com.itextpdf.text.Image" name="float getAbsoluteX()" map="&#x00cc;"/>
  <method class="com.itextpdf.text.Image" name="boolean isImgTemplate()" map="&#x00cd;"/>
  <method class="com.itextpdf.text.Image" name="int getBpc()" map="&#x00ce;"/>
  <method class="com.itextpdf.text.Image" name="void setRole(com.itextpdf.text.pdf.PdfName)" map="A"/>
  <method class="com.itextpdf.text.Image" name="int[] getTransparency()" map="&#x00cf;"/>
  <method class="com.itextpdf.text.Image" name="int getColorTransform()" map="&#x00d0;"/>
  <method class="com.itextpdf.text.Image" name="float getIndentationLeft()" map="&#x00d1;"/>
  <method class="com.itextpdf.text.Image" name="com.itextpdf.text.pdf.PdfIndirectReference getDirectReference()" map="&#x00d2;"/>
  <method class="com.itextpdf.text.Image" name="boolean isScaleToFitLineWhenOverflow()" map="&#x00d3;"/>
  <method class="com.itextpdf.text.Image" name="void scalePercent(float)" map="P"/>
  <method class="com.itextpdf.text.Image" name="boolean isMask()" map="&#x00d4;"/>
  <method class="com.itextpdf.text.Image" name="java.net.URL getUrl()" map="&#x00d5;"/>
  <method class="com.itextpdf.text.Image" name="boolean hasAbsoluteY()" map="&#x00d6;"/>
  <method class="com.itextpdf.text.Image" name="float getWidthPercentage()" map="&#x00d8;"/>
  <method class="com.itextpdf.text.Image" name="int getAlignment()" map="&#x00d9;"/>
  <method class="com.itextpdf.text.Image" name="com.itextpdf.text.pdf.PdfTemplate getTemplateData()" map="&#x00da;"/>
  <method class="com.itextpdf.text.Image" name="float getSpacingBefore()" map="d"/>
  <method class="com.itextpdf.text.Image" name="float getScaledHeight()" map="&#x00db;"/>
  <method class="com.itextpdf.text.Image" name="java.util.HashMap getAccessibleAttributes()" map="_"/>
  <method class="com.itextpdf.text.Image" name="void setScaleToFitLineWhenOverflow(boolean)" map="C"/>
  <method class="com.itextpdf.text.Image" name="com.itextpdf.text.Annotation getAnnotation()" map="&#x00dc;"/>
  <method class="com.itextpdf.text.Image" name="float getImageRotation()" map="&#x00dd;"/>
  <method class="com.itextpdf.text.Image" name="boolean isDeflated()" map="&#x00de;"/>
  <method class="com.itextpdf.text.Image" name="com.itextpdf.text.Image getImageMask()" map="&#x00df;"/>
  <method class="com.itextpdf.text.Image" name="void setId(com.itextpdf.text.AccessibleElementId)" map="A"/>
  <method class="com.itextpdf.text.Image" name="com.itextpdf.text.pdf.PdfObject getAccessibleAttribute(com.itextpdf.text.pdf.PdfName)" map="B"/>
  <method class="com.itextpdf.text.Image" name="float getAbsoluteY()" map="&#x00e0;"/>
  <method class="com.itextpdf.text.Image" name="com.itextpdf.text.Image getInstance(com.itextpdf.text.Image)" map="A"/>
  <method class="com.itextpdf.text.Image" name="boolean isInterpolation()" map="&#x00e1;"/>
  <method class="com.itextpdf.text.Image" name="int type()" map="C"/>
  <method class="com.itextpdf.text.Image" name="com.itextpdf.text.pdf.PdfName getRole()" map="b"/>
  <method class="com.itextpdf.text.Image" name="com.itextpdf.text.pdf.PdfOCG getLayer()" map="&#x00e2;"/>
  <method class="com.itextpdf.text.Image" name="int getColorspace()" map="&#x00e3;"/>
  <method class="com.itextpdf.text.Image" name="java.lang.Long getMySerialId()" map="&#x00e4;"/>
  <method class="com.itextpdf.text.Image" name="float[] matrix(float)" map="Q"/>
  <method class="com.itextpdf.text.Image" name="boolean hasICCProfile()" map="&#x00e5;"/>
  <method class="com.itextpdf.text.Image" name="float getPaddingTop()" map="c"/>
  <method class="com.itextpdf.text.Image" name="float[] matrix()" map="&#x00e6;"/>
  <method class="com.itextpdf.text.Image" name="void setRotation(float)" map="R"/>
  <method class="com.itextpdf.text.Image" name="float getIndentationRight()" map="&#x00e7;"/>
  <method class="com.itextpdf.text.Image" name="int getCompressionLevel()" map="&#x00e8;"/>
  <class name="com.itextpdf.text.LargeElement" map="p"/>
  <method class="com.itextpdf.text.LargeElement" name="boolean isComplete()" map="e"/>
  <method class="com.itextpdf.text.LargeElement" name="void flushContent()" map="f"/>
  <package name="com.toedter" map="C"/>
  <package name="com.toedter.components" map="A"/>
  <class name="com.toedter.components.JSpinField$1" map="1"/>
  <field class="com.toedter.components.JSpinField$1" name="this$0" map="this$0"/>
  <field class="com.toedter.components.JSpinField$1" name="textField" map="A"/>
  <method class="com.toedter.components.JSpinField$1" name="java.awt.Dimension getPreferredSize()" map="getPreferredSize"/>
  <class name="com.toedter.components.JSpinField" map="A"/>
  <field class="com.toedter.components.JSpinField" name="max" map="A"/>
  <field class="com.toedter.components.JSpinField" name="textField" map="B"/>
  <field class="com.toedter.components.JSpinField" name="min" map="C"/>
  <field class="com.toedter.components.JSpinField" name="darkGreen" map="D"/>
  <field class="com.toedter.components.JSpinField" name="value" map="E"/>
  <field class="com.toedter.components.JSpinField" name="spinner" map="F"/>
  <method class="com.toedter.components.JSpinField" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="com.toedter.components.JSpinField" name="void setMaximum(int)" map="A"/>
  <method class="com.toedter.components.JSpinField" name="void setValue(int, boolean, boolean)" map="A"/>
  <method class="com.toedter.components.JSpinField" name="void setMinimum(int)" map="B"/>
  <method class="com.toedter.components.JSpinField" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <method class="com.toedter.components.JSpinField" name="void setForeground(java.awt.Color)" map="setForeground"/>
  <method class="com.toedter.components.JSpinField" name="void caretUpdate(javax.swing.event.CaretEvent)" map="caretUpdate"/>
  <method class="com.toedter.components.JSpinField" name="int getValue()" map="A"/>
  <method class="com.toedter.components.JSpinField" name="void setEnabled(boolean)" map="setEnabled"/>
  <method class="com.toedter.components.JSpinField" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <method class="com.toedter.components.JSpinField" name="void focusGained(java.awt.event.FocusEvent)" map="focusGained"/>
  <method class="com.toedter.components.JSpinField" name="void setFont(java.awt.Font)" map="setFont"/>
  <method class="com.toedter.components.JSpinField" name="void setValue(int)" map="C"/>
  <class name="com.toedter.components.UTF8ResourceBundle$1" map="1"/>
  <class name="com.toedter.components.UTF8ResourceBundle$UTF8PropertyResourceBundle" map="_A"/>
  <field class="com.toedter.components.UTF8ResourceBundle$UTF8PropertyResourceBundle" name="propertyResourceBundle" map="A"/>
  <method class="com.toedter.components.UTF8ResourceBundle$UTF8PropertyResourceBundle" name="java.lang.Object handleGetObject(java.lang.String)" map="handleGetObject"/>
  <method class="com.toedter.components.UTF8ResourceBundle$UTF8PropertyResourceBundle" name="java.util.Enumeration getKeys()" map="getKeys"/>
  <class name="com.toedter.components.UTF8ResourceBundle" map="B"/>
  <method class="com.toedter.components.UTF8ResourceBundle" name="java.util.ResourceBundle getBundle(java.lang.String, java.util.Locale)" map="A"/>
  <package name="com.toedter.calendar" map="B"/>
  <class name="com.toedter.calendar.JMonthChooser$1" map="1"/>
  <field class="com.toedter.calendar.JMonthChooser$1" name="this$0" map="this$0"/>
  <field class="com.toedter.calendar.JMonthChooser$1" name="textField" map="A"/>
  <method class="com.toedter.calendar.JMonthChooser$1" name="java.awt.Dimension getPreferredSize()" map="getPreferredSize"/>
  <class name="com.toedter.calendar.JMonthChooser" map="A"/>
  <field class="com.toedter.calendar.JMonthChooser" name="localInitialize" map="A"/>
  <field class="com.toedter.calendar.JMonthChooser" name="initialized" map="B"/>
  <field class="com.toedter.calendar.JMonthChooser" name="oldSpinnerValue" map="C"/>
  <field class="com.toedter.calendar.JMonthChooser" name="hasSpinner" map="D"/>
  <field class="com.toedter.calendar.JMonthChooser" name="month" map="E"/>
  <field class="com.toedter.calendar.JMonthChooser" name="locale" map="F"/>
  <field class="com.toedter.calendar.JMonthChooser" name="spinner" map="G"/>
  <field class="com.toedter.calendar.JMonthChooser" name="comboBox" map="H"/>
  <field class="com.toedter.calendar.JMonthChooser" name="dayChooser" map="I"/>
  <field class="com.toedter.calendar.JMonthChooser" name="yearChooser" map="J"/>
  <method class="com.toedter.calendar.JMonthChooser" name="void setMonth(int)" map="A"/>
  <method class="com.toedter.calendar.JMonthChooser" name="void itemStateChanged(java.awt.event.ItemEvent)" map="itemStateChanged"/>
  <method class="com.toedter.calendar.JMonthChooser" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <method class="com.toedter.calendar.JMonthChooser" name="void setDayChooser(com.toedter.calendar.JDayChooser)" map="A"/>
  <method class="com.toedter.calendar.JMonthChooser" name="void updateUI()" map="updateUI"/>
  <method class="com.toedter.calendar.JMonthChooser" name="void initNames()" map="A"/>
  <method class="com.toedter.calendar.JMonthChooser" name="java.awt.Component getComboBox()" map="B"/>
  <method class="com.toedter.calendar.JMonthChooser" name="java.util.Locale getLocale()" map="getLocale"/>
  <method class="com.toedter.calendar.JMonthChooser" name="void setMonth(int, boolean)" map="A"/>
  <method class="com.toedter.calendar.JMonthChooser" name="int getMonth()" map="C"/>
  <method class="com.toedter.calendar.JMonthChooser" name="void setLocale(java.util.Locale)" map="setLocale"/>
  <method class="com.toedter.calendar.JMonthChooser" name="void setYearChooser(com.toedter.calendar.JYearChooser)" map="A"/>
  <method class="com.toedter.calendar.JMonthChooser" name="void setEnabled(boolean)" map="setEnabled"/>
  <method class="com.toedter.calendar.JMonthChooser" name="void setFont(java.awt.Font)" map="setFont"/>
  <class name="com.toedter.calendar.JTextFieldDateEditor" map="B"/>
  <field class="com.toedter.calendar.JTextFieldDateEditor" name="millis" map="A"/>
  <field class="com.toedter.calendar.JTextFieldDateEditor" name="datePattern" map="B"/>
  <field class="com.toedter.calendar.JTextFieldDateEditor" name="maskPattern" map="C"/>
  <field class="com.toedter.calendar.JTextFieldDateEditor" name="dateUtil" map="D"/>
  <field class="com.toedter.calendar.JTextFieldDateEditor" name="date" map="E"/>
  <field class="com.toedter.calendar.JTextFieldDateEditor" name="dateFormatter" map="F"/>
  <field class="com.toedter.calendar.JTextFieldDateEditor" name="minutes" map="G"/>
  <field class="com.toedter.calendar.JTextFieldDateEditor" name="ignoreDatePatternChange" map="H"/>
  <field class="com.toedter.calendar.JTextFieldDateEditor" name="isMaskVisible" map="I"/>
  <field class="com.toedter.calendar.JTextFieldDateEditor" name="calendar" map="J"/>
  <field class="com.toedter.calendar.JTextFieldDateEditor" name="darkGreen" map="K"/>
  <field class="com.toedter.calendar.JTextFieldDateEditor" name="hours" map="L"/>
  <field class="com.toedter.calendar.JTextFieldDateEditor" name="seconds" map="M"/>
  <field class="com.toedter.calendar.JTextFieldDateEditor" name="placeholder" map="N"/>
  <field class="com.toedter.calendar.JTextFieldDateEditor" name="maskFormatter" map="O"/>
  <method class="com.toedter.calendar.JTextFieldDateEditor" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="com.toedter.calendar.JTextFieldDateEditor" name="void setDate(java.util.Date)" map="A"/>
  <method class="com.toedter.calendar.JTextFieldDateEditor" name="java.awt.Dimension getPreferredSize()" map="getPreferredSize"/>
  <method class="com.toedter.calendar.JTextFieldDateEditor" name="void checkText()" map="C"/>
  <method class="com.toedter.calendar.JTextFieldDateEditor" name="void setMaskVisible(boolean)" map="A"/>
  <method class="com.toedter.calendar.JTextFieldDateEditor" name="java.util.Date getDate()" map="B"/>
  <method class="com.toedter.calendar.JTextFieldDateEditor" name="void setDateFormatString(java.lang.String)" map="A"/>
  <method class="com.toedter.calendar.JTextFieldDateEditor" name="void caretUpdate(javax.swing.event.CaretEvent)" map="caretUpdate"/>
  <method class="com.toedter.calendar.JTextFieldDateEditor" name="java.lang.String createMaskFromDatePattern(java.lang.String)" map="B"/>
  <method class="com.toedter.calendar.JTextFieldDateEditor" name="void setDate(java.util.Date, boolean)" map="A"/>
  <method class="com.toedter.calendar.JTextFieldDateEditor" name="void setLocale(java.util.Locale)" map="setLocale"/>
  <method class="com.toedter.calendar.JTextFieldDateEditor" name="void setEnabled(boolean)" map="setEnabled"/>
  <method class="com.toedter.calendar.JTextFieldDateEditor" name="void focusGained(java.awt.event.FocusEvent)" map="focusGained"/>
  <method class="com.toedter.calendar.JTextFieldDateEditor" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <method class="com.toedter.calendar.JTextFieldDateEditor" name="javax.swing.JComponent getUiComponent()" map="A"/>
  <class name="com.toedter.calendar.JCalendar$2" map="2"/>
  <field class="com.toedter.calendar.JCalendar$2" name="this$0" map="this$0"/>
  <method class="com.toedter.calendar.JCalendar$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="com.toedter.calendar.JCalendar$1" map="1"/>
  <field class="com.toedter.calendar.JCalendar$1" name="this$0" map="this$0"/>
  <method class="com.toedter.calendar.JCalendar$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="com.toedter.calendar.JCalendar" map="C"/>
  <field class="com.toedter.calendar.JCalendar" name="isTodayButtonVisible" map="A"/>
  <field class="com.toedter.calendar.JCalendar" name="specialButtonPanel" map="B"/>
  <field class="com.toedter.calendar.JCalendar" name="monthYearPanel" map="C"/>
  <field class="com.toedter.calendar.JCalendar" name="initialized" map="D"/>
  <field class="com.toedter.calendar.JCalendar" name="isNullDateButtonVisible" map="E"/>
  <field class="com.toedter.calendar.JCalendar" name="nullDateButtonText" map="F"/>
  <field class="com.toedter.calendar.JCalendar" name="todayButton" map="G"/>
  <field class="com.toedter.calendar.JCalendar" name="weekOfYearVisible" map="H"/>
  <field class="com.toedter.calendar.JCalendar" name="defaultNullDateButtonText" map="I"/>
  <field class="com.toedter.calendar.JCalendar" name="calendar" map="J"/>
  <field class="com.toedter.calendar.JCalendar" name="todayButtonText" map="K"/>
  <field class="com.toedter.calendar.JCalendar" name="monthChooser" map="L"/>
  <field class="com.toedter.calendar.JCalendar" name="locale" map="locale"/>
  <field class="com.toedter.calendar.JCalendar" name="yearChooser" map="M"/>
  <field class="com.toedter.calendar.JCalendar" name="dayChooser" map="N"/>
  <field class="com.toedter.calendar.JCalendar" name="defaultTodayButtonText" map="O"/>
  <field class="com.toedter.calendar.JCalendar" name="nullDateButton" map="P"/>
  <method class="com.toedter.calendar.JCalendar" name="void setDate(java.util.Date)" map="A"/>
  <method class="com.toedter.calendar.JCalendar" name="void setCalendar(java.util.Calendar)" map="A"/>
  <method class="com.toedter.calendar.JCalendar" name="boolean isEnabled()" map="isEnabled"/>
  <method class="com.toedter.calendar.JCalendar" name="java.util.Calendar getCalendar()" map="A"/>
  <method class="com.toedter.calendar.JCalendar" name="void relayoutSpecialButtonPanel()" map="B"/>
  <method class="com.toedter.calendar.JCalendar" name="void setForeground(java.awt.Color)" map="setForeground"/>
  <method class="com.toedter.calendar.JCalendar" name="void propertyChange(java.beans.PropertyChangeEvent)" map="propertyChange"/>
  <method class="com.toedter.calendar.JCalendar" name="java.util.Locale getLocale()" map="getLocale"/>
  <method class="com.toedter.calendar.JCalendar" name="com.toedter.calendar.JDayChooser getDayChooser()" map="C"/>
  <method class="com.toedter.calendar.JCalendar" name="void setBackground(java.awt.Color)" map="setBackground"/>
  <method class="com.toedter.calendar.JCalendar" name="void setLocale(java.util.Locale)" map="setLocale"/>
  <method class="com.toedter.calendar.JCalendar" name="void setEnabled(boolean)" map="setEnabled"/>
  <method class="com.toedter.calendar.JCalendar" name="void setFont(java.awt.Font)" map="setFont"/>
  <method class="com.toedter.calendar.JCalendar" name="void setCalendar(java.util.Calendar, boolean)" map="A"/>
  <class name="com.toedter.calendar.JDateChooser$3" map="3"/>
  <field class="com.toedter.calendar.JDateChooser$3" name="this$0" map="this$0"/>
  <field class="com.toedter.calendar.JDateChooser$3" name="hasListened" map="A"/>
  <method class="com.toedter.calendar.JDateChooser$3" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="com.toedter.calendar.JDateChooser$2" map="2"/>
  <field class="com.toedter.calendar.JDateChooser$2" name="this$0" map="this$0"/>
  <method class="com.toedter.calendar.JDateChooser$2" name="void setVisible(boolean)" map="setVisible"/>
  <class name="com.toedter.calendar.JDateChooser$1" map="1"/>
  <field class="com.toedter.calendar.JDateChooser$1" name="this$0" map="this$0"/>
  <method class="com.toedter.calendar.JDateChooser$1" name="boolean isFocusable()" map="isFocusable"/>
  <class name="com.toedter.calendar.JDateChooser" map="D"/>
  <field class="com.toedter.calendar.JDateChooser" name="changeListener" map="A"/>
  <field class="com.toedter.calendar.JDateChooser" name="lastSelectedDate" map="B"/>
  <field class="com.toedter.calendar.JDateChooser" name="popup" map="C"/>
  <field class="com.toedter.calendar.JDateChooser" name="calendarButton" map="D"/>
  <field class="com.toedter.calendar.JDateChooser" name="jcalendar" map="E"/>
  <field class="com.toedter.calendar.JDateChooser" name="isInitialized" map="F"/>
  <field class="com.toedter.calendar.JDateChooser" name="dateSelected" map="G"/>
  <field class="com.toedter.calendar.JDateChooser" name="dateEditor" map="H"/>
  <method class="com.toedter.calendar.JDateChooser" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="com.toedter.calendar.JDateChooser" name="void setDate(java.util.Date)" map="A"/>
  <method class="com.toedter.calendar.JDateChooser" name="boolean isEnabled()" map="isEnabled"/>
  <method class="com.toedter.calendar.JDateChooser" name="void updateUI()" map="updateUI"/>
  <method class="com.toedter.calendar.JDateChooser" name="void setDateFormatString(java.lang.String)" map="A"/>
  <method class="com.toedter.calendar.JDateChooser" name="void propertyChange(java.beans.PropertyChangeEvent)" map="propertyChange"/>
  <method class="com.toedter.calendar.JDateChooser" name="void setLocale(java.util.Locale)" map="setLocale"/>
  <method class="com.toedter.calendar.JDateChooser" name="boolean requestFocusInWindow()" map="requestFocusInWindow"/>
  <method class="com.toedter.calendar.JDateChooser" name="void setEnabled(boolean)" map="setEnabled"/>
  <method class="com.toedter.calendar.JDateChooser" name="void setFont(java.awt.Font)" map="setFont"/>
  <class name="com.toedter.calendar.JDayChooser$1" map="1"/>
  <field class="com.toedter.calendar.JDayChooser$1" name="this$0" map="this$0"/>
  <method class="com.toedter.calendar.JDayChooser$1" name="void paint(java.awt.Graphics)" map="paint"/>
  <class name="com.toedter.calendar.JDayChooser$DecoratorButton" map="_A"/>
  <field class="com.toedter.calendar.JDayChooser$DecoratorButton" name="this$0" map="this$0"/>
  <method class="com.toedter.calendar.JDayChooser$DecoratorButton" name="boolean isFocusable()" map="isFocusable"/>
  <method class="com.toedter.calendar.JDayChooser$DecoratorButton" name="void addMouseListener(java.awt.event.MouseListener)" map="addMouseListener"/>
  <method class="com.toedter.calendar.JDayChooser$DecoratorButton" name="void paint(java.awt.Graphics)" map="paint"/>
  <class name="com.toedter.calendar.JDayChooser" map="E"/>
  <field class="com.toedter.calendar.JDayChooser" name="oldDayBackgroundColor" map="A"/>
  <field class="com.toedter.calendar.JDayChooser" name="maxDayCharacters" map="B"/>
  <field class="com.toedter.calendar.JDayChooser" name="decorationBackgroundVisible" map="C"/>
  <field class="com.toedter.calendar.JDayChooser" name="initialized" map="D"/>
  <field class="com.toedter.calendar.JDayChooser" name="sundayForeground" map="E"/>
  <field class="com.toedter.calendar.JDayChooser" name="days" map="F"/>
  <field class="com.toedter.calendar.JDayChooser" name="weeks" map="G"/>
  <field class="com.toedter.calendar.JDayChooser" name="selectedDay" map="H"/>
  <field class="com.toedter.calendar.JDayChooser" name="decorationBackgroundColor" map="I"/>
  <field class="com.toedter.calendar.JDayChooser" name="weekOfYearVisible" map="J"/>
  <field class="com.toedter.calendar.JDayChooser" name="dateEvaluators" map="K"/>
  <field class="com.toedter.calendar.JDayChooser" name="decorationBordersVisible" map="L"/>
  <field class="com.toedter.calendar.JDayChooser" name="calendar" map="M"/>
  <field class="com.toedter.calendar.JDayChooser" name="minMaxDateEvaluator" map="N"/>
  <field class="com.toedter.calendar.JDayChooser" name="selectedColor" map="O"/>
  <field class="com.toedter.calendar.JDayChooser" name="dayBordersVisible" map="P"/>
  <field class="com.toedter.calendar.JDayChooser" name="locale" map="locale"/>
  <field class="com.toedter.calendar.JDayChooser" name="day" map="Q"/>
  <field class="com.toedter.calendar.JDayChooser" name="dayPanel" map="R"/>
  <field class="com.toedter.calendar.JDayChooser" name="today" map="S"/>
  <field class="com.toedter.calendar.JDayChooser" name="dayNames" map="T"/>
  <field class="com.toedter.calendar.JDayChooser" name="alwaysFireDayProperty" map="U"/>
  <field class="com.toedter.calendar.JDayChooser" name="weekPanel" map="V"/>
  <field class="com.toedter.calendar.JDayChooser" name="weekdayForeground" map="W"/>
  <method class="com.toedter.calendar.JDayChooser" name="void setCalendar(java.util.Calendar)" map="A"/>
  <method class="com.toedter.calendar.JDayChooser" name="void keyPressed(java.awt.event.KeyEvent)" map="keyPressed"/>
  <method class="com.toedter.calendar.JDayChooser" name="void setDay(int)" map="A"/>
  <method class="com.toedter.calendar.JDayChooser" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="com.toedter.calendar.JDayChooser" name="void drawWeeks()" map="A"/>
  <method class="com.toedter.calendar.JDayChooser" name="void updateUI()" map="updateUI"/>
  <method class="com.toedter.calendar.JDayChooser" name="void setYear(int)" map="B"/>
  <method class="com.toedter.calendar.JDayChooser" name="void drawDayNames()" map="B"/>
  <method class="com.toedter.calendar.JDayChooser" name="void initDecorations()" map="C"/>
  <method class="com.toedter.calendar.JDayChooser" name="java.util.Locale getLocale()" map="getLocale"/>
  <method class="com.toedter.calendar.JDayChooser" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <method class="com.toedter.calendar.JDayChooser" name="void setDecorationBackgroundVisible(boolean)" map="A"/>
  <method class="com.toedter.calendar.JDayChooser" name="void setMonth(int)" map="C"/>
  <method class="com.toedter.calendar.JDayChooser" name="void addDateEvaluator(com.toedter.calendar.IDateEvaluator)" map="A"/>
  <method class="com.toedter.calendar.JDayChooser" name="void setDecorationBordersVisible(boolean)" map="B"/>
  <method class="com.toedter.calendar.JDayChooser" name="int getDay()" map="D"/>
  <method class="com.toedter.calendar.JDayChooser" name="void init()" map="E"/>
  <method class="com.toedter.calendar.JDayChooser" name="void setEnabled(boolean)" map="setEnabled"/>
  <method class="com.toedter.calendar.JDayChooser" name="void setAlwaysFireDayProperty(boolean)" map="C"/>
  <method class="com.toedter.calendar.JDayChooser" name="void keyReleased(java.awt.event.KeyEvent)" map="keyReleased"/>
  <method class="com.toedter.calendar.JDayChooser" name="void setLocale(java.util.Locale)" map="setLocale"/>
  <method class="com.toedter.calendar.JDayChooser" name="void focusGained(java.awt.event.FocusEvent)" map="focusGained"/>
  <method class="com.toedter.calendar.JDayChooser" name="void setForeground(java.awt.Color)" map="setForeground"/>
  <method class="com.toedter.calendar.JDayChooser" name="void keyTyped(java.awt.event.KeyEvent)" map="keyTyped"/>
  <method class="com.toedter.calendar.JDayChooser" name="void setDayBordersVisible(boolean)" map="D"/>
  <method class="com.toedter.calendar.JDayChooser" name="void setFont(java.awt.Font)" map="setFont"/>
  <method class="com.toedter.calendar.JDayChooser" name="void drawDays()" map="F"/>
  <class name="com.toedter.calendar.IDateEditor" map="F"/>
  <method class="com.toedter.calendar.IDateEditor" name="javax.swing.JComponent getUiComponent()" map="A"/>
  <method class="com.toedter.calendar.IDateEditor" name="void addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)" map="addPropertyChangeListener"/>
  <method class="com.toedter.calendar.IDateEditor" name="void setEnabled(boolean)" map="setEnabled"/>
  <method class="com.toedter.calendar.IDateEditor" name="void setDate(java.util.Date)" map="A"/>
  <method class="com.toedter.calendar.IDateEditor" name="java.util.Date getDate()" map="B"/>
  <method class="com.toedter.calendar.IDateEditor" name="void setLocale(java.util.Locale)" map="setLocale"/>
  <method class="com.toedter.calendar.IDateEditor" name="void setDateFormatString(java.lang.String)" map="A"/>
  <class name="com.toedter.calendar.IDateEvaluator" map="G"/>
  <method class="com.toedter.calendar.IDateEvaluator" name="boolean isInvalid(java.util.Date)" map="A"/>
  <method class="com.toedter.calendar.IDateEvaluator" name="java.lang.String getSpecialTooltip()" map="A"/>
  <method class="com.toedter.calendar.IDateEvaluator" name="java.lang.String getInvalidTooltip()" map="B"/>
  <method class="com.toedter.calendar.IDateEvaluator" name="java.awt.Color getSpecialForegroundColor()" map="C"/>
  <method class="com.toedter.calendar.IDateEvaluator" name="java.awt.Color getSpecialBackroundColor()" map="D"/>
  <method class="com.toedter.calendar.IDateEvaluator" name="boolean isSpecial(java.util.Date)" map="B"/>
  <method class="com.toedter.calendar.IDateEvaluator" name="java.awt.Color getInvalidForegroundColor()" map="E"/>
  <method class="com.toedter.calendar.IDateEvaluator" name="java.awt.Color getInvalidBackroundColor()" map="F"/>
  <class name="com.toedter.calendar.MinMaxDateEvaluator" map="H"/>
  <field class="com.toedter.calendar.MinMaxDateEvaluator" name="dateUtil" map="A"/>
  <method class="com.toedter.calendar.MinMaxDateEvaluator" name="boolean isInvalid(java.util.Date)" map="A"/>
  <method class="com.toedter.calendar.MinMaxDateEvaluator" name="java.lang.String getSpecialTooltip()" map="A"/>
  <method class="com.toedter.calendar.MinMaxDateEvaluator" name="java.lang.String getInvalidTooltip()" map="B"/>
  <method class="com.toedter.calendar.MinMaxDateEvaluator" name="java.awt.Color getSpecialForegroundColor()" map="C"/>
  <method class="com.toedter.calendar.MinMaxDateEvaluator" name="java.awt.Color getSpecialBackroundColor()" map="D"/>
  <method class="com.toedter.calendar.MinMaxDateEvaluator" name="boolean isSpecial(java.util.Date)" map="B"/>
  <method class="com.toedter.calendar.MinMaxDateEvaluator" name="java.awt.Color getInvalidForegroundColor()" map="E"/>
  <method class="com.toedter.calendar.MinMaxDateEvaluator" name="java.awt.Color getInvalidBackroundColor()" map="F"/>
  <class name="com.toedter.calendar.JYearChooser" map="I"/>
  <field class="com.toedter.calendar.JYearChooser" name="dayChooser" map="G"/>
  <field class="com.toedter.calendar.JYearChooser" name="oldYear" map="H"/>
  <method class="com.toedter.calendar.JYearChooser" name="void setValue(int)" map="C"/>
  <method class="com.toedter.calendar.JYearChooser" name="int getYear()" map="B"/>
  <method class="com.toedter.calendar.JYearChooser" name="void setYear(int)" map="D"/>
  <method class="com.toedter.calendar.JYearChooser" name="void setDayChooser(com.toedter.calendar.JDayChooser)" map="A"/>
  <class name="com.toedter.calendar.DateUtil" map="J"/>
  <field class="com.toedter.calendar.DateUtil" name="maxSelectableDate" map="A"/>
  <field class="com.toedter.calendar.DateUtil" name="minSelectableDate" map="B"/>
  <field class="com.toedter.calendar.DateUtil" name="defaultMaxSelectableDate" map="C"/>
  <field class="com.toedter.calendar.DateUtil" name="defaultMinSelectableDate" map="D"/>
  <method class="com.toedter.calendar.DateUtil" name="boolean checkDate(java.util.Date)" map="A"/>
  <package name="com.hexidec" map="D"/>
  <package name="com.hexidec.ekit" map="A"/>
  <package name="com.hexidec.ekit.thirdparty" map="A"/>
  <package name="com.hexidec.ekit.thirdparty.print" map="A"/>
  <class name="com.hexidec.ekit.thirdparty.print.DocumentRenderer" map="A"/>
  <field class="com.hexidec.ekit.thirdparty.print.DocumentRenderer" name="scaleWidthToFit" map="A"/>
  <field class="com.hexidec.ekit.thirdparty.print.DocumentRenderer" name="pageEndY" map="B"/>
  <field class="com.hexidec.ekit.thirdparty.print.DocumentRenderer" name="pFormat" map="C"/>
  <field class="com.hexidec.ekit.thirdparty.print.DocumentRenderer" name="jeditorPane" map="D"/>
  <field class="com.hexidec.ekit.thirdparty.print.DocumentRenderer" name="currentPage" map="E"/>
  <field class="com.hexidec.ekit.thirdparty.print.DocumentRenderer" name="pageStartY" map="F"/>
  <field class="com.hexidec.ekit.thirdparty.print.DocumentRenderer" name="pJob" map="G"/>
  <method class="com.hexidec.ekit.thirdparty.print.DocumentRenderer" name="void setDocument(java.lang.String, javax.swing.text.Document)" map="A"/>
  <method class="com.hexidec.ekit.thirdparty.print.DocumentRenderer" name="void printDialog()" map="A"/>
  <method class="com.hexidec.ekit.thirdparty.print.DocumentRenderer" name="void setContentType(java.lang.String)" map="A"/>
  <method class="com.hexidec.ekit.thirdparty.print.DocumentRenderer" name="boolean printView(java.awt.Graphics2D, java.awt.Shape, javax.swing.text.View)" map="A"/>
  <method class="com.hexidec.ekit.thirdparty.print.DocumentRenderer" name="void print(javax.swing.text.html.HTMLDocument)" map="A"/>
  <method class="com.hexidec.ekit.thirdparty.print.DocumentRenderer" name="int print(java.awt.Graphics, java.awt.print.PageFormat, int)" map="print"/>
  <method class="com.hexidec.ekit.thirdparty.print.DocumentRenderer" name="void setDocument(javax.swing.text.html.HTMLDocument)" map="B"/>
  <package name="com.hexidec.ekit.component" map="B"/>
  <class name="com.hexidec.ekit.component.UserInputAnchorDialog" map="A"/>
  <field class="com.hexidec.ekit.component.UserInputAnchorDialog" name="jtxfInput" map="A"/>
  <field class="com.hexidec.ekit.component.UserInputAnchorDialog" name="inputText" map="B"/>
  <method class="com.hexidec.ekit.component.UserInputAnchorDialog" name="java.lang.String getInputText()" map="A"/>
  <method class="com.hexidec.ekit.component.UserInputAnchorDialog" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="com.hexidec.ekit.component.UserInputAnchorDialog" name="void init()" map="B"/>
  <class name="com.hexidec.ekit.component.ExtendedHTMLEditorKit$HTMLFactoryExtended" map="_A"/>
  <method class="com.hexidec.ekit.component.ExtendedHTMLEditorKit$HTMLFactoryExtended" name="javax.swing.text.View create(javax.swing.text.Element)" map="create"/>
  <class name="com.hexidec.ekit.component.ExtendedHTMLEditorKit" map="B"/>
  <method class="com.hexidec.ekit.component.ExtendedHTMLEditorKit" name="javax.swing.text.ViewFactory getViewFactory()" map="getViewFactory"/>
  <method class="com.hexidec.ekit.component.ExtendedHTMLEditorKit" name="javax.swing.text.Document createDefaultDocument()" map="createDefaultDocument"/>
  <class name="com.hexidec.ekit.component.UnicodeDialog" map="C"/>
  <field class="com.hexidec.ekit.component.UnicodeDialog" name="unicodeBlockStart" map="A"/>
  <field class="com.hexidec.ekit.component.UnicodeDialog" name="buttonFont" map="B"/>
  <field class="com.hexidec.ekit.component.UnicodeDialog" name="jcmbPageSelector" map="C"/>
  <field class="com.hexidec.ekit.component.UnicodeDialog" name="buttonArray" map="D"/>
  <field class="com.hexidec.ekit.component.UnicodeDialog" name="unicodeBlocks" map="E"/>
  <field class="com.hexidec.ekit.component.UnicodeDialog" name="buttonGroup" map="F"/>
  <field class="com.hexidec.ekit.component.UnicodeDialog" name="parentEkit" map="G"/>
  <field class="com.hexidec.ekit.component.UnicodeDialog" name="unicodeBlockEnd" map="H"/>
  <field class="com.hexidec.ekit.component.UnicodeDialog" name="jcmbBlockSelector" map="I"/>
  <method class="com.hexidec.ekit.component.UnicodeDialog" name="void populateButtons(int, int)" map="A"/>
  <method class="com.hexidec.ekit.component.UnicodeDialog" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="com.hexidec.ekit.component.UnicodeDialog" name="void init(int)" map="A"/>
  <class name="com.hexidec.ekit.component.SimpleInfoDialog$1" map="1"/>
  <field class="com.hexidec.ekit.component.SimpleInfoDialog$1" name="this$0" map="A"/>
  <method class="com.hexidec.ekit.component.SimpleInfoDialog$1" name="void propertyChange(java.beans.PropertyChangeEvent)" map="propertyChange"/>
  <class name="com.hexidec.ekit.component.SimpleInfoDialog" map="D"/>
  <field class="com.hexidec.ekit.component.SimpleInfoDialog" name="buttonState" map="A"/>
  <field class="com.hexidec.ekit.component.SimpleInfoDialog" name="jOptionPane" map="B"/>
  <field class="com.hexidec.ekit.component.SimpleInfoDialog" name="buttonLabels" map="C"/>
  <method class="com.hexidec.ekit.component.SimpleInfoDialog" name="java.lang.String getDecisionValue()" map="A"/>
  <method class="com.hexidec.ekit.component.SimpleInfoDialog" name="javax.swing.JOptionPane access$000(com.hexidec.ekit.component.SimpleInfoDialog)" map="A"/>
  <class name="com.hexidec.ekit.component.HTMLUtilities" map="E"/>
  <field class="com.hexidec.ekit.component.HTMLUtilities" name="tags" map="A"/>
  <field class="com.hexidec.ekit.component.HTMLUtilities" name="parent" map="B"/>
  <method class="com.hexidec.ekit.component.HTMLUtilities" name="javax.swing.text.html.HTML$Tag getHTMLTag(javax.swing.text.Element)" map="A"/>
  <method class="com.hexidec.ekit.component.HTMLUtilities" name="java.lang.String[] getUniString(int)" map="A"/>
  <method class="com.hexidec.ekit.component.HTMLUtilities" name="void removeTag(javax.swing.text.Element, boolean)" map="A"/>
  <method class="com.hexidec.ekit.component.HTMLUtilities" name="void insertListElement(java.lang.String)" map="A"/>
  <method class="com.hexidec.ekit.component.HTMLUtilities" name="java.lang.String getAllTableTags(java.lang.String)" map="B"/>
  <method class="com.hexidec.ekit.component.HTMLUtilities" name="javax.swing.text.SimpleAttributeSet removeAttributeByKey(javax.swing.text.SimpleAttributeSet, java.lang.String)" map="A"/>
  <method class="com.hexidec.ekit.component.HTMLUtilities" name="javax.swing.text.Element getListItemContainer()" map="A"/>
  <method class="com.hexidec.ekit.component.HTMLUtilities" name="boolean checkParentsTag(javax.swing.text.html.HTML$Tag)" map="A"/>
  <method class="com.hexidec.ekit.component.HTMLUtilities" name="void delete()" map="B"/>
  <method class="com.hexidec.ekit.component.HTMLUtilities" name="javax.swing.text.Element getListItemParent()" map="C"/>
  <method class="com.hexidec.ekit.component.HTMLUtilities" name="javax.swing.text.SimpleAttributeSet removeAttribute(javax.swing.text.SimpleAttributeSet, javax.swing.text.SimpleAttributeSet)" map="A"/>
  <method class="com.hexidec.ekit.component.HTMLUtilities" name="int[] getPositions(javax.swing.text.Element, java.lang.String, boolean, java.lang.String)" map="A"/>
  <class name="com.hexidec.ekit.component.SearchDialog$2" map="2"/>
  <field class="com.hexidec.ekit.component.SearchDialog$2" name="this$0" map="A"/>
  <field class="com.hexidec.ekit.component.SearchDialog$2" name="val$isReplaceDialog" map="B"/>
  <field class="com.hexidec.ekit.component.SearchDialog$2" name="val$jchkTop" map="C"/>
  <field class="com.hexidec.ekit.component.SearchDialog$2" name="val$jchkCase" map="D"/>
  <field class="com.hexidec.ekit.component.SearchDialog$2" name="val$jtxfFindTerm" map="E"/>
  <field class="com.hexidec.ekit.component.SearchDialog$2" name="val$jtxfReplaceTerm" map="F"/>
  <field class="com.hexidec.ekit.component.SearchDialog$2" name="val$buttonLabels" map="G"/>
  <field class="com.hexidec.ekit.component.SearchDialog$2" name="val$jchkAll" map="H"/>
  <method class="com.hexidec.ekit.component.SearchDialog$2" name="void propertyChange(java.beans.PropertyChangeEvent)" map="propertyChange"/>
  <class name="com.hexidec.ekit.component.SearchDialog$1" map="1"/>
  <field class="com.hexidec.ekit.component.SearchDialog$1" name="this$0" map="A"/>
  <method class="com.hexidec.ekit.component.SearchDialog$1" name="void windowClosing(java.awt.event.WindowEvent)" map="windowClosing"/>
  <class name="com.hexidec.ekit.component.SearchDialog" map="F"/>
  <field class="com.hexidec.ekit.component.SearchDialog" name="inputReplaceTerm" map="A"/>
  <field class="com.hexidec.ekit.component.SearchDialog" name="inputFindTerm" map="B"/>
  <field class="com.hexidec.ekit.component.SearchDialog" name="bReplaceAll" map="C"/>
  <field class="com.hexidec.ekit.component.SearchDialog" name="bStartAtTop" map="D"/>
  <field class="com.hexidec.ekit.component.SearchDialog" name="bCaseSensitive" map="E"/>
  <field class="com.hexidec.ekit.component.SearchDialog" name="jOptionPane" map="F"/>
  <method class="com.hexidec.ekit.component.SearchDialog" name="java.lang.String getFindTerm()" map="A"/>
  <method class="com.hexidec.ekit.component.SearchDialog" name="javax.swing.JOptionPane access$000(com.hexidec.ekit.component.SearchDialog)" map="A"/>
  <method class="com.hexidec.ekit.component.SearchDialog" name="boolean access$202(com.hexidec.ekit.component.SearchDialog, boolean)" map="A"/>
  <method class="com.hexidec.ekit.component.SearchDialog" name="boolean getReplaceAll()" map="B"/>
  <method class="com.hexidec.ekit.component.SearchDialog" name="boolean getStartAtTop()" map="C"/>
  <method class="com.hexidec.ekit.component.SearchDialog" name="boolean getCaseSensitive()" map="D"/>
  <method class="com.hexidec.ekit.component.SearchDialog" name="boolean access$502(com.hexidec.ekit.component.SearchDialog, boolean)" map="B"/>
  <method class="com.hexidec.ekit.component.SearchDialog" name="java.lang.String access$402(com.hexidec.ekit.component.SearchDialog, java.lang.String)" map="A"/>
  <method class="com.hexidec.ekit.component.SearchDialog" name="java.lang.String getReplaceTerm()" map="E"/>
  <method class="com.hexidec.ekit.component.SearchDialog" name="java.lang.String access$102(com.hexidec.ekit.component.SearchDialog, java.lang.String)" map="B"/>
  <method class="com.hexidec.ekit.component.SearchDialog" name="boolean access$302(com.hexidec.ekit.component.SearchDialog, boolean)" map="C"/>
  <class name="com.hexidec.ekit.component.ImageFileChooser" map="G"/>
  <class name="com.hexidec.ekit.component.PropertiesDialog$1" map="1"/>
  <field class="com.hexidec.ekit.component.PropertiesDialog$1" name="this$0" map="A"/>
  <field class="com.hexidec.ekit.component.PropertiesDialog$1" name="val$buttonLabels" map="B"/>
  <method class="com.hexidec.ekit.component.PropertiesDialog$1" name="void propertyChange(java.beans.PropertyChangeEvent)" map="propertyChange"/>
  <class name="com.hexidec.ekit.component.PropertiesDialog" map="H"/>
  <field class="com.hexidec.ekit.component.PropertiesDialog" name="htInputFields" map="A"/>
  <field class="com.hexidec.ekit.component.PropertiesDialog" name="jOptionPane" map="B"/>
  <method class="com.hexidec.ekit.component.PropertiesDialog" name="java.lang.String getDecisionValue()" map="A"/>
  <method class="com.hexidec.ekit.component.PropertiesDialog" name="javax.swing.JOptionPane access$000(com.hexidec.ekit.component.PropertiesDialog)" map="A"/>
  <method class="com.hexidec.ekit.component.PropertiesDialog" name="java.lang.String getFieldValue(java.lang.String)" map="A"/>
  <class name="com.hexidec.ekit.component.MutableFilter" map="I"/>
  <field class="com.hexidec.ekit.component.MutableFilter" name="descriptor" map="A"/>
  <field class="com.hexidec.ekit.component.MutableFilter" name="acceptableExtensions" map="B"/>
  <method class="com.hexidec.ekit.component.MutableFilter" name="boolean accept(java.io.File)" map="accept"/>
  <method class="com.hexidec.ekit.component.MutableFilter" name="java.lang.String getDescription()" map="getDescription"/>
  <class name="com.hexidec.ekit.component.ImageFileDialog$2" map="2"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog$2" name="this$0" map="A"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog$2" name="val$buttonLabels" map="B"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog$2" name="void propertyChange(java.beans.PropertyChangeEvent)" map="propertyChange"/>
  <class name="com.hexidec.ekit.component.ImageFileDialog$1" map="1"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog$1" name="this$0" map="A"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog$1" name="void windowClosing(java.awt.event.WindowEvent)" map="windowClosing"/>
  <class name="com.hexidec.ekit.component.ImageFileDialog" map="J"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog" name="jlblSrc" map="A"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog" name="imageDesc" map="B"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog" name="jtxfWidth" map="C"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog" name="imageAlt" map="D"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog" name="jOptionPane" map="E"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog" name="imageHeight" map="F"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog" name="jtxfAlt" map="G"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog" name="jbtnBrowse" map="H"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog" name="jtxfHeight" map="I"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog" name="imageWidth" map="J"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog" name="imageSrc" map="K"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog" name="imageFile" map="L"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog" name="imageExts" map="M"/>
  <field class="com.hexidec.ekit.component.ImageFileDialog" name="imageDir" map="N"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="java.lang.String getImageHeight()" map="A"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="java.io.File browseForImage()" map="B"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="java.lang.String access$502(com.hexidec.ekit.component.ImageFileDialog, java.lang.String)" map="A"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="java.lang.String getImageAlt()" map="C"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="javax.swing.JTextField access$800(com.hexidec.ekit.component.ImageFileDialog)" map="A"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="java.lang.String access$302(com.hexidec.ekit.component.ImageFileDialog, java.lang.String)" map="B"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="java.io.File getImageFile()" map="D"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="java.lang.String getImageWidth()" map="E"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="javax.swing.JTextField access$600(com.hexidec.ekit.component.ImageFileDialog)" map="B"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="java.lang.String access$102(com.hexidec.ekit.component.ImageFileDialog, java.lang.String)" map="C"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="javax.swing.JOptionPane access$000(com.hexidec.ekit.component.ImageFileDialog)" map="C"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="javax.swing.JTextField access$400(com.hexidec.ekit.component.ImageFileDialog)" map="D"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="java.lang.String access$702(com.hexidec.ekit.component.ImageFileDialog, java.lang.String)" map="D"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="java.lang.String getDecisionValue()" map="F"/>
  <method class="com.hexidec.ekit.component.ImageFileDialog" name="javax.swing.JLabel access$200(com.hexidec.ekit.component.ImageFileDialog)" map="E"/>
  <class name="com.hexidec.ekit.component.FontSelectorDialog$2" map="2"/>
  <field class="com.hexidec.ekit.component.FontSelectorDialog$2" name="this$0" map="A"/>
  <field class="com.hexidec.ekit.component.FontSelectorDialog$2" name="val$buttonLabels" map="B"/>
  <method class="com.hexidec.ekit.component.FontSelectorDialog$2" name="void propertyChange(java.beans.PropertyChangeEvent)" map="propertyChange"/>
  <class name="com.hexidec.ekit.component.FontSelectorDialog$1" map="1"/>
  <field class="com.hexidec.ekit.component.FontSelectorDialog$1" name="this$0" map="A"/>
  <method class="com.hexidec.ekit.component.FontSelectorDialog$1" name="void windowClosing(java.awt.event.WindowEvent)" map="windowClosing"/>
  <class name="com.hexidec.ekit.component.FontSelectorDialog" map="K"/>
  <field class="com.hexidec.ekit.component.FontSelectorDialog" name="defaultText" map="A"/>
  <field class="com.hexidec.ekit.component.FontSelectorDialog" name="jtpFontPreview" map="B"/>
  <field class="com.hexidec.ekit.component.FontSelectorDialog" name="fontName" map="C"/>
  <field class="com.hexidec.ekit.component.FontSelectorDialog" name="vcFontnames" map="D"/>
  <field class="com.hexidec.ekit.component.FontSelectorDialog" name="jOptionPane" map="E"/>
  <field class="com.hexidec.ekit.component.FontSelectorDialog" name="jcmbFontlist" map="F"/>
  <method class="com.hexidec.ekit.component.FontSelectorDialog" name="java.lang.String getFontSampleString(java.lang.String)" map="A"/>
  <method class="com.hexidec.ekit.component.FontSelectorDialog" name="javax.swing.JOptionPane access$000(com.hexidec.ekit.component.FontSelectorDialog)" map="A"/>
  <method class="com.hexidec.ekit.component.FontSelectorDialog" name="void itemStateChanged(java.awt.event.ItemEvent)" map="itemStateChanged"/>
  <method class="com.hexidec.ekit.component.FontSelectorDialog" name="javax.swing.JComboBox access$200(com.hexidec.ekit.component.FontSelectorDialog)" map="B"/>
  <method class="com.hexidec.ekit.component.FontSelectorDialog" name="java.lang.String getFontName()" map="A"/>
  <method class="com.hexidec.ekit.component.FontSelectorDialog" name="java.lang.String access$102(com.hexidec.ekit.component.FontSelectorDialog, java.lang.String)" map="A"/>
  <class name="com.hexidec.ekit.component.ExtendedHTMLDocument" map="L"/>
  <method class="com.hexidec.ekit.component.ExtendedHTMLDocument" name="void removeElements(javax.swing.text.Element, int, int)" map="A"/>
  <method class="com.hexidec.ekit.component.ExtendedHTMLDocument" name="void replaceAttributes(javax.swing.text.Element, javax.swing.text.AttributeSet, javax.swing.text.html.HTML$Tag)" map="A"/>
  <class name="com.hexidec.ekit.component.RelativeImageView" map="M"/>
  <field class="com.hexidec.ekit.component.RelativeImageView" name="sPendingImageIcon" map="A"/>
  <field class="com.hexidec.ekit.component.RelativeImageView" name="sIncRate" map="B"/>
  <field class="com.hexidec.ekit.component.RelativeImageView" name="sIsInc" map="C"/>
  <field class="com.hexidec.ekit.component.RelativeImageView" name="fWidth" map="D"/>
  <field class="com.hexidec.ekit.component.RelativeImageView" name="bLoading" map="E"/>
  <field class="com.hexidec.ekit.component.RelativeImageView" name="fContainer" map="F"/>
  <field class="com.hexidec.ekit.component.RelativeImageView" name="fImage" map="G"/>
  <field class="com.hexidec.ekit.component.RelativeImageView" name="fGrowBase" map="H"/>
  <field class="com.hexidec.ekit.component.RelativeImageView" name="fHeight" map="I"/>
  <field class="com.hexidec.ekit.component.RelativeImageView" name="sMissingImageIcon" map="J"/>
  <field class="com.hexidec.ekit.component.RelativeImageView" name="fGrowProportionally" map="K"/>
  <field class="com.hexidec.ekit.component.RelativeImageView" name="fBounds" map="L"/>
  <field class="com.hexidec.ekit.component.RelativeImageView" name="fElement" map="M"/>
  <field class="com.hexidec.ekit.component.RelativeImageView" name="attr" map="N"/>
  <field class="com.hexidec.ekit.component.RelativeImageView" name="fComponent" map="O"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="void mouseClicked(java.awt.event.MouseEvent)" map="mouseClicked"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="java.lang.String processSrcPath(java.lang.String)" map="A"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="void mouseReleased(java.awt.event.MouseEvent)" map="mouseReleased"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="void loadImageStatusIcons()" map="A"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="java.awt.Color getBorderColor()" map="B"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="javax.swing.text.html.StyleSheet getStyleSheet()" map="C"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="java.awt.Shape modelToView(int, java.awt.Shape, javax.swing.text.Position$Bias)" map="modelToView"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="void waitForImage()" map="D"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="java.net.URL getSourceURL()" map="E"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="void mouseDragged(java.awt.event.MouseEvent)" map="mouseDragged"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="void mouseMoved(java.awt.event.MouseEvent)" map="mouseMoved"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="int getIntAttr(javax.swing.text.html.HTML$Attribute, int)" map="A"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="void initialize(javax.swing.text.Element)" map="A"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="void mouseExited(java.awt.event.MouseEvent)" map="mouseExited"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="javax.swing.text.AttributeSet getAttributes()" map="getAttributes"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="void resize(int, int)" map="A"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="int getBorder()" map="F"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="void mousePressed(java.awt.event.MouseEvent)" map="mousePressed"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="void setParent(javax.swing.text.View)" map="setParent"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="javax.swing.Icon makeIcon(java.lang.String)" map="B"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="boolean imageUpdate(java.awt.Image, int, int, int, int, int)" map="imageUpdate"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="float getPreferredSpan(int)" map="getPreferredSpan"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="float getAlignment(int)" map="getAlignment"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="void changedUpdate(javax.swing.event.DocumentEvent, java.awt.Shape, javax.swing.text.ViewFactory)" map="changedUpdate"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="float getVerticalAlignment()" map="G"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="void paint(java.awt.Graphics, java.awt.Shape)" map="paint"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="void repaint(long)" map="A"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="boolean isEditable()" map="H"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="int getSpace(int)" map="A"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="boolean isLink()" map="I"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="int getSelectionState()" map="J"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="boolean hasPixels(java.awt.image.ImageObserver)" map="A"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="boolean isURL()" map="K"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="void mouseEntered(java.awt.event.MouseEvent)" map="mouseEntered"/>
  <method class="com.hexidec.ekit.component.RelativeImageView" name="int viewToModel(float, float, java.awt.Shape, javax.swing.text.Position$Bias[])" map="viewToModel"/>
  <class name="com.hexidec.ekit.component.JButtonNoFocus" map="N"/>
  <method class="com.hexidec.ekit.component.JButtonNoFocus" name="boolean isFocusable()" map="isFocusable"/>
  <class name="com.hexidec.ekit.component.JComboBoxNoFocus" map="O"/>
  <method class="com.hexidec.ekit.component.JComboBoxNoFocus" name="boolean isFocusable()" map="isFocusable"/>
  <class name="com.hexidec.ekit.component.JToggleButtonNoFocus" map="P"/>
  <method class="com.hexidec.ekit.component.JToggleButtonNoFocus" name="boolean isFocusable()" map="isFocusable"/>
  <class name="com.hexidec.ekit.component.ImageFileChooserPreview" map="Q"/>
  <field class="com.hexidec.ekit.component.ImageFileChooserPreview" name="imageFile" map="A"/>
  <field class="com.hexidec.ekit.component.ImageFileChooserPreview" name="imageThumb" map="B"/>
  <method class="com.hexidec.ekit.component.ImageFileChooserPreview" name="void paintComponent(java.awt.Graphics)" map="paintComponent"/>
  <method class="com.hexidec.ekit.component.ImageFileChooserPreview" name="void loadImage()" map="A"/>
  <method class="com.hexidec.ekit.component.ImageFileChooserPreview" name="void propertyChange(java.beans.PropertyChangeEvent)" map="propertyChange"/>
  <class name="com.hexidec.ekit.component.ImageURLDialog$2" map="2"/>
  <field class="com.hexidec.ekit.component.ImageURLDialog$2" name="this$0" map="A"/>
  <field class="com.hexidec.ekit.component.ImageURLDialog$2" name="val$buttonLabels" map="B"/>
  <method class="com.hexidec.ekit.component.ImageURLDialog$2" name="void propertyChange(java.beans.PropertyChangeEvent)" map="propertyChange"/>
  <class name="com.hexidec.ekit.component.ImageURLDialog$1" map="1"/>
  <field class="com.hexidec.ekit.component.ImageURLDialog$1" name="this$0" map="A"/>
  <method class="com.hexidec.ekit.component.ImageURLDialog$1" name="void windowClosing(java.awt.event.WindowEvent)" map="windowClosing"/>
  <class name="com.hexidec.ekit.component.ImageURLDialog" map="R"/>
  <field class="com.hexidec.ekit.component.ImageURLDialog" name="imageAlt" map="A"/>
  <field class="com.hexidec.ekit.component.ImageURLDialog" name="jtxfWidth" map="B"/>
  <field class="com.hexidec.ekit.component.ImageURLDialog" name="jOptionPane" map="C"/>
  <field class="com.hexidec.ekit.component.ImageURLDialog" name="imageHeight" map="D"/>
  <field class="com.hexidec.ekit.component.ImageURLDialog" name="jtxtUrl" map="E"/>
  <field class="com.hexidec.ekit.component.ImageURLDialog" name="jtxfAlt" map="F"/>
  <field class="com.hexidec.ekit.component.ImageURLDialog" name="jtxfHeight" map="G"/>
  <field class="com.hexidec.ekit.component.ImageURLDialog" name="imageWidth" map="H"/>
  <field class="com.hexidec.ekit.component.ImageURLDialog" name="imageUrl" map="I"/>
  <method class="com.hexidec.ekit.component.ImageURLDialog" name="java.lang.String access$702(com.hexidec.ekit.component.ImageURLDialog, java.lang.String)" map="A"/>
  <method class="com.hexidec.ekit.component.ImageURLDialog" name="java.lang.String getImageUrl()" map="A"/>
  <method class="com.hexidec.ekit.component.ImageURLDialog" name="java.lang.String getImageHeight()" map="B"/>
  <method class="com.hexidec.ekit.component.ImageURLDialog" name="java.lang.String access$102(com.hexidec.ekit.component.ImageURLDialog, java.lang.String)" map="B"/>
  <method class="com.hexidec.ekit.component.ImageURLDialog" name="java.lang.String getImageAlt()" map="C"/>
  <method class="com.hexidec.ekit.component.ImageURLDialog" name="java.lang.String getImageWidth()" map="D"/>
  <method class="com.hexidec.ekit.component.ImageURLDialog" name="java.lang.String access$302(com.hexidec.ekit.component.ImageURLDialog, java.lang.String)" map="C"/>
  <method class="com.hexidec.ekit.component.ImageURLDialog" name="javax.swing.JTextField access$200(com.hexidec.ekit.component.ImageURLDialog)" map="A"/>
  <method class="com.hexidec.ekit.component.ImageURLDialog" name="javax.swing.JTextField access$400(com.hexidec.ekit.component.ImageURLDialog)" map="B"/>
  <method class="com.hexidec.ekit.component.ImageURLDialog" name="javax.swing.JOptionPane access$000(com.hexidec.ekit.component.ImageURLDialog)" map="C"/>
  <method class="com.hexidec.ekit.component.ImageURLDialog" name="javax.swing.JTextField access$600(com.hexidec.ekit.component.ImageURLDialog)" map="D"/>
  <method class="com.hexidec.ekit.component.ImageURLDialog" name="javax.swing.JTextField access$800(com.hexidec.ekit.component.ImageURLDialog)" map="E"/>
  <method class="com.hexidec.ekit.component.ImageURLDialog" name="java.lang.String access$502(com.hexidec.ekit.component.ImageURLDialog, java.lang.String)" map="D"/>
  <package name="com.hexidec.ekit.action" map="C"/>
  <class name="com.hexidec.ekit.action.StylesAction" map="A"/>
  <field class="com.hexidec.ekit.action.StylesAction" name="parent" map="A"/>
  <method class="com.hexidec.ekit.action.StylesAction" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="com.hexidec.ekit.action.FormatAction" map="B"/>
  <field class="com.hexidec.ekit.action.FormatAction" name="htmlTag" map="A"/>
  <field class="com.hexidec.ekit.action.FormatAction" name="parentEkit" map="B"/>
  <method class="com.hexidec.ekit.action.FormatAction" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="com.hexidec.ekit.action.AlignAction" map="C"/>
  <field class="com.hexidec.ekit.action.AlignAction" name="parent" map="A"/>
  <method class="com.hexidec.ekit.action.AlignAction" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="com.hexidec.ekit.action.CustomAction" map="D"/>
  <field class="com.hexidec.ekit.action.CustomAction" name="htmlTag" map="A"/>
  <field class="com.hexidec.ekit.action.CustomAction" name="htmlAttribs" map="B"/>
  <field class="com.hexidec.ekit.action.CustomAction" name="parentEkit" map="C"/>
  <method class="com.hexidec.ekit.action.CustomAction" name="void insertAttr(javax.swing.text.SimpleAttributeSet, java.lang.Object, java.lang.Object)" map="A"/>
  <method class="com.hexidec.ekit.action.CustomAction" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="com.hexidec.ekit.action.CustomAction" name="void insertAttribute(javax.swing.text.SimpleAttributeSet, java.lang.Object, java.lang.Object)" map="B"/>
  <class name="com.hexidec.ekit.action.SetFontFamilyAction" map="E"/>
  <field class="com.hexidec.ekit.action.SetFontFamilyAction" name="name" map="A"/>
  <field class="com.hexidec.ekit.action.SetFontFamilyAction" name="parentEkit" map="B"/>
  <method class="com.hexidec.ekit.action.SetFontFamilyAction" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="com.hexidec.ekit.action.ListAutomationAction" map="F"/>
  <field class="com.hexidec.ekit.action.ListAutomationAction" name="baseTag" map="A"/>
  <field class="com.hexidec.ekit.action.ListAutomationAction" name="htmlUtilities" map="B"/>
  <field class="com.hexidec.ekit.action.ListAutomationAction" name="parentEkit" map="C"/>
  <method class="com.hexidec.ekit.action.ListAutomationAction" name="void revertList(javax.swing.text.Element)" map="A"/>
  <method class="com.hexidec.ekit.action.ListAutomationAction" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="com.hexidec.ekit.EkitCore$UndoAction" map="_A"/>
  <field class="com.hexidec.ekit.EkitCore$UndoAction" name="this$0" map="A"/>
  <method class="com.hexidec.ekit.EkitCore$UndoAction" name="void updateUndoState()" map="A"/>
  <method class="com.hexidec.ekit.EkitCore$UndoAction" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="com.hexidec.ekit.EkitCore$5" map="5"/>
  <field class="com.hexidec.ekit.EkitCore$5" name="this$0" map="A"/>
  <method class="com.hexidec.ekit.EkitCore$5" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="com.hexidec.ekit.EkitCore$4" map="4"/>
  <field class="com.hexidec.ekit.EkitCore$4" name="this$0" map="A"/>
  <method class="com.hexidec.ekit.EkitCore$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="com.hexidec.ekit.EkitCore$CustomUndoableEditListener" map="_B"/>
  <field class="com.hexidec.ekit.EkitCore$CustomUndoableEditListener" name="this$0" map="A"/>
  <method class="com.hexidec.ekit.EkitCore$CustomUndoableEditListener" name="void undoableEditHappened(javax.swing.event.UndoableEditEvent)" map="undoableEditHappened"/>
  <class name="com.hexidec.ekit.EkitCore$3" map="3"/>
  <field class="com.hexidec.ekit.EkitCore$3" name="this$0" map="A"/>
  <method class="com.hexidec.ekit.EkitCore$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="com.hexidec.ekit.EkitCore$2" map="2"/>
  <field class="com.hexidec.ekit.EkitCore$2" name="this$0" map="A"/>
  <method class="com.hexidec.ekit.EkitCore$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="com.hexidec.ekit.EkitCore$RedoAction" map="_C"/>
  <field class="com.hexidec.ekit.EkitCore$RedoAction" name="this$0" map="A"/>
  <method class="com.hexidec.ekit.EkitCore$RedoAction" name="void updateRedoState()" map="A"/>
  <method class="com.hexidec.ekit.EkitCore$RedoAction" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="com.hexidec.ekit.EkitCore$1" map="1"/>
  <field class="com.hexidec.ekit.EkitCore$1" name="this$0" map="A"/>
  <method class="com.hexidec.ekit.EkitCore$1" name="void caretUpdate(javax.swing.event.CaretEvent)" map="caretUpdate"/>
  <class name="com.hexidec.ekit.EkitCore" map="A"/>
  <field class="com.hexidec.ekit.EkitCore" name="lastSearchFindTerm" map="A"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnUnderline" map="B"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnPrint" map="C"/>
  <field class="com.hexidec.ekit.EkitCore" name="preserveUnknownTags" map="D"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnSaveHTML" map="E"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnNewStyledHTML" map="F"/>
  <field class="com.hexidec.ekit.EkitCore" name="jMenuDebug" map="G"/>
  <field class="com.hexidec.ekit.EkitCore" name="jcmbFontSelector" map="H"/>
  <field class="com.hexidec.ekit.EkitCore" name="redoAction" map="I"/>
  <field class="com.hexidec.ekit.EkitCore" name="actionFontItalic" map="J"/>
  <field class="com.hexidec.ekit.EkitCore" name="htmlDoc" map="K"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnNewHTML" map="L"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnSuperscript" map="M"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnEditTable" map="N"/>
  <field class="com.hexidec.ekit.EkitCore" name="jMenuFile" map="O"/>
  <field class="com.hexidec.ekit.EkitCore" name="actionAlignLeft" map="P"/>
  <field class="com.hexidec.ekit.EkitCore" name="jcbmiViewSource" map="Q"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnAlignCenter" map="R"/>
  <field class="com.hexidec.ekit.EkitCore" name="actionFontSubscript" map="S"/>
  <field class="com.hexidec.ekit.EkitCore" name="actionAlignJustified" map="T"/>
  <field class="com.hexidec.ekit.EkitCore" name="jcbmiViewToolbarStyles" map="U"/>
  <field class="com.hexidec.ekit.EkitCore" name="imageChooserStartDir" map="V"/>
  <field class="com.hexidec.ekit.EkitCore" name="extsSer" map="W"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnPasteX" map="X"/>
  <field class="com.hexidec.ekit.EkitCore" name="actionInsertAnchor" map="Y"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnAlignRight" map="Z"/>
  <field class="com.hexidec.ekit.EkitCore" name="extsRTF" map="_"/>
  <field class="com.hexidec.ekit.EkitCore" name="jToolBarStyles" map="a"/>
  <field class="com.hexidec.ekit.EkitCore" name="useFormIndicator" map="b"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnUndo" map="c"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnOpenHTML" map="d"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnDeleteRow" map="e"/>
  <field class="com.hexidec.ekit.EkitCore" name="jToolBar" map="f"/>
  <field class="com.hexidec.ekit.EkitCore" name="jspSource" map="g"/>
  <field class="com.hexidec.ekit.EkitCore" name="jMenuHelp" map="h"/>
  <field class="com.hexidec.ekit.EkitCore" name="jcbmiViewToolbarMain" map="i"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnUList" map="j"/>
  <field class="com.hexidec.ekit.EkitCore" name="actionAlignCenter" map="k"/>
  <field class="com.hexidec.ekit.EkitCore" name="currentFile" map="l"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnInsertRow" map="m"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnAlignLeft" map="n"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnEditCell" map="o"/>
  <field class="com.hexidec.ekit.EkitCore" name="jMenuTools" map="p"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnInsertColumn" map="q"/>
  <field class="com.hexidec.ekit.EkitCore" name="jMenuBar" map="r"/>
  <field class="com.hexidec.ekit.EkitCore" name="actionSelectFont" map="s"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnStrike" map="t"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnPaste" map="u"/>
  <field class="com.hexidec.ekit.EkitCore" name="actionFontSuperscript" map="v"/>
  <field class="com.hexidec.ekit.EkitCore" name="jtpMain" map="w"/>
  <field class="com.hexidec.ekit.EkitCore" name="clrFormIndicator" map="z"/>
  <field class="com.hexidec.ekit.EkitCore" name="actionListUnordered" map="&#x00a2;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnOList" map="&#x00a3;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnSubscript" map="&#x00a4;"/>
  <field class="com.hexidec.ekit.EkitCore" name="extsHTML" map="&#x00a5;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnFind" map="&#x00aa;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnRedo" map="&#x00b5;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnInsertTable" map="&#x00ba;"/>
  <field class="com.hexidec.ekit.EkitCore" name="enterIsBreak" map="&#x00c0;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnAlignJustified" map="&#x00c1;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jcmbStyleSelector" map="&#x00c2;"/>
  <field class="com.hexidec.ekit.EkitCore" name="lastSearchReplaceTerm" map="&#x00c3;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jMenuTable" map="&#x00c4;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnBold" map="&#x00c5;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jcbmiEnterKeyParag" map="&#x00c6;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jspltDisplay" map="&#x00c7;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jcbmiViewToolbarFormat" map="&#x00c8;"/>
  <field class="com.hexidec.ekit.EkitCore" name="actionFontBold" map="&#x00c9;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnUnicodeMath" map="&#x00ca;"/>
  <field class="com.hexidec.ekit.EkitCore" name="indentStep" map="&#x00cb;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnDeleteColumn" map="&#x00cc;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jToolBarFormat" map="&#x00cd;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jMenuSearch" map="&#x00ce;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jMenuFont" map="&#x00cf;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnAnchor" map="&#x00d0;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnItalic" map="&#x00d1;"/>
  <field class="com.hexidec.ekit.EkitCore" name="htMenus" map="&#x00d2;"/>
  <field class="com.hexidec.ekit.EkitCore" name="indent" map="&#x00d3;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jMenuFormat" map="&#x00d4;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jMenuView" map="&#x00d5;"/>
  <field class="com.hexidec.ekit.EkitCore" name="dfPlainText" map="&#x00d6;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnCut" map="&#x00d8;"/>
  <field class="com.hexidec.ekit.EkitCore" name="extsIMG" map="&#x00d9;"/>
  <field class="com.hexidec.ekit.EkitCore" name="frameHandler" map="&#x00da;"/>
  <field class="com.hexidec.ekit.EkitCore" name="actionAlignRight" map="&#x00db;"/>
  <field class="com.hexidec.ekit.EkitCore" name="CTRLKEY" map="&#x00dc;"/>
  <field class="com.hexidec.ekit.EkitCore" name="extsB64" map="&#x00dd;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jMenuEdit" map="&#x00de;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jtpSource" map="&#x00df;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jMenuForms" map="&#x00e0;"/>
  <field class="com.hexidec.ekit.EkitCore" name="actionListOrdered" map="&#x00e1;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnCopy" map="&#x00e2;"/>
  <field class="com.hexidec.ekit.EkitCore" name="actionFontUnderline" map="&#x00e3;"/>
  <field class="com.hexidec.ekit.EkitCore" name="extsCSS" map="&#x00e4;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jMenuInsert" map="&#x00e5;"/>
  <field class="com.hexidec.ekit.EkitCore" name="htmlKit" map="&#x00e6;"/>
  <field class="com.hexidec.ekit.EkitCore" name="exclusiveEdit" map="&#x00e7;"/>
  <field class="com.hexidec.ekit.EkitCore" name="appName" map="&#x00e8;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jtbtnViewSource" map="&#x00e9;"/>
  <field class="com.hexidec.ekit.EkitCore" name="menuDialog" map="&#x00ea;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jToolBarMain" map="&#x00eb;"/>
  <field class="com.hexidec.ekit.EkitCore" name="htmlUtilities" map="&#x00ec;"/>
  <field class="com.hexidec.ekit.EkitCore" name="actionFontStrike" map="&#x00ed;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jMenuToolbars" map="&#x00ee;"/>
  <field class="com.hexidec.ekit.EkitCore" name="undoMngr" map="&#x00ef;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jbtnUnicode" map="&#x00f0;"/>
  <field class="com.hexidec.ekit.EkitCore" name="lastSearchCaseSetting" map="&#x00f1;"/>
  <field class="com.hexidec.ekit.EkitCore" name="iSplitPos" map="&#x00f2;"/>
  <field class="com.hexidec.ekit.EkitCore" name="undoAction" map="&#x00f3;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jcbmiEnterKeyBreak" map="&#x00f4;"/>
  <field class="com.hexidec.ekit.EkitCore" name="lastSearchTopSetting" map="&#x00f5;"/>
  <field class="com.hexidec.ekit.EkitCore" name="sysClipboard" map="&#x00f6;"/>
  <field class="com.hexidec.ekit.EkitCore" name="htTools" map="&#x00f8;"/>
  <field class="com.hexidec.ekit.EkitCore" name="jcbmiViewToolbar" map="&#x00f9;"/>
  <field class="com.hexidec.ekit.EkitCore" name="styleSheet" map="&#x00fa;"/>
  <method class="com.hexidec.ekit.EkitCore" name="int getCaretPosition()" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="javax.swing.JMenuBar getMenuBar()" map="B"/>
  <method class="com.hexidec.ekit.EkitCore" name="boolean getEnterKeyIsBreak()" map="C"/>
  <method class="com.hexidec.ekit.EkitCore" name="java.lang.String getDocumentBody()" map="D"/>
  <method class="com.hexidec.ekit.EkitCore" name="void changedUpdate(javax.swing.event.DocumentEvent)" map="changedUpdate"/>
  <method class="com.hexidec.ekit.EkitCore" name="void describeDocument(javax.swing.text.StyledDocument)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="int findText(java.lang.String, java.lang.String, boolean, int)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="java.lang.String findStyle(javax.swing.text.Element)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void setFormattersActive(boolean)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void initializeMultiToolbars(java.lang.String)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void registerDocument(com.hexidec.ekit.component.ExtendedHTMLDocument)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void logException(java.lang.String, java.lang.Exception)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void removeEmptyLists()" map="E"/>
  <method class="com.hexidec.ekit.EkitCore" name="void insertURLImage()" map="F"/>
  <method class="com.hexidec.ekit.EkitCore" name="void removeUpdate(javax.swing.event.DocumentEvent)" map="removeUpdate"/>
  <method class="com.hexidec.ekit.EkitCore" name="java.lang.String getSubText(java.lang.String)" map="B"/>
  <method class="com.hexidec.ekit.EkitCore" name="void insertFormElement(javax.swing.text.html.HTML$Tag, java.lang.String, java.util.Hashtable, java.lang.String[], java.lang.String[], java.lang.String[], boolean)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void insertTable(java.util.Hashtable, java.lang.String[], java.lang.String[], java.lang.String[])" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void keyTyped(java.awt.event.KeyEvent)" map="keyTyped"/>
  <method class="com.hexidec.ekit.EkitCore" name="void removeEmptyListElement(javax.swing.text.Element)" map="B"/>
  <method class="com.hexidec.ekit.EkitCore" name="void writeOutFragment(javax.swing.text.html.HTMLDocument, java.lang.String)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void writeOutRTF(javax.swing.text.StyledDocument)" map="B"/>
  <method class="com.hexidec.ekit.EkitCore" name="javax.swing.JToolBar customizeToolBar(int, java.util.Vector, boolean)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void doSearch(java.lang.String, java.lang.String, boolean, boolean, boolean)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void writeOutFragment(javax.swing.text.html.HTMLDocument, java.lang.String, java.io.File)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void insertBreak()" map="G"/>
  <method class="com.hexidec.ekit.EkitCore" name="void insertUpdate(javax.swing.event.DocumentEvent)" map="insertUpdate"/>
  <method class="com.hexidec.ekit.EkitCore" name="void deleteTableRow()" map="H"/>
  <method class="com.hexidec.ekit.EkitCore" name="void loadDocument(java.io.File, java.lang.String, javax.swing.text.html.HTMLEditorKit$ParserCallback)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void access$000(com.hexidec.ekit.EkitCore, javax.swing.event.CaretEvent)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void openStyleSheet(java.io.File)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void insertFormElement(javax.swing.text.html.HTML$Tag, java.lang.String, java.util.Hashtable, java.lang.String[], java.lang.String[], boolean)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void insertTableRow()" map="I"/>
  <method class="com.hexidec.ekit.EkitCore" name="void registerDocumentStyles()" map="J"/>
  <method class="com.hexidec.ekit.EkitCore" name="void initializeSingleToolbar(java.lang.String)" map="C"/>
  <method class="com.hexidec.ekit.EkitCore" name="java.lang.String getFontNameFromSelector()" map="K"/>
  <method class="com.hexidec.ekit.EkitCore" name="void setEnterKeyIsBreak(boolean)" map="B"/>
  <method class="com.hexidec.ekit.EkitCore" name="com.hexidec.ekit.component.ExtendedHTMLDocument getExtendedHtmlDoc()" map="L"/>
  <method class="com.hexidec.ekit.EkitCore" name="javax.swing.JToolBar getToolBarStyles(boolean)" map="C"/>
  <method class="com.hexidec.ekit.EkitCore" name="void insertUnicodeChar(java.lang.String)" map="D"/>
  <method class="com.hexidec.ekit.EkitCore" name="void handleCaretPositionChange(javax.swing.event.CaretEvent)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="javax.swing.JToolBar getToolBarFormat(boolean)" map="D"/>
  <method class="com.hexidec.ekit.EkitCore" name="void purgeUndos()" map="M"/>
  <method class="com.hexidec.ekit.EkitCore" name="void writeOutRTF(javax.swing.text.StyledDocument, java.io.File)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void insertTableColumn()" map="N"/>
  <method class="com.hexidec.ekit.EkitCore" name="void insertLocalImage(java.io.File)" map="B"/>
  <method class="com.hexidec.ekit.EkitCore" name="void checkDocumentSpelling(javax.swing.text.Document)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void insertUnicode(int)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="boolean isSourceWindowActive()" map="O"/>
  <method class="com.hexidec.ekit.EkitCore" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <method class="com.hexidec.ekit.EkitCore" name="void refreshOnUpdate()" map="P"/>
  <method class="com.hexidec.ekit.EkitCore" name="javax.swing.JToolBar getToolBarMain(boolean)" map="E"/>
  <method class="com.hexidec.ekit.EkitCore" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="com.hexidec.ekit.EkitCore" name="void writeOutBase64(java.lang.String, java.io.File)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void keyReleased(java.awt.event.KeyEvent)" map="keyReleased"/>
  <method class="com.hexidec.ekit.EkitCore" name="javax.swing.JTextPane getTextPane()" map="Q"/>
  <method class="com.hexidec.ekit.EkitCore" name="void insertListStyle(javax.swing.text.Element)" map="C"/>
  <method class="com.hexidec.ekit.EkitCore" name="void focusGained(java.awt.event.FocusEvent)" map="focusGained"/>
  <method class="com.hexidec.ekit.EkitCore" name="void traverseElement(javax.swing.text.Element)" map="D"/>
  <method class="com.hexidec.ekit.EkitCore" name="void editTable()" map="R"/>
  <method class="com.hexidec.ekit.EkitCore" name="void insertHR()" map="S"/>
  <method class="com.hexidec.ekit.EkitCore" name="void writeOutBase64(java.lang.String)" map="E"/>
  <method class="com.hexidec.ekit.EkitCore" name="void handleDocumentChange(javax.swing.event.DocumentEvent)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void getImageFromChooser(java.lang.String, java.lang.String[], java.lang.String)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void setDocumentText(java.lang.String)" map="F"/>
  <method class="com.hexidec.ekit.EkitCore" name="void dispose()" map="T"/>
  <method class="com.hexidec.ekit.EkitCore" name="void openDocument(java.io.File, javax.swing.text.html.HTMLEditorKit$ParserCallback)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="javax.swing.JTextArea getSourcePane()" map="U"/>
  <method class="com.hexidec.ekit.EkitCore" name="void writeOut(javax.swing.text.html.HTMLDocument, java.io.File)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void serializeIn()" map="V"/>
  <method class="com.hexidec.ekit.EkitCore" name="void serializeOut(javax.swing.text.html.HTMLDocument)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void toggleSourceWindow()" map="W"/>
  <method class="com.hexidec.ekit.EkitCore" name="javax.swing.ImageIcon getEkitIcon(java.lang.String)" map="G"/>
  <method class="com.hexidec.ekit.EkitCore" name="void keyPressed(java.awt.event.KeyEvent)" map="keyPressed"/>
  <method class="com.hexidec.ekit.EkitCore" name="void openDocumentBase64(java.io.File)" map="C"/>
  <method class="com.hexidec.ekit.EkitCore" name="void openDocument(java.io.File)" map="D"/>
  <method class="com.hexidec.ekit.EkitCore" name="java.awt.Frame getFrame()" map="X"/>
  <method class="com.hexidec.ekit.EkitCore" name="void deleteTableColumn()" map="Y"/>
  <method class="com.hexidec.ekit.EkitCore" name="void setCaretPosition(int)" map="B"/>
  <method class="com.hexidec.ekit.EkitCore" name="void insertNonbreakingSpace()" map="Z"/>
  <method class="com.hexidec.ekit.EkitCore" name="java.io.File getFileFromChooser(java.lang.String, int, java.lang.String[], java.lang.String)" map="A"/>
  <method class="com.hexidec.ekit.EkitCore" name="void editCell()" map="_"/>
  <method class="com.hexidec.ekit.EkitCore" name="void updateTitle()" map="a"/>
  <package name="com.hexidec.util" map="B"/>
  <class name="com.hexidec.util.Base64Codec" map="A"/>
  <field class="com.hexidec.util.Base64Codec" name="Base64Tokens" map="A"/>
  <method class="com.hexidec.util.Base64Codec" name="java.lang.String encode(byte[])" map="A"/>
  <method class="com.hexidec.util.Base64Codec" name="java.lang.String decode(java.lang.String)" map="A"/>
  <method class="com.hexidec.util.Base64Codec" name="java.lang.String encode(java.lang.String)" map="B"/>
  <method class="com.hexidec.util.Base64Codec" name="byte[] decodeBytes(java.lang.String)" map="C"/>
  <method class="com.hexidec.util.Base64Codec" name="byte[] decodeBytes(byte[])" map="B"/>
  <class name="com.hexidec.util.Translatrix" map="B"/>
  <field class="com.hexidec.util.Translatrix" name="bundleName" map="A"/>
  <field class="com.hexidec.util.Translatrix" name="langResources" map="B"/>
  <method class="com.hexidec.util.Translatrix" name="void setLocale(java.util.Locale)" map="A"/>
  <method class="com.hexidec.util.Translatrix" name="void setBundleName(java.lang.String)" map="A"/>
  <method class="com.hexidec.util.Translatrix" name="void logException(java.lang.String, java.lang.Exception)" map="A"/>
  <method class="com.hexidec.util.Translatrix" name="java.lang.String getTranslationString(java.lang.String)" map="B"/>
  <package name="teamma" map="D"/>
  <package name="teamma.views" map="A"/>
  <package name="teamma.views.report" map="A"/>
  <class name="teamma.views.report.JdgPrintableRoster$4" map="4"/>
  <field class="teamma.views.report.JdgPrintableRoster$4" name="this$0" map="A"/>
  <method class="teamma.views.report.JdgPrintableRoster$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.report.JdgPrintableRoster$3" map="3"/>
  <field class="teamma.views.report.JdgPrintableRoster$3" name="this$0" map="A"/>
  <method class="teamma.views.report.JdgPrintableRoster$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.report.JdgPrintableRoster$2" map="2"/>
  <field class="teamma.views.report.JdgPrintableRoster$2" name="this$0" map="A"/>
  <method class="teamma.views.report.JdgPrintableRoster$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.report.JdgPrintableRoster$1" map="1"/>
  <field class="teamma.views.report.JdgPrintableRoster$1" name="this$0" map="A"/>
  <method class="teamma.views.report.JdgPrintableRoster$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.report.JdgPrintableRoster" map="A"/>
  <field class="teamma.views.report.JdgPrintableRoster" name="jPanel1" map="A"/>
  <field class="teamma.views.report.JdgPrintableRoster" name="jbtExport" map="B"/>
  <field class="teamma.views.report.JdgPrintableRoster" name="jepHTML" map="C"/>
  <field class="teamma.views.report.JdgPrintableRoster" name="jbtExportPDF" map="D"/>
  <field class="teamma.views.report.JdgPrintableRoster" name="jScrollPane1" map="E"/>
  <field class="teamma.views.report.JdgPrintableRoster" name="jbtPrint" map="F"/>
  <field class="teamma.views.report.JdgPrintableRoster" name="jbtOK" map="G"/>
  <field class="teamma.views.report.JdgPrintableRoster" name="mCoach" map="H"/>
  <field class="teamma.views.report.JdgPrintableRoster" name="mRoster" map="I"/>
  <field class="teamma.views.report.JdgPrintableRoster" name="mFilename" map="J"/>
  <field class="teamma.views.report.JdgPrintableRoster" name="mWithSkill" map="K"/>
  <field class="teamma.views.report.JdgPrintableRoster" name="LOG" map="L"/>
  <method class="teamma.views.report.JdgPrintableRoster" name="boolean isWithSkill()" map="A"/>
  <method class="teamma.views.report.JdgPrintableRoster" name="void initComponents()" map="B"/>
  <method class="teamma.views.report.JdgPrintableRoster" name="void jbtExportPDFActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="teamma.views.report.JdgPrintableRoster" name="void jbtPrintActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="teamma.views.report.JdgPrintableRoster" name="void access$200(teamma.views.report.JdgPrintableRoster, java.awt.event.ActionEvent)" map="A"/>
  <method class="teamma.views.report.JdgPrintableRoster" name="void access$300(teamma.views.report.JdgPrintableRoster, java.awt.event.ActionEvent)" map="B"/>
  <method class="teamma.views.report.JdgPrintableRoster" name="void access$100(teamma.views.report.JdgPrintableRoster, java.awt.event.ActionEvent)" map="C"/>
  <method class="teamma.views.report.JdgPrintableRoster" name="java.io.File createReport()" map="C"/>
  <method class="teamma.views.report.JdgPrintableRoster" name="void access$000(teamma.views.report.JdgPrintableRoster, java.awt.event.ActionEvent)" map="D"/>
  <method class="teamma.views.report.JdgPrintableRoster" name="java.io.File getmFilename()" map="D"/>
  <method class="teamma.views.report.JdgPrintableRoster" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="teamma.views.report.JdgPrintableRoster" name="void jbtExportActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="teamma.views.report.JdgPrintableRoster" name="tourma.data.Coach getmCoach()" map="E"/>
  <method class="teamma.views.report.JdgPrintableRoster" name="teamma.data.Roster getmRoster()" map="F"/>
  <class name="teamma.views.JdgRoster$19" map="19"/>
  <field class="teamma.views.JdgRoster$19" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$19" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgRoster$18" map="18"/>
  <field class="teamma.views.JdgRoster$18" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$18" name="void mouseClicked(java.awt.event.MouseEvent)" map="mouseClicked"/>
  <class name="teamma.views.JdgRoster$17" map="17"/>
  <field class="teamma.views.JdgRoster$17" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$17" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgRoster$16" map="16"/>
  <field class="teamma.views.JdgRoster$16" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$16" name="void mouseClicked(java.awt.event.MouseEvent)" map="mouseClicked"/>
  <class name="teamma.views.JdgRoster$15" map="15"/>
  <field class="teamma.views.JdgRoster$15" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$15" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgRoster$14" map="14"/>
  <field class="teamma.views.JdgRoster$14" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$14" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgRoster$13" map="13"/>
  <field class="teamma.views.JdgRoster$13" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$13" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgRoster$12" map="12"/>
  <field class="teamma.views.JdgRoster$12" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$12" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgRoster$11" map="11"/>
  <field class="teamma.views.JdgRoster$11" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$11" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgRoster$10" map="10"/>
  <field class="teamma.views.JdgRoster$10" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$10" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgRoster$9" map="9"/>
  <field class="teamma.views.JdgRoster$9" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$9" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgRoster$8" map="8"/>
  <field class="teamma.views.JdgRoster$8" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$8" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgRoster$7" map="7"/>
  <field class="teamma.views.JdgRoster$7" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$7" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgRoster$6" map="6"/>
  <field class="teamma.views.JdgRoster$6" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$6" name="void mouseClicked(java.awt.event.MouseEvent)" map="mouseClicked"/>
  <class name="teamma.views.JdgRoster$5" map="5"/>
  <field class="teamma.views.JdgRoster$5" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$5" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="teamma.views.JdgRoster$4" map="4"/>
  <field class="teamma.views.JdgRoster$4" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$4" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="teamma.views.JdgRoster$25" map="25"/>
  <field class="teamma.views.JdgRoster$25" name="$SwitchMap$teamma$data$LRB$E_Version" map="A"/>
  <class name="teamma.views.JdgRoster$24" map="24"/>
  <field class="teamma.views.JdgRoster$24" name="this$0" map="A"/>
  <field class="teamma.views.JdgRoster$24" name="val$jlbTotalCost" map="B"/>
  <field class="teamma.views.JdgRoster$24" name="val$team" map="C"/>
  <field class="teamma.views.JdgRoster$24" name="val$jslNb" map="D"/>
  <field class="teamma.views.JdgRoster$24" name="val$it" map="E"/>
  <method class="teamma.views.JdgRoster$24" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="teamma.views.JdgRoster$3" map="3"/>
  <field class="teamma.views.JdgRoster$3" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$3" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="teamma.views.JdgRoster$23" map="23"/>
  <field class="teamma.views.JdgRoster$23" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$23" name="void propertyChange(java.beans.PropertyChangeEvent)" map="propertyChange"/>
  <class name="teamma.views.JdgRoster$2" map="2"/>
  <field class="teamma.views.JdgRoster$2" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$2" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="teamma.views.JdgRoster$22" map="22"/>
  <field class="teamma.views.JdgRoster$22" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$22" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgRoster$1" map="1"/>
  <field class="teamma.views.JdgRoster$1" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$1" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="teamma.views.JdgRoster$21" map="21"/>
  <field class="teamma.views.JdgRoster$21" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$21" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgRoster$20" map="20"/>
  <field class="teamma.views.JdgRoster$20" name="this$0" map="A"/>
  <method class="teamma.views.JdgRoster$20" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgRoster" map="A"/>
  <field class="teamma.views.JdgRoster" name="jlbCostReroll" map="A"/>
  <field class="teamma.views.JdgRoster" name="jlbPriceCheerleaders" map="B"/>
  <field class="teamma.views.JdgRoster" name="jcbWithSkills" map="C"/>
  <field class="teamma.views.JdgRoster" name="jlbNbReroll" map="D"/>
  <field class="teamma.views.JdgRoster" name="jslCheerleaders" map="E"/>
  <field class="teamma.views.JdgRoster" name="_lrb" map="F"/>
  <field class="teamma.views.JdgRoster" name="jlbTotalCost" map="G"/>
  <field class="teamma.views.JdgRoster" name="jlbPriceAssists" map="H"/>
  <field class="teamma.views.JdgRoster" name="jbtRemove" map="I"/>
  <field class="teamma.views.JdgRoster" name="jbtExport" map="J"/>
  <field class="teamma.views.JdgRoster" name="jlbPriceApothecary" map="K"/>
  <field class="teamma.views.JdgRoster" name="jPanel7" map="L"/>
  <field class="teamma.views.JdgRoster" name="jPanel6" map="M"/>
  <field class="teamma.views.JdgRoster" name="jPanel5" map="N"/>
  <field class="teamma.views.JdgRoster" name="jPanel4" map="O"/>
  <field class="teamma.views.JdgRoster" name="jPanel3" map="P"/>
  <field class="teamma.views.JdgRoster" name="jPanel2" map="Q"/>
  <field class="teamma.views.JdgRoster" name="jlbRanking" map="R"/>
  <field class="teamma.views.JdgRoster" name="jLabel9" map="S"/>
  <field class="teamma.views.JdgRoster" name="jtbStars" map="T"/>
  <field class="teamma.views.JdgRoster" name="jLabel8" map="U"/>
  <field class="teamma.views.JdgRoster" name="jslReroll" map="V"/>
  <field class="teamma.views.JdgRoster" name="jlbCoachName" map="W"/>
  <field class="teamma.views.JdgRoster" name="jbtAdd" map="X"/>
  <field class="teamma.views.JdgRoster" name="jslFanFactor" map="Y"/>
  <field class="teamma.views.JdgRoster" name="jLabel1" map="Z"/>
  <field class="teamma.views.JdgRoster" name="_data" map="_"/>
  <field class="teamma.views.JdgRoster" name="jlbNbFanFactor" map="a"/>
  <field class="teamma.views.JdgRoster" name="jtbPlayers" map="b"/>
  <field class="teamma.views.JdgRoster" name="jlbCostApothecary" map="c"/>
  <field class="teamma.views.JdgRoster" name="_coach" map="d"/>
  <field class="teamma.views.JdgRoster" name="jcbLRB" map="e"/>
  <field class="teamma.views.JdgRoster" name="jlbTeamName" map="f"/>
  <field class="teamma.views.JdgRoster" name="LOG" map="g"/>
  <field class="teamma.views.JdgRoster" name="jbtRemoveStar" map="h"/>
  <field class="teamma.views.JdgRoster" name="jbtAddStar" map="i"/>
  <field class="teamma.views.JdgRoster" name="jtpGoods" map="j"/>
  <field class="teamma.views.JdgRoster" name="jPanel22" map="k"/>
  <field class="teamma.views.JdgRoster" name="jlbNbAssists" map="l"/>
  <field class="teamma.views.JdgRoster" name="jlbNbApothecary" map="m"/>
  <field class="teamma.views.JdgRoster" name="jPanel20" map="n"/>
  <field class="teamma.views.JdgRoster" name="jbtSelectCoach" map="o"/>
  <field class="teamma.views.JdgRoster" name="jslApothecary" map="p"/>
  <field class="teamma.views.JdgRoster" name="jlbCostCheerleaders" map="q"/>
  <field class="teamma.views.JdgRoster" name="jScrollPane2" map="r"/>
  <field class="teamma.views.JdgRoster" name="jPanel19" map="s"/>
  <field class="teamma.views.JdgRoster" name="jScrollPane1" map="t"/>
  <field class="teamma.views.JdgRoster" name="jPanel18" map="u"/>
  <field class="teamma.views.JdgRoster" name="jPanel17" map="v"/>
  <field class="teamma.views.JdgRoster" name="jPanel16" map="w"/>
  <field class="teamma.views.JdgRoster" name="jlbX20" map="z"/>
  <field class="teamma.views.JdgRoster" name="jPanel15" map="&#x00a2;"/>
  <field class="teamma.views.JdgRoster" name="jlbPriceFanFactor" map="&#x00a3;"/>
  <field class="teamma.views.JdgRoster" name="jLabel18" map="&#x00a4;"/>
  <field class="teamma.views.JdgRoster" name="jpnInducements" map="&#x00a5;"/>
  <field class="teamma.views.JdgRoster" name="jPanel14" map="&#x00aa;"/>
  <field class="teamma.views.JdgRoster" name="jLabel17" map="&#x00b5;"/>
  <field class="teamma.views.JdgRoster" name="jlbCostFanFactor" map="&#x00ba;"/>
  <field class="teamma.views.JdgRoster" name="jLabel16" map="&#x00c0;"/>
  <field class="teamma.views.JdgRoster" name="jbtRemoveSkill" map="&#x00c1;"/>
  <field class="teamma.views.JdgRoster" name="jLabel15" map="&#x00c2;"/>
  <field class="teamma.views.JdgRoster" name="jlbIcon" map="&#x00c3;"/>
  <field class="teamma.views.JdgRoster" name="jLabel12" map="&#x00c4;"/>
  <field class="teamma.views.JdgRoster" name="jLabel10" map="&#x00c5;"/>
  <field class="teamma.views.JdgRoster" name="lrbversion" map="&#x00c6;"/>
  <field class="teamma.views.JdgRoster" name="jlbRosterType" map="&#x00c7;"/>
  <field class="teamma.views.JdgRoster" name="jbtOK" map="&#x00c8;"/>
  <field class="teamma.views.JdgRoster" name="jslAssists" map="&#x00c9;"/>
  <field class="teamma.views.JdgRoster" name="jlbX10" map="&#x00ca;"/>
  <field class="teamma.views.JdgRoster" name="jlbPriceReroll" map="&#x00cb;"/>
  <field class="teamma.views.JdgRoster" name="jbtHTML" map="&#x00cc;"/>
  <field class="teamma.views.JdgRoster" name="jbtAddSkill" map="&#x00cd;"/>
  <field class="teamma.views.JdgRoster" name="jlbNbAssists9" map="&#x00ce;"/>
  <field class="teamma.views.JdgRoster" name="jlbNbAssists8" map="&#x00cf;"/>
  <field class="teamma.views.JdgRoster" name="jbtImport" map="&#x00d0;"/>
  <field class="teamma.views.JdgRoster" name="jpnTitle" map="&#x00d1;"/>
  <field class="teamma.views.JdgRoster" name="jlbNbAssists6" map="&#x00d2;"/>
  <field class="teamma.views.JdgRoster" name="jlbNbAssists5" map="&#x00d3;"/>
  <field class="teamma.views.JdgRoster" name="jlbNbAssists4" map="&#x00d4;"/>
  <field class="teamma.views.JdgRoster" name="jlbApothecary" map="&#x00d5;"/>
  <field class="teamma.views.JdgRoster" name="jlbNbAssists3" map="&#x00d6;"/>
  <field class="teamma.views.JdgRoster" name="jlbNbAssists2" map="&#x00d8;"/>
  <field class="teamma.views.JdgRoster" name="jlbNbAssists1" map="&#x00d9;"/>
  <field class="teamma.views.JdgRoster" name="jlbNbCherrleaders" map="&#x00da;"/>
  <field class="teamma.views.JdgRoster" name="jlbCostAssists" map="&#x00db;"/>
  <field class="teamma.views.JdgRoster" name="jpnCenter" map="&#x00dc;"/>
  <method class="teamma.views.JdgRoster" name="void jslFanFactorStateChanged(javax.swing.event.ChangeEvent)" map="A"/>
  <method class="teamma.views.JdgRoster" name="void access$2000(teamma.views.JdgRoster, java.awt.event.ActionEvent)" map="A"/>
  <method class="teamma.views.JdgRoster" name="void jcbLRBActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="teamma.views.JdgRoster" name="void access$800(teamma.views.JdgRoster, java.awt.event.ActionEvent)" map="B"/>
  <method class="teamma.views.JdgRoster" name="void access$300(teamma.views.JdgRoster, javax.swing.event.ChangeEvent)" map="A"/>
  <method class="teamma.views.JdgRoster" name="void jbtRemoveSkillActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="teamma.views.JdgRoster" name="javax.swing.JPanel createInducementPanel(teamma.data.InducementType, teamma.data.Roster)" map="A"/>
  <method class="teamma.views.JdgRoster" name="void jtbStarsMouseClicked(java.awt.event.MouseEvent)" map="A"/>
  <method class="teamma.views.JdgRoster" name="void access$1200(teamma.views.JdgRoster, java.awt.event.ActionEvent)" map="C"/>
  <method class="teamma.views.JdgRoster" name="void jbtAddStarActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="teamma.views.JdgRoster" name="void jbtExportActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="teamma.views.JdgRoster" name="void access$200(teamma.views.JdgRoster, javax.swing.event.ChangeEvent)" map="B"/>
  <method class="teamma.views.JdgRoster" name="void access$1800(teamma.views.JdgRoster, java.awt.event.ActionEvent)" map="D"/>
  <method class="teamma.views.JdgRoster" name="void jtbPlayersMouseClicked(java.awt.event.MouseEvent)" map="B"/>
  <method class="teamma.views.JdgRoster" name="void access$1700(teamma.views.JdgRoster, java.awt.event.MouseEvent)" map="A"/>
  <method class="teamma.views.JdgRoster" name="void clearRoster()" map="A"/>
  <method class="teamma.views.JdgRoster" name="void access$100(teamma.views.JdgRoster, javax.swing.event.ChangeEvent)" map="C"/>
  <method class="teamma.views.JdgRoster" name="void initComponents()" map="B"/>
  <method class="teamma.views.JdgRoster" name="void jbtSelectCoachActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="teamma.views.JdgRoster" name="void access$2100(teamma.views.JdgRoster, java.awt.event.ActionEvent)" map="E"/>
  <method class="teamma.views.JdgRoster" name="void access$600(teamma.views.JdgRoster, java.awt.event.ActionEvent)" map="F"/>
  <method class="teamma.views.JdgRoster" name="void access$900(teamma.views.JdgRoster, java.awt.event.ActionEvent)" map="G"/>
  <method class="teamma.views.JdgRoster" name="void jbtAddSkillActionPerformed(java.awt.event.ActionEvent)" map="F"/>
  <method class="teamma.views.JdgRoster" name="void access$1500(teamma.views.JdgRoster, java.awt.event.MouseEvent)" map="B"/>
  <method class="teamma.views.JdgRoster" name="void jslCheerleadersStateChanged(javax.swing.event.ChangeEvent)" map="B"/>
  <method class="teamma.views.JdgRoster" name="void access$000(teamma.views.JdgRoster, javax.swing.event.ChangeEvent)" map="D"/>
  <method class="teamma.views.JdgRoster" name="void jbtImportActionPerformed(java.awt.event.ActionEvent)" map="G"/>
  <method class="teamma.views.JdgRoster" name="void access$1000(teamma.views.JdgRoster, java.awt.event.ActionEvent)" map="H"/>
  <method class="teamma.views.JdgRoster" name="void access$1300(teamma.views.JdgRoster, java.awt.event.ActionEvent)" map="I"/>
  <method class="teamma.views.JdgRoster" name="void access$1600(teamma.views.JdgRoster, java.awt.event.ActionEvent)" map="J"/>
  <method class="teamma.views.JdgRoster" name="void access$2400(teamma.views.JdgRoster)" map="A"/>
  <method class="teamma.views.JdgRoster" name="void jslApothecaryStateChanged(javax.swing.event.ChangeEvent)" map="C"/>
  <method class="teamma.views.JdgRoster" name="void access$1900(teamma.views.JdgRoster, java.awt.event.ActionEvent)" map="K"/>
  <method class="teamma.views.JdgRoster" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="H"/>
  <method class="teamma.views.JdgRoster" name="void update()" map="C"/>
  <method class="teamma.views.JdgRoster" name="void access$700(teamma.views.JdgRoster, java.awt.event.ActionEvent)" map="L"/>
  <method class="teamma.views.JdgRoster" name="void jbtAddActionPerformed(java.awt.event.ActionEvent)" map="I"/>
  <method class="teamma.views.JdgRoster" name="void jbtHTMLActionPerformed(java.awt.event.ActionEvent)" map="J"/>
  <method class="teamma.views.JdgRoster" name="void access$500(teamma.views.JdgRoster, java.awt.event.MouseEvent)" map="C"/>
  <method class="teamma.views.JdgRoster" name="void jslRerollStateChanged(javax.swing.event.ChangeEvent)" map="D"/>
  <method class="teamma.views.JdgRoster" name="teamma.data.Roster access$2300(teamma.views.JdgRoster)" map="B"/>
  <method class="teamma.views.JdgRoster" name="javax.swing.JTable access$2200(teamma.views.JdgRoster)" map="C"/>
  <method class="teamma.views.JdgRoster" name="void jbtRemoveActionPerformed(java.awt.event.ActionEvent)" map="K"/>
  <method class="teamma.views.JdgRoster" name="void jlbIconActionPerformed(java.awt.event.ActionEvent)" map="L"/>
  <method class="teamma.views.JdgRoster" name="void jslAssistsStateChanged(javax.swing.event.ChangeEvent)" map="E"/>
  <method class="teamma.views.JdgRoster" name="void access$1100(teamma.views.JdgRoster, java.awt.event.ActionEvent)" map="M"/>
  <method class="teamma.views.JdgRoster" name="void access$1400(teamma.views.JdgRoster, java.awt.event.ActionEvent)" map="N"/>
  <method class="teamma.views.JdgRoster" name="void jbtRemoveStarActionPerformed(java.awt.event.ActionEvent)" map="M"/>
  <method class="teamma.views.JdgRoster" name="void jlbRosterTypeMouseClicked(java.awt.event.MouseEvent)" map="C"/>
  <method class="teamma.views.JdgRoster" name="void jcbWithSkillsActionPerformed(java.awt.event.ActionEvent)" map="N"/>
  <method class="teamma.views.JdgRoster" name="void access$400(teamma.views.JdgRoster, javax.swing.event.ChangeEvent)" map="E"/>
  <class name="teamma.views.JdgSelectSkill$4" map="4"/>
  <field class="teamma.views.JdgSelectSkill$4" name="this$0" map="A"/>
  <method class="teamma.views.JdgSelectSkill$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgSelectSkill$3" map="3"/>
  <field class="teamma.views.JdgSelectSkill$3" name="this$0" map="A"/>
  <method class="teamma.views.JdgSelectSkill$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgSelectSkill$2" map="2"/>
  <field class="teamma.views.JdgSelectSkill$2" name="this$0" map="A"/>
  <method class="teamma.views.JdgSelectSkill$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgSelectSkill$1" map="1"/>
  <field class="teamma.views.JdgSelectSkill$1" name="this$0" map="A"/>
  <method class="teamma.views.JdgSelectSkill$1" name="void itemStateChanged(java.awt.event.ItemEvent)" map="itemStateChanged"/>
  <class name="teamma.views.JdgSelectSkill" map="B"/>
  <field class="teamma.views.JdgSelectSkill" name="jPanel1" map="A"/>
  <field class="teamma.views.JdgSelectSkill" name="jpnSkills" map="B"/>
  <field class="teamma.views.JdgSelectSkill" name="_player" map="C"/>
  <field class="teamma.views.JdgSelectSkill" name="jbtCancel" map="D"/>
  <field class="teamma.views.JdgSelectSkill" name="_color" map="E"/>
  <field class="teamma.views.JdgSelectSkill" name="_jcbs" map="F"/>
  <field class="teamma.views.JdgSelectSkill" name="jbtOK" map="G"/>
  <field class="teamma.views.JdgSelectSkill" name="_lrb" map="H"/>
  <field class="teamma.views.JdgSelectSkill" name="jbtColor" map="I"/>
  <field class="teamma.views.JdgSelectSkill" name="jLabel1" map="J"/>
  <field class="teamma.views.JdgSelectSkill" name="jPanel2" map="K"/>
  <method class="teamma.views.JdgSelectSkill" name="void access$100(teamma.views.JdgSelectSkill, java.awt.event.ActionEvent)" map="A"/>
  <method class="teamma.views.JdgSelectSkill" name="void jbtColorActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="teamma.views.JdgSelectSkill" name="void initComponents()" map="A"/>
  <method class="teamma.views.JdgSelectSkill" name="void access$300(teamma.views.JdgSelectSkill, java.awt.event.ActionEvent)" map="B"/>
  <method class="teamma.views.JdgSelectSkill" name="void access$200(teamma.views.JdgSelectSkill, java.awt.event.ActionEvent)" map="C"/>
  <method class="teamma.views.JdgSelectSkill" name="java.util.ArrayList access$000(teamma.views.JdgSelectSkill)" map="A"/>
  <method class="teamma.views.JdgSelectSkill" name="void jbtCancelActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="teamma.views.JdgSelectSkill" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="teamma.views.JdgSelectSkill" name="teamma.data.Player getPlayer()" map="B"/>
  <method class="teamma.views.JdgSelectSkill" name="java.awt.Color getColor()" map="C"/>
  <class name="teamma.views.JdgSelectPosition$2" map="2"/>
  <field class="teamma.views.JdgSelectPosition$2" name="this$0" map="A"/>
  <method class="teamma.views.JdgSelectPosition$2" name="void mouseClicked(java.awt.event.MouseEvent)" map="mouseClicked"/>
  <class name="teamma.views.JdgSelectPosition$1" map="1"/>
  <field class="teamma.views.JdgSelectPosition$1" name="this$0" map="A"/>
  <method class="teamma.views.JdgSelectPosition$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="teamma.views.JdgSelectPosition" map="C"/>
  <field class="teamma.views.JdgSelectPosition" name="mStarPlayer" map="A"/>
  <field class="teamma.views.JdgSelectPosition" name="jpn" map="B"/>
  <field class="teamma.views.JdgSelectPosition" name="mPlayerType" map="C"/>
  <field class="teamma.views.JdgSelectPosition" name="jScrollPane1" map="D"/>
  <field class="teamma.views.JdgSelectPosition" name="mPositions" map="E"/>
  <field class="teamma.views.JdgSelectPosition" name="jtPositions" map="F"/>
  <field class="teamma.views.JdgSelectPosition" name="mStarPlayers" map="G"/>
  <field class="teamma.views.JdgSelectPosition" name="jbtOK" map="H"/>
  <field class="teamma.views.JdgSelectPosition" name="jLabel1" map="I"/>
  <field class="teamma.views.JdgSelectPosition" name="jPanel2" map="J"/>
  <method class="teamma.views.JdgSelectPosition" name="void access$000(teamma.views.JdgSelectPosition, java.awt.event.ActionEvent)" map="A"/>
  <method class="teamma.views.JdgSelectPosition" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="teamma.views.JdgSelectPosition" name="void initComponents()" map="A"/>
  <method class="teamma.views.JdgSelectPosition" name="teamma.data.StarPlayer getStarPlayer()" map="B"/>
  <method class="teamma.views.JdgSelectPosition" name="void access$100(teamma.views.JdgSelectPosition, java.awt.event.MouseEvent)" map="A"/>
  <method class="teamma.views.JdgSelectPosition" name="void jtPositionsMouseClicked(java.awt.event.MouseEvent)" map="A"/>
  <method class="teamma.views.JdgSelectPosition" name="teamma.data.PlayerType getPosition()" map="C"/>
  <package name="teamma.data" map="B"/>
  <class name="teamma.data.RosterType" map="A"/>
  <field class="teamma.data.RosterType" name="_cheerleader_cost" map="A"/>
  <field class="teamma.data.RosterType" name="_apothecary" map="B"/>
  <field class="teamma.data.RosterType" name="_Fink_Da_Fixer_cost" map="C"/>
  <field class="teamma.data.RosterType" name="_igor_cost" map="D"/>
  <field class="teamma.data.RosterType" name="_image" map="E"/>
  <field class="teamma.data.RosterType" name="version" map="F"/>
  <field class="teamma.data.RosterType" name="_inducements" map="G"/>
  <field class="teamma.data.RosterType" name="_player_types" map="H"/>
  <field class="teamma.data.RosterType" name="_Horatio_X_Schottenheim_cost" map="I"/>
  <field class="teamma.data.RosterType" name="_babe_cost" map="J"/>
  <field class="teamma.data.RosterType" name="LOG" map="K"/>
  <field class="teamma.data.RosterType" name="_reroll_cost" map="L"/>
  <field class="teamma.data.RosterType" name="_Galandril_Silverwater_cost" map="M"/>
  <field class="teamma.data.RosterType" name="_available_starplayers" map="N"/>
  <field class="teamma.data.RosterType" name="_name" map="O"/>
  <field class="teamma.data.RosterType" name="_Krot_Shockwhisker_cost" map="P"/>
  <field class="teamma.data.RosterType" name="_fan_factor_cost" map="Q"/>
  <field class="teamma.data.RosterType" name="_Kari_Coldstell_cost" map="R"/>
  <field class="teamma.data.RosterType" name="_chaos_wizard_cost" map="S"/>
  <field class="teamma.data.RosterType" name="extraRerollCost" map="T"/>
  <field class="teamma.data.RosterType" name="_apothecary_cost" map="U"/>
  <field class="teamma.data.RosterType" name="_local_apo_cost" map="V"/>
  <field class="teamma.data.RosterType" name="_assistant_cost" map="W"/>
  <field class="teamma.data.RosterType" name="_wizard_cost" map="X"/>
  <field class="teamma.data.RosterType" name="_Papa_Skullbones_cost" map="Y"/>
  <method class="teamma.data.RosterType" name="void clearPlayerType()" map="A"/>
  <method class="teamma.data.RosterType" name="teamma.data.StarPlayer getAvailableStarplayer(int)" map="A"/>
  <method class="teamma.data.RosterType" name="teamma.data.PlayerType getPlayerType(java.lang.String, boolean)" map="A"/>
  <method class="teamma.data.RosterType" name="int getFan_factor_cost()" map="B"/>
  <method class="teamma.data.RosterType" name="int getAssistant_cost()" map="C"/>
  <method class="teamma.data.RosterType" name="void addPlayerType(teamma.data.PlayerType)" map="A"/>
  <method class="teamma.data.RosterType" name="void addAvailableStarPlayer(teamma.data.StarPlayer)" map="A"/>
  <method class="teamma.data.RosterType" name="teamma.data.PlayerType getPlayerType(int)" map="B"/>
  <method class="teamma.data.RosterType" name="teamma.data.InducementType getInducementType(int)" map="C"/>
  <method class="teamma.data.RosterType" name="void addInducementType(teamma.data.InducementType)" map="A"/>
  <method class="teamma.data.RosterType" name="void setReroll_cost(int)" map="D"/>
  <method class="teamma.data.RosterType" name="int getAvailableStarplayerCount()" map="D"/>
  <method class="teamma.data.RosterType" name="void setVersion(teamma.data.LRB$E_Version)" map="A"/>
  <method class="teamma.data.RosterType" name="teamma.data.InducementType getInducementType(java.lang.String)" map="A"/>
  <method class="teamma.data.RosterType" name="java.lang.String getImage()" map="E"/>
  <method class="teamma.data.RosterType" name="java.lang.String getName()" map="F"/>
  <method class="teamma.data.RosterType" name="int getCheerleader_cost()" map="G"/>
  <method class="teamma.data.RosterType" name="int getReroll_cost()" map="H"/>
  <method class="teamma.data.RosterType" name="int getPlayerTypeCount()" map="I"/>
  <method class="teamma.data.RosterType" name="void setApothecary(boolean)" map="A"/>
  <method class="teamma.data.RosterType" name="void clearInducementType()" map="J"/>
  <method class="teamma.data.RosterType" name="boolean isApothecary()" map="K"/>
  <method class="teamma.data.RosterType" name="teamma.data.LRB$E_Version getVersion()" map="L"/>
  <method class="teamma.data.RosterType" name="int getApothecary_cost()" map="M"/>
  <method class="teamma.data.RosterType" name="int getInducementTypeSize()" map="N"/>
  <method class="teamma.data.RosterType" name="void setImage(java.lang.String)" map="B"/>
  <class name="teamma.data.Player" map="B"/>
  <field class="teamma.data.Player" name="_name" map="A"/>
  <field class="teamma.data.Player" name="_skills" map="B"/>
  <field class="teamma.data.Player" name="_playertype" map="C"/>
  <method class="teamma.data.Player" name="int getStrength()" map="A"/>
  <method class="teamma.data.Player" name="void setName(java.lang.String)" map="A"/>
  <method class="teamma.data.Player" name="int getArmor()" map="B"/>
  <method class="teamma.data.Player" name="int getSkillCount()" map="C"/>
  <method class="teamma.data.Player" name="void removeSkill(int)" map="A"/>
  <method class="teamma.data.Player" name="int getAgility()" map="D"/>
  <method class="teamma.data.Player" name="teamma.data.PlayerType getPlayertype()" map="E"/>
  <method class="teamma.data.Player" name="void pull(teamma.data.Player, teamma.data.LRB$E_Version)" map="A"/>
  <method class="teamma.data.Player" name="int getValue(boolean)" map="A"/>
  <method class="teamma.data.Player" name="int getMovement()" map="F"/>
  <method class="teamma.data.Player" name="java.lang.String getName()" map="G"/>
  <method class="teamma.data.Player" name="teamma.data.Skill getSkill(int)" map="B"/>
  <method class="teamma.data.Player" name="void addSkill(teamma.data.Skill)" map="A"/>
  <class name="teamma.data.LRB$E_Version" map="_A"/>
  <field class="teamma.data.LRB$E_Version" name="BB2016" map="A"/>
  <field class="teamma.data.LRB$E_Version" name="$VALUES" map="B"/>
  <field class="teamma.data.LRB$E_Version" name="CRP1" map="C"/>
  <field class="teamma.data.LRB$E_Version" name="LRB6" map="D"/>
  <field class="teamma.data.LRB$E_Version" name="LRB5" map="E"/>
  <field class="teamma.data.LRB$E_Version" name="LRB4" map="F"/>
  <field class="teamma.data.LRB$E_Version" name="LRB3" map="G"/>
  <field class="teamma.data.LRB$E_Version" name="LRB2" map="H"/>
  <field class="teamma.data.LRB$E_Version" name="LRB1" map="I"/>
  <method class="teamma.data.LRB$E_Version" name="teamma.data.LRB$E_Version[] values()" map="values"/>
  <method class="teamma.data.LRB$E_Version" name="teamma.data.LRB$E_Version valueOf(java.lang.String)" map="valueOf"/>
  <class name="teamma.data.LRB$1" map="1"/>
  <field class="teamma.data.LRB$1" name="$SwitchMap$teamma$data$LRB$E_Version" map="A"/>
  <class name="teamma.data.LRB" map="C"/>
  <field class="teamma.data.LRB" name="_reroll_enabled" map="A"/>
  <field class="teamma.data.LRB" name="myLock" map="B"/>
  <field class="teamma.data.LRB" name="_cards_enabled" map="C"/>
  <field class="teamma.data.LRB" name="_naf2017" map="D"/>
  <field class="teamma.data.LRB" name="_papa_skullbones" map="E"/>
  <field class="teamma.data.LRB" name="_chaos_wizard" map="F"/>
  <field class="teamma.data.LRB" name="_name" map="G"/>
  <field class="teamma.data.LRB" name="_fink_da_fixer" map="H"/>
  <field class="teamma.data.LRB" name="_version" map="I"/>
  <field class="teamma.data.LRB" name="_allowSpecialSkills" map="J"/>
  <field class="teamma.data.LRB" name="_crp1" map="K"/>
  <field class="teamma.data.LRB" name="_igor_enabled" map="L"/>
  <field class="teamma.data.LRB" name="_chef_enabled" map="M"/>
  <field class="teamma.data.LRB" name="_mercenaries_enabled" map="N"/>
  <field class="teamma.data.LRB" name="_bribes_enabled" map="O"/>
  <field class="teamma.data.LRB" name="_krot_shockwhisker" map="P"/>
  <field class="teamma.data.LRB" name="_starplayers_enabled" map="Q"/>
  <field class="teamma.data.LRB" name="_wizard_enabled" map="R"/>
  <field class="teamma.data.LRB" name="_min_ff" map="S"/>
  <field class="teamma.data.LRB" name="_lrb6" map="T"/>
  <field class="teamma.data.LRB" name="_lrb5" map="U"/>
  <field class="teamma.data.LRB" name="_lrb4" map="V"/>
  <field class="teamma.data.LRB" name="_lrb3" map="W"/>
  <field class="teamma.data.LRB" name="_lrb2" map="X"/>
  <field class="teamma.data.LRB" name="_babes_enabled" map="Y"/>
  <field class="teamma.data.LRB" name="_lrb1" map="Z"/>
  <field class="teamma.data.LRB" name="LOG" map="_"/>
  <field class="teamma.data.LRB" name="_starPlayers" map="a"/>
  <field class="teamma.data.LRB" name="_rosterTypes" map="b"/>
  <field class="teamma.data.LRB" name="_skillTypes" map="c"/>
  <field class="teamma.data.LRB" name="_check_nb_big_guys" map="d"/>
  <field class="teamma.data.LRB" name="_max_ff" map="e"/>
  <field class="teamma.data.LRB" name="_galandril_silverwater" map="f"/>
  <field class="teamma.data.LRB" name="_horacio_x_schottenheim" map="g"/>
  <field class="teamma.data.LRB" name="_kari_coldstell" map="h"/>
  <field class="teamma.data.LRB" name="_local_apothecaries_enabled" map="i"/>
  <method class="teamma.data.LRB" name="void addStarPlayer(teamma.data.StarPlayer)" map="A"/>
  <method class="teamma.data.LRB" name="teamma.data.RosterType getRosterType(java.lang.String, boolean)" map="A"/>
  <method class="teamma.data.LRB" name="void clearRosterTypes()" map="A"/>
  <method class="teamma.data.LRB" name="teamma.data.StarPlayer getStarPlayer(int)" map="A"/>
  <method class="teamma.data.LRB" name="teamma.data.Skill getSkill(java.lang.String, boolean)" map="B"/>
  <method class="teamma.data.LRB" name="teamma.data.RosterType getRosterType(int)" map="B"/>
  <method class="teamma.data.LRB" name="int getSkillTypeCount()" map="B"/>
  <method class="teamma.data.LRB" name="int getStarPlayerCount()" map="C"/>
  <method class="teamma.data.LRB" name="void setAllowSpecialSkills(boolean)" map="A"/>
  <method class="teamma.data.LRB" name="void loadStarPlayers(java.io.InputStream)" map="A"/>
  <method class="teamma.data.LRB" name="teamma.data.SkillType getSkillType(int)" map="C"/>
  <method class="teamma.data.LRB" name="teamma.data.StarPlayer getStarPlayer(java.lang.String)" map="A"/>
  <method class="teamma.data.LRB" name="void addRosterType(teamma.data.RosterType)" map="A"/>
  <method class="teamma.data.LRB" name="void addSkillType(teamma.data.SkillType)" map="A"/>
  <method class="teamma.data.LRB" name="void loadLRB(java.io.InputStream, java.lang.String)" map="A"/>
  <method class="teamma.data.LRB" name="void setName(java.lang.String)" map="B"/>
  <method class="teamma.data.LRB" name="teamma.data.SkillType getSkillType(java.lang.String)" map="C"/>
  <method class="teamma.data.LRB" name="void loadSkills(java.io.InputStream)" map="B"/>
  <method class="teamma.data.LRB" name="int getRosterTypeCount()" map="D"/>
  <method class="teamma.data.LRB" name="void clearSkillTypes()" map="E"/>
  <method class="teamma.data.LRB" name="void loadTeam(java.io.InputStream, java.lang.String)" map="B"/>
  <method class="teamma.data.LRB" name="teamma.data.LRB getLRB(teamma.data.LRB$E_Version)" map="A"/>
  <method class="teamma.data.LRB" name="void clearStarPlayers()" map="F"/>
  <method class="teamma.data.LRB" name="teamma.data.RosterType getRosterType(java.lang.String)" map="D"/>
  <method class="teamma.data.LRB" name="java.util.ArrayList getRosterTypeListAsString(boolean)" map="B"/>
  <method class="teamma.data.LRB" name="boolean isAllowSpecialSkills()" map="G"/>
  <class name="teamma.data.SkillType" map="D"/>
  <field class="teamma.data.SkillType" name="_special" map="A"/>
  <field class="teamma.data.SkillType" name="_name" map="B"/>
  <field class="teamma.data.SkillType" name="LOG" map="C"/>
  <field class="teamma.data.SkillType" name="_accronym" map="D"/>
  <field class="teamma.data.SkillType" name="_skills" map="E"/>
  <method class="teamma.data.SkillType" name="boolean isSpecial()" map="A"/>
  <method class="teamma.data.SkillType" name="void setSpecial(boolean)" map="A"/>
  <method class="teamma.data.SkillType" name="void addSkill(teamma.data.Skill)" map="A"/>
  <method class="teamma.data.SkillType" name="teamma.data.Skill getSkill(int)" map="A"/>
  <method class="teamma.data.SkillType" name="int getSkillCount()" map="B"/>
  <method class="teamma.data.SkillType" name="java.lang.String getAccronym()" map="C"/>
  <method class="teamma.data.SkillType" name="java.lang.String getName()" map="D"/>
  <class name="teamma.data.Skill" map="E"/>
  <field class="teamma.data.Skill" name="mColor" map="A"/>
  <field class="teamma.data.Skill" name="mName" map="B"/>
  <field class="teamma.data.Skill" name="mCategory" map="C"/>
  <method class="teamma.data.Skill" name="java.awt.Color getmColor()" map="A"/>
  <method class="teamma.data.Skill" name="void setmColor(java.awt.Color)" map="A"/>
  <method class="teamma.data.Skill" name="teamma.data.SkillType getmCategory()" map="B"/>
  <method class="teamma.data.Skill" name="java.lang.String getmName()" map="C"/>
  <class name="teamma.data.InducementType" map="F"/>
  <field class="teamma.data.InducementType" name="_name" map="A"/>
  <field class="teamma.data.InducementType" name="_nbMax" map="B"/>
  <field class="teamma.data.InducementType" name="_cost" map="C"/>
  <method class="teamma.data.InducementType" name="int getNbMax()" map="A"/>
  <method class="teamma.data.InducementType" name="void setCost(int)" map="A"/>
  <method class="teamma.data.InducementType" name="void setName(java.lang.String)" map="A"/>
  <method class="teamma.data.InducementType" name="java.lang.String getName()" map="B"/>
  <method class="teamma.data.InducementType" name="void setNbMax(int)" map="B"/>
  <method class="teamma.data.InducementType" name="int getCost()" map="C"/>
  <class name="teamma.data.StarPlayer" map="G"/>
  <field class="teamma.data.StarPlayer" name="_agility" map="A"/>
  <field class="teamma.data.StarPlayer" name="_armor" map="B"/>
  <field class="teamma.data.StarPlayer" name="_movement" map="C"/>
  <field class="teamma.data.StarPlayer" name="_strength" map="D"/>
  <field class="teamma.data.StarPlayer" name="_position" map="E"/>
  <field class="teamma.data.StarPlayer" name="_rosters" map="F"/>
  <field class="teamma.data.StarPlayer" name="_name" map="G"/>
  <field class="teamma.data.StarPlayer" name="_skills" map="H"/>
  <field class="teamma.data.StarPlayer" name="LOG" map="I"/>
  <field class="teamma.data.StarPlayer" name="_cost" map="J"/>
  <method class="teamma.data.StarPlayer" name="int getStrength()" map="A"/>
  <method class="teamma.data.StarPlayer" name="void setAgility(int)" map="A"/>
  <method class="teamma.data.StarPlayer" name="void setStrength(int)" map="B"/>
  <method class="teamma.data.StarPlayer" name="void addRoster(teamma.data.RosterType)" map="A"/>
  <method class="teamma.data.StarPlayer" name="int getArmor()" map="B"/>
  <method class="teamma.data.StarPlayer" name="void setPosition(java.lang.String)" map="A"/>
  <method class="teamma.data.StarPlayer" name="void setCost(int)" map="C"/>
  <method class="teamma.data.StarPlayer" name="int getSkillCount()" map="C"/>
  <method class="teamma.data.StarPlayer" name="int getAgility()" map="D"/>
  <method class="teamma.data.StarPlayer" name="int getCost()" map="E"/>
  <method class="teamma.data.StarPlayer" name="void setArmor(int)" map="D"/>
  <method class="teamma.data.StarPlayer" name="int getMovement()" map="F"/>
  <method class="teamma.data.StarPlayer" name="java.lang.String getName()" map="G"/>
  <method class="teamma.data.StarPlayer" name="void setMovement(int)" map="E"/>
  <method class="teamma.data.StarPlayer" name="teamma.data.Skill getSkill(int)" map="F"/>
  <method class="teamma.data.StarPlayer" name="void addSkill(teamma.data.Skill)" map="A"/>
  <method class="teamma.data.StarPlayer" name="java.lang.String getPosition()" map="H"/>
  <class name="teamma.data.Roster$1" map="1"/>
  <field class="teamma.data.Roster$1" name="$SwitchMap$teamma$data$LRB$E_Version" map="A"/>
  <class name="teamma.data.Roster" map="H"/>
  <field class="teamma.data.Roster" name="_players" map="&#x01b3;"/>
  <field class="teamma.data.Roster" name="_fanfactor" map="&#x01b4;"/>
  <field class="teamma.data.Roster" name="_inducements" map="&#x01b5;"/>
  <field class="teamma.data.Roster" name="_version" map="&#x01b6;"/>
  <field class="teamma.data.Roster" name="_cheerleaders" map="&#x01b7;"/>
  <field class="teamma.data.Roster" name="_assistants" map="&#x01b8;"/>
  <field class="teamma.data.Roster" name="_rerolls" map="&#x01b9;"/>
  <field class="teamma.data.Roster" name="_apothecary" map="&#x01ba;"/>
  <field class="teamma.data.Roster" name="_champions" map="&#x01bb;"/>
  <field class="teamma.data.Roster" name="_roster" map="&#x01bc;"/>
  <method class="teamma.data.Roster" name="int getCheerleaders()" map="&#x019f;"/>
  <method class="teamma.data.Roster" name="teamma.data.Player getPlayer(int)" map="&#x00ee;"/>
  <method class="teamma.data.Roster" name="void pull(teamma.data.Roster)" map="B"/>
  <method class="teamma.data.Roster" name="void addChampion(teamma.data.StarPlayer)" map="A"/>
  <method class="teamma.data.Roster" name="void setCheerleaders(int)" map="&#x00ef;"/>
  <method class="teamma.data.Roster" name="void setRerolls(int)" map="&#x00f0;"/>
  <method class="teamma.data.Roster" name="int getInducementsSize()" map="&#x01a0;"/>
  <method class="teamma.data.Roster" name="teamma.data.Inducement getInducement(int)" map="&#x00f1;"/>
  <method class="teamma.data.Roster" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="teamma.data.Roster" name="void setAssistants(int)" map="&#x00f2;"/>
  <method class="teamma.data.Roster" name="void setVersion(teamma.data.LRB$E_Version)" map="A"/>
  <method class="teamma.data.Roster" name="int getAssistants()" map="&#x01a1;"/>
  <method class="teamma.data.Roster" name="teamma.data.RosterType getRoster()" map="&#x01a2;"/>
  <method class="teamma.data.Roster" name="int getFanfactor()" map="&#x01a3;"/>
  <method class="teamma.data.Roster" name="void removeChampion(int)" map="&#x00f3;"/>
  <method class="teamma.data.Roster" name="void setApothecary(boolean)" map="y"/>
  <method class="teamma.data.Roster" name="int getRerolls()" map="&#x01a4;"/>
  <method class="teamma.data.Roster" name="boolean isApothecary()" map="&#x01a5;"/>
  <method class="teamma.data.Roster" name="int getPlayerCount()" map="&#x01a6;"/>
  <method class="teamma.data.Roster" name="void setFanfactor(int)" map="&#x00f4;"/>
  <method class="teamma.data.Roster" name="int getValue(boolean)" map="z"/>
  <method class="teamma.data.Roster" name="teamma.data.LRB$E_Version getVersion()" map="&#x01a7;"/>
  <method class="teamma.data.Roster" name="void clearPlayers()" map="&#x01a8;"/>
  <method class="teamma.data.Roster" name="void removePlayer(int)" map="&#x00f5;"/>
  <method class="teamma.data.Roster" name="int getNbInduc(teamma.data.InducementType)" map="A"/>
  <method class="teamma.data.Roster" name="void setInducement(teamma.data.InducementType, int)" map="A"/>
  <method class="teamma.data.Roster" name="void addPlayer(teamma.data.Player)" map="A"/>
  <method class="teamma.data.Roster" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="teamma.data.Roster" name="void setRoster(teamma.data.RosterType)" map="A"/>
  <method class="teamma.data.Roster" name="int getChampionCount()" map="&#x01a9;"/>
  <method class="teamma.data.Roster" name="teamma.data.StarPlayer getChampion(int)" map="&#x00f6;"/>
  <class name="teamma.data.PlayerType" map="I"/>
  <field class="teamma.data.PlayerType" name="_agility" map="A"/>
  <field class="teamma.data.PlayerType" name="_armor" map="B"/>
  <field class="teamma.data.PlayerType" name="_movement" map="C"/>
  <field class="teamma.data.PlayerType" name="_strength" map="D"/>
  <field class="teamma.data.PlayerType" name="_double" map="E"/>
  <field class="teamma.data.PlayerType" name="_single" map="F"/>
  <field class="teamma.data.PlayerType" name="_limit" map="G"/>
  <field class="teamma.data.PlayerType" name="_position" map="H"/>
  <field class="teamma.data.PlayerType" name="_skills" map="I"/>
  <field class="teamma.data.PlayerType" name="_cost" map="J"/>
  <method class="teamma.data.PlayerType" name="void setCost(int)" map="A"/>
  <method class="teamma.data.PlayerType" name="void setArmor(int)" map="B"/>
  <method class="teamma.data.PlayerType" name="teamma.data.Skill getSkill(int)" map="C"/>
  <method class="teamma.data.PlayerType" name="boolean containedBySingle(teamma.data.SkillType)" map="A"/>
  <method class="teamma.data.PlayerType" name="void addSingle(teamma.data.SkillType)" map="B"/>
  <method class="teamma.data.PlayerType" name="void setStrength(int)" map="D"/>
  <method class="teamma.data.PlayerType" name="java.lang.String getPosition()" map="A"/>
  <method class="teamma.data.PlayerType" name="void setAgility(int)" map="E"/>
  <method class="teamma.data.PlayerType" name="int getLimit()" map="B"/>
  <method class="teamma.data.PlayerType" name="int getMovement()" map="C"/>
  <method class="teamma.data.PlayerType" name="int getCost()" map="D"/>
  <method class="teamma.data.PlayerType" name="int getSingleCount()" map="E"/>
  <method class="teamma.data.PlayerType" name="teamma.data.SkillType getSingle(int)" map="F"/>
  <method class="teamma.data.PlayerType" name="boolean containedByDouble(teamma.data.SkillType)" map="C"/>
  <method class="teamma.data.PlayerType" name="int getSkillCount()" map="F"/>
  <method class="teamma.data.PlayerType" name="int getArmor()" map="G"/>
  <method class="teamma.data.PlayerType" name="teamma.data.SkillType getDouble(int)" map="G"/>
  <method class="teamma.data.PlayerType" name="int getAgility()" map="H"/>
  <method class="teamma.data.PlayerType" name="void setMovement(int)" map="H"/>
  <method class="teamma.data.PlayerType" name="void setLimit(int)" map="I"/>
  <method class="teamma.data.PlayerType" name="void addSkill(teamma.data.Skill)" map="A"/>
  <method class="teamma.data.PlayerType" name="int getDoubleCount()" map="I"/>
  <method class="teamma.data.PlayerType" name="void addDouble(teamma.data.SkillType)" map="D"/>
  <method class="teamma.data.PlayerType" name="int getStrength()" map="J"/>
  <class name="teamma.data.Inducement" map="J"/>
  <field class="teamma.data.Inducement" name="_type" map="A"/>
  <field class="teamma.data.Inducement" name="_nb" map="B"/>
  <method class="teamma.data.Inducement" name="int getNb()" map="A"/>
  <method class="teamma.data.Inducement" name="teamma.data.InducementType getType()" map="B"/>
  <method class="teamma.data.Inducement" name="void setType(teamma.data.InducementType)" map="A"/>
  <method class="teamma.data.Inducement" name="void setNb(int)" map="A"/>
  <package name="teamma.languages" map="C"/>
  <class name="teamma.languages.Translate" map="A"/>
  <field class="teamma.languages.Translate" name="sBundle" map="A"/>
  <method class="teamma.languages.Translate" name="java.lang.String translate(java.lang.String)" map="A"/>
  <package name="teamma.tableModel" map="D"/>
  <class name="teamma.tableModel.MjtStarPlayers" map="A"/>
  <field class="teamma.tableModel.MjtStarPlayers" name="LOG" map="A"/>
  <field class="teamma.tableModel.MjtStarPlayers" name="mPlayers" map="B"/>
  <method class="teamma.tableModel.MjtStarPlayers" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <method class="teamma.tableModel.MjtStarPlayers" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="teamma.tableModel.MjtStarPlayers" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="teamma.tableModel.MjtStarPlayers" name="int getRowCount()" map="getRowCount"/>
  <method class="teamma.tableModel.MjtStarPlayers" name="int getColumnCount()" map="getColumnCount"/>
  <method class="teamma.tableModel.MjtStarPlayers" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="teamma.tableModel.MjtStarPlayers" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="teamma.tableModel.MjtTeamPlayers" map="B"/>
  <field class="teamma.tableModel.MjtTeamPlayers" name="_roster" map="A"/>
  <field class="teamma.tableModel.MjtTeamPlayers" name="LOG" map="B"/>
  <method class="teamma.tableModel.MjtTeamPlayers" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <method class="teamma.tableModel.MjtTeamPlayers" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="teamma.tableModel.MjtTeamPlayers" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="teamma.tableModel.MjtTeamPlayers" name="int getRowCount()" map="getRowCount"/>
  <method class="teamma.tableModel.MjtTeamPlayers" name="int getColumnCount()" map="getColumnCount"/>
  <method class="teamma.tableModel.MjtTeamPlayers" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="teamma.tableModel.MjtTeamPlayers" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="teamma.tableModel.MjtTeamStars" map="C"/>
  <field class="teamma.tableModel.MjtTeamStars" name="_roster" map="A"/>
  <method class="teamma.tableModel.MjtTeamStars" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <method class="teamma.tableModel.MjtTeamStars" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="teamma.tableModel.MjtTeamStars" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="teamma.tableModel.MjtTeamStars" name="int getRowCount()" map="getRowCount"/>
  <method class="teamma.tableModel.MjtTeamStars" name="int getColumnCount()" map="getColumnCount"/>
  <method class="teamma.tableModel.MjtTeamStars" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="teamma.tableModel.MjtTeamStars" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="teamma.tableModel.MjtPlayerTypes" map="D"/>
  <field class="teamma.tableModel.MjtPlayerTypes" name="LOG" map="A"/>
  <field class="teamma.tableModel.MjtPlayerTypes" name="mPlayers" map="B"/>
  <method class="teamma.tableModel.MjtPlayerTypes" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <method class="teamma.tableModel.MjtPlayerTypes" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="teamma.tableModel.MjtPlayerTypes" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="teamma.tableModel.MjtPlayerTypes" name="int getRowCount()" map="getRowCount"/>
  <method class="teamma.tableModel.MjtPlayerTypes" name="int getColumnCount()" map="getColumnCount"/>
  <method class="teamma.tableModel.MjtPlayerTypes" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="teamma.tableModel.MjtPlayerTypes" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <package name="tourma.views" map="A"/>
  <package name="tourma.views.report" map="A"/>
  <class name="tourma.views.report.SwingWebView$2" map="2"/>
  <field class="tourma.views.report.SwingWebView$2" name="this$0" map="A"/>
  <method class="tourma.views.report.SwingWebView$2" name="void run()" map="run"/>
  <class name="tourma.views.report.SwingWebView$1" map="1"/>
  <field class="tourma.views.report.SwingWebView$1" name="this$0" map="A"/>
  <method class="tourma.views.report.SwingWebView$1" name="void run()" map="run"/>
  <class name="tourma.views.report.SwingWebView" map="A"/>
  <field class="tourma.views.report.SwingWebView" name="mUrl" map="A"/>
  <field class="tourma.views.report.SwingWebView" name="browser" map="B"/>
  <field class="tourma.views.report.SwingWebView" name="stage" map="C"/>
  <field class="tourma.views.report.SwingWebView" name="webEngine" map="D"/>
  <method class="tourma.views.report.SwingWebView" name="javafx.stage.Stage access$000(tourma.views.report.SwingWebView)" map="A"/>
  <method class="tourma.views.report.SwingWebView" name="java.lang.String access$300(tourma.views.report.SwingWebView)" map="B"/>
  <method class="tourma.views.report.SwingWebView" name="javafx.scene.web.WebView access$102(tourma.views.report.SwingWebView, javafx.scene.web.WebView)" map="A"/>
  <method class="tourma.views.report.SwingWebView" name="void initComponents()" map="A"/>
  <method class="tourma.views.report.SwingWebView" name="javafx.scene.web.WebEngine access$200(tourma.views.report.SwingWebView)" map="C"/>
  <method class="tourma.views.report.SwingWebView" name="void setURL(java.lang.String)" map="A"/>
  <method class="tourma.views.report.SwingWebView" name="javafx.scene.web.WebView access$100(tourma.views.report.SwingWebView)" map="D"/>
  <method class="tourma.views.report.SwingWebView" name="javafx.stage.Stage access$002(tourma.views.report.SwingWebView, javafx.stage.Stage)" map="A"/>
  <method class="tourma.views.report.SwingWebView" name="javafx.scene.web.WebEngine access$202(tourma.views.report.SwingWebView, javafx.scene.web.WebEngine)" map="A"/>
  <method class="tourma.views.report.SwingWebView" name="void createScene()" map="B"/>
  <class name="tourma.views.report.JdgRanking$4" map="4"/>
  <field class="tourma.views.report.JdgRanking$4" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgRanking$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgRanking$3" map="3"/>
  <field class="tourma.views.report.JdgRanking$3" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgRanking$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgRanking$2" map="2"/>
  <field class="tourma.views.report.JdgRanking$2" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgRanking$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgRanking$1" map="1"/>
  <field class="tourma.views.report.JdgRanking$1" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgRanking$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgRanking" map="B"/>
  <field class="tourma.views.report.JdgRanking" name="jPanel1" map="A"/>
  <field class="tourma.views.report.JdgRanking" name="mTour" map="B"/>
  <field class="tourma.views.report.JdgRanking" name="mRoundNumber" map="C"/>
  <field class="tourma.views.report.JdgRanking" name="jbtExport" map="D"/>
  <field class="tourma.views.report.JdgRanking" name="jepHTML" map="E"/>
  <field class="tourma.views.report.JdgRanking" name="mRanking" map="F"/>
  <field class="tourma.views.report.JdgRanking" name="jbtExportPDF" map="G"/>
  <field class="tourma.views.report.JdgRanking" name="jScrollPane1" map="H"/>
  <field class="tourma.views.report.JdgRanking" name="mType" map="I"/>
  <field class="tourma.views.report.JdgRanking" name="jbtPrint" map="J"/>
  <field class="tourma.views.report.JdgRanking" name="jbtOK" map="K"/>
  <field class="tourma.views.report.JdgRanking" name="mFilename" map="L"/>
  <field class="tourma.views.report.JdgRanking" name="LOG" map="M"/>
  <field class="tourma.views.report.JdgRanking" name="mTitle" map="N"/>
  <method class="tourma.views.report.JdgRanking" name="void initComponents()" map="A"/>
  <method class="tourma.views.report.JdgRanking" name="void jbtExportPDFActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.report.JdgRanking" name="void access$100(tourma.views.report.JdgRanking, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.report.JdgRanking" name="void jbtPrintActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.report.JdgRanking" name="void access$200(tourma.views.report.JdgRanking, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.report.JdgRanking" name="void access$300(tourma.views.report.JdgRanking, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.report.JdgRanking" name="java.io.File createReport()" map="B"/>
  <method class="tourma.views.report.JdgRanking" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.report.JdgRanking" name="void jbtExportActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.report.JdgRanking" name="void access$000(tourma.views.report.JdgRanking, java.awt.event.ActionEvent)" map="D"/>
  <class name="tourma.views.report.JdgReport$9" map="9"/>
  <field class="tourma.views.report.JdgReport$9" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgReport$9" name="void valueChanged(javax.swing.event.ListSelectionEvent)" map="valueChanged"/>
  <class name="tourma.views.report.JdgReport$8" map="8"/>
  <field class="tourma.views.report.JdgReport$8" name="this$0" map="A"/>
  <field class="tourma.views.report.JdgReport$8" name="strings" map="B"/>
  <method class="tourma.views.report.JdgReport$8" name="java.lang.Object getElementAt(int)" map="getElementAt"/>
  <method class="tourma.views.report.JdgReport$8" name="int getSize()" map="getSize"/>
  <method class="tourma.views.report.JdgReport$8" name="java.lang.String getElementAt(int)" map="A"/>
  <class name="tourma.views.report.JdgReport$7" map="7"/>
  <field class="tourma.views.report.JdgReport$7" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgReport$7" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgReport$6" map="6"/>
  <field class="tourma.views.report.JdgReport$6" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgReport$6" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgReport$5" map="5"/>
  <field class="tourma.views.report.JdgReport$5" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgReport$5" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgReport$4" map="4"/>
  <field class="tourma.views.report.JdgReport$4" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgReport$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgReport$3" map="3"/>
  <field class="tourma.views.report.JdgReport$3" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgReport$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgReport$2" map="2"/>
  <field class="tourma.views.report.JdgReport$2" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgReport$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgReport$1" map="1"/>
  <field class="tourma.views.report.JdgReport$1" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgReport$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgReport" map="C"/>
  <field class="tourma.views.report.JdgReport" name="objects" map="A"/>
  <field class="tourma.views.report.JdgReport" name="jbtExportPDFAll" map="B"/>
  <field class="tourma.views.report.JdgReport" name="jbtExportPDF" map="C"/>
  <field class="tourma.views.report.JdgReport" name="jbtExport" map="D"/>
  <field class="tourma.views.report.JdgReport" name="jPanel1" map="E"/>
  <field class="tourma.views.report.JdgReport" name="jScrollPane2" map="F"/>
  <field class="tourma.views.report.JdgReport" name="jlsObject" map="G"/>
  <field class="tourma.views.report.JdgReport" name="webView" map="H"/>
  <field class="tourma.views.report.JdgReport" name="mRoundNumber" map="I"/>
  <field class="tourma.views.report.JdgReport" name="LOG" map="J"/>
  <field class="tourma.views.report.JdgReport" name="jbtOK" map="K"/>
  <field class="tourma.views.report.JdgReport" name="mTour" map="L"/>
  <field class="tourma.views.report.JdgReport" name="mRanking" map="M"/>
  <field class="tourma.views.report.JdgReport" name="mFilename" map="N"/>
  <field class="tourma.views.report.JdgReport" name="mType" map="O"/>
  <field class="tourma.views.report.JdgReport" name="jbtPrint" map="P"/>
  <field class="tourma.views.report.JdgReport" name="jbtPrintAll" map="Q"/>
  <field class="tourma.views.report.JdgReport" name="jcxWithMembers" map="R"/>
  <method class="tourma.views.report.JdgReport" name="void jbtExportActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.report.JdgReport" name="java.io.File createTeamReport(tourma.data.Team)" map="A"/>
  <method class="tourma.views.report.JdgReport" name="void access$700(tourma.views.report.JdgReport, javax.swing.event.ListSelectionEvent)" map="A"/>
  <method class="tourma.views.report.JdgReport" name="java.lang.String readFile(java.io.File)" map="A"/>
  <method class="tourma.views.report.JdgReport" name="java.io.File createAllPDFfromHTML()" map="A"/>
  <method class="tourma.views.report.JdgReport" name="java.io.File createClanReport(tourma.data.Clan)" map="A"/>
  <method class="tourma.views.report.JdgReport" name="void printPDFFile(java.io.File)" map="B"/>
  <method class="tourma.views.report.JdgReport" name="void initComponents()" map="B"/>
  <method class="tourma.views.report.JdgReport" name="void jbtExportPDFActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.report.JdgReport" name="void access$200(tourma.views.report.JdgReport, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.report.JdgReport" name="void jbtPrintActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.report.JdgReport" name="void access$100(tourma.views.report.JdgReport, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.report.JdgReport" name="void jlsObjectValueChanged(javax.swing.event.ListSelectionEvent)" map="A"/>
  <method class="tourma.views.report.JdgReport" name="void access$600(tourma.views.report.JdgReport, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.report.JdgReport" name="java.io.File createIndivReport(tourma.data.Coach)" map="A"/>
  <method class="tourma.views.report.JdgReport" name="void jcxWithMembersActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.report.JdgReport" name="java.io.File createPDFfromHTML(java.io.File)" map="C"/>
  <method class="tourma.views.report.JdgReport" name="void access$300(tourma.views.report.JdgReport, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.report.JdgReport" name="java.io.File mergeReports(java.io.File, java.util.ArrayList)" map="A"/>
  <method class="tourma.views.report.JdgReport" name="void jbtPrintAllActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.views.report.JdgReport" name="java.io.File createCoachGroupReport(tourma.data.IWithNameAndPicture, java.lang.String, java.util.ArrayList, int, int)" map="A"/>
  <method class="tourma.views.report.JdgReport" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.views.report.JdgReport" name="java.io.File createReport(int)" map="A"/>
  <method class="tourma.views.report.JdgReport" name="void access$000(tourma.views.report.JdgReport, java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.views.report.JdgReport" name="void access$500(tourma.views.report.JdgReport, java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.views.report.JdgReport" name="void jbtExportPDFAllActionPerformed(java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.views.report.JdgReport" name="void access$400(tourma.views.report.JdgReport, java.awt.event.ActionEvent)" map="G"/>
  <class name="tourma.views.report.HTMLtoPDF" map="D"/>
  <method class="tourma.views.report.HTMLtoPDF" name="void exportToPDF(java.io.FileOutputStream, java.lang.String, java.lang.String, com.itextpdf.text.Rectangle, boolean)" map="A"/>
  <method class="tourma.views.report.HTMLtoPDF" name="void exportToPDF(java.io.FileOutputStream, java.lang.String, java.lang.String)" map="A"/>
  <method class="tourma.views.report.HTMLtoPDF" name="void exportToPDF(java.io.FileOutputStream, java.lang.String, java.lang.String, com.itextpdf.text.Rectangle)" map="A"/>
  <class name="tourma.views.report.JdgRound$4" map="4"/>
  <field class="tourma.views.report.JdgRound$4" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgRound$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgRound$3" map="3"/>
  <field class="tourma.views.report.JdgRound$3" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgRound$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgRound$2" map="2"/>
  <field class="tourma.views.report.JdgRound$2" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgRound$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgRound$1" map="1"/>
  <field class="tourma.views.report.JdgRound$1" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgRound$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgRound" map="E"/>
  <field class="tourma.views.report.JdgRound" name="jPanel1" map="A"/>
  <field class="tourma.views.report.JdgRound" name="mTeam" map="B"/>
  <field class="tourma.views.report.JdgRound" name="mTour" map="C"/>
  <field class="tourma.views.report.JdgRound" name="mRoundNumber" map="D"/>
  <field class="tourma.views.report.JdgRound" name="jbtExport" map="E"/>
  <field class="tourma.views.report.JdgRound" name="mRound" map="F"/>
  <field class="tourma.views.report.JdgRound" name="jepHTML" map="G"/>
  <field class="tourma.views.report.JdgRound" name="jbtExportPDF" map="H"/>
  <field class="tourma.views.report.JdgRound" name="mResult" map="I"/>
  <field class="tourma.views.report.JdgRound" name="jScrollPane1" map="J"/>
  <field class="tourma.views.report.JdgRound" name="jbtPrint" map="K"/>
  <field class="tourma.views.report.JdgRound" name="jbtOK" map="L"/>
  <field class="tourma.views.report.JdgRound" name="mFilename" map="M"/>
  <field class="tourma.views.report.JdgRound" name="LOG" map="N"/>
  <method class="tourma.views.report.JdgRound" name="java.io.File createTeamReport()" map="A"/>
  <method class="tourma.views.report.JdgRound" name="void initComponents()" map="B"/>
  <method class="tourma.views.report.JdgRound" name="void access$300(tourma.views.report.JdgRound, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.report.JdgRound" name="void jbtExportPDFActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.report.JdgRound" name="void access$000(tourma.views.report.JdgRound, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.report.JdgRound" name="void jbtPrintActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.report.JdgRound" name="void access$100(tourma.views.report.JdgRound, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.report.JdgRound" name="java.io.File createReport()" map="C"/>
  <method class="tourma.views.report.JdgRound" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.report.JdgRound" name="void access$200(tourma.views.report.JdgRound, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.report.JdgRound" name="void jbtExportActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <class name="tourma.views.report.JdgPrintLabel$2" map="2"/>
  <field class="tourma.views.report.JdgPrintLabel$2" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgPrintLabel$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgPrintLabel$1" map="1"/>
  <field class="tourma.views.report.JdgPrintLabel$1" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgPrintLabel$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgPrintLabel" map="F"/>
  <field class="tourma.views.report.JdgPrintLabel" name="jPanel1" map="A"/>
  <field class="tourma.views.report.JdgPrintLabel" name="mTour" map="B"/>
  <field class="tourma.views.report.JdgPrintLabel" name="mRoundNumber" map="C"/>
  <field class="tourma.views.report.JdgPrintLabel" name="mRound" map="D"/>
  <field class="tourma.views.report.JdgPrintLabel" name="jepHTML" map="E"/>
  <field class="tourma.views.report.JdgPrintLabel" name="mByTeam" map="F"/>
  <field class="tourma.views.report.JdgPrintLabel" name="jbtExportPDF" map="G"/>
  <field class="tourma.views.report.JdgPrintLabel" name="jScrollPane1" map="H"/>
  <field class="tourma.views.report.JdgPrintLabel" name="jbtOK" map="I"/>
  <field class="tourma.views.report.JdgPrintLabel" name="mPreFilled" map="J"/>
  <field class="tourma.views.report.JdgPrintLabel" name="mFilename" map="K"/>
  <field class="tourma.views.report.JdgPrintLabel" name="LOG" map="L"/>
  <method class="tourma.views.report.JdgPrintLabel" name="void readObject(java.io.ObjectInputStream)" map="A"/>
  <method class="tourma.views.report.JdgPrintLabel" name="void initComponents()" map="A"/>
  <method class="tourma.views.report.JdgPrintLabel" name="java.io.File createTeamLabels(boolean)" map="A"/>
  <method class="tourma.views.report.JdgPrintLabel" name="void jbtExportPDFActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.report.JdgPrintLabel" name="void writeObject(java.io.ObjectOutputStream)" map="A"/>
  <method class="tourma.views.report.JdgPrintLabel" name="void access$100(tourma.views.report.JdgPrintLabel, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.report.JdgPrintLabel" name="java.io.File createIndivLabels(boolean)" map="B"/>
  <method class="tourma.views.report.JdgPrintLabel" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.report.JdgPrintLabel" name="void update()" map="B"/>
  <method class="tourma.views.report.JdgPrintLabel" name="void access$000(tourma.views.report.JdgPrintLabel, java.awt.event.ActionEvent)" map="B"/>
  <class name="tourma.views.report.JdgGlobal$4" map="4"/>
  <field class="tourma.views.report.JdgGlobal$4" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgGlobal$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgGlobal$3" map="3"/>
  <field class="tourma.views.report.JdgGlobal$3" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgGlobal$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgGlobal$2" map="2"/>
  <field class="tourma.views.report.JdgGlobal$2" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgGlobal$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgGlobal$1" map="1"/>
  <field class="tourma.views.report.JdgGlobal$1" name="this$0" map="A"/>
  <method class="tourma.views.report.JdgGlobal$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.report.JdgGlobal" map="G"/>
  <field class="tourma.views.report.JdgGlobal" name="jPanel1" map="A"/>
  <field class="tourma.views.report.JdgGlobal" name="mTeam" map="B"/>
  <field class="tourma.views.report.JdgGlobal" name="mTour" map="C"/>
  <field class="tourma.views.report.JdgGlobal" name="mRoundNumber" map="D"/>
  <field class="tourma.views.report.JdgGlobal" name="mAnnexAgainstRankings" map="E"/>
  <field class="tourma.views.report.JdgGlobal" name="jbtExport" map="F"/>
  <field class="tourma.views.report.JdgGlobal" name="jepHTML" map="G"/>
  <field class="tourma.views.report.JdgGlobal" name="mRanking" map="H"/>
  <field class="tourma.views.report.JdgGlobal" name="jbtExportPDF" map="I"/>
  <field class="tourma.views.report.JdgGlobal" name="jScrollPane1" map="J"/>
  <field class="tourma.views.report.JdgGlobal" name="jbtPrint" map="K"/>
  <field class="tourma.views.report.JdgGlobal" name="jbtOK" map="L"/>
  <field class="tourma.views.report.JdgGlobal" name="mAnnexForRankings" map="M"/>
  <field class="tourma.views.report.JdgGlobal" name="mFilename" map="N"/>
  <field class="tourma.views.report.JdgGlobal" name="LOG" map="O"/>
  <field class="tourma.views.report.JdgGlobal" name="mClan" map="P"/>
  <method class="tourma.views.report.JdgGlobal" name="void access$100(tourma.views.report.JdgGlobal, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.report.JdgGlobal" name="void initComponents()" map="A"/>
  <method class="tourma.views.report.JdgGlobal" name="void jbtExportPDFActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.report.JdgGlobal" name="void jbtPrintActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.report.JdgGlobal" name="void access$200(tourma.views.report.JdgGlobal, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.report.JdgGlobal" name="void access$300(tourma.views.report.JdgGlobal, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.report.JdgGlobal" name="java.io.File createReport()" map="B"/>
  <method class="tourma.views.report.JdgGlobal" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.report.JdgGlobal" name="void jbtExportActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.report.JdgGlobal" name="void access$000(tourma.views.report.JdgGlobal, java.awt.event.ActionEvent)" map="D"/>
  <package name="tourma.views.round" map="B"/>
  <class name="tourma.views.round.JPNTeamRound$3" map="3"/>
  <field class="tourma.views.round.JPNTeamRound$3" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNTeamRound$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNTeamRound$2" map="2"/>
  <field class="tourma.views.round.JPNTeamRound$2" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNTeamRound$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNTeamRound$1" map="1"/>
  <field class="tourma.views.round.JPNTeamRound$1" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNTeamRound$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNTeamRound" map="A"/>
  <field class="tourma.views.round.JPNTeamRound" name="jPanel1" map="A"/>
  <field class="tourma.views.round.JPNTeamRound" name="mRound" map="B"/>
  <field class="tourma.views.round.JPNTeamRound" name="jbtShowMatchTeam" map="C"/>
  <field class="tourma.views.round.JPNTeamRound" name="mRoundOnly" map="D"/>
  <field class="tourma.views.round.JPNTeamRound" name="mJtbTeamMatch" map="E"/>
  <field class="tourma.views.round.JPNTeamRound" name="jScrollPane3" map="F"/>
  <field class="tourma.views.round.JPNTeamRound" name="mTournament" map="G"/>
  <field class="tourma.views.round.JPNTeamRound" name="jSplitPane1" map="H"/>
  <field class="tourma.views.round.JPNTeamRound" name="jbtGlobal" map="I"/>
  <field class="tourma.views.round.JPNTeamRound" name="jtbRankingTeam" map="J"/>
  <field class="tourma.views.round.JPNTeamRound" name="jbtGeneralTeam" map="K"/>
  <field class="tourma.views.round.JPNTeamRound" name="jPanel8" map="L"/>
  <field class="tourma.views.round.JPNTeamRound" name="jtpTeams" map="M"/>
  <field class="tourma.views.round.JPNTeamRound" name="jtpAnnexRank" map="N"/>
  <field class="tourma.views.round.JPNTeamRound" name="jpnTeam" map="O"/>
  <method class="tourma.views.round.JPNTeamRound" name="void jbtShowMatchTeamActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.round.JPNTeamRound" name="void initComponents()" map="A"/>
  <method class="tourma.views.round.JPNTeamRound" name="void setRoundOnly(boolean)" map="A"/>
  <method class="tourma.views.round.JPNTeamRound" name="void access$100(tourma.views.round.JPNTeamRound, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.round.JPNTeamRound" name="void jbtGeneralTeamActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.round.JPNTeamRound" name="void access$200(tourma.views.round.JPNTeamRound, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.round.JPNTeamRound" name="void jbtGlobalActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.round.JPNTeamRound" name="void update()" map="B"/>
  <method class="tourma.views.round.JPNTeamRound" name="void access$000(tourma.views.round.JPNTeamRound, java.awt.event.ActionEvent)" map="C"/>
  <class name="tourma.views.round.JPNAnnexRanking$2" map="2"/>
  <field class="tourma.views.round.JPNAnnexRanking$2" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNAnnexRanking$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNAnnexRanking$1" map="1"/>
  <field class="tourma.views.round.JPNAnnexRanking$1" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNAnnexRanking$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNAnnexRanking" map="B"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="jPanel4" map="A"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="jPanel3" map="B"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="jPanel2" map="C"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="jPanel1" map="D"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="jbtPositive" map="E"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="mTeam" map="F"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="jScrollPane2" map="G"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="jScrollPane1" map="H"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="LOG" map="I"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="mName" map="J"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="jbtNegative" map="K"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="mRound" map="L"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="jtbPositive" map="M"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="mTeams" map="N"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="mFormula" map="O"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="mTour" map="P"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="mClan" map="Q"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="mCoachs" map="R"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="mCriteria" map="S"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="jtbNegative" map="T"/>
  <field class="tourma.views.round.JPNAnnexRanking" name="mRoundOnly" map="U"/>
  <method class="tourma.views.round.JPNAnnexRanking" name="void access$100(tourma.views.round.JPNAnnexRanking, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.round.JPNAnnexRanking" name="void jbtNegativeActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.round.JPNAnnexRanking" name="void access$000(tourma.views.round.JPNAnnexRanking, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.round.JPNAnnexRanking" name="void setRoundOnly(boolean)" map="A"/>
  <method class="tourma.views.round.JPNAnnexRanking" name="void initComponents()" map="A"/>
  <method class="tourma.views.round.JPNAnnexRanking" name="void update()" map="B"/>
  <method class="tourma.views.round.JPNAnnexRanking" name="void jbtPositiveActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <class name="tourma.views.round.JPNCategory$1" map="1"/>
  <field class="tourma.views.round.JPNCategory$1" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNCategory$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNCategory" map="C"/>
  <field class="tourma.views.round.JPNCategory" name="mEnableTeam" map="A"/>
  <field class="tourma.views.round.JPNCategory" name="jPanel1" map="B"/>
  <field class="tourma.views.round.JPNCategory" name="jtbCategory" map="C"/>
  <field class="tourma.views.round.JPNCategory" name="mRoundNumber" map="D"/>
  <field class="tourma.views.round.JPNCategory" name="jtbTeam" map="E"/>
  <field class="tourma.views.round.JPNCategory" name="mRoundOnly" map="F"/>
  <field class="tourma.views.round.JPNCategory" name="mTournament" map="G"/>
  <field class="tourma.views.round.JPNCategory" name="jspTeam" map="H"/>
  <field class="tourma.views.round.JPNCategory" name="jspIndiv" map="I"/>
  <field class="tourma.views.round.JPNCategory" name="mEnableCoach" map="J"/>
  <field class="tourma.views.round.JPNCategory" name="mCategory" map="K"/>
  <field class="tourma.views.round.JPNCategory" name="jbtGeneral" map="L"/>
  <field class="tourma.views.round.JPNCategory" name="jPanel2" map="M"/>
  <method class="tourma.views.round.JPNCategory" name="void access$000(tourma.views.round.JPNCategory, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.round.JPNCategory" name="void jbtGeneralActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.round.JPNCategory" name="void setRoundOnly(boolean)" map="A"/>
  <method class="tourma.views.round.JPNCategory" name="void initComponents()" map="A"/>
  <method class="tourma.views.round.JPNCategory" name="void update()" map="B"/>
  <class name="tourma.views.round.JPNGroup$1" map="1"/>
  <field class="tourma.views.round.JPNGroup$1" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNGroup$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNGroup" map="D"/>
  <field class="tourma.views.round.JPNGroup" name="jPanel1" map="A"/>
  <field class="tourma.views.round.JPNGroup" name="jScrollPane1" map="B"/>
  <field class="tourma.views.round.JPNGroup" name="mGroup" map="C"/>
  <field class="tourma.views.round.JPNGroup" name="mTournament" map="D"/>
  <field class="tourma.views.round.JPNGroup" name="jtbGroup" map="E"/>
  <field class="tourma.views.round.JPNGroup" name="jbtGeneral" map="F"/>
  <field class="tourma.views.round.JPNGroup" name="mRoundNumber" map="G"/>
  <field class="tourma.views.round.JPNGroup" name="mRoundOnly" map="H"/>
  <method class="tourma.views.round.JPNGroup" name="void jbtGeneralActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.round.JPNGroup" name="void setRoundOnly(boolean)" map="A"/>
  <method class="tourma.views.round.JPNGroup" name="void initComponents()" map="A"/>
  <method class="tourma.views.round.JPNGroup" name="void access$000(tourma.views.round.JPNGroup, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.round.JPNGroup" name="void update()" map="B"/>
  <class name="tourma.views.round.JPNClan$2" map="2"/>
  <field class="tourma.views.round.JPNClan$2" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNClan$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNClan$1" map="1"/>
  <field class="tourma.views.round.JPNClan$1" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNClan$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNClan" map="E"/>
  <field class="tourma.views.round.JPNClan" name="jPanel1" map="A"/>
  <field class="tourma.views.round.JPNClan" name="mRound" map="B"/>
  <field class="tourma.views.round.JPNClan" name="mRoundOnly" map="C"/>
  <field class="tourma.views.round.JPNClan" name="jScrollPane3" map="D"/>
  <field class="tourma.views.round.JPNClan" name="mTournament" map="E"/>
  <field class="tourma.views.round.JPNClan" name="jtbRankingClan" map="F"/>
  <field class="tourma.views.round.JPNClan" name="jbtGeneralClan" map="G"/>
  <field class="tourma.views.round.JPNClan" name="jSplitPane1" map="H"/>
  <field class="tourma.views.round.JPNClan" name="jbtGGlobalClan" map="I"/>
  <field class="tourma.views.round.JPNClan" name="jtpAnnexRank" map="J"/>
  <field class="tourma.views.round.JPNClan" name="jPanel3" map="K"/>
  <field class="tourma.views.round.JPNClan" name="jPanel2" map="L"/>
  <method class="tourma.views.round.JPNClan" name="void jbtGeneralClanActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.round.JPNClan" name="void access$000(tourma.views.round.JPNClan, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.round.JPNClan" name="void setRoundOnly(boolean)" map="A"/>
  <method class="tourma.views.round.JPNClan" name="void initComponents()" map="A"/>
  <method class="tourma.views.round.JPNClan" name="void update()" map="B"/>
  <method class="tourma.views.round.JPNClan" name="void access$100(tourma.views.round.JPNClan, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.round.JPNClan" name="void jbtGGlobalClanActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <class name="tourma.views.round.JPNPool$2" map="2"/>
  <field class="tourma.views.round.JPNPool$2" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNPool$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNPool$1" map="1"/>
  <field class="tourma.views.round.JPNPool$1" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNPool$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNPool" map="F"/>
  <field class="tourma.views.round.JPNPool" name="jPanel1" map="A"/>
  <field class="tourma.views.round.JPNPool" name="mRound" map="B"/>
  <field class="tourma.views.round.JPNPool" name="mRoundOnly" map="C"/>
  <field class="tourma.views.round.JPNPool" name="jScrollPane3" map="D"/>
  <field class="tourma.views.round.JPNPool" name="mTournament" map="E"/>
  <field class="tourma.views.round.JPNPool" name="jSplitPane1" map="F"/>
  <field class="tourma.views.round.JPNPool" name="mPool" map="G"/>
  <field class="tourma.views.round.JPNPool" name="jbtGlobalPool" map="H"/>
  <field class="tourma.views.round.JPNPool" name="jtpAnnexRank" map="I"/>
  <field class="tourma.views.round.JPNPool" name="jtbRankingPool" map="J"/>
  <field class="tourma.views.round.JPNPool" name="jbtGeneralPool" map="K"/>
  <field class="tourma.views.round.JPNPool" name="jPanel3" map="L"/>
  <field class="tourma.views.round.JPNPool" name="jPanel2" map="M"/>
  <method class="tourma.views.round.JPNPool" name="void access$000(tourma.views.round.JPNPool, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.round.JPNPool" name="void jbtGeneralPoolActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.round.JPNPool" name="void access$100(tourma.views.round.JPNPool, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.round.JPNPool" name="void setRoundOnly(boolean)" map="A"/>
  <method class="tourma.views.round.JPNPool" name="void jbtGlobalPoolActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.round.JPNPool" name="void initComponents()" map="A"/>
  <method class="tourma.views.round.JPNPool" name="void update()" map="B"/>
  <class name="tourma.views.round.JPNRound$9" map="9"/>
  <field class="tourma.views.round.JPNRound$9" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNRound$9" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNRound$8" map="8"/>
  <field class="tourma.views.round.JPNRound$8" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNRound$8" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNRound$7" map="7"/>
  <field class="tourma.views.round.JPNRound$7" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNRound$7" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNRound$6" map="6"/>
  <field class="tourma.views.round.JPNRound$6" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNRound$6" name="void keyPressed(java.awt.event.KeyEvent)" map="keyPressed"/>
  <class name="tourma.views.round.JPNRound$5" map="5"/>
  <field class="tourma.views.round.JPNRound$5" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNRound$5" name="void mouseClicked(java.awt.event.MouseEvent)" map="mouseClicked"/>
  <class name="tourma.views.round.JPNRound$4" map="4"/>
  <field class="tourma.views.round.JPNRound$4" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNRound$4" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="tourma.views.round.JPNRound$12" map="12"/>
  <field class="tourma.views.round.JPNRound$12" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNRound$12" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNRound$3" map="3"/>
  <field class="tourma.views.round.JPNRound$3" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNRound$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNRound$2" map="2"/>
  <field class="tourma.views.round.JPNRound$2" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNRound$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNRound$11" map="11"/>
  <field class="tourma.views.round.JPNRound$11" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNRound$11" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNRound$10" map="10"/>
  <field class="tourma.views.round.JPNRound$10" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNRound$10" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNRound$1" map="1"/>
  <field class="tourma.views.round.JPNRound$1" name="this$0" map="A"/>
  <method class="tourma.views.round.JPNRound$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.round.JPNRound" map="G"/>
  <field class="tourma.views.round.JPNRound" name="jPanel8" map="A"/>
  <field class="tourma.views.round.JPNRound" name="jbtGlobal" map="B"/>
  <field class="tourma.views.round.JPNRound" name="jPanel7" map="C"/>
  <field class="tourma.views.round.JPNRound" name="jPanel6" map="D"/>
  <field class="tourma.views.round.JPNRound" name="jSplitPane1" map="E"/>
  <field class="tourma.views.round.JPNRound" name="jtbRankingIndiv" map="F"/>
  <field class="tourma.views.round.JPNRound" name="jpmCoach" map="G"/>
  <field class="tourma.views.round.JPNRound" name="jPanel3" map="H"/>
  <field class="tourma.views.round.JPNRound" name="jPanel2" map="I"/>
  <field class="tourma.views.round.JPNRound" name="jPanel1" map="J"/>
  <field class="tourma.views.round.JPNRound" name="jmiEditCoach" map="K"/>
  <field class="tourma.views.round.JPNRound" name="jmiChangePairing" map="L"/>
  <field class="tourma.views.round.JPNRound" name="jbtGeneralIndiv" map="M"/>
  <field class="tourma.views.round.JPNRound" name="jtpAnnexRankings" map="N"/>
  <field class="tourma.views.round.JPNRound" name="mJpnTeamRound" map="O"/>
  <field class="tourma.views.round.JPNRound" name="jScrollPane2" map="P"/>
  <field class="tourma.views.round.JPNRound" name="jScrollPane1" map="Q"/>
  <field class="tourma.views.round.JPNRound" name="mRoundNumber" map="R"/>
  <field class="tourma.views.round.JPNRound" name="mRound" map="S"/>
  <field class="tourma.views.round.JPNRound" name="jmiChangeRosterForThisRound" map="T"/>
  <field class="tourma.views.round.JPNRound" name="mTournament" map="U"/>
  <field class="tourma.views.round.JPNRound" name="jbtShowMatches" map="V"/>
  <field class="tourma.views.round.JPNRound" name="jbtShowResults" map="W"/>
  <field class="tourma.views.round.JPNRound" name="jtbMatches" map="X"/>
  <field class="tourma.views.round.JPNRound" name="mJpnClanRound" map="Y"/>
  <field class="tourma.views.round.JPNRound" name="jcxCupOption" map="Z"/>
  <field class="tourma.views.round.JPNRound" name="jtpGlobal" map="_"/>
  <field class="tourma.views.round.JPNRound" name="jcxPoolOption" map="a"/>
  <field class="tourma.views.round.JPNRound" name="mRoundOnly" map="b"/>
  <field class="tourma.views.round.JPNRound" name="mNafOnly" map="c"/>
  <method class="tourma.views.round.JPNRound" name="void access$000(tourma.views.round.JPNRound, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.round.JPNRound" name="void jmiChangeRosterForThisRoundActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.round.JPNRound" name="void access$300(tourma.views.round.JPNRound, javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.views.round.JPNRound" name="void jcxPoolOptionActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.round.JPNRound" name="void jmiChangePairingActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.round.JPNRound" name="void jtpGlobalStateChanged(javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.views.round.JPNRound" name="void initComponents()" map="A"/>
  <method class="tourma.views.round.JPNRound" name="void jbtGlobalActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.round.JPNRound" name="void access$400(tourma.views.round.JPNRound, java.awt.event.MouseEvent)" map="A"/>
  <method class="tourma.views.round.JPNRound" name="void jtbMatchesMouseClicked(java.awt.event.MouseEvent)" map="A"/>
  <method class="tourma.views.round.JPNRound" name="void jbtShowResultsActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.views.round.JPNRound" name="int getMatchTableSelectedRow()" map="B"/>
  <method class="tourma.views.round.JPNRound" name="void access$800(tourma.views.round.JPNRound, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.round.JPNRound" name="void jmiEditCoachActionPerformed(java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.views.round.JPNRound" name="void access$100(tourma.views.round.JPNRound, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.round.JPNRound" name="void access$1000(tourma.views.round.JPNRound, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.round.JPNRound" name="void setRoundOnly(boolean)" map="A"/>
  <method class="tourma.views.round.JPNRound" name="void jbtGeneralIndivActionPerformed(java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.views.round.JPNRound" name="void access$600(tourma.views.round.JPNRound, java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.views.round.JPNRound" name="void setNafOnly(boolean)" map="B"/>
  <method class="tourma.views.round.JPNRound" name="void access$500(tourma.views.round.JPNRound, java.awt.event.KeyEvent)" map="A"/>
  <method class="tourma.views.round.JPNRound" name="tourma.data.Round getRound()" map="C"/>
  <method class="tourma.views.round.JPNRound" name="void access$900(tourma.views.round.JPNRound, java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.views.round.JPNRound" name="void jcxCupOptionActionPerformed(java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.views.round.JPNRound" name="void jbtShowMatchesActionPerformed(java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.views.round.JPNRound" name="void access$200(tourma.views.round.JPNRound, java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.views.round.JPNRound" name="void access$1100(tourma.views.round.JPNRound, java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.views.round.JPNRound" name="void update()" map="D"/>
  <method class="tourma.views.round.JPNRound" name="void access$700(tourma.views.round.JPNRound, java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.views.round.JPNRound" name="void jtbMatchesKeyPressed(java.awt.event.KeyEvent)" map="A"/>
  <class name="tourma.views.round.JPNMatch" map="H"/>
  <field class="tourma.views.round.JPNMatch" name="jPanel1" map="A"/>
  <field class="tourma.views.round.JPNMatch" name="jlbScore2" map="B"/>
  <field class="tourma.views.round.JPNMatch" name="jlbScore1" map="C"/>
  <field class="tourma.views.round.JPNMatch" name="jSeparator3" map="D"/>
  <field class="tourma.views.round.JPNMatch" name="jSeparator2" map="E"/>
  <field class="tourma.views.round.JPNMatch" name="jSeparator1" map="F"/>
  <field class="tourma.views.round.JPNMatch" name="jlbPlayer2" map="G"/>
  <field class="tourma.views.round.JPNMatch" name="jlbPlayer1" map="H"/>
  <field class="tourma.views.round.JPNMatch" name="jlbTag" map="I"/>
  <field class="tourma.views.round.JPNMatch" name="jPanel4" map="J"/>
  <field class="tourma.views.round.JPNMatch" name="LOG" map="K"/>
  <field class="tourma.views.round.JPNMatch" name="jPanel2" map="L"/>
  <method class="tourma.views.round.JPNMatch" name="void initComponents()" map="A"/>
  <package name="tourma.views.system" map="C"/>
  <class name="tourma.views.system.JdgRevisions$1" map="1"/>
  <field class="tourma.views.system.JdgRevisions$1" name="this$0" map="A"/>
  <method class="tourma.views.system.JdgRevisions$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.system.JdgRevisions" map="A"/>
  <field class="tourma.views.system.JdgRevisions" name="jPanel1" map="A"/>
  <field class="tourma.views.system.JdgRevisions" name="jScrollPane1" map="B"/>
  <field class="tourma.views.system.JdgRevisions" name="jButton1" map="C"/>
  <field class="tourma.views.system.JdgRevisions" name="jxtVersions" map="D"/>
  <method class="tourma.views.system.JdgRevisions" name="void jButton1ActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.system.JdgRevisions" name="void initComponents()" map="A"/>
  <method class="tourma.views.system.JdgRevisions" name="void access$000(tourma.views.system.JdgRevisions, java.awt.event.ActionEvent)" map="A"/>
  <class name="tourma.views.system.JdgOnlineHelp$1" map="1"/>
  <field class="tourma.views.system.JdgOnlineHelp$1" name="this$0" map="A"/>
  <method class="tourma.views.system.JdgOnlineHelp$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.system.JdgOnlineHelp" map="B"/>
  <field class="tourma.views.system.JdgOnlineHelp" name="LOG" map="A"/>
  <field class="tourma.views.system.JdgOnlineHelp" name="jPanel1" map="B"/>
  <field class="tourma.views.system.JdgOnlineHelp" name="jButton1" map="C"/>
  <field class="tourma.views.system.JdgOnlineHelp" name="jLabel1" map="D"/>
  <method class="tourma.views.system.JdgOnlineHelp" name="void jButton1ActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.system.JdgOnlineHelp" name="void initComponents()" map="A"/>
  <method class="tourma.views.system.JdgOnlineHelp" name="void access$000(tourma.views.system.JdgOnlineHelp, java.awt.event.ActionEvent)" map="A"/>
  <class name="tourma.views.system.MtRevisions" map="C"/>
  <field class="tourma.views.system.MtRevisions" name="LOG" map="A"/>
  <field class="tourma.views.system.MtRevisions" name="mVersions" map="B"/>
  <field class="tourma.views.system.MtRevisions" name="mDescriptions" map="C"/>
  <method class="tourma.views.system.MtRevisions" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <method class="tourma.views.system.MtRevisions" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="tourma.views.system.MtRevisions" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.views.system.MtRevisions" name="int getRowCount()" map="getRowCount"/>
  <method class="tourma.views.system.MtRevisions" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.views.system.MtRevisions" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.views.system.MtRevisions" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.views.system.JdgAbout$1" map="1"/>
  <field class="tourma.views.system.JdgAbout$1" name="this$0" map="A"/>
  <method class="tourma.views.system.JdgAbout$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.system.JdgAbout" map="D"/>
  <field class="tourma.views.system.JdgAbout" name="jlbVersion" map="A"/>
  <field class="tourma.views.system.JdgAbout" name="jPanel4" map="B"/>
  <field class="tourma.views.system.JdgAbout" name="jPanel3" map="C"/>
  <field class="tourma.views.system.JdgAbout" name="jPanel2" map="D"/>
  <field class="tourma.views.system.JdgAbout" name="jPanel1" map="E"/>
  <field class="tourma.views.system.JdgAbout" name="jButton1" map="F"/>
  <field class="tourma.views.system.JdgAbout" name="jlbJFreeChart" map="G"/>
  <field class="tourma.views.system.JdgAbout" name="jlbJCommonC" map="H"/>
  <field class="tourma.views.system.JdgAbout" name="jScrollPane1" map="I"/>
  <field class="tourma.views.system.JdgAbout" name="jlbJFreeChartC" map="J"/>
  <field class="tourma.views.system.JdgAbout" name="jlbFreeMarker" map="K"/>
  <field class="tourma.views.system.JdgAbout" name="jlbJCommon" map="L"/>
  <field class="tourma.views.system.JdgAbout" name="jlbFreeMarkerC" map="M"/>
  <field class="tourma.views.system.JdgAbout" name="jlbEkit" map="N"/>
  <field class="tourma.views.system.JdgAbout" name="jTextArea1" map="O"/>
  <field class="tourma.views.system.JdgAbout" name="jlbNom" map="P"/>
  <field class="tourma.views.system.JdgAbout" name="jlbJDomC" map="Q"/>
  <field class="tourma.views.system.JdgAbout" name="jlbJDom" map="R"/>
  <field class="tourma.views.system.JdgAbout" name="jlbDate" map="S"/>
  <field class="tourma.views.system.JdgAbout" name="jlbEkit1" map="T"/>
  <method class="tourma.views.system.JdgAbout" name="void jButton1ActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.system.JdgAbout" name="void access$000(tourma.views.system.JdgAbout, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.system.JdgAbout" name="void initComponents()" map="A"/>
  <package name="tourma.views.parameters" map="D"/>
  <class name="tourma.views.parameters.JPNParamCategories$6" map="6"/>
  <field class="tourma.views.parameters.JPNParamCategories$6" name="this$0" map="A"/>
  <field class="tourma.views.parameters.JPNParamCategories$6" name="strings" map="B"/>
  <method class="tourma.views.parameters.JPNParamCategories$6" name="java.lang.Object getElementAt(int)" map="getElementAt"/>
  <method class="tourma.views.parameters.JPNParamCategories$6" name="int getSize()" map="getSize"/>
  <class name="tourma.views.parameters.JPNParamCategories$5" map="5"/>
  <field class="tourma.views.parameters.JPNParamCategories$5" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamCategories$5" name="void mouseClicked(java.awt.event.MouseEvent)" map="mouseClicked"/>
  <class name="tourma.views.parameters.JPNParamCategories$4" map="4"/>
  <field class="tourma.views.parameters.JPNParamCategories$4" name="this$0" map="A"/>
  <field class="tourma.views.parameters.JPNParamCategories$4" name="strings" map="B"/>
  <method class="tourma.views.parameters.JPNParamCategories$4" name="java.lang.Object getElementAt(int)" map="getElementAt"/>
  <method class="tourma.views.parameters.JPNParamCategories$4" name="int getSize()" map="getSize"/>
  <class name="tourma.views.parameters.JPNParamCategories$3" map="3"/>
  <field class="tourma.views.parameters.JPNParamCategories$3" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamCategories$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamCategories$2" map="2"/>
  <field class="tourma.views.parameters.JPNParamCategories$2" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamCategories$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamCategories$1" map="1"/>
  <field class="tourma.views.parameters.JPNParamCategories$1" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamCategories$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamCategories$7" map="7"/>
  <field class="tourma.views.parameters.JPNParamCategories$7" name="this$0" map="A"/>
  <field class="tourma.views.parameters.JPNParamCategories$7" name="strings" map="B"/>
  <method class="tourma.views.parameters.JPNParamCategories$7" name="java.lang.Object getElementAt(int)" map="getElementAt"/>
  <method class="tourma.views.parameters.JPNParamCategories$7" name="int getSize()" map="getSize"/>
  <class name="tourma.views.parameters.JPNParamCategories" map="A"/>
  <field class="tourma.views.parameters.JPNParamCategories" name="jbtRemoveCategory" map="A"/>
  <field class="tourma.views.parameters.JPNParamCategories" name="jlsTeamList" map="B"/>
  <field class="tourma.views.parameters.JPNParamCategories" name="jScrollPane4" map="C"/>
  <field class="tourma.views.parameters.JPNParamCategories" name="jScrollPane3" map="D"/>
  <field class="tourma.views.parameters.JPNParamCategories" name="jPanel14" map="E"/>
  <field class="tourma.views.parameters.JPNParamCategories" name="jScrollPane1" map="F"/>
  <field class="tourma.views.parameters.JPNParamCategories" name="mTournament" map="G"/>
  <field class="tourma.views.parameters.JPNParamCategories" name="jPanel13" map="H"/>
  <field class="tourma.views.parameters.JPNParamCategories" name="jbtAddCategory" map="I"/>
  <field class="tourma.views.parameters.JPNParamCategories" name="jlsCoachList" map="J"/>
  <field class="tourma.views.parameters.JPNParamCategories" name="jbtEditCategory" map="K"/>
  <field class="tourma.views.parameters.JPNParamCategories" name="jlsCategories" map="L"/>
  <method class="tourma.views.parameters.JPNParamCategories" name="void jbtEditCategoryActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamCategories" name="void jbtAddCategoryActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamCategories" name="void initComponents()" map="A"/>
  <method class="tourma.views.parameters.JPNParamCategories" name="void access$200(tourma.views.parameters.JPNParamCategories, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamCategories" name="void access$100(tourma.views.parameters.JPNParamCategories, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamCategories" name="void jbtRemoveCategoryActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamCategories" name="void access$300(tourma.views.parameters.JPNParamCategories, java.awt.event.MouseEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamCategories" name="void access$000(tourma.views.parameters.JPNParamCategories, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamCategories" name="void jlsCategoriesMouseClicked(java.awt.event.MouseEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamCategories" name="void update()" map="B"/>
  <class name="tourma.views.parameters.JPNParamGroup$9" map="9"/>
  <field class="tourma.views.parameters.JPNParamGroup$9" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup$9" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamGroup$8" map="8"/>
  <field class="tourma.views.parameters.JPNParamGroup$8" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup$8" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamGroup$17" map="17"/>
  <field class="tourma.views.parameters.JPNParamGroup$17" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup$17" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="tourma.views.parameters.JPNParamGroup$7" map="7"/>
  <field class="tourma.views.parameters.JPNParamGroup$7" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup$7" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamGroup$16" map="16"/>
  <field class="tourma.views.parameters.JPNParamGroup$16" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup$16" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamGroup$6" map="6"/>
  <field class="tourma.views.parameters.JPNParamGroup$6" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup$6" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamGroup$15" map="15"/>
  <field class="tourma.views.parameters.JPNParamGroup$15" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup$15" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamGroup$14" map="14"/>
  <field class="tourma.views.parameters.JPNParamGroup$14" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup$14" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamGroup$5" map="5"/>
  <field class="tourma.views.parameters.JPNParamGroup$5" name="this$0" map="A"/>
  <field class="tourma.views.parameters.JPNParamGroup$5" name="strings" map="B"/>
  <method class="tourma.views.parameters.JPNParamGroup$5" name="java.lang.Object getElementAt(int)" map="getElementAt"/>
  <method class="tourma.views.parameters.JPNParamGroup$5" name="int getSize()" map="getSize"/>
  <class name="tourma.views.parameters.JPNParamGroup$13" map="13"/>
  <field class="tourma.views.parameters.JPNParamGroup$13" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup$13" name="void mouseClicked(java.awt.event.MouseEvent)" map="mouseClicked"/>
  <class name="tourma.views.parameters.JPNParamGroup$4" map="4"/>
  <field class="tourma.views.parameters.JPNParamGroup$4" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamGroup$12" map="12"/>
  <field class="tourma.views.parameters.JPNParamGroup$12" name="this$0" map="A"/>
  <field class="tourma.views.parameters.JPNParamGroup$12" name="strings" map="B"/>
  <method class="tourma.views.parameters.JPNParamGroup$12" name="java.lang.Object getElementAt(int)" map="getElementAt"/>
  <method class="tourma.views.parameters.JPNParamGroup$12" name="int getSize()" map="getSize"/>
  <class name="tourma.views.parameters.JPNParamGroup$3" map="3"/>
  <field class="tourma.views.parameters.JPNParamGroup$3" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamGroup$11" map="11"/>
  <field class="tourma.views.parameters.JPNParamGroup$11" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup$11" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamGroup$2" map="2"/>
  <field class="tourma.views.parameters.JPNParamGroup$2" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamGroup$10" map="10"/>
  <field class="tourma.views.parameters.JPNParamGroup$10" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup$10" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamGroup$1" map="1"/>
  <field class="tourma.views.parameters.JPNParamGroup$1" name="this$0" map="A"/>
  <field class="tourma.views.parameters.JPNParamGroup$1" name="strings" map="B"/>
  <method class="tourma.views.parameters.JPNParamGroup$1" name="java.lang.Object getElementAt(int)" map="getElementAt"/>
  <method class="tourma.views.parameters.JPNParamGroup$1" name="int getSize()" map="getSize"/>
  <class name="tourma.views.parameters.JPNParamGroup" map="B"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jbtGrouToLeft" map="A"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jlbPoints" map="B"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jftfGroupDraw" map="C"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jcbGroupRight" map="D"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jbtAddGroup" map="E"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jcbPointsOpponentGroup" map="F"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jbtRenameGroup" map="G"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jbtGroupToRight" map="H"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jlsRight" map="I"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jlsLeft" map="J"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jcbPointsSelectedGroup" map="K"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jPanel24" map="L"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jPanel23" map="M"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jPanel22" map="N"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jPanel21" map="O"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jlsGroups" map="P"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jPanel20" map="Q"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jLabel9" map="R"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jLabel8" map="S"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jLabel7" map="T"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jspPoints" map="U"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jLabel6" map="V"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jLabel5" map="W"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jftfGroupVictory" map="X"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jLabel4" map="Y"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jLabel3" map="Z"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jLabel2" map="_"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jLabel1" map="a"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jpnPointsModifiers" map="b"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jPanel19" map="c"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jPanel18" map="d"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jScrollPane8" map="e"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jScrollPane7" map="f"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jScrollPane6" map="g"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jcbGroupLeft" map="h"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jftfGroupLoss" map="i"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="mTournament" map="j"/>
  <field class="tourma.views.parameters.JPNParamGroup" name="jbtRemoveGroup" map="k"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void access$300(tourma.views.parameters.JPNParamGroup, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void access$900(tourma.views.parameters.JPNParamGroup, java.awt.event.MouseEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void jftfGroupVictoryFocusLost(java.awt.event.FocusEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void updatePoints()" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void jbtGrouToLeftActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void jspPointsStateChanged(javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void jbtRenameGroupActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void initComponents()" map="B"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void access$700(tourma.views.parameters.JPNParamGroup, java.awt.event.FocusEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void jcbPointsSelectedGroupActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void access$1200(tourma.views.parameters.JPNParamGroup, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void access$1100(tourma.views.parameters.JPNParamGroup, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void access$200(tourma.views.parameters.JPNParamGroup, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void access$100(tourma.views.parameters.JPNParamGroup, java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void access$500(tourma.views.parameters.JPNParamGroup, java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void jbtRemoveGroupActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void jftfGroupDrawFocusLost(java.awt.event.FocusEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void jlsGroupsMouseClicked(java.awt.event.MouseEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void jcbGroupLeftActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void access$800(tourma.views.parameters.JPNParamGroup, java.awt.event.FocusEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void jcbGroupRightActionPerformed(java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void jbtGroupToRightActionPerformed(java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void jcbPointsOpponentGroupActionPerformed(java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void access$1300(tourma.views.parameters.JPNParamGroup, javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void jbtAddGroupActionPerformed(java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void access$1000(tourma.views.parameters.JPNParamGroup, java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void access$600(tourma.views.parameters.JPNParamGroup, java.awt.event.FocusEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void update()" map="C"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void access$000(tourma.views.parameters.JPNParamGroup, java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void access$400(tourma.views.parameters.JPNParamGroup, java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.views.parameters.JPNParamGroup" name="void jftfGroupLossFocusLost(java.awt.event.FocusEvent)" map="C"/>
  <class name="tourma.views.parameters.JPNParamClan$JLSCellRenderer" map="_A"/>
  <field class="tourma.views.parameters.JPNParamClan$JLSCellRenderer" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan$JLSCellRenderer" name="java.awt.Component getListCellRendererComponent(javax.swing.JList, tourma.data.Clan, int, boolean, boolean)" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan$JLSCellRenderer" name="java.awt.Component getListCellRendererComponent(javax.swing.JList, java.lang.Object, int, boolean, boolean)" map="getListCellRendererComponent"/>
  <class name="tourma.views.parameters.JPNParamClan$9" map="9"/>
  <field class="tourma.views.parameters.JPNParamClan$9" name="this$0" map="A"/>
  <field class="tourma.views.parameters.JPNParamClan$9" name="strings" map="B"/>
  <method class="tourma.views.parameters.JPNParamClan$9" name="java.lang.Object getElementAt(int)" map="getElementAt"/>
  <method class="tourma.views.parameters.JPNParamClan$9" name="int getSize()" map="getSize"/>
  <class name="tourma.views.parameters.JPNParamClan$8" map="8"/>
  <field class="tourma.views.parameters.JPNParamClan$8" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan$8" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamClan$7" map="7"/>
  <field class="tourma.views.parameters.JPNParamClan$7" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan$7" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamClan$6" map="6"/>
  <field class="tourma.views.parameters.JPNParamClan$6" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan$6" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamClan$5" map="5"/>
  <field class="tourma.views.parameters.JPNParamClan$5" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan$5" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamClan$4" map="4"/>
  <field class="tourma.views.parameters.JPNParamClan$4" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamClan$3" map="3"/>
  <field class="tourma.views.parameters.JPNParamClan$3" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamClan$2" map="2"/>
  <field class="tourma.views.parameters.JPNParamClan$2" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan$2" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="tourma.views.parameters.JPNParamClan$11" map="11"/>
  <field class="tourma.views.parameters.JPNParamClan$11" name="this$0" map="A"/>
  <field class="tourma.views.parameters.JPNParamClan$11" name="strings" map="B"/>
  <method class="tourma.views.parameters.JPNParamClan$11" name="java.lang.Object getElementAt(int)" map="getElementAt"/>
  <method class="tourma.views.parameters.JPNParamClan$11" name="int getSize()" map="getSize"/>
  <class name="tourma.views.parameters.JPNParamClan$10" map="10"/>
  <field class="tourma.views.parameters.JPNParamClan$10" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan$10" name="void mouseClicked(java.awt.event.MouseEvent)" map="mouseClicked"/>
  <class name="tourma.views.parameters.JPNParamClan$1" map="1"/>
  <field class="tourma.views.parameters.JPNParamClan$1" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamClan" map="C"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jcxAvoidFirstMatch" map="A"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jbtRemoveClan" map="B"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jbtAddClan" map="C"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jcxAvoidMatch" map="D"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jbtEditClanIcon" map="E"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jspClanMembers" map="F"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jScrollPane4" map="G"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jPanel14" map="H"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jScrollPane3" map="I"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jPanel13" map="J"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jPanel12" map="K"/>
  <field class="tourma.views.parameters.JPNParamClan" name="LOG" map="L"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jlbClansMembersNUmbers" map="M"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jbtEditClan" map="N"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jlsClans" map="O"/>
  <field class="tourma.views.parameters.JPNParamClan" name="mTournament" map="P"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jlsCoachList" map="Q"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jlbActivateClans" map="R"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jlbTeamMatesNumber" map="S"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jcxActivatesClans" map="T"/>
  <field class="tourma.views.parameters.JPNParamClan" name="jlbAvoidClansMembersMatch" map="U"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void jcxAvoidFirstMatchActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void access$300(tourma.views.parameters.JPNParamClan, javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void access$800(tourma.views.parameters.JPNParamClan, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void updateSublist()" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan" name="tourma.data.Tournament access$000(tourma.views.parameters.JPNParamClan)" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void initComponents()" map="B"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void access$1000(tourma.views.parameters.JPNParamClan, java.awt.event.MouseEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void access$600(tourma.views.parameters.JPNParamClan, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void jspClanMembersStateChanged(javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void jcxActivatesClansActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void jcxAvoidMatchActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void jbtEditClanIconActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void access$400(tourma.views.parameters.JPNParamClan, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void access$900(tourma.views.parameters.JPNParamClan, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void jlsClansMouseClicked(java.awt.event.MouseEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void access$200(tourma.views.parameters.JPNParamClan, java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void access$700(tourma.views.parameters.JPNParamClan, java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void jbtRemoveClanActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void jbtAddClanActionPerformed(java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void access$500(tourma.views.parameters.JPNParamClan, java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void jbtEditClanActionPerformed(java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.views.parameters.JPNParamClan" name="void update()" map="C"/>
  <class name="tourma.views.parameters.JPNParamTeam$35" map="35"/>
  <field class="tourma.views.parameters.JPNParamTeam$35" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$35" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$34" map="34"/>
  <field class="tourma.views.parameters.JPNParamTeam$34" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$34" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$33" map="33"/>
  <field class="tourma.views.parameters.JPNParamTeam$33" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$33" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$32" map="32"/>
  <field class="tourma.views.parameters.JPNParamTeam$32" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$32" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$31" map="31"/>
  <field class="tourma.views.parameters.JPNParamTeam$31" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$31" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$30" map="30"/>
  <field class="tourma.views.parameters.JPNParamTeam$30" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$30" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$19" map="19"/>
  <field class="tourma.views.parameters.JPNParamTeam$19" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$19" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$18" map="18"/>
  <field class="tourma.views.parameters.JPNParamTeam$18" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$18" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$17" map="17"/>
  <field class="tourma.views.parameters.JPNParamTeam$17" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$17" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamTeam$16" map="16"/>
  <field class="tourma.views.parameters.JPNParamTeam$16" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$16" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamTeam$15" map="15"/>
  <field class="tourma.views.parameters.JPNParamTeam$15" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$15" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$14" map="14"/>
  <field class="tourma.views.parameters.JPNParamTeam$14" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$14" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamTeam$13" map="13"/>
  <field class="tourma.views.parameters.JPNParamTeam$13" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$13" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamTeam$12" map="12"/>
  <field class="tourma.views.parameters.JPNParamTeam$12" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$12" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamTeam$11" map="11"/>
  <field class="tourma.views.parameters.JPNParamTeam$11" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$11" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$10" map="10"/>
  <field class="tourma.views.parameters.JPNParamTeam$10" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$10" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamTeam$9" map="9"/>
  <field class="tourma.views.parameters.JPNParamTeam$9" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$9" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamTeam$29" map="29"/>
  <field class="tourma.views.parameters.JPNParamTeam$29" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$29" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$8" map="8"/>
  <field class="tourma.views.parameters.JPNParamTeam$8" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$8" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamTeam$28" map="28"/>
  <field class="tourma.views.parameters.JPNParamTeam$28" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$28" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$7" map="7"/>
  <field class="tourma.views.parameters.JPNParamTeam$7" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$7" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamTeam$27" map="27"/>
  <field class="tourma.views.parameters.JPNParamTeam$27" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$27" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$6" map="6"/>
  <field class="tourma.views.parameters.JPNParamTeam$6" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$6" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$26" map="26"/>
  <field class="tourma.views.parameters.JPNParamTeam$26" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$26" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="tourma.views.parameters.JPNParamTeam$5" map="5"/>
  <field class="tourma.views.parameters.JPNParamTeam$5" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$5" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamTeam$25" map="25"/>
  <field class="tourma.views.parameters.JPNParamTeam$25" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$25" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$4" map="4"/>
  <field class="tourma.views.parameters.JPNParamTeam$4" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$4" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamTeam$24" map="24"/>
  <field class="tourma.views.parameters.JPNParamTeam$24" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$24" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamTeam$3" map="3"/>
  <field class="tourma.views.parameters.JPNParamTeam$3" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$23" map="23"/>
  <field class="tourma.views.parameters.JPNParamTeam$23" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$23" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamTeam$2" map="2"/>
  <field class="tourma.views.parameters.JPNParamTeam$2" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$22" map="22"/>
  <field class="tourma.views.parameters.JPNParamTeam$22" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$22" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$1" map="1"/>
  <field class="tourma.views.parameters.JPNParamTeam$1" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$21" map="21"/>
  <field class="tourma.views.parameters.JPNParamTeam$21" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$21" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam$20" map="20"/>
  <field class="tourma.views.parameters.JPNParamTeam$20" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam$20" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamTeam" map="D"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jtffHugeVictory" map="A"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jcbRank2Team" map="B"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jtffTeamDrawBonus" map="C"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jlbLittleLossGap" map="D"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jtffLargeVictory" map="E"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jcxExceptBestAndWorst" map="F"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jlbVictoryPoints1" map="G"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jrbTeamVictory" map="H"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jtffBigLostGap" map="I"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jcbRank5Team" map="J"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jtffLostTeam" map="K"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jcxTeamBalance" map="L"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jlbVictoryPoints" map="M"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jcxIndividualBalance" map="N"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jcbRank1Team" map="O"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jcxBigLoss" map="P"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jspBestResults" map="Q"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jtffLargeVictoryGap" map="R"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jtffVictoryTeam" map="S"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jtffDrawTeam" map="T"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jcbRank4Team" map="U"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jcxHugeVictory" map="V"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jcxLargeVictory" map="W"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jLabel30" map="X"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jcxLittleLoss" map="Y"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jcxForAnnexRankingToo" map="Z"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jPanel2" map="_"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jPanel1" map="a"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jtffLittleLost" map="b"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jtffHugeVictoryGap" map="c"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jlbHugeVictoryGap" map="d"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jLabel29" map="e"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jcbRank3Team" map="f"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jLabel28" map="g"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jLabel27" map="h"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jLabel26" map="i"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jLabel25" map="j"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jLabel24" map="k"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jlbLargeVictoryGap" map="l"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jLabel23" map="m"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jtffTeamVictoryBonus" map="n"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jtffHugeLostTeam" map="o"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jrbCoachPoints" map="p"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jtffLittleLostGap" map="q"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jcxBestResult" map="r"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="mTournament" map="s"/>
  <field class="tourma.views.parameters.JPNParamTeam" name="jlbBigLossGap" map="t"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$1400(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$800(tourma.views.parameters.JPNParamTeam, java.awt.event.FocusEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jtffTeamDrawBonusFocusLost(java.awt.event.FocusEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$1100(tourma.views.parameters.JPNParamTeam, java.awt.event.FocusEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$2500(tourma.views.parameters.JPNParamTeam, javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$400(tourma.views.parameters.JPNParamTeam, java.awt.event.FocusEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jtffLargeVictoryFocusLost(java.awt.event.FocusEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jcxLargeVictoryActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jrbTeamVictoryActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$1000(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jtffVictoryTeamFocusLost(java.awt.event.FocusEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jtffHugeVictoryGapFocusLost(java.awt.event.FocusEvent)" map="D"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$1600(tourma.views.parameters.JPNParamTeam, java.awt.event.FocusEvent)" map="D"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$2200(tourma.views.parameters.JPNParamTeam, java.awt.event.FocusEvent)" map="E"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$900(tourma.views.parameters.JPNParamTeam, java.awt.event.FocusEvent)" map="F"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jtffLittleLostGapFocusLost(java.awt.event.FocusEvent)" map="E"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$1200(tourma.views.parameters.JPNParamTeam, java.awt.event.FocusEvent)" map="G"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jtffHugeVictoryFocusLost(java.awt.event.FocusEvent)" map="F"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jtffLargeVictoryGapFocusLost(java.awt.event.FocusEvent)" map="G"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jspBestResultsStateChanged(javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void initComponents()" map="A"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jcxBigLossActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jcxForAnnexRankingTooActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jcxExceptBestAndWorstActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jcxBestResultActionPerformed(java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$2300(tourma.views.parameters.JPNParamTeam, java.awt.event.FocusEvent)" map="H"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$1300(tourma.views.parameters.JPNParamTeam, java.awt.event.FocusEvent)" map="I"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$500(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jrbCoachPointsActionPerformed(java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$2900(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$2800(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$600(tourma.views.parameters.JPNParamTeam, java.awt.event.FocusEvent)" map="J"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$2700(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jcxHugeVictoryActionPerformed(java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jtffLostTeamFocusLost(java.awt.event.FocusEvent)" map="H"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$200(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jtffLittleLostFocusLost(java.awt.event.FocusEvent)" map="I"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$2600(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$100(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void update()" map="B"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$000(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="J"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jtffDrawTeamFocusLost(java.awt.event.FocusEvent)" map="J"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$2400(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="K"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$700(tourma.views.parameters.JPNParamTeam, java.awt.event.FocusEvent)" map="K"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jcxTeamBalanceActionPerformed(java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$1900(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="L"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jcbRank5TeamActionPerformed(java.awt.event.ActionEvent)" map="J"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$1800(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="M"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jtffTeamVictoryBonusFocusLost(java.awt.event.FocusEvent)" map="K"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$2100(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="N"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jcbRank4TeamActionPerformed(java.awt.event.ActionEvent)" map="K"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jcbRank3TeamActionPerformed(java.awt.event.ActionEvent)" map="L"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jcxLittleLossActionPerformed(java.awt.event.ActionEvent)" map="M"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$1700(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="O"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$300(tourma.views.parameters.JPNParamTeam, java.awt.event.FocusEvent)" map="L"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jcbRank1TeamActionPerformed(java.awt.event.ActionEvent)" map="N"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jtffBigLostGapFocusLost(java.awt.event.FocusEvent)" map="L"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jcbRank2TeamActionPerformed(java.awt.event.ActionEvent)" map="O"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$2000(tourma.views.parameters.JPNParamTeam, java.awt.event.ActionEvent)" map="P"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jtffHugeLostTeamFocusLost(java.awt.event.FocusEvent)" map="M"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void access$1500(tourma.views.parameters.JPNParamTeam, java.awt.event.FocusEvent)" map="M"/>
  <method class="tourma.views.parameters.JPNParamTeam" name="void jcxIndividualBalanceActionPerformed(java.awt.event.ActionEvent)" map="P"/>
  <class name="tourma.views.parameters.JPNTeams$3" map="3"/>
  <field class="tourma.views.parameters.JPNTeams$3" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNTeams$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNTeams$2" map="2"/>
  <field class="tourma.views.parameters.JPNTeams$2" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNTeams$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNTeams$1" map="1"/>
  <field class="tourma.views.parameters.JPNTeams$1" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNTeams$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNTeams" map="E"/>
  <field class="tourma.views.parameters.JPNTeams" name="jtbTeam" map="A"/>
  <field class="tourma.views.parameters.JPNTeams" name="jbtModifyTeam" map="B"/>
  <field class="tourma.views.parameters.JPNTeams" name="jbtRemoveTeam" map="C"/>
  <field class="tourma.views.parameters.JPNTeams" name="jScrollPane2" map="D"/>
  <field class="tourma.views.parameters.JPNTeams" name="mTournament" map="E"/>
  <field class="tourma.views.parameters.JPNTeams" name="jlbDetails" map="F"/>
  <field class="tourma.views.parameters.JPNTeams" name="jPanel8" map="G"/>
  <field class="tourma.views.parameters.JPNTeams" name="jPanel3" map="H"/>
  <field class="tourma.views.parameters.JPNTeams" name="jbtAddTeam" map="I"/>
  <method class="tourma.views.parameters.JPNTeams" name="void access$100(tourma.views.parameters.JPNTeams, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNTeams" name="void jbtModifyTeamActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNTeams" name="void jbtRemoveTeamActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNTeams" name="void access$000(tourma.views.parameters.JPNTeams, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNTeams" name="void jbtAddTeamActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNTeams" name="void initComponents()" map="A"/>
  <method class="tourma.views.parameters.JPNTeams" name="void update()" map="B"/>
  <method class="tourma.views.parameters.JPNTeams" name="void access$200(tourma.views.parameters.JPNTeams, java.awt.event.ActionEvent)" map="C"/>
  <class name="tourma.views.parameters.JPNParamIndiv$19" map="19"/>
  <field class="tourma.views.parameters.JPNParamIndiv$19" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$19" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamIndiv$18" map="18"/>
  <field class="tourma.views.parameters.JPNParamIndiv$18" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$18" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="tourma.views.parameters.JPNParamIndiv$17" map="17"/>
  <field class="tourma.views.parameters.JPNParamIndiv$17" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$17" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamIndiv$16" map="16"/>
  <field class="tourma.views.parameters.JPNParamIndiv$16" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$16" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamIndiv$15" map="15"/>
  <field class="tourma.views.parameters.JPNParamIndiv$15" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$15" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamIndiv$14" map="14"/>
  <field class="tourma.views.parameters.JPNParamIndiv$14" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$14" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamIndiv$13" map="13"/>
  <field class="tourma.views.parameters.JPNParamIndiv$13" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$13" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamIndiv$12" map="12"/>
  <field class="tourma.views.parameters.JPNParamIndiv$12" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$12" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamIndiv$11" map="11"/>
  <field class="tourma.views.parameters.JPNParamIndiv$11" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$11" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamIndiv$10" map="10"/>
  <field class="tourma.views.parameters.JPNParamIndiv$10" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$10" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamIndiv$9" map="9"/>
  <field class="tourma.views.parameters.JPNParamIndiv$9" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$9" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamIndiv$8" map="8"/>
  <field class="tourma.views.parameters.JPNParamIndiv$8" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$8" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamIndiv$7" map="7"/>
  <field class="tourma.views.parameters.JPNParamIndiv$7" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$7" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamIndiv$6" map="6"/>
  <field class="tourma.views.parameters.JPNParamIndiv$6" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$6" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamIndiv$5" map="5"/>
  <field class="tourma.views.parameters.JPNParamIndiv$5" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$5" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamIndiv$4" map="4"/>
  <field class="tourma.views.parameters.JPNParamIndiv$4" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$4" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamIndiv$25" map="25"/>
  <field class="tourma.views.parameters.JPNParamIndiv$25" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$25" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamIndiv$24" map="24"/>
  <field class="tourma.views.parameters.JPNParamIndiv$24" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$24" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamIndiv$3" map="3"/>
  <field class="tourma.views.parameters.JPNParamIndiv$3" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$3" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamIndiv$23" map="23"/>
  <field class="tourma.views.parameters.JPNParamIndiv$23" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$23" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamIndiv$2" map="2"/>
  <field class="tourma.views.parameters.JPNParamIndiv$2" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$2" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="tourma.views.parameters.JPNParamIndiv$22" map="22"/>
  <field class="tourma.views.parameters.JPNParamIndiv$22" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$22" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamIndiv$1" map="1"/>
  <field class="tourma.views.parameters.JPNParamIndiv$1" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamIndiv$21" map="21"/>
  <field class="tourma.views.parameters.JPNParamIndiv$21" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$21" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamIndiv$20" map="20"/>
  <field class="tourma.views.parameters.JPNParamIndiv$20" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv$20" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamIndiv" map="F"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jtffConcedeed" map="A"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jcxLargeVictory" map="B"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jcxForAnnexRankingToo" map="C"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jcxExceptBestAndWorst" map="D"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jLabel18" map="E"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jspBestResults" map="F"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jLabel17" map="G"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jLabel16" map="H"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jcbRank5" map="I"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jLabel15" map="J"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jcbRank4" map="K"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jLabel14" map="L"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jcbRank3" map="M"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jtffLost" map="N"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jcbRank2" map="O"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jcbRank1" map="P"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jlbLargeVictoryGap" map="Q"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="LOG" map="R"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jtffLittleLost" map="S"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jtffDraw" map="T"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jtffVictory" map="U"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jtffRefused" map="V"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="mTournament" map="W"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jlbLittleLossGap" map="X"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jcxBestResult" map="Y"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jLabel9" map="Z"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jLabel8" map="_"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jLabel7" map="a"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jcxLittleLoss" map="b"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jLabel5" map="c"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jtffLargeVictory" map="d"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jLabel4" map="e"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jtffLittleLostGap" map="f"/>
  <field class="tourma.views.parameters.JPNParamIndiv" name="jtffLargeVictoryGap" map="g"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$1000(tourma.views.parameters.JPNParamIndiv, java.awt.event.FocusEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$1400(tourma.views.parameters.JPNParamIndiv, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jtffRefusedFocusLost(java.awt.event.FocusEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jcbRank5ActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jtffLargeVictoryFocusLost(java.awt.event.FocusEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jcxLargeVictoryActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$900(tourma.views.parameters.JPNParamIndiv, java.awt.event.FocusEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jcbRank4ActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$800(tourma.views.parameters.JPNParamIndiv, java.awt.event.FocusEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$500(tourma.views.parameters.JPNParamIndiv, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void readObject(java.io.ObjectInputStream)" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$700(tourma.views.parameters.JPNParamIndiv, java.awt.event.FocusEvent)" map="D"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jtffLittleLostGapFocusLost(java.awt.event.FocusEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jcbRank3ActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jtffLargeVictoryGapFocusLost(java.awt.event.FocusEvent)" map="D"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$600(tourma.views.parameters.JPNParamIndiv, java.awt.event.FocusEvent)" map="E"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$1300(tourma.views.parameters.JPNParamIndiv, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jtffVictoryFocusLost(java.awt.event.FocusEvent)" map="E"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jspBestResultsStateChanged(javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jcbRank2ActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void initComponents()" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$400(tourma.views.parameters.JPNParamIndiv, java.awt.event.FocusEvent)" map="F"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jtffLostFocusLost(java.awt.event.FocusEvent)" map="F"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$300(tourma.views.parameters.JPNParamIndiv, java.awt.event.FocusEvent)" map="G"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jcxForAnnexRankingTooActionPerformed(java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jcxExceptBestAndWorstActionPerformed(java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$1600(tourma.views.parameters.JPNParamIndiv, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jcxBestResultActionPerformed(java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$200(tourma.views.parameters.JPNParamIndiv, java.awt.event.FocusEvent)" map="H"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jcbRank1ActionPerformed(java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jtffConcedeedFocusLost(java.awt.event.FocusEvent)" map="G"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$100(tourma.views.parameters.JPNParamIndiv, java.awt.event.FocusEvent)" map="I"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jtffDrawFocusLost(java.awt.event.FocusEvent)" map="H"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$1900(tourma.views.parameters.JPNParamIndiv, java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$1200(tourma.views.parameters.JPNParamIndiv, java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jtffLittleLostFocusLost(java.awt.event.FocusEvent)" map="I"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$1700(tourma.views.parameters.JPNParamIndiv, javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void writeObject(java.io.ObjectOutputStream)" map="A"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void update()" map="B"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$000(tourma.views.parameters.JPNParamIndiv, java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$1500(tourma.views.parameters.JPNParamIndiv, java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void jcxLittleLossActionPerformed(java.awt.event.ActionEvent)" map="J"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$1800(tourma.views.parameters.JPNParamIndiv, java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.views.parameters.JPNParamIndiv" name="void access$1100(tourma.views.parameters.JPNParamIndiv, java.awt.event.ActionEvent)" map="J"/>
  <class name="tourma.views.parameters.JPNParamFormulas$2" map="2"/>
  <field class="tourma.views.parameters.JPNParamFormulas$2" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamFormulas$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamFormulas$1" map="1"/>
  <field class="tourma.views.parameters.JPNParamFormulas$1" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamFormulas$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamFormulas" map="G"/>
  <field class="tourma.views.parameters.JPNParamFormulas" name="jScrollPane5" map="A"/>
  <field class="tourma.views.parameters.JPNParamFormulas" name="jPanel16" map="B"/>
  <field class="tourma.views.parameters.JPNParamFormulas" name="jbtAddFormula" map="C"/>
  <field class="tourma.views.parameters.JPNParamFormulas" name="jScrollPane1" map="D"/>
  <field class="tourma.views.parameters.JPNParamFormulas" name="jtxpDescription" map="E"/>
  <field class="tourma.views.parameters.JPNParamFormulas" name="mTournament" map="F"/>
  <field class="tourma.views.parameters.JPNParamFormulas" name="jbtRemoveFormula" map="G"/>
  <field class="tourma.views.parameters.JPNParamFormulas" name="jtbFormulas" map="H"/>
  <method class="tourma.views.parameters.JPNParamFormulas" name="void jbtAddFormulaActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamFormulas" name="void access$100(tourma.views.parameters.JPNParamFormulas, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamFormulas" name="void initComponents()" map="A"/>
  <method class="tourma.views.parameters.JPNParamFormulas" name="void jbtRemoveFormulaActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamFormulas" name="void update()" map="B"/>
  <method class="tourma.views.parameters.JPNParamFormulas" name="void access$000(tourma.views.parameters.JPNParamFormulas, java.awt.event.ActionEvent)" map="B"/>
  <class name="tourma.views.parameters.JPNParameters$6" map="6"/>
  <field class="tourma.views.parameters.JPNParameters$6" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParameters$6" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParameters$5" map="5"/>
  <field class="tourma.views.parameters.JPNParameters$5" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParameters$5" name="void mouseClicked(java.awt.event.MouseEvent)" map="mouseClicked"/>
  <class name="tourma.views.parameters.JPNParameters$4" map="4"/>
  <field class="tourma.views.parameters.JPNParameters$4" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParameters$4" name="void keyPressed(java.awt.event.KeyEvent)" map="keyPressed"/>
  <class name="tourma.views.parameters.JPNParameters$3" map="3"/>
  <field class="tourma.views.parameters.JPNParameters$3" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParameters$3" name="void keyPressed(java.awt.event.KeyEvent)" map="keyPressed"/>
  <class name="tourma.views.parameters.JPNParameters$2" map="2"/>
  <field class="tourma.views.parameters.JPNParameters$2" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParameters$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParameters$1" map="1"/>
  <field class="tourma.views.parameters.JPNParameters$1" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParameters$1" name="void keyPressed(java.awt.event.KeyEvent)" map="keyPressed"/>
  <class name="tourma.views.parameters.JPNParameters$8" map="8"/>
  <field class="tourma.views.parameters.JPNParameters$8" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParameters$8" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParameters$7" map="7"/>
  <field class="tourma.views.parameters.JPNParameters$7" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParameters$7" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParameters" map="H"/>
  <field class="tourma.views.parameters.JPNParameters" name="jPanel9" map="A"/>
  <field class="tourma.views.parameters.JPNParameters" name="jPanel7" map="B"/>
  <field class="tourma.views.parameters.JPNParameters" name="jPanel5" map="C"/>
  <field class="tourma.views.parameters.JPNParameters" name="jtfOrgas" map="D"/>
  <field class="tourma.views.parameters.JPNParameters" name="jPanel1" map="E"/>
  <field class="tourma.views.parameters.JPNParameters" name="mJpnCategories" map="F"/>
  <field class="tourma.views.parameters.JPNParameters" name="mJpnGroup" map="G"/>
  <field class="tourma.views.parameters.JPNParameters" name="jbtRemove" map="H"/>
  <field class="tourma.views.parameters.JPNParameters" name="jbtModify" map="I"/>
  <field class="tourma.views.parameters.JPNParameters" name="jtpOptions" map="J"/>
  <field class="tourma.views.parameters.JPNParameters" name="mJpnTeam" map="K"/>
  <field class="tourma.views.parameters.JPNParameters" name="jScrollPane1" map="L"/>
  <field class="tourma.views.parameters.JPNParameters" name="jtfTournamentName" map="M"/>
  <field class="tourma.views.parameters.JPNParameters" name="jDate" map="N"/>
  <field class="tourma.views.parameters.JPNParameters" name="jtfPlace" map="O"/>
  <field class="tourma.views.parameters.JPNParameters" name="jbtAdd" map="P"/>
  <field class="tourma.views.parameters.JPNParameters" name="jLabel22" map="Q"/>
  <field class="tourma.views.parameters.JPNParameters" name="mJpnIndiv" map="R"/>
  <field class="tourma.views.parameters.JPNParameters" name="jLabel21" map="S"/>
  <field class="tourma.views.parameters.JPNParameters" name="mTournament" map="T"/>
  <field class="tourma.views.parameters.JPNParameters" name="mJpnClan" map="U"/>
  <field class="tourma.views.parameters.JPNParameters" name="mJpnFormulas" map="V"/>
  <field class="tourma.views.parameters.JPNParameters" name="jtbCoachs" map="W"/>
  <field class="tourma.views.parameters.JPNParameters" name="mJpnCriterias" map="X"/>
  <field class="tourma.views.parameters.JPNParameters" name="jLabel2" map="Y"/>
  <field class="tourma.views.parameters.JPNParameters" name="jLabel1" map="Z"/>
  <field class="tourma.views.parameters.JPNParameters" name="jpnParticipant" map="_"/>
  <field class="tourma.views.parameters.JPNParameters" name="jpnTeamTour" map="a"/>
  <field class="tourma.views.parameters.JPNParameters" name="jpnCoachButtons" map="b"/>
  <method class="tourma.views.parameters.JPNParameters" name="void jtpOptionsMouseClicked(java.awt.event.MouseEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParameters" name="void jtfPlaceKeyPressed(java.awt.event.KeyEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParameters" name="void jbtAddActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParameters" name="void initComponents()" map="A"/>
  <method class="tourma.views.parameters.JPNParameters" name="void jtfOrgasKeyPressed(java.awt.event.KeyEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParameters" name="void access$400(tourma.views.parameters.JPNParameters, java.awt.event.MouseEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParameters" name="void access$100(tourma.views.parameters.JPNParameters, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParameters" name="void access$500(tourma.views.parameters.JPNParameters, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParameters" name="void jtfOrgasActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParameters" name="void access$000(tourma.views.parameters.JPNParameters, java.awt.event.KeyEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParameters" name="void jbtModifyActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParameters" name="void access$300(tourma.views.parameters.JPNParameters, java.awt.event.KeyEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParameters" name="void access$200(tourma.views.parameters.JPNParameters, java.awt.event.KeyEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParameters" name="void jtfTournamentNameKeyPressed(java.awt.event.KeyEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParameters" name="void updateTables(boolean)" map="A"/>
  <method class="tourma.views.parameters.JPNParameters" name="void access$700(tourma.views.parameters.JPNParameters, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParameters" name="void access$600(tourma.views.parameters.JPNParameters, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.parameters.JPNParameters" name="void update()" map="B"/>
  <method class="tourma.views.parameters.JPNParameters" name="void jbtRemoveActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <class name="tourma.views.parameters.JPNParamCriterias$6" map="6"/>
  <field class="tourma.views.parameters.JPNParamCriterias$6" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamCriterias$6" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="tourma.views.parameters.JPNParamCriterias$5" map="5"/>
  <field class="tourma.views.parameters.JPNParamCriterias$5" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamCriterias$5" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamCriterias$4" map="4"/>
  <field class="tourma.views.parameters.JPNParamCriterias$4" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamCriterias$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamCriterias$3" map="3"/>
  <field class="tourma.views.parameters.JPNParamCriterias$3" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamCriterias$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamCriterias$2" map="2"/>
  <field class="tourma.views.parameters.JPNParamCriterias$2" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamCriterias$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.views.parameters.JPNParamCriterias$1" map="1"/>
  <field class="tourma.views.parameters.JPNParamCriterias$1" name="this$0" map="A"/>
  <method class="tourma.views.parameters.JPNParamCriterias$1" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="tourma.views.parameters.JPNParamCriterias" map="I"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="jtbCriteria" map="A"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="jPanel1" map="B"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="jcxTableCoefPerRound" map="C"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="jspTeamBonuses" map="D"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="jspCoef" map="E"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="jcxTableBonus" map="F"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="jScrollPane6" map="G"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="jtpCriterias" map="H"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="jScrollPane5" map="I"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="jlbCoef" map="J"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="jPanel16" map="K"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="jbtAddCriteria" map="L"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="mTournament" map="M"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="jtbPlayerBonuses" map="N"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="jtbTeamBonus" map="O"/>
  <field class="tourma.views.parameters.JPNParamCriterias" name="jbtRemoveCriteria" map="P"/>
  <method class="tourma.views.parameters.JPNParamCriterias" name="void jspCoefStateChanged(javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamCriterias" name="void initComponents()" map="A"/>
  <method class="tourma.views.parameters.JPNParamCriterias" name="void jcxTableBonusActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamCriterias" name="void access$200(tourma.views.parameters.JPNParamCriterias, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamCriterias" name="void jbtRemoveCriteriaActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamCriterias" name="void jcxTableCoefPerRoundActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamCriterias" name="void access$000(tourma.views.parameters.JPNParamCriterias, javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.views.parameters.JPNParamCriterias" name="void jbtAddCriteriaActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.views.parameters.JPNParamCriterias" name="void access$300(tourma.views.parameters.JPNParamCriterias, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.views.parameters.JPNParamCriterias" name="void update()" map="B"/>
  <method class="tourma.views.parameters.JPNParamCriterias" name="void access$100(tourma.views.parameters.JPNParamCriterias, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.views.parameters.JPNParamCriterias" name="void access$400(tourma.views.parameters.JPNParamCriterias, java.awt.event.ActionEvent)" map="D"/>
  <package name="tourma.views.fullscreen" map="E"/>
  <class name="tourma.views.fullscreen.JFullScreenIndivAnnex" map="A"/>
  <field class="tourma.views.fullscreen.JFullScreenIndivAnnex" name="LOG" map="o"/>
  <field class="tourma.views.fullscreen.JFullScreenIndivAnnex" name="loopStop" map="p"/>
  <field class="tourma.views.fullscreen.JFullScreenIndivAnnex" name="round" map="q"/>
  <field class="tourma.views.fullscreen.JFullScreenIndivAnnex" name="indivRankType" map="r"/>
  <method class="tourma.views.fullscreen.JFullScreenIndivAnnex" name="void initComponents()" map="G"/>
  <method class="tourma.views.fullscreen.JFullScreenIndivAnnex" name="void buildPanel(java.util.ArrayList, int)" map="B"/>
  <class name="tourma.views.fullscreen.JFullScreenTeamRank" map="B"/>
  <field class="tourma.views.fullscreen.JFullScreenTeamRank" name="LOG" map="L"/>
  <field class="tourma.views.fullscreen.JFullScreenTeamRank" name="loopStop" map="M"/>
  <field class="tourma.views.fullscreen.JFullScreenTeamRank" name="round" map="N"/>
  <field class="tourma.views.fullscreen.JFullScreenTeamRank" name="forPool" map="O"/>
  <method class="tourma.views.fullscreen.JFullScreenTeamRank" name="void initComponents()" map="B"/>
  <method class="tourma.views.fullscreen.JFullScreenTeamRank" name="void buildPanel(java.util.ArrayList, int)" map="A"/>
  <class name="tourma.views.fullscreen.JFullScreenClanRank" map="C"/>
  <field class="tourma.views.fullscreen.JFullScreenClanRank" name="loopStop" map="P"/>
  <field class="tourma.views.fullscreen.JFullScreenClanRank" name="round" map="Q"/>
  <method class="tourma.views.fullscreen.JFullScreenClanRank" name="void buildPanel(tourma.utils.display.IRanked)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreenClanRank" name="void initComponents()" map="C"/>
  <class name="tourma.views.fullscreen.JFullScreenClanTeamAnnex" map="D"/>
  <field class="tourma.views.fullscreen.JFullScreenClanTeamAnnex" name="LOG" map="R"/>
  <field class="tourma.views.fullscreen.JFullScreenClanTeamAnnex" name="loopStop" map="S"/>
  <field class="tourma.views.fullscreen.JFullScreenClanTeamAnnex" name="round" map="T"/>
  <field class="tourma.views.fullscreen.JFullScreenClanTeamAnnex" name="team" map="U"/>
  <field class="tourma.views.fullscreen.JFullScreenClanTeamAnnex" name="forPool" map="V"/>
  <method class="tourma.views.fullscreen.JFullScreenClanTeamAnnex" name="void initComponents()" map="D"/>
  <method class="tourma.views.fullscreen.JFullScreenClanTeamAnnex" name="void buildPanel(java.util.ArrayList)" map="A"/>
  <class name="tourma.views.fullscreen.JFullScreen$1" map="1"/>
  <field class="tourma.views.fullscreen.JFullScreen$1" name="this$0" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreen$1" name="void keyPressed(java.awt.event.KeyEvent)" map="keyPressed"/>
  <class name="tourma.views.fullscreen.JFullScreen$Animation" map="_A"/>
  <field class="tourma.views.fullscreen.JFullScreen$Animation" name="this$0" map="F"/>
  <field class="tourma.views.fullscreen.JFullScreen$Animation" name="millis" map="G"/>
  <field class="tourma.views.fullscreen.JFullScreen$Animation" name="suspended" map="H"/>
  <field class="tourma.views.fullscreen.JFullScreen$Animation" name="computedTime" map="I"/>
  <field class="tourma.views.fullscreen.JFullScreen$Animation" name="ncomputedTime" map="J"/>
  <method class="tourma.views.fullscreen.JFullScreen$Animation" name="void decrementSync()" map="C"/>
  <method class="tourma.views.fullscreen.JFullScreen$Animation" name="void setSuspended(boolean)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreen$Animation" name="void incrementSync()" map="D"/>
  <method class="tourma.views.fullscreen.JFullScreen$Animation" name="void run()" map="run"/>
  <class name="tourma.views.fullscreen.JFullScreen$ClientLoop" map="_B"/>
  <method class="tourma.views.fullscreen.JFullScreen$ClientLoop" name="void setStop(boolean)" map="A"/>
  <class name="tourma.views.fullscreen.JFullScreen" map="E"/>
  <field class="tourma.views.fullscreen.JFullScreen" name="semAnimate" map="A"/>
  <field class="tourma.views.fullscreen.JFullScreen" name="animation" map="B"/>
  <field class="tourma.views.fullscreen.JFullScreen" name="jpnContent" map="C"/>
  <field class="tourma.views.fullscreen.JFullScreen" name="semStart" map="D"/>
  <field class="tourma.views.fullscreen.JFullScreen" name="jpnNorth" map="E"/>
  <field class="tourma.views.fullscreen.JFullScreen" name="mSelectedGD" map="F"/>
  <field class="tourma.views.fullscreen.JFullScreen" name="jscrp" map="G"/>
  <field class="tourma.views.fullscreen.JFullScreen" name="socket" map="H"/>
  <field class="tourma.views.fullscreen.JFullScreen" name="cl" map="I"/>
  <field class="tourma.views.fullscreen.JFullScreen" name="LOG" map="J"/>
  <field class="tourma.views.fullscreen.JFullScreen" name="animationStarted" map="K"/>
  <method class="tourma.views.fullscreen.JFullScreen" name="void formKeyPressed(java.awt.event.KeyEvent)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreen" name="java.awt.GridBagConstraints getGridbBagConstraints(int, int, int, int)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreen" name="void access$000(tourma.views.fullscreen.JFullScreen, java.awt.event.KeyEvent)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreen" name="void keyPressed(java.awt.event.KeyEvent)" map="B"/>
  <method class="tourma.views.fullscreen.JFullScreen" name="void initComponents()" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreen" name="javax.swing.JLabel getLabelForObject(tourma.data.IWithNameAndPicture, int, int, java.awt.Font, java.awt.Color)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreen" name="javax.swing.JLabel getLabelForObject(tourma.data.IWithNameAndPicture, int, int, java.awt.Font, java.awt.Color, boolean, int)" map="A"/>
  <class name="tourma.views.fullscreen.JFullScreenIndivRank" map="F"/>
  <field class="tourma.views.fullscreen.JFullScreenIndivRank" name="loopStop" map="W"/>
  <field class="tourma.views.fullscreen.JFullScreenIndivRank" name="round" map="X"/>
  <field class="tourma.views.fullscreen.JFullScreenIndivRank" name="indivRankType" map="Y"/>
  <method class="tourma.views.fullscreen.JFullScreenIndivRank" name="void initComponents()" map="E"/>
  <method class="tourma.views.fullscreen.JFullScreenIndivRank" name="void buildPanel(java.util.ArrayList)" map="B"/>
  <class name="tourma.views.fullscreen.JFullScreenMatchs$Animation" map="_A"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs$Animation" name="this$0" map="A"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs$Animation" name="nanos" map="B"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs$Animation" name="suspended" map="C"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs$Animation" name="_screen" map="D"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs$Animation" name="step" map="E"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs$Animation" name="void decrementSync()" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs$Animation" name="void setSuspended(boolean)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs$Animation" name="void incrementSync()" map="B"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs$Animation" name="void run()" map="run"/>
  <class name="tourma.views.fullscreen.JFullScreenMatchs" map="G"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="jpnClash1" map="Z"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="jpn2Y" map="_"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="jpn2X" map="a"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="jlbTitle2" map="b"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="jlbTitle1" map="c"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="jpn" map="d"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="loopStop" map="e"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="jpn1Y" map="f"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="mSelectedGD" map="F"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="jpn1X" map="g"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="me" map="h"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="_screenIndex" map="i"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="clash" map="j"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="clashAnim" map="k"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="LOG" map="l"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="round" map="m"/>
  <field class="tourma.views.fullscreen.JFullScreenMatchs" name="jpnClash2" map="n"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="javax.swing.JPanel access$402(tourma.views.fullscreen.JFullScreenMatchs, javax.swing.JPanel)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="boolean access$100(tourma.views.fullscreen.JFullScreenMatchs)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="void buildPanel(tourma.data.Round, int)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="javax.swing.JLabel access$602(tourma.views.fullscreen.JFullScreenMatchs, javax.swing.JLabel)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="void keyPressed(java.awt.event.KeyEvent)" map="B"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="int access$702(tourma.views.fullscreen.JFullScreenMatchs, int)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="void initComponents()" map="F"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="int access$802(tourma.views.fullscreen.JFullScreenMatchs, int)" map="B"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="javax.swing.JLabel access$502(tourma.views.fullscreen.JFullScreenMatchs, javax.swing.JLabel)" map="B"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="javax.swing.JPanel access$400(tourma.views.fullscreen.JFullScreenMatchs)" map="B"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="int access$902(tourma.views.fullscreen.JFullScreenMatchs, int)" map="C"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="int access$900(tourma.views.fullscreen.JFullScreenMatchs)" map="C"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="int access$1002(tourma.views.fullscreen.JFullScreenMatchs, int)" map="D"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="javax.swing.JLabel access$500(tourma.views.fullscreen.JFullScreenMatchs)" map="D"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="javax.swing.JPanel createClashCoachPane(tourma.data.Coach, int, boolean, int)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="tourma.views.fullscreen.JFullScreenMatchs access$000(tourma.views.fullscreen.JFullScreenMatchs)" map="E"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="int access$800(tourma.views.fullscreen.JFullScreenMatchs)" map="F"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="javax.swing.JPanel access$302(tourma.views.fullscreen.JFullScreenMatchs, javax.swing.JPanel)" map="B"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="java.awt.Font getCoachMatchFont(tourma.data.CoachMatch, tourma.data.Competitor, java.awt.Font, java.awt.Font, java.awt.Font, java.awt.Font)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="javax.swing.JPanel access$300(tourma.views.fullscreen.JFullScreenMatchs)" map="G"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="void buildClash(int)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="javax.swing.JPanel createClashTeamPane(tourma.data.Team, tourma.data.TeamMatch, boolean)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="javax.swing.JLabel access$600(tourma.views.fullscreen.JFullScreenMatchs)" map="H"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="int access$700(tourma.views.fullscreen.JFullScreenMatchs)" map="I"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="java.awt.Font getOptimalFont(int, int, java.lang.String)" map="A"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="tourma.data.Round access$200(tourma.views.fullscreen.JFullScreenMatchs)" map="J"/>
  <method class="tourma.views.fullscreen.JFullScreenMatchs" name="int access$1000(tourma.views.fullscreen.JFullScreenMatchs)" map="K"/>
  <class name="tourma.views.JPNStatistics$4" map="4"/>
  <field class="tourma.views.JPNStatistics$4" name="this$0" map="A"/>
  <method class="tourma.views.JPNStatistics$4" name="void valueChanged(javax.swing.event.ListSelectionEvent)" map="valueChanged"/>
  <class name="tourma.views.JPNStatistics$3" map="3"/>
  <field class="tourma.views.JPNStatistics$3" name="this$0" map="A"/>
  <method class="tourma.views.JPNStatistics$3" name="void valueChanged(javax.swing.event.ListSelectionEvent)" map="valueChanged"/>
  <class name="tourma.views.JPNStatistics$2" map="2"/>
  <field class="tourma.views.JPNStatistics$2" name="this$0" map="A"/>
  <method class="tourma.views.JPNStatistics$2" name="void valueChanged(javax.swing.event.ListSelectionEvent)" map="valueChanged"/>
  <class name="tourma.views.JPNStatistics$1" map="1"/>
  <field class="tourma.views.JPNStatistics$1" name="this$0" map="A"/>
  <method class="tourma.views.JPNStatistics$1" name="void valueChanged(javax.swing.event.ListSelectionEvent)" map="valueChanged"/>
  <class name="tourma.views.JPNStatistics" map="A"/>
  <field class="tourma.views.JPNStatistics" name="mHIndivBalanced" map="A"/>
  <field class="tourma.views.JPNStatistics" name="cpTeamPositions" map="B"/>
  <field class="tourma.views.JPNStatistics" name="jpnPositions" map="C"/>
  <field class="tourma.views.JPNStatistics" name="jpnBalancedTeam" map="D"/>
  <field class="tourma.views.JPNStatistics" name="jpnTeamPositions" map="E"/>
  <field class="tourma.views.JPNStatistics" name="mHpositions" map="F"/>
  <field class="tourma.views.JPNStatistics" name="mHTeamBalanced" map="G"/>
  <field class="tourma.views.JPNStatistics" name="jtpStatistics" map="H"/>
  <field class="tourma.views.JPNStatistics" name="cpBalancedTeam" map="I"/>
  <field class="tourma.views.JPNStatistics" name="cpBalancedIndiv" map="J"/>
  <field class="tourma.views.JPNStatistics" name="cpPositions" map="K"/>
  <field class="tourma.views.JPNStatistics" name="LOG" map="L"/>
  <field class="tourma.views.JPNStatistics" name="mHTeampositions" map="M"/>
  <field class="tourma.views.JPNStatistics" name="jlsTeamPositions" map="N"/>
  <field class="tourma.views.JPNStatistics" name="jlsBalancedTeam" map="O"/>
  <field class="tourma.views.JPNStatistics" name="jpnBalancedIndiv" map="P"/>
  <field class="tourma.views.JPNStatistics" name="mTournament" map="Q"/>
  <field class="tourma.views.JPNStatistics" name="jlsBalancedIndiv" map="R"/>
  <field class="tourma.views.JPNStatistics" name="jlsPositions" map="S"/>
  <method class="tourma.views.JPNStatistics" name="void addGroupPie()" map="A"/>
  <method class="tourma.views.JPNStatistics" name="void initComponents()" map="B"/>
  <method class="tourma.views.JPNStatistics" name="void addTeamBalanced()" map="C"/>
  <method class="tourma.views.JPNStatistics" name="void addWinLoss()" map="D"/>
  <method class="tourma.views.JPNStatistics" name="void addRosterPie()" map="E"/>
  <method class="tourma.views.JPNStatistics" name="void updatePositions()" map="F"/>
  <method class="tourma.views.JPNStatistics" name="void updateBalancedTeam()" map="G"/>
  <method class="tourma.views.JPNStatistics" name="void addIndivBalanced()" map="H"/>
  <method class="tourma.views.JPNStatistics" name="void readObject(java.io.ObjectInputStream)" map="A"/>
  <method class="tourma.views.JPNStatistics" name="javax.swing.JTabbedPane getTabbedPane()" map="I"/>
  <method class="tourma.views.JPNStatistics" name="void updateBalancedIndiv()" map="J"/>
  <method class="tourma.views.JPNStatistics" name="void addPointsAverage()" map="K"/>
  <method class="tourma.views.JPNStatistics" name="void addPositions()" map="L"/>
  <method class="tourma.views.JPNStatistics" name="void updateTeamPositions()" map="M"/>
  <method class="tourma.views.JPNStatistics" name="void writeObject(java.io.ObjectOutputStream)" map="A"/>
  <method class="tourma.views.JPNStatistics" name="void update()" map="N"/>
  <method class="tourma.views.JPNStatistics" name="void addCounterPerRoster()" map="O"/>
  <method class="tourma.views.JPNStatistics" name="void addTeamPositions()" map="P"/>
  <class name="tourma.views.JPNCup" map="B"/>
  <field class="tourma.views.JPNCup" name="jsp1" map="A"/>
  <field class="tourma.views.JPNCup" name="LOG" map="B"/>
  <field class="tourma.views.JPNCup" name="jpnCup" map="C"/>
  <field class="tourma.views.JPNCup" name="jPanel1" map="D"/>
  <method class="tourma.views.JPNCup" name="void initComponents()" map="A"/>
  <method class="tourma.views.JPNCup" name="void update()" map="B"/>
  <package name="tourma.utils" map="B"/>
  <package name="tourma.utils.web" map="A"/>
  <class name="tourma.utils.web.WebStatistics" map="A"/>
  <method class="tourma.utils.web.WebStatistics" name="java.lang.String getHTML()" map="A"/>
  <class name="tourma.utils.web.WebMatchResult" map="B"/>
  <method class="tourma.utils.web.WebMatchResult" name="java.lang.String getHTML(java.util.Map)" map="A"/>
  <method class="tourma.utils.web.WebMatchResult" name="java.lang.String getHTML(java.lang.String, java.lang.String)" map="A"/>
  <method class="tourma.utils.web.WebMatchResult" name="java.lang.String getHTML()" map="A"/>
  <class name="tourma.utils.web.WebCup" map="C"/>
  <field class="tourma.utils.web.WebCup" name="CS_Victory" map="A"/>
  <field class="tourma.utils.web.WebCup" name="CS_Draw" map="B"/>
  <field class="tourma.utils.web.WebCup" name="CS_MainTable" map="C"/>
  <field class="tourma.utils.web.WebCup" name="CS_LooserTable" map="D"/>
  <field class="tourma.utils.web.WebCup" name="CS_ThirdPlace" map="E"/>
  <method class="tourma.utils.web.WebCup" name="java.lang.String getHTMLLine(tourma.data.Match, int)" map="A"/>
  <method class="tourma.utils.web.WebCup" name="java.lang.String getHTML()" map="A"/>
  <method class="tourma.utils.web.WebCup" name="java.lang.String getHTMLHeader()" map="B"/>
  <class name="tourma.utils.web.WebPicture" map="D"/>
  <method class="tourma.utils.web.WebPicture" name="java.lang.String getPictureAsHTML(java.awt.image.BufferedImage, int, int, boolean)" map="A"/>
  <method class="tourma.utils.web.WebPicture" name="java.lang.String getPictureAsHTML(javax.swing.ImageIcon, int, int)" map="A"/>
  <class name="tourma.utils.web.WebRules" map="E"/>
  <field class="tourma.utils.web.WebRules" name="LOG" map="A"/>
  <method class="tourma.utils.web.WebRules" name="java.lang.String getHTML()" map="A"/>
  <class name="tourma.utils.web.WebServer" map="F"/>
  <method class="tourma.utils.web.WebServer" name="java.lang.String createScript()" map="G"/>
  <method class="tourma.utils.web.WebServer" name="java.lang.String createHome()" map="H"/>
  <method class="tourma.utils.web.WebServer" name="java.lang.String createMenu(boolean)" map="A"/>
  <method class="tourma.utils.web.WebServer" name="java.io.File createTempDirectory()" map="I"/>
  <method class="tourma.utils.web.WebServer" name="void cleanFiles(java.util.ArrayList)" map="A"/>
  <method class="tourma.utils.web.WebServer" name="java.lang.String getPageText(java.lang.String, java.util.Map, boolean)" map="A"/>
  <method class="tourma.utils.web.WebServer" name="java.lang.String createStyles(java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="tourma.utils.web.WebServer" name="fi.iki.elonen.NanoHTTPD$Response serve(fi.iki.elonen.NanoHTTPD$IHTTPSession)" map="A"/>
  <method class="tourma.utils.web.WebServer" name="java.util.ArrayList getWebSiteFiles()" map="J"/>
  <method class="tourma.utils.web.WebServer" name="java.io.File getWebpageFile(java.lang.String, java.lang.String, java.io.File)" map="A"/>
  <class name="tourma.utils.web.WebRound" map="G"/>
  <field class="tourma.utils.web.WebRound" name="LOG" map="A"/>
  <method class="tourma.utils.web.WebRound" name="java.lang.String createClanRanking(tourma.data.Round)" map="A"/>
  <method class="tourma.utils.web.WebRound" name="java.lang.String createIndividualMatch(tourma.data.Round)" map="B"/>
  <method class="tourma.utils.web.WebRound" name="java.lang.String getMenu(int, boolean)" map="A"/>
  <method class="tourma.utils.web.WebRound" name="java.lang.String createGroupRanking(tourma.data.Round, tourma.data.Group)" map="A"/>
  <method class="tourma.utils.web.WebRound" name="java.lang.String createIndividualRanking(tourma.data.Round)" map="C"/>
  <method class="tourma.utils.web.WebRound" name="java.lang.String createTeamMatchs(tourma.data.Round)" map="D"/>
  <method class="tourma.utils.web.WebRound" name="java.lang.String createClanCriteria(tourma.data.Round, tourma.data.Criteria)" map="A"/>
  <method class="tourma.utils.web.WebRound" name="java.lang.String createPoolRanking(tourma.data.Round, tourma.data.Pool)" map="A"/>
  <method class="tourma.utils.web.WebRound" name="java.lang.String createIndividualRanking(tourma.data.Round, java.util.ArrayList, java.lang.String)" map="A"/>
  <method class="tourma.utils.web.WebRound" name="java.lang.String createTeamRanking(tourma.data.Round, java.util.ArrayList, java.lang.String)" map="B"/>
  <method class="tourma.utils.web.WebRound" name="java.lang.String createTeamRanking(tourma.data.Round)" map="E"/>
  <method class="tourma.utils.web.WebRound" name="java.lang.String createIndividualCriteria(tourma.data.Round, tourma.data.Criteria)" map="B"/>
  <method class="tourma.utils.web.WebRound" name="java.lang.String createCategoryRanking(tourma.data.Round, tourma.data.Category)" map="A"/>
  <method class="tourma.utils.web.WebRound" name="java.lang.String createTeamCriteria(tourma.data.Round, tourma.data.Criteria)" map="C"/>
  <method class="tourma.utils.web.WebRound" name="java.lang.String getHTML(int, java.lang.String)" map="A"/>
  <package name="tourma.utils.display" map="B"/>
  <class name="tourma.utils.display.TableFormat" map="A"/>
  <method class="tourma.utils.display.TableFormat" name="void setColumnSize(javax.swing.JTable)" map="A"/>
  <class name="tourma.utils.display.TMultiServer" map="B"/>
  <field class="tourma.utils.display.TMultiServer" name="_port" map="A"/>
  <field class="tourma.utils.display.TMultiServer" name="stop" map="B"/>
  <field class="tourma.utils.display.TMultiServer" name="serverSocket" map="C"/>
  <field class="tourma.utils.display.TMultiServer" name="threads" map="D"/>
  <method class="tourma.utils.display.TMultiServer" name="void run()" map="run"/>
  <method class="tourma.utils.display.TMultiServer" name="void stopServer()" map="A"/>
  <class name="tourma.utils.display.TourmaProtocol$TKey" map="_A"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="POOL_TEAM_ANNEX" map="A"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="INDIVIDUAL_RANK" map="B"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="TEAM_RANK" map="C"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="POOL_INDIV_RANK" map="D"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="CATEGORY_RANK" map="E"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="END" map="F"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="GROUP_ANNEX" map="G"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="CLAN_ANNEX" map="H"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="TEAM_ANNEX" map="I"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="CATEGORY_ANNEX" map="J"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="CLAN_RANK" map="K"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="MATCHS" map="L"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="$VALUES" map="M"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="POOL_TEAM_RANK" map="N"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="INDIVIDUAL_ANNEX" map="O"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="GROUP_RANK" map="P"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="POOL_INDIV_ANNEX" map="Q"/>
  <field class="tourma.utils.display.TourmaProtocol$TKey" name="UNKNOWN" map="R"/>
  <method class="tourma.utils.display.TourmaProtocol$TKey" name="tourma.utils.display.TourmaProtocol$TKey valueOf(java.lang.String)" map="valueOf"/>
  <method class="tourma.utils.display.TourmaProtocol$TKey" name="tourma.utils.display.TourmaProtocol$TKey[] values()" map="values"/>
  <class name="tourma.utils.display.TourmaProtocol$1" map="1"/>
  <field class="tourma.utils.display.TourmaProtocol$1" name="$SwitchMap$tourma$utils$display$TourmaProtocol$TKey" map="A"/>
  <class name="tourma.utils.display.TourmaProtocol" map="C"/>
  <method class="tourma.utils.display.TourmaProtocol" name="tourma.utils.display.TourmaProtocol$TKey getKey(java.lang.String)" map="A"/>
  <method class="tourma.utils.display.TourmaProtocol" name="java.lang.String processInput(java.lang.Object)" map="A"/>
  <class name="tourma.utils.display.IRanked" map="D"/>
  <method class="tourma.utils.display.IRanked" name="int getSortedValue(int, int)" map="A"/>
  <method class="tourma.utils.display.IRanked" name="tourma.data.ObjectRanking getSortedObject(int)" map="w"/>
  <method class="tourma.utils.display.IRanked" name="java.lang.String getDetail()" map="&#x0118;"/>
  <method class="tourma.utils.display.IRanked" name="int getRowCount()" map="getRowCount"/>
  <class name="tourma.utils.display.TServerThread" map="E"/>
  <field class="tourma.utils.display.TServerThread" name="LOG" map="A"/>
  <field class="tourma.utils.display.TServerThread" name="_socket" map="B"/>
  <method class="tourma.utils.display.TServerThread" name="java.net.Socket getSocket()" map="A"/>
  <method class="tourma.utils.display.TServerThread" name="void run()" map="run"/>
  <class name="tourma.utils.NAF" map="A"/>
  <field class="tourma.utils.NAF" name="LOG" map="A"/>
  <field class="tourma.utils.NAF" name="_sIgnoreCaps" map="B"/>
  <field class="tourma.utils.NAF" name="_singleton" map="C"/>
  <field class="tourma.utils.NAF" name="coachs" map="D"/>
  <method class="tourma.utils.NAF" name="double getRanking(java.net.URL, tourma.data.Coach)" map="A"/>
  <method class="tourma.utils.NAF" name="boolean netIsAvailable()" map="A"/>
  <method class="tourma.utils.NAF" name="tourma.utils.NAFCoach getCoachByName(java.lang.String)" map="A"/>
  <method class="tourma.utils.NAF" name="void setIgnoreCaps(boolean)" map="A"/>
  <method class="tourma.utils.NAF" name="void initCoachs(java.io.File)" map="A"/>
  <method class="tourma.utils.NAF" name="java.util.ArrayList getNameProposals(java.lang.String)" map="B"/>
  <method class="tourma.utils.NAF" name="float getDistance(java.lang.String, java.lang.String)" map="A"/>
  <method class="tourma.utils.NAF" name="java.util.ArrayList getFileList()" map="B"/>
  <method class="tourma.utils.NAF" name="void updateCoachID(tourma.data.Coach)" map="A"/>
  <method class="tourma.utils.NAF" name="double getRanking(java.lang.String, tourma.data.Coach)" map="A"/>
  <class name="tourma.utils.NAFCoach" map="B"/>
  <field class="tourma.utils.NAFCoach" name="name" map="A"/>
  <field class="tourma.utils.NAFCoach" name="id" map="B"/>
  <method class="tourma.utils.NAFCoach" name="void setId(int)" map="A"/>
  <method class="tourma.utils.NAFCoach" name="void setName(java.lang.String)" map="A"/>
  <method class="tourma.utils.NAFCoach" name="java.lang.String getName()" map="A"/>
  <method class="tourma.utils.NAFCoach" name="int getId()" map="B"/>
  <class name="tourma.utils.Generation$CATEGORY_DRAW" map="_A"/>
  <field class="tourma.utils.Generation$CATEGORY_DRAW" name="$VALUES" map="A"/>
  <field class="tourma.utils.Generation$CATEGORY_DRAW" name="ABSOLUTE_ORDER" map="B"/>
  <field class="tourma.utils.Generation$CATEGORY_DRAW" name="NO_MIX" map="C"/>
  <field class="tourma.utils.Generation$CATEGORY_DRAW" name="MIX_ALL" map="D"/>
  <field class="tourma.utils.Generation$CATEGORY_DRAW" name="CATEGORY_RANKING" map="E"/>
  <method class="tourma.utils.Generation$CATEGORY_DRAW" name="tourma.utils.Generation$CATEGORY_DRAW[] values()" map="values"/>
  <method class="tourma.utils.Generation$CATEGORY_DRAW" name="tourma.utils.Generation$CATEGORY_DRAW valueOf(java.lang.String)" map="valueOf"/>
  <class name="tourma.utils.Generation$1" map="1"/>
  <field class="tourma.utils.Generation$1" name="$SwitchMap$tourma$data$EIndivPairing" map="A"/>
  <field class="tourma.utils.Generation$1" name="$SwitchMap$tourma$data$Cup$INITIAL_DRAW" map="B"/>
  <class name="tourma.utils.Generation" map="C"/>
  <field class="tourma.utils.Generation" name="mPortugueses" map="A"/>
  <method class="tourma.utils.Generation" name="tourma.data.Round genSwiss(java.util.ArrayList, tourma.tableModel.MjtRanking, tourma.data.Round, boolean)" map="A"/>
  <method class="tourma.utils.Generation" name="tourma.data.Round genQSwiss(java.util.ArrayList, tourma.tableModel.MjtRanking, tourma.data.Round)" map="A"/>
  <method class="tourma.utils.Generation" name="tourma.data.Round nextRoundQSwiss(tourma.data.Round, int)" map="A"/>
  <method class="tourma.utils.Generation" name="void finalGenerationStep(tourma.data.Round, tourma.data.Round)" map="A"/>
  <method class="tourma.utils.Generation" name="java.util.ArrayList subRanking(tourma.data.Team, java.util.ArrayList, boolean)" map="A"/>
  <method class="tourma.utils.Generation" name="void nextRound(tourma.data.Round, int, int)" map="A"/>
  <method class="tourma.utils.Generation" name="void applyPortugal(tourma.data.Round)" map="A"/>
  <method class="tourma.utils.Generation" name="tourma.data.Round nextRoundSwiss(tourma.data.Round, int, boolean)" map="A"/>
  <method class="tourma.utils.Generation" name="tourma.data.Round genSwiss(java.util.ArrayList, java.util.ArrayList, tourma.data.Round, boolean)" map="A"/>
  <method class="tourma.utils.Generation" name="void set3TeamsMatches(tourma.data.Team, tourma.data.Team, tourma.data.Team, tourma.data.Round)" map="A"/>
  <method class="tourma.utils.Generation" name="void generateFirstRoundRobin(java.util.ArrayList)" map="A"/>
  <method class="tourma.utils.Generation" name="java.util.ArrayList subRanking(java.util.ArrayList, java.util.ArrayList, boolean)" map="A"/>
  <method class="tourma.utils.Generation" name="void genCup(tourma.data.Round, tourma.data.Round)" map="B"/>
  <method class="tourma.utils.Generation" name="void genBalanced(java.util.ArrayList, tourma.data.Round)" map="A"/>
  <method class="tourma.utils.Generation" name="void generateFirstRoundCup(java.util.ArrayList)" map="B"/>
  <method class="tourma.utils.Generation" name="void generateFirstRoundPool(java.util.ArrayList)" map="C"/>
  <method class="tourma.utils.Generation" name="tourma.data.Round nextRoundCup(tourma.data.Round, int)" map="B"/>
  <method class="tourma.utils.Generation" name="void generateFirstRoundOrder(java.util.ArrayList, boolean, boolean)" map="A"/>
  <method class="tourma.utils.Generation" name="tourma.tableModel.MjtRanking getSortedRankingData(int)" map="A"/>
  <method class="tourma.utils.Generation" name="tourma.tableModel.MjtRanking getSortedRankingDataCategories(int, java.util.List, tourma.utils.Generation$CATEGORY_DRAW, int)" map="A"/>
  <method class="tourma.utils.Generation" name="void generateFirstRoundManual(java.util.ArrayList)" map="D"/>
  <method class="tourma.utils.Generation" name="void generateFirstRoundFree()" map="A"/>
  <method class="tourma.utils.Generation" name="void generateFirstRound(int)" map="B"/>
  <method class="tourma.utils.Generation" name="tourma.tableModel.MjtRanking getSortedRankingData(tourma.data.Pool, int)" map="A"/>
  <method class="tourma.utils.Generation" name="void genCupFirst(tourma.data.Round, tourma.tableModel.MjtRanking, int)" map="A"/>
  <method class="tourma.utils.Generation" name="tourma.data.Round genRandom(java.util.ArrayList, tourma.data.Round)" map="B"/>
  <method class="tourma.utils.Generation" name="void setHalfTeamMatch(int, tourma.data.Team, tourma.data.Team, java.util.ArrayList, java.util.ArrayList, tourma.data.Round)" map="A"/>
  <method class="tourma.utils.Generation" name="tourma.data.Round nextRoundRandom(tourma.data.Round)" map="B"/>
  <method class="tourma.utils.Generation" name="void setManualHalfTeamMatch(int, tourma.data.Team, tourma.data.Team, java.util.ArrayList, java.util.ArrayList, tourma.data.Round)" map="B"/>
  <method class="tourma.utils.Generation" name="tourma.data.Round nextRoundFree()" map="B"/>
  <method class="tourma.utils.Generation" name="void buildUntilRound(tourma.data.Round, java.util.ArrayList, java.util.ArrayList)" map="A"/>
  <method class="tourma.utils.Generation" name="tourma.data.Round nextRoundBalanced()" map="C"/>
  <method class="tourma.utils.Generation" name="void saveTemporaryTournament()" map="D"/>
  <class name="tourma.utils.NafTask" map="D"/>
  <field class="tourma.utils.NafTask" name="_jpn" map="A"/>
  <field class="tourma.utils.NafTask" name="_progressMonitor" map="B"/>
  <method class="tourma.utils.NafTask" name="void done()" map="done"/>
  <method class="tourma.utils.NafTask" name="java.lang.Void doInBackground()" map="A"/>
  <method class="tourma.utils.NafTask" name="java.lang.Object doInBackground()" map="doInBackground"/>
  <class name="tourma.utils.ImageTreatment" map="E"/>
  <method class="tourma.utils.ImageTreatment" name="javax.swing.ImageIcon resize(javax.swing.ImageIcon, int, int)" map="A"/>
  <class name="tourma.utils.Icons" map="F"/>
  <field class="tourma.utils.Icons" name="sPARAMS" map="A"/>
  <field class="tourma.utils.Icons" name="sDICES" map="B"/>
  <field class="tourma.utils.Icons" name="sSTAT" map="C"/>
  <field class="tourma.utils.Icons" name="sSTAR" map="D"/>
  <method class="tourma.utils.Icons" name="javax.swing.ImageIcon getStar()" map="A"/>
  <method class="tourma.utils.Icons" name="javax.swing.ImageIcon getStats()" map="B"/>
  <method class="tourma.utils.Icons" name="javax.swing.ImageIcon getParams()" map="C"/>
  <method class="tourma.utils.Icons" name="javax.swing.ImageIcon getDices()" map="D"/>
  <package name="tourma.utility" map="C"/>
  <class name="tourma.utility.TimerTaskSleep" map="A"/>
  <field class="tourma.utility.TimerTaskSleep" name="thread" map="A"/>
  <field class="tourma.utility.TimerTaskSleep" name="timer" map="B"/>
  <method class="tourma.utility.TimerTaskSleep" name="void run()" map="run"/>
  <method class="tourma.utility.TimerTaskSleep" name="void setTimer(java.util.Timer)" map="A"/>
  <class name="tourma.utility.Pair" map="B"/>
  <field class="tourma.utility.Pair" name="LOG" map="A"/>
  <field class="tourma.utility.Pair" name="second" map="B"/>
  <field class="tourma.utility.Pair" name="first" map="C"/>
  <method class="tourma.utility.Pair" name="java.lang.Object getFirst()" map="A"/>
  <method class="tourma.utility.Pair" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.utility.Pair" name="java.lang.Object getSecond()" map="B"/>
  <method class="tourma.utility.Pair" name="int hashCode()" map="hashCode"/>
  <method class="tourma.utility.Pair" name="java.lang.String toString()" map="toString"/>
  <class name="tourma.utility.ExtensionFileFilter" map="C"/>
  <field class="tourma.utility.ExtensionFileFilter" name="extensions" map="A"/>
  <field class="tourma.utility.ExtensionFileFilter" name="description" map="B"/>
  <method class="tourma.utility.ExtensionFileFilter" name="boolean accept(java.io.File)" map="accept"/>
  <method class="tourma.utility.ExtensionFileFilter" name="java.lang.String getDescription()" map="getDescription"/>
  <method class="tourma.utility.ExtensionFileFilter" name="void toLower(java.lang.String[])" map="A"/>
  <class name="tourma.utility.Version" map="D"/>
  <field class="tourma.utility.Version" name="LOG" map="A"/>
  <field class="tourma.utility.Version" name="myLock" map="B"/>
  <field class="tourma.utility.Version" name="mSingleton" map="C"/>
  <field class="tourma.utility.Version" name="mData" map="D"/>
  <method class="tourma.utility.Version" name="java.lang.String getProperty(java.lang.String)" map="A"/>
  <method class="tourma.utility.Version" name="tourma.utility.Version getSingleton()" map="A"/>
  <class name="tourma.utility.Suspendable" map="E"/>
  <method class="tourma.utility.Suspendable" name="void setSuspended(boolean)" map="A"/>
  <class name="tourma.utility.Sleeping" map="F"/>
  <field class="tourma.utility.Sleeping" name="t" map="A"/>
  <field class="tourma.utility.Sleeping" name="timer" map="B"/>
  <method class="tourma.utility.Sleeping" name="void sleep(long, int)" map="A"/>
  <package name="tourma.data" map="D"/>
  <class name="tourma.data.Coach" map="A"/>
  <field class="tourma.data.Coach" name="LOG_BALANCED_EMPTY" map="p"/>
  <field class="tourma.data.Coach" name="mRoster" map="q"/>
  <field class="tourma.data.Coach" name="myLock" map="r"/>
  <field class="tourma.data.Coach" name="mNafRankAvg" map="s"/>
  <field class="tourma.data.Coach" name="mNafRank" map="t"/>
  <field class="tourma.data.Coach" name="mActive" map="u"/>
  <field class="tourma.data.Coach" name="mNaf" map="v"/>
  <field class="tourma.data.Coach" name="sNullCoach" map="w"/>
  <field class="tourma.data.Coach" name="mRank" map="x"/>
  <field class="tourma.data.Coach" name="mHandicap" map="y"/>
  <field class="tourma.data.Coach" name="mTeam" map="z"/>
  <field class="tourma.data.Coach" name="LOG" map="&#x00a2;"/>
  <field class="tourma.data.Coach" name="UID" map="&#x00a3;"/>
  <field class="tourma.data.Coach" name="mTeamMates" map="&#x00a4;"/>
  <field class="tourma.data.Coach" name="mCompositions" map="&#x00a5;"/>
  <field class="tourma.data.Coach" name="sGenUID" map="&#x00aa;"/>
  <field class="tourma.data.Coach" name="sCoachMap" map="&#x00b5;"/>
  <field class="tourma.data.Coach" name="_PinCode" map="&#x00ba;"/>
  <field class="tourma.data.Coach" name="LOG_INDIV_EMPTY" map="&#x00c0;"/>
  <method class="tourma.data.Coach" name="java.util.ArrayList getPossibleOpponents(java.util.ArrayList, tourma.data.Round)" map="A"/>
  <method class="tourma.data.Coach" name="void setNaf(int)" map="P"/>
  <method class="tourma.data.Coach" name="void newCoachMap()" map="w"/>
  <method class="tourma.data.Coach" name="tourma.data.RosterType getRoster()" map="x"/>
  <method class="tourma.data.Coach" name="int getMinimumFromHash(java.util.HashMap)" map="A"/>
  <method class="tourma.data.Coach" name="void setTeamMates(tourma.data.Team)" map="F"/>
  <method class="tourma.data.Coach" name="void removeComposition(int)" map="Q"/>
  <method class="tourma.data.Coach" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <method class="tourma.data.Coach" name="int getUID()" map="y"/>
  <method class="tourma.data.Coach" name="boolean isBalanced(tourma.data.Team, tourma.data.Round)" map="C"/>
  <method class="tourma.data.Coach" name="double getNafRank()" map="z"/>
  <method class="tourma.data.Coach" name="void roundCheck(tourma.data.Round)" map="A"/>
  <method class="tourma.data.Coach" name="void setNafRank(double)" map="A"/>
  <method class="tourma.data.Coach" name="java.lang.String getMatchRoster(int)" map="R"/>
  <method class="tourma.data.Coach" name="void setNafAvg(double)" map="B"/>
  <method class="tourma.data.Coach" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.Coach" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.Coach" name="void addMatch(tourma.data.Competitor, tourma.data.Round)" map="A"/>
  <method class="tourma.data.Coach" name="void addComposition(teamma.data.Roster)" map="A"/>
  <method class="tourma.data.Coach" name="void setRank(int)" map="S"/>
  <method class="tourma.data.Coach" name="void putCoach(java.lang.String, tourma.data.Coach)" map="A"/>
  <method class="tourma.data.Coach" name="void setHandicap(int)" map="T"/>
  <method class="tourma.data.Coach" name="int getCompositionCount()" map="&#x00a2;"/>
  <method class="tourma.data.Coach" name="void setTeam(java.lang.String)" map="K"/>
  <method class="tourma.data.Coach" name="tourma.data.Team getTeamMates()" map="&#x00a3;"/>
  <method class="tourma.data.Coach" name="void push(tourma.data.Coach)" map="F"/>
  <method class="tourma.data.Coach" name="java.util.ArrayList getPossibleTeams(tourma.data.Round, tourma.data.Coach)" map="A"/>
  <method class="tourma.data.Coach" name="boolean canMatch(tourma.data.Coach, tourma.data.Coach, tourma.data.Coach, tourma.data.Round)" map="A"/>
  <method class="tourma.data.Coach" name="void setActive(boolean)" map="K"/>
  <method class="tourma.data.Coach" name="int getHandicap()" map="&#x00a4;"/>
  <method class="tourma.data.Coach" name="void addMatchRoundRobin(tourma.data.Competitor, tourma.data.Round, boolean)" map="A"/>
  <method class="tourma.data.Coach" name="int getRank()" map="&#x00a5;"/>
  <method class="tourma.data.Coach" name="java.lang.String getTeam()" map="&#x00aa;"/>
  <method class="tourma.data.Coach" name="java.util.HashMap getTeamOppositionCount(java.util.ArrayList, tourma.data.Round)" map="C"/>
  <method class="tourma.data.Coach" name="void setRoster(tourma.data.RosterType)" map="A"/>
  <method class="tourma.data.Coach" name="java.lang.String getStringRoster()" map="&#x00b5;"/>
  <method class="tourma.data.Coach" name="boolean isActive()" map="&#x00ba;"/>
  <method class="tourma.data.Coach" name="boolean havePlayed(tourma.data.Competitor)" map="C"/>
  <method class="tourma.data.Coach" name="teamma.data.Roster getComposition(int)" map="U"/>
  <method class="tourma.data.Coach" name="double getNafRankAvg()" map="&#x00c0;"/>
  <method class="tourma.data.Coach" name="int getNaf()" map="&#x00c1;"/>
  <method class="tourma.data.Coach" name="tourma.data.Coach getCoach(java.lang.String)" map="L"/>
  <method class="tourma.data.Coach" name="void pull(tourma.data.Coach)" map="G"/>
  <method class="tourma.data.Coach" name="void setPinCode(int)" map="V"/>
  <method class="tourma.data.Coach" name="java.lang.String getDecoratedName()" map="O"/>
  <method class="tourma.data.Coach" name="tourma.data.Coach getNullCoach()" map="&#x00c2;"/>
  <method class="tourma.data.Coach" name="boolean isBalanced(tourma.data.Coach, tourma.data.Round)" map="A"/>
  <method class="tourma.data.Coach" name="tourma.data.CoachMatch createMatch(tourma.data.Competitor, tourma.data.Round)" map="B"/>
  <method class="tourma.data.Coach" name="int getPinCode()" map="&#x00c3;"/>
  <class name="tourma.data.Team$1" map="1"/>
  <field class="tourma.data.Team$1" name="$SwitchMap$tourma$data$EIndivPairing" map="A"/>
  <class name="tourma.data.Team" map="B"/>
  <field class="tourma.data.Team" name="UID" map="i"/>
  <field class="tourma.data.Team" name="LOG" map="j"/>
  <field class="tourma.data.Team" name="sTeamMap" map="k"/>
  <field class="tourma.data.Team" name="mCoachs" map="l"/>
  <field class="tourma.data.Team" name="myLock" map="m"/>
  <field class="tourma.data.Team" name="sGenUID" map="n"/>
  <field class="tourma.data.Team" name="sNullTeam" map="o"/>
  <method class="tourma.data.Team" name="java.lang.String getDecoratedName()" map="O"/>
  <method class="tourma.data.Team" name="void putTeam(java.lang.String, tourma.data.Team)" map="A"/>
  <method class="tourma.data.Team" name="void newTeamMap()" map="p"/>
  <method class="tourma.data.Team" name="void pull(tourma.data.Team)" map="D"/>
  <method class="tourma.data.Team" name="java.util.HashMap getTeamOppositionCount(java.util.ArrayList, tourma.data.Round)" map="B"/>
  <method class="tourma.data.Team" name="org.jdom.Element getXMLElementForDisplay()" map="q"/>
  <method class="tourma.data.Team" name="void removeCoach(int)" map="O"/>
  <method class="tourma.data.Team" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.Team" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.Team" name="boolean containsCoach(tourma.data.Coach)" map="D"/>
  <method class="tourma.data.Team" name="boolean canPlay(tourma.data.Team, tourma.data.Round)" map="A"/>
  <method class="tourma.data.Team" name="void addMatch(tourma.data.Competitor, tourma.data.Round)" map="A"/>
  <method class="tourma.data.Team" name="void addMatchRoundRobin(tourma.data.Competitor, tourma.data.Round, boolean)" map="A"/>
  <method class="tourma.data.Team" name="int hashCode()" map="hashCode"/>
  <method class="tourma.data.Team" name="tourma.data.Coach getCoach(int)" map="C"/>
  <method class="tourma.data.Team" name="java.lang.String getName()" map="C"/>
  <method class="tourma.data.Team" name="void clearCoachs()" map="r"/>
  <method class="tourma.data.Team" name="void roundCheck(tourma.data.Round)" map="A"/>
  <method class="tourma.data.Team" name="tourma.data.Team getNullTeam()" map="s"/>
  <method class="tourma.data.Team" name="java.util.ArrayList getActivePlayers()" map="t"/>
  <method class="tourma.data.Team" name="java.util.ArrayList getPossibleOpponents(java.util.ArrayList, tourma.data.Round)" map="A"/>
  <method class="tourma.data.Team" name="int getActivePlayerNumber()" map="u"/>
  <method class="tourma.data.Team" name="tourma.data.Team getTeam(java.lang.String)" map="J"/>
  <method class="tourma.data.Team" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <method class="tourma.data.Team" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.Team" name="boolean havePlayed(tourma.data.Competitor)" map="C"/>
  <method class="tourma.data.Team" name="int getCoachsCount()" map="Q"/>
  <method class="tourma.data.Team" name="void push(tourma.data.Team)" map="E"/>
  <method class="tourma.data.Team" name="boolean isBalanced(tourma.data.Team, tourma.data.Round)" map="B"/>
  <method class="tourma.data.Team" name="void addCoach(tourma.data.Coach)" map="E"/>
  <method class="tourma.data.Team" name="int getUID()" map="v"/>
  <class name="tourma.data.ITournament" map="C"/>
  <method class="tourma.data.ITournament" name="java.util.HashMap getRosterTypes()" map="A"/>
  <method class="tourma.data.ITournament" name="tourma.data.Tournament getTournament()" map="B"/>
  <method class="tourma.data.ITournament" name="void setTournament(tourma.data.Tournament)" map="A"/>
  <class name="tourma.data.ETeamPairing" map="D"/>
  <field class="tourma.data.ETeamPairing" name="INDIVIDUAL_PAIRING" map="A"/>
  <field class="tourma.data.ETeamPairing" name="$VALUES" map="B"/>
  <field class="tourma.data.ETeamPairing" name="TEAM_PAIRING" map="C"/>
  <method class="tourma.data.ETeamPairing" name="tourma.data.ETeamPairing valueOf(java.lang.String)" map="valueOf"/>
  <method class="tourma.data.ETeamPairing" name="tourma.data.ETeamPairing[] values()" map="values"/>
  <class name="tourma.data.Substitute" map="E"/>
  <field class="tourma.data.Substitute" name="mMatch" map="&#x00c1;"/>
  <field class="tourma.data.Substitute" name="UID" map="&#x00c2;"/>
  <field class="tourma.data.Substitute" name="LOG" map="&#x00c3;"/>
  <field class="tourma.data.Substitute" name="sGenUID" map="&#x00c4;"/>
  <field class="tourma.data.Substitute" name="mSubstitute" map="&#x00c5;"/>
  <field class="tourma.data.Substitute" name="mTitular" map="&#x00c6;"/>
  <method class="tourma.data.Substitute" name="void setTitular(tourma.data.Coach)" map="H"/>
  <method class="tourma.data.Substitute" name="tourma.data.Coach getSubstitute()" map="&#x00c4;"/>
  <method class="tourma.data.Substitute" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.Substitute" name="void setSubstitute(tourma.data.Coach)" map="I"/>
  <method class="tourma.data.Substitute" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.Substitute" name="tourma.data.Coach getTitular()" map="&#x00c5;"/>
  <method class="tourma.data.Substitute" name="void setMatch(tourma.data.CoachMatch)" map="A"/>
  <method class="tourma.data.Substitute" name="org.jdom.Element getXMLElement()" map="A"/>
  <class name="tourma.data.Round" map="F"/>
  <field class="tourma.data.Round" name="UID" map="&#x00c7;"/>
  <field class="tourma.data.Round" name="mHour" map="&#x00c8;"/>
  <field class="tourma.data.Round" name="mCupMaxTour" map="&#x00c9;"/>
  <field class="tourma.data.Round" name="mMaxBonus" map="&#x00ca;"/>
  <field class="tourma.data.Round" name="mCupTour" map="&#x00cb;"/>
  <field class="tourma.data.Round" name="updated" map="&#x00cc;"/>
  <field class="tourma.data.Round" name="mMatchs" map="&#x00cd;"/>
  <field class="tourma.data.Round" name="mMinBonus" map="&#x00ce;"/>
  <field class="tourma.data.Round" name="mCup" map="&#x00cf;"/>
  <field class="tourma.data.Round" name="sGenUID" map="&#x00d0;"/>
  <field class="tourma.data.Round" name="LOG" map="&#x00d1;"/>
  <method class="tourma.data.Round" name="void removeMatch(tourma.data.Match)" map="E"/>
  <method class="tourma.data.Round" name="void addMatch(tourma.data.Match)" map="F"/>
  <method class="tourma.data.Round" name="boolean isCup()" map="&#x00c6;"/>
  <method class="tourma.data.Round" name="int getUID()" map="&#x00c7;"/>
  <method class="tourma.data.Round" name="void setCupTour(int)" map="W"/>
  <method class="tourma.data.Round" name="tourma.data.Match getMatch(int)" map="X"/>
  <method class="tourma.data.Round" name="void setMatchPosition(tourma.data.Match, int)" map="A"/>
  <method class="tourma.data.Round" name="boolean allMatchesEntered()" map="&#x00c8;"/>
  <method class="tourma.data.Round" name="int getCupTour()" map="&#x00c9;"/>
  <method class="tourma.data.Round" name="java.util.Date getHour()" map="&#x00ca;"/>
  <method class="tourma.data.Round" name="int getMatchsCount()" map="&#x00cb;"/>
  <method class="tourma.data.Round" name="void setMaxBonus(double)" map="C"/>
  <method class="tourma.data.Round" name="double getCoef(tourma.data.Match)" map="G"/>
  <method class="tourma.data.Round" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.Round" name="org.jdom.Element getXMLElementForDisplay()" map="&#x00cc;"/>
  <method class="tourma.data.Round" name="double getMinBonus()" map="&#x00cd;"/>
  <method class="tourma.data.Round" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.Round" name="void push(tourma.data.Round)" map="E"/>
  <method class="tourma.data.Round" name="java.util.ArrayList getCoachMatchs()" map="&#x00ce;"/>
  <method class="tourma.data.Round" name="int getCupMaxTour()" map="&#x00cf;"/>
  <method class="tourma.data.Round" name="int indexOf(tourma.data.Match)" map="H"/>
  <method class="tourma.data.Round" name="void setUpdated(boolean)" map="L"/>
  <method class="tourma.data.Round" name="void setCupMaxTour(int)" map="Y"/>
  <method class="tourma.data.Round" name="java.lang.String toString()" map="toString"/>
  <method class="tourma.data.Round" name="boolean isUpdated()" map="&#x00d0;"/>
  <method class="tourma.data.Round" name="void setCup(boolean)" map="M"/>
  <method class="tourma.data.Round" name="void shuffleMatchs()" map="&#x00d1;"/>
  <method class="tourma.data.Round" name="boolean containsMatch(tourma.data.Match)" map="I"/>
  <method class="tourma.data.Round" name="void setMinBonus(double)" map="D"/>
  <method class="tourma.data.Round" name="void pull(tourma.data.Round)" map="F"/>
  <method class="tourma.data.Round" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.Round" name="void recomputeMatchs()" map="&#x00d2;"/>
  <method class="tourma.data.Round" name="void clearMatchs()" map="&#x00d3;"/>
  <method class="tourma.data.Round" name="double getMaxBonus()" map="&#x00d4;"/>
  <method class="tourma.data.Round" name="void setCurrentHour()" map="&#x00d5;"/>
  <method class="tourma.data.Round" name="boolean containsCoachMatch(tourma.data.CoachMatch)" map="B"/>
  <class name="tourma.data.EIndivPairing" map="G"/>
  <field class="tourma.data.EIndivPairing" name="NAF" map="A"/>
  <field class="tourma.data.EIndivPairing" name="FREE" map="B"/>
  <field class="tourma.data.EIndivPairing" name="$VALUES" map="C"/>
  <field class="tourma.data.EIndivPairing" name="RANKING" map="D"/>
  <field class="tourma.data.EIndivPairing" name="RANDOM" map="E"/>
  <method class="tourma.data.EIndivPairing" name="tourma.data.EIndivPairing[] values()" map="values"/>
  <method class="tourma.data.EIndivPairing" name="tourma.data.EIndivPairing valueOf(java.lang.String)" map="valueOf"/>
  <class name="tourma.data.CoachMatch" map="H"/>
  <field class="tourma.data.CoachMatch" name="mSubstitute1" map="&#x0109;"/>
  <field class="tourma.data.CoachMatch" name="UID" map="&#x010a;"/>
  <field class="tourma.data.CoachMatch" name="refusedBy2" map="&#x010b;"/>
  <field class="tourma.data.CoachMatch" name="mValues" map="&#x010c;"/>
  <field class="tourma.data.CoachMatch" name="refusedBy1" map="&#x010d;"/>
  <field class="tourma.data.CoachMatch" name="mRoster2" map="&#x010e;"/>
  <field class="tourma.data.CoachMatch" name="mRoster1" map="&#x010f;"/>
  <field class="tourma.data.CoachMatch" name="sGenUID" map="&#x0110;"/>
  <field class="tourma.data.CoachMatch" name="remotely" map="&#x0111;"/>
  <field class="tourma.data.CoachMatch" name="concedeedBy2" map="&#x0112;"/>
  <field class="tourma.data.CoachMatch" name="mComputedValues" map="&#x0113;"/>
  <field class="tourma.data.CoachMatch" name="LOG" map="&#x0114;"/>
  <field class="tourma.data.CoachMatch" name="concedeedBy1" map="&#x0115;"/>
  <field class="tourma.data.CoachMatch" name="mSubstitute2" map="&#x0116;"/>
  <method class="tourma.data.CoachMatch" name="int getValueCount()" map="&#x0104;"/>
  <method class="tourma.data.CoachMatch" name="boolean isRemotely()" map="&#x0105;"/>
  <method class="tourma.data.CoachMatch" name="boolean isRefusedBy1()" map="&#x0106;"/>
  <method class="tourma.data.CoachMatch" name="void setSubstitute1(tourma.data.Substitute)" map="A"/>
  <method class="tourma.data.CoachMatch" name="int getUID()" map="&#x0103;"/>
  <method class="tourma.data.CoachMatch" name="int getCoachTablePoints(tourma.data.Coach, tourma.data.CoachMatch)" map="A"/>
  <method class="tourma.data.CoachMatch" name="void putValue(tourma.data.Formula, tourma.data.Value)" map="A"/>
  <method class="tourma.data.CoachMatch" name="void push(tourma.data.Match)" map="J"/>
  <method class="tourma.data.CoachMatch" name="int getCoachRosterGroups(tourma.data.Coach)" map="J"/>
  <method class="tourma.data.CoachMatch" name="void setRemotely(boolean)" map="Q"/>
  <method class="tourma.data.CoachMatch" name="int getCriteriaBonusPoints(tourma.data.Coach, tourma.data.CoachMatch, tourma.data.Criteria)" map="A"/>
  <method class="tourma.data.CoachMatch" name="void putValue(tourma.data.Criteria, tourma.data.Value)" map="A"/>
  <method class="tourma.data.CoachMatch" name="boolean isConcedeedBy2()" map="&#x0107;"/>
  <method class="tourma.data.CoachMatch" name="int getCriteriasBonusPoints(tourma.data.Coach, tourma.data.CoachMatch)" map="B"/>
  <method class="tourma.data.CoachMatch" name="int recomputeValue(int, tourma.data.Competitor)" map="B"/>
  <method class="tourma.data.CoachMatch" name="void resetWL()" map="&#x0100;"/>
  <method class="tourma.data.CoachMatch" name="int getVNDByCoach(tourma.data.Coach, tourma.data.CoachMatch)" map="C"/>
  <method class="tourma.data.CoachMatch" name="int getGroupModifier(tourma.data.Coach, tourma.data.CoachMatch)" map="D"/>
  <method class="tourma.data.CoachMatch" name="org.jdom.Element getXMLElementForDisplay()" map="&#x00f9;"/>
  <method class="tourma.data.CoachMatch" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.CoachMatch" name="void removeValue(tourma.data.Formula)" map="B"/>
  <method class="tourma.data.CoachMatch" name="void setRoster1(tourma.data.RosterType)" map="B"/>
  <method class="tourma.data.CoachMatch" name="void setSubstitute2(tourma.data.Substitute)" map="B"/>
  <method class="tourma.data.CoachMatch" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.CoachMatch" name="int hashCode()" map="hashCode"/>
  <method class="tourma.data.CoachMatch" name="void pull(tourma.data.Match)" map="K"/>
  <method class="tourma.data.CoachMatch" name="tourma.data.Value getValue(tourma.data.Criteria)" map="B"/>
  <method class="tourma.data.CoachMatch" name="void switchCoachs()" map="&#x0108;"/>
  <method class="tourma.data.CoachMatch" name="int getELOByCoach(tourma.data.Coach, tourma.data.CoachMatch)" map="E"/>
  <method class="tourma.data.CoachMatch" name="boolean isRefusedBy2()" map="&#x0109;"/>
  <method class="tourma.data.CoachMatch" name="void setConcedeedBy2(boolean)" map="R"/>
  <method class="tourma.data.CoachMatch" name="void setUpdated(boolean)" map="P"/>
  <method class="tourma.data.CoachMatch" name="boolean isFullNaf()" map="&#x010a;"/>
  <method class="tourma.data.CoachMatch" name="boolean isUpdated()" map="&#x00ff;"/>
  <method class="tourma.data.CoachMatch" name="tourma.data.Substitute getSubstitute1()" map="&#x010b;"/>
  <method class="tourma.data.CoachMatch" name="boolean isEntered()" map="&#x00fd;"/>
  <method class="tourma.data.CoachMatch" name="tourma.data.Competitor getWinner()" map="&#x00fa;"/>
  <method class="tourma.data.CoachMatch" name="void setRoster2(tourma.data.RosterType)" map="C"/>
  <method class="tourma.data.CoachMatch" name="int getValue(tourma.data.Criteria, int, tourma.data.Competitor)" map="A"/>
  <method class="tourma.data.CoachMatch" name="int getPointsByCoach(tourma.data.Coach, tourma.data.CoachMatch, boolean, boolean)" map="A"/>
  <method class="tourma.data.CoachMatch" name="void setRefusedBy2(boolean)" map="S"/>
  <method class="tourma.data.CoachMatch" name="int getValue(tourma.data.Formula, tourma.data.Competitor)" map="A"/>
  <method class="tourma.data.CoachMatch" name="int getValue(tourma.data.Coach, int)" map="A"/>
  <method class="tourma.data.CoachMatch" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.CoachMatch" name="void setConcedeedBy1(boolean)" map="T"/>
  <method class="tourma.data.CoachMatch" name="tourma.data.RosterType getRoster1()" map="&#x010c;"/>
  <method class="tourma.data.CoachMatch" name="void recomputeValues()" map="&#x00fe;"/>
  <method class="tourma.data.CoachMatch" name="tourma.data.Substitute getSubstitute2()" map="&#x010d;"/>
  <method class="tourma.data.CoachMatch" name="boolean isConcedeedBy1()" map="&#x010e;"/>
  <method class="tourma.data.CoachMatch" name="int getCoachNbMatchs(tourma.data.Coach, tourma.data.CoachMatch)" map="F"/>
  <method class="tourma.data.CoachMatch" name="int getOppPointsByCoach(tourma.data.Coach, tourma.data.CoachMatch, boolean)" map="A"/>
  <method class="tourma.data.CoachMatch" name="java.util.HashMap getValues()" map="&#x010f;"/>
  <method class="tourma.data.CoachMatch" name="int getOppELOByCoach(tourma.data.Coach, tourma.data.CoachMatch)" map="G"/>
  <method class="tourma.data.CoachMatch" name="tourma.data.Value getValue(tourma.data.Formula)" map="C"/>
  <method class="tourma.data.CoachMatch" name="tourma.data.Competitor getLooser()" map="&#x00fc;"/>
  <method class="tourma.data.CoachMatch" name="void setRefusedBy1(boolean)" map="U"/>
  <method class="tourma.data.CoachMatch" name="void removeValue(tourma.data.Criteria)" map="C"/>
  <method class="tourma.data.CoachMatch" name="tourma.data.RosterType getRoster2()" map="&#x0110;"/>
  <class name="tourma.data.IContainCoachs" map="I"/>
  <method class="tourma.data.IContainCoachs" name="int getCoachsCount()" map="Q"/>
  <method class="tourma.data.IContainCoachs" name="tourma.data.Coach getCoach(int)" map="C"/>
  <class name="tourma.data.Criteria" map="J"/>
  <field class="tourma.data.Criteria" name="mOffensiveBonusesByTeam" map="&#x00d2;"/>
  <field class="tourma.data.Criteria" name="mOffensiveThreshold" map="&#x00d3;"/>
  <field class="tourma.data.Criteria" name="mAccronym" map="&#x00d4;"/>
  <field class="tourma.data.Criteria" name="mCriticalValueThreshold" map="&#x00d5;"/>
  <field class="tourma.data.Criteria" name="mDefensiveDiffThresholdByTeam" map="&#x00d6;"/>
  <field class="tourma.data.Criteria" name="LOG" map="&#x00d8;"/>
  <field class="tourma.data.Criteria" name="UID" map="&#x00d9;"/>
  <field class="tourma.data.Criteria" name="mName" map="&#x00da;"/>
  <field class="tourma.data.Criteria" name="mPointsFor" map="&#x00db;"/>
  <field class="tourma.data.Criteria" name="mOffensiveDiffThresholdByTeam" map="&#x00dc;"/>
  <field class="tourma.data.Criteria" name="mOffensiveDiffBonuses" map="&#x00dd;"/>
  <field class="tourma.data.Criteria" name="mDefensiveDiffThreshold" map="&#x00de;"/>
  <field class="tourma.data.Criteria" name="mOffensiveDiffBonusesForTeam" map="&#x00df;"/>
  <field class="tourma.data.Criteria" name="mOffensiveDiffThreshold" map="&#x00e0;"/>
  <field class="tourma.data.Criteria" name="mOffensiveBonuses" map="&#x00e1;"/>
  <field class="tourma.data.Criteria" name="mOffensiveThresholdByTeam" map="&#x00e2;"/>
  <field class="tourma.data.Criteria" name="mOffensiveBonusesForTeam" map="&#x00e3;"/>
  <field class="tourma.data.Criteria" name="mDefensiveDiffBonusesByTeam" map="&#x00e4;"/>
  <field class="tourma.data.Criteria" name="sGenUID" map="&#x00e5;"/>
  <field class="tourma.data.Criteria" name="mPointsAgainst" map="&#x00e6;"/>
  <field class="tourma.data.Criteria" name="mPointsTeamAgainst" map="&#x00e7;"/>
  <field class="tourma.data.Criteria" name="mDefensiveDiffBonuses" map="&#x00e8;"/>
  <field class="tourma.data.Criteria" name="mOffensiveDiffBonusesByTeam" map="&#x00e9;"/>
  <field class="tourma.data.Criteria" name="mPointsTeamFor" map="&#x00ea;"/>
  <field class="tourma.data.Criteria" name="mDefensiveDiffBonusesForTeam" map="&#x00eb;"/>
  <method class="tourma.data.Criteria" name="int getOffensiveBonusesForTeam()" map="&#x00d6;"/>
  <method class="tourma.data.Criteria" name="void setPointsTeamAgainst(int)" map="Z"/>
  <method class="tourma.data.Criteria" name="void setDefensiveDiffThreshold(int)" map="_"/>
  <method class="tourma.data.Criteria" name="int getUID()" map="&#x00d8;"/>
  <method class="tourma.data.Criteria" name="int getOffensiveDiffThresholdByTeam()" map="&#x00d9;"/>
  <method class="tourma.data.Criteria" name="void setOffensiveBonusesForTeam(int)" map="a"/>
  <method class="tourma.data.Criteria" name="void setOffensiveDiffBonusesForTeam(int)" map="b"/>
  <method class="tourma.data.Criteria" name="int getDefensiveDiffBonusesByTeam()" map="&#x00da;"/>
  <method class="tourma.data.Criteria" name="int getPointsTeamAgainst()" map="&#x00db;"/>
  <method class="tourma.data.Criteria" name="int getDefensiveDiffBonuses()" map="&#x00dc;"/>
  <method class="tourma.data.Criteria" name="void setPointsTeamFor(int)" map="c"/>
  <method class="tourma.data.Criteria" name="void setOffensiveDiffBonuses(int)" map="d"/>
  <method class="tourma.data.Criteria" name="int getDefensiveDiffThresholdByTeam()" map="&#x00dd;"/>
  <method class="tourma.data.Criteria" name="void setDefensiveDiffBonusesForTeam(int)" map="e"/>
  <method class="tourma.data.Criteria" name="void setName(java.lang.String)" map="M"/>
  <method class="tourma.data.Criteria" name="int getOffensiveThreshold()" map="&#x00de;"/>
  <method class="tourma.data.Criteria" name="int getOffensiveDiffBonuses()" map="&#x00df;"/>
  <method class="tourma.data.Criteria" name="int getOffensiveThresholdByTeam()" map="&#x00e0;"/>
  <method class="tourma.data.Criteria" name="int getPointsFor()" map="&#x00e1;"/>
  <method class="tourma.data.Criteria" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.Criteria" name="void setOffensiveDiffThresholdByTeam(int)" map="f"/>
  <method class="tourma.data.Criteria" name="int getPointsTeamFor()" map="&#x00e2;"/>
  <method class="tourma.data.Criteria" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.Criteria" name="void setOffensiveDiffThreshold(int)" map="g"/>
  <method class="tourma.data.Criteria" name="int getCriticalThreshold()" map="&#x00e3;"/>
  <method class="tourma.data.Criteria" name="int getDefensiveDiffThreshold()" map="&#x00e4;"/>
  <method class="tourma.data.Criteria" name="int getDefensiveDiffBonusesForTeam()" map="&#x00e5;"/>
  <method class="tourma.data.Criteria" name="void setDefensiveDiffBonuses(int)" map="h"/>
  <method class="tourma.data.Criteria" name="void setOffensiveBonusesByTeam(int)" map="i"/>
  <method class="tourma.data.Criteria" name="int getOffensiveBonuses()" map="&#x00e6;"/>
  <method class="tourma.data.Criteria" name="java.lang.String getAccronym()" map="&#x00e7;"/>
  <method class="tourma.data.Criteria" name="void setDefensiveDiffBonusesByTeam(int)" map="j"/>
  <method class="tourma.data.Criteria" name="void setAccronym(java.lang.String)" map="N"/>
  <method class="tourma.data.Criteria" name="void setPointsAgainst(int)" map="k"/>
  <method class="tourma.data.Criteria" name="int getPointsAgainst()" map="&#x00e8;"/>
  <method class="tourma.data.Criteria" name="java.lang.String getName()" map="&#x00e9;"/>
  <method class="tourma.data.Criteria" name="int getOffensiveBonusesByTeam()" map="&#x00ea;"/>
  <method class="tourma.data.Criteria" name="void setOffensiveThreshold(int)" map="l"/>
  <method class="tourma.data.Criteria" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.Criteria" name="void setCriticalThreshold(int)" map="m"/>
  <method class="tourma.data.Criteria" name="int getOffensiveDiffBonusesForTeam()" map="&#x00eb;"/>
  <method class="tourma.data.Criteria" name="void setOffensiveThresholdByTeam(int)" map="n"/>
  <method class="tourma.data.Criteria" name="void setDefensiveDiffThresholdByTeam(int)" map="o"/>
  <method class="tourma.data.Criteria" name="int getOffensiveDiffBonusesByTeam()" map="&#x00ec;"/>
  <method class="tourma.data.Criteria" name="void setPointsFor(int)" map="p"/>
  <method class="tourma.data.Criteria" name="void setOffensiveDiffBonusesByTeam(int)" map="q"/>
  <method class="tourma.data.Criteria" name="void setOffensiveBonuses(int)" map="r"/>
  <method class="tourma.data.Criteria" name="int getOffensiveDiffThreshold()" map="&#x00ed;"/>
  <method class="tourma.data.Criteria" name="void pull(tourma.data.Criteria)" map="A"/>
  <class name="tourma.data.GroupPoints" map="K"/>
  <field class="tourma.data.GroupPoints" name="lossPoints" map="A"/>
  <field class="tourma.data.GroupPoints" name="UID" map="B"/>
  <field class="tourma.data.GroupPoints" name="sGenUID" map="C"/>
  <field class="tourma.data.GroupPoints" name="victoryPoints" map="D"/>
  <field class="tourma.data.GroupPoints" name="drawPoints" map="E"/>
  <method class="tourma.data.GroupPoints" name="void setLossPoints(int)" map="A"/>
  <method class="tourma.data.GroupPoints" name="int getLossPoints()" map="A"/>
  <method class="tourma.data.GroupPoints" name="int getDrawPoints()" map="B"/>
  <method class="tourma.data.GroupPoints" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.GroupPoints" name="void setDrawPoints(int)" map="B"/>
  <method class="tourma.data.GroupPoints" name="void setVictoryPoints(int)" map="C"/>
  <method class="tourma.data.GroupPoints" name="int getVictoryPoints()" map="C"/>
  <method class="tourma.data.GroupPoints" name="void pull(tourma.data.GroupPoints)" map="A"/>
  <class name="tourma.data.Clan" map="L"/>
  <field class="tourma.data.Clan" name="updated" map="A"/>
  <field class="tourma.data.Clan" name="UID" map="B"/>
  <field class="tourma.data.Clan" name="LOG" map="C"/>
  <field class="tourma.data.Clan" name="sGenUID" map="D"/>
  <field class="tourma.data.Clan" name="mName" map="E"/>
  <field class="tourma.data.Clan" name="picture" map="F"/>
  <field class="tourma.data.Clan" name="sClanMap" map="G"/>
  <method class="tourma.data.Clan" name="void newClanMap()" map="D"/>
  <method class="tourma.data.Clan" name="boolean isUpdated()" map="E"/>
  <method class="tourma.data.Clan" name="void pull(tourma.data.Clan)" map="A"/>
  <method class="tourma.data.Clan" name="void setName(java.lang.String)" map="A"/>
  <method class="tourma.data.Clan" name="int hashCode()" map="hashCode"/>
  <method class="tourma.data.Clan" name="javax.swing.ImageIcon getPicture()" map="B"/>
  <method class="tourma.data.Clan" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.Clan" name="void setUpdated(boolean)" map="A"/>
  <method class="tourma.data.Clan" name="void push(tourma.data.Clan)" map="B"/>
  <method class="tourma.data.Clan" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.Clan" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.Clan" name="void setPicture(javax.swing.ImageIcon)" map="A"/>
  <method class="tourma.data.Clan" name="int getUID()" map="F"/>
  <method class="tourma.data.Clan" name="java.lang.String getName()" map="C"/>
  <method class="tourma.data.Clan" name="tourma.data.Clan getClan(java.lang.String)" map="B"/>
  <method class="tourma.data.Clan" name="java.lang.String toString()" map="toString"/>
  <method class="tourma.data.Clan" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <class name="tourma.data.IXMLExport" map="M"/>
  <method class="tourma.data.IXMLExport" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.IXMLExport" name="org.jdom.Element getXMLElement()" map="A"/>
  <class name="tourma.data.Cup$ROUND_TYPE" map="_A"/>
  <field class="tourma.data.Cup$ROUND_TYPE" name="CLASSIC" map="A"/>
  <field class="tourma.data.Cup$ROUND_TYPE" name="$VALUES" map="B"/>
  <field class="tourma.data.Cup$ROUND_TYPE" name="RANKING_MATCHES" map="C"/>
  <field class="tourma.data.Cup$ROUND_TYPE" name="CLASSIC_THIRD" map="D"/>
  <field class="tourma.data.Cup$ROUND_TYPE" name="LOOSER" map="E"/>
  <method class="tourma.data.Cup$ROUND_TYPE" name="tourma.data.Cup$ROUND_TYPE valueOf(java.lang.String)" map="valueOf"/>
  <method class="tourma.data.Cup$ROUND_TYPE" name="tourma.data.Cup$ROUND_TYPE[] values()" map="values"/>
  <class name="tourma.data.Cup$1" map="1"/>
  <field class="tourma.data.Cup$1" name="$SwitchMap$tourma$data$Cup$INITIAL_DRAW" map="A"/>
  <field class="tourma.data.Cup$1" name="$SwitchMap$tourma$data$Cup$ROUND_TYPE" map="B"/>
  <class name="tourma.data.Cup$INITIAL_DRAW" map="_B"/>
  <field class="tourma.data.Cup$INITIAL_DRAW" name="CATEGORIES_MIXED" map="A"/>
  <field class="tourma.data.Cup$INITIAL_DRAW" name="MANUAL" map="B"/>
  <field class="tourma.data.Cup$INITIAL_DRAW" name="$VALUES" map="C"/>
  <field class="tourma.data.Cup$INITIAL_DRAW" name="RANKING" map="D"/>
  <field class="tourma.data.Cup$INITIAL_DRAW" name="CATEGORIES_NOT_MIXED" map="E"/>
  <field class="tourma.data.Cup$INITIAL_DRAW" name="RANDOM" map="F"/>
  <field class="tourma.data.Cup$INITIAL_DRAW" name="CATEGORIES_ABSOLUTE_RANKING" map="G"/>
  <field class="tourma.data.Cup$INITIAL_DRAW" name="CATEGORIES_CROSSED" map="H"/>
  <method class="tourma.data.Cup$INITIAL_DRAW" name="tourma.data.Cup$INITIAL_DRAW valueOf(java.lang.String)" map="valueOf"/>
  <method class="tourma.data.Cup$INITIAL_DRAW" name="tourma.data.Cup$INITIAL_DRAW[] values()" map="values"/>
  <class name="tourma.data.Cup" map="N"/>
  <field class="tourma.data.Cup" name="mTables" map="&#x00ec;"/>
  <field class="tourma.data.Cup" name="mRoundsCount" map="&#x00ed;"/>
  <field class="tourma.data.Cup" name="mInitialDraw" map="&#x00ee;"/>
  <field class="tourma.data.Cup" name="mShuffle" map="&#x00ef;"/>
  <field class="tourma.data.Cup" name="mType" map="&#x00f0;"/>
  <field class="tourma.data.Cup" name="mSwissForLoosers" map="&#x00f1;"/>
  <method class="tourma.data.Cup" name="void setType(tourma.data.Cup$ROUND_TYPE)" map="A"/>
  <method class="tourma.data.Cup" name="java.util.ArrayList generateMatchesLastRound(java.util.ArrayList, java.util.ArrayList)" map="A"/>
  <method class="tourma.data.Cup" name="void setRoundsCount(int)" map="s"/>
  <method class="tourma.data.Cup" name="int getRoundsCount()" map="&#x00ee;"/>
  <method class="tourma.data.Cup" name="void setSwissForLoosers(boolean)" map="N"/>
  <method class="tourma.data.Cup" name="void setInitialDraw(tourma.data.Cup$INITIAL_DRAW)" map="A"/>
  <method class="tourma.data.Cup" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.Cup" name="java.util.ArrayList generateMatchesRound(int, java.util.ArrayList, java.util.ArrayList)" map="A"/>
  <method class="tourma.data.Cup" name="boolean isSwissForLoosers()" map="&#x00ef;"/>
  <method class="tourma.data.Cup" name="java.util.ArrayList generateMatches(int, tourma.data.Round, java.util.ArrayList, java.util.ArrayList)" map="A"/>
  <method class="tourma.data.Cup" name="void cleanRound(tourma.data.Round)" map="G"/>
  <method class="tourma.data.Cup" name="boolean isShuffle()" map="&#x00f0;"/>
  <method class="tourma.data.Cup" name="void setShuffle(boolean)" map="O"/>
  <method class="tourma.data.Cup" name="java.util.ArrayList generateMatchesFirstRound(java.util.ArrayList)" map="K"/>
  <method class="tourma.data.Cup" name="tourma.data.Cup$ROUND_TYPE getType()" map="&#x00f1;"/>
  <method class="tourma.data.Cup" name="java.util.ArrayList getTables()" map="&#x00f2;"/>
  <method class="tourma.data.Cup" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.Cup" name="tourma.data.Cup$INITIAL_DRAW getInitialDraw()" map="&#x00f3;"/>
  <class name="tourma.data.TeamMatch" map="O"/>
  <field class="tourma.data.TeamMatch" name="UID" map="&#x0117;"/>
  <field class="tourma.data.TeamMatch" name="LOG" map="&#x0118;"/>
  <field class="tourma.data.TeamMatch" name="sGenUID" map="&#x0119;"/>
  <field class="tourma.data.TeamMatch" name="mMatchs" map="&#x011a;"/>
  <method class="tourma.data.TeamMatch" name="int getOppELOByTeam(tourma.data.Team, tourma.data.TeamMatch, int)" map="A"/>
  <method class="tourma.data.TeamMatch" name="void addMatch(tourma.data.CoachMatch)" map="C"/>
  <method class="tourma.data.TeamMatch" name="int getUID()" map="&#x0103;"/>
  <method class="tourma.data.TeamMatch" name="int getLoss(tourma.data.Team)" map="G"/>
  <method class="tourma.data.TeamMatch" name="void push(tourma.data.Match)" map="J"/>
  <method class="tourma.data.TeamMatch" name="tourma.data.CoachMatch getMatch(int)" map="t"/>
  <method class="tourma.data.TeamMatch" name="int getDraw(tourma.data.Team)" map="H"/>
  <method class="tourma.data.TeamMatch" name="int getOppPointsByTeam(tourma.data.Team, tourma.data.TeamMatch, boolean)" map="A"/>
  <method class="tourma.data.TeamMatch" name="int getCriteriaBonusPoints(tourma.data.Coach, tourma.data.CoachMatch, tourma.data.Criteria)" map="B"/>
  <method class="tourma.data.TeamMatch" name="int getPointsByTeam(tourma.data.Team, tourma.data.TeamMatch, boolean, boolean)" map="A"/>
  <method class="tourma.data.TeamMatch" name="int recomputeValue(int, tourma.data.Competitor)" map="C"/>
  <method class="tourma.data.TeamMatch" name="int getVNDByTeam(tourma.data.Team, tourma.data.TeamMatch, boolean)" map="B"/>
  <method class="tourma.data.TeamMatch" name="int getTeamNbMatch(tourma.data.Team, tourma.data.TeamMatch)" map="A"/>
  <method class="tourma.data.TeamMatch" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.TeamMatch" name="org.jdom.Element getXMLElementForDisplay()" map="&#x00f9;"/>
  <method class="tourma.data.TeamMatch" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.TeamMatch" name="int getValue(tourma.data.Team, int, boolean)" map="A"/>
  <method class="tourma.data.TeamMatch" name="void pull(tourma.data.Match)" map="K"/>
  <method class="tourma.data.TeamMatch" name="int getTeammatesVND(tourma.data.Team)" map="I"/>
  <method class="tourma.data.TeamMatch" name="void setUpdated(boolean)" map="P"/>
  <method class="tourma.data.TeamMatch" name="boolean isUpdated()" map="&#x00ff;"/>
  <method class="tourma.data.TeamMatch" name="boolean isEntered()" map="&#x00fd;"/>
  <method class="tourma.data.TeamMatch" name="boolean containsMatch(tourma.data.CoachMatch)" map="D"/>
  <method class="tourma.data.TeamMatch" name="tourma.data.Competitor getWinner()" map="&#x00fa;"/>
  <method class="tourma.data.TeamMatch" name="int getTeammatesPoints(tourma.data.Team)" map="J"/>
  <method class="tourma.data.TeamMatch" name="int getELOByTeam(tourma.data.Team, tourma.data.TeamMatch, int)" map="B"/>
  <method class="tourma.data.TeamMatch" name="int getValue(tourma.data.Criteria, int, tourma.data.Competitor)" map="B"/>
  <method class="tourma.data.TeamMatch" name="int getValue(tourma.data.Formula, tourma.data.Competitor)" map="B"/>
  <method class="tourma.data.TeamMatch" name="int getMatchCount()" map="&#x0111;"/>
  <method class="tourma.data.TeamMatch" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.TeamMatch" name="int getTeamTable(tourma.data.Team, tourma.data.TeamMatch)" map="B"/>
  <method class="tourma.data.TeamMatch" name="void recomputeValues()" map="&#x00fe;"/>
  <method class="tourma.data.TeamMatch" name="int getVictories(tourma.data.Team)" map="K"/>
  <method class="tourma.data.TeamMatch" name="int getCriteriasBonusPoints(tourma.data.Team, tourma.data.TeamMatch)" map="C"/>
  <method class="tourma.data.TeamMatch" name="int getTeamRosterGroups(tourma.data.Team)" map="L"/>
  <method class="tourma.data.TeamMatch" name="tourma.data.Competitor getLooser()" map="&#x00fc;"/>
  <method class="tourma.data.TeamMatch" name="void clearMatchs()" map="&#x0112;"/>
  <class name="tourma.data.Competitor" map="P"/>
  <field class="tourma.data.Competitor" name="mColor" map="H"/>
  <field class="tourma.data.Competitor" name="updated" map="I"/>
  <field class="tourma.data.Competitor" name="mClan" map="J"/>
  <field class="tourma.data.Competitor" name="mName" map="K"/>
  <field class="tourma.data.Competitor" name="picture" map="L"/>
  <field class="tourma.data.Competitor" name="_naf_avg" map="M"/>
  <field class="tourma.data.Competitor" name="mMatchs" map="N"/>
  <field class="tourma.data.Competitor" name="mCategories" map="O"/>
  <method class="tourma.data.Competitor" name="void removeMatch(tourma.data.Match)" map="A"/>
  <method class="tourma.data.Competitor" name="java.util.ArrayList getPossibleOpponents(java.util.ArrayList, tourma.data.Round)" map="A"/>
  <method class="tourma.data.Competitor" name="void addMatch(tourma.data.Match)" map="B"/>
  <method class="tourma.data.Competitor" name="int getCategoryCount()" map="G"/>
  <method class="tourma.data.Competitor" name="java.awt.Color getColor()" map="H"/>
  <method class="tourma.data.Competitor" name="void setPicture(javax.swing.ImageIcon)" map="B"/>
  <method class="tourma.data.Competitor" name="void setColor(java.awt.Color)" map="A"/>
  <method class="tourma.data.Competitor" name="void enableNafAvg(boolean)" map="B"/>
  <method class="tourma.data.Competitor" name="void roundCheck(tourma.data.Round)" map="A"/>
  <method class="tourma.data.Competitor" name="javax.swing.ImageIcon getPicture()" map="B"/>
  <method class="tourma.data.Competitor" name="java.lang.String getRawName()" map="I"/>
  <method class="tourma.data.Competitor" name="boolean isMatchsNotNull()" map="J"/>
  <method class="tourma.data.Competitor" name="tourma.data.Match getMatch(int)" map="A"/>
  <method class="tourma.data.Competitor" name="void pull(tourma.data.Competitor)" map="A"/>
  <method class="tourma.data.Competitor" name="void delCategory(tourma.data.Category)" map="A"/>
  <method class="tourma.data.Competitor" name="void setClan(tourma.data.Clan)" map="C"/>
  <method class="tourma.data.Competitor" name="void setName(java.lang.String)" map="C"/>
  <method class="tourma.data.Competitor" name="java.awt.Color generateRandomColor(java.awt.Color)" map="B"/>
  <method class="tourma.data.Competitor" name="void addMatch(tourma.data.Competitor, tourma.data.Round)" map="A"/>
  <method class="tourma.data.Competitor" name="int hashCode()" map="hashCode"/>
  <method class="tourma.data.Competitor" name="void setUpdated(boolean)" map="C"/>
  <method class="tourma.data.Competitor" name="int matchIndex(tourma.data.Match)" map="C"/>
  <method class="tourma.data.Competitor" name="java.lang.String toString()" map="toString"/>
  <method class="tourma.data.Competitor" name="boolean isUpdated()" map="K"/>
  <method class="tourma.data.Competitor" name="tourma.data.Clan getClan()" map="L"/>
  <method class="tourma.data.Competitor" name="boolean containsMatch(tourma.data.Match)" map="D"/>
  <method class="tourma.data.Competitor" name="void push(tourma.data.Competitor)" map="B"/>
  <method class="tourma.data.Competitor" name="tourma.data.Category getCategory(int)" map="B"/>
  <method class="tourma.data.Competitor" name="java.lang.String getName()" map="C"/>
  <method class="tourma.data.Competitor" name="void newMatchs()" map="M"/>
  <method class="tourma.data.Competitor" name="void addMatchRoundRobin(tourma.data.Competitor, tourma.data.Round, boolean)" map="A"/>
  <method class="tourma.data.Competitor" name="int getMatchCount()" map="N"/>
  <method class="tourma.data.Competitor" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.Competitor" name="boolean havePlayed(tourma.data.Competitor)" map="C"/>
  <method class="tourma.data.Competitor" name="void addCategory(tourma.data.Category)" map="B"/>
  <method class="tourma.data.Competitor" name="java.lang.String getDecoratedName()" map="O"/>
  <method class="tourma.data.Competitor" name="void clearMatchs()" map="P"/>
  <method class="tourma.data.Competitor" name="boolean containsCategory(tourma.data.Category)" map="C"/>
  <class name="tourma.data.Formula" map="Q"/>
  <field class="tourma.data.Formula" name="UID" map="&#x00f2;"/>
  <field class="tourma.data.Formula" name="_name" map="&#x00f3;"/>
  <field class="tourma.data.Formula" name="sGenUID" map="&#x00f4;"/>
  <field class="tourma.data.Formula" name="_formula" map="&#x00f5;"/>
  <field class="tourma.data.Formula" name="_npi" map="&#x00f6;"/>
  <method class="tourma.data.Formula" name="void setFormula(java.lang.String)" map="O"/>
  <method class="tourma.data.Formula" name="boolean isValid(java.lang.String)" map="P"/>
  <method class="tourma.data.Formula" name="void pull(tourma.data.Formula)" map="A"/>
  <method class="tourma.data.Formula" name="void setName(java.lang.String)" map="Q"/>
  <method class="tourma.data.Formula" name="boolean isNum(char)" map="A"/>
  <method class="tourma.data.Formula" name="java.util.Stack transformToNPI(java.lang.String)" map="R"/>
  <method class="tourma.data.Formula" name="void updateCriteria(java.lang.String, java.lang.String)" map="A"/>
  <method class="tourma.data.Formula" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.Formula" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.Formula" name="int getUID()" map="&#x00f4;"/>
  <method class="tourma.data.Formula" name="boolean isOperator(char)" map="B"/>
  <method class="tourma.data.Formula" name="java.lang.String getFormula()" map="&#x00f5;"/>
  <method class="tourma.data.Formula" name="int evaluate(java.util.HashMap, int)" map="A"/>
  <method class="tourma.data.Formula" name="java.lang.String getName()" map="&#x00f6;"/>
  <class name="tourma.data.Match" map="R"/>
  <field class="tourma.data.Match" name="c2value2" map="&#x00f8;"/>
  <field class="tourma.data.Match" name="c2value1" map="&#x00f9;"/>
  <field class="tourma.data.Match" name="mRound" map="&#x00fa;"/>
  <field class="tourma.data.Match" name="c1value5" map="&#x00fb;"/>
  <field class="tourma.data.Match" name="updated" map="&#x00fc;"/>
  <field class="tourma.data.Match" name="c1value4" map="&#x00fd;"/>
  <field class="tourma.data.Match" name="c1value3" map="&#x00fe;"/>
  <field class="tourma.data.Match" name="c1value2" map="&#x00ff;"/>
  <field class="tourma.data.Match" name="c1value1" map="&#x0100;"/>
  <field class="tourma.data.Match" name="mCompetitor2" map="&#x0101;"/>
  <field class="tourma.data.Match" name="mLooser" map="&#x0102;"/>
  <field class="tourma.data.Match" name="values_computed" map="&#x0103;"/>
  <field class="tourma.data.Match" name="mCompetitor1" map="&#x0104;"/>
  <field class="tourma.data.Match" name="mWinner" map="&#x0105;"/>
  <field class="tourma.data.Match" name="c2value5" map="&#x0106;"/>
  <field class="tourma.data.Match" name="c2value4" map="&#x0107;"/>
  <field class="tourma.data.Match" name="c2value3" map="&#x0108;"/>
  <method class="tourma.data.Match" name="tourma.data.Competitor getCompetitor2()" map="&#x00f8;"/>
  <method class="tourma.data.Match" name="org.jdom.Element getXMLElementForDisplay()" map="&#x00f9;"/>
  <method class="tourma.data.Match" name="tourma.data.Competitor getWinner()" map="&#x00fa;"/>
  <method class="tourma.data.Match" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.Match" name="void setCompetitor2(tourma.data.Competitor)" map="D"/>
  <method class="tourma.data.Match" name="tourma.data.Competitor getCompetitor1()" map="&#x00fb;"/>
  <method class="tourma.data.Match" name="tourma.data.Competitor getLooser()" map="&#x00fc;"/>
  <method class="tourma.data.Match" name="boolean isEntered()" map="&#x00fd;"/>
  <method class="tourma.data.Match" name="void recomputeValues()" map="&#x00fe;"/>
  <method class="tourma.data.Match" name="void setLooser(tourma.data.Competitor)" map="E"/>
  <method class="tourma.data.Match" name="boolean isUpdated()" map="&#x00ff;"/>
  <method class="tourma.data.Match" name="void resetWL()" map="&#x0100;"/>
  <method class="tourma.data.Match" name="void setCompetitor1(tourma.data.Competitor)" map="F"/>
  <method class="tourma.data.Match" name="tourma.data.Round getRound()" map="&#x0101;"/>
  <method class="tourma.data.Match" name="void push(tourma.data.Match)" map="J"/>
  <method class="tourma.data.Match" name="void setUpdated(boolean)" map="P"/>
  <method class="tourma.data.Match" name="int getValue(int, tourma.data.Competitor)" map="A"/>
  <method class="tourma.data.Match" name="boolean isValues_computed()" map="&#x0102;"/>
  <method class="tourma.data.Match" name="void pull(tourma.data.Match)" map="K"/>
  <method class="tourma.data.Match" name="void setWinner(tourma.data.Competitor)" map="G"/>
  <method class="tourma.data.Match" name="void setRound(tourma.data.Round)" map="H"/>
  <method class="tourma.data.Match" name="int getUID()" map="&#x0103;"/>
  <class name="tourma.data.Group" map="S"/>
  <field class="tourma.data.Group" name="UID" map="&#x011b;"/>
  <field class="tourma.data.Group" name="LOG" map="&#x011c;"/>
  <field class="tourma.data.Group" name="sGenUID" map="&#x011d;"/>
  <field class="tourma.data.Group" name="mName" map="&#x011e;"/>
  <field class="tourma.data.Group" name="opponentModificationPoints" map="&#x011f;"/>
  <field class="tourma.data.Group" name="_points" map="&#x0120;"/>
  <field class="tourma.data.Group" name="mRosters" map="&#x0121;"/>
  <method class="tourma.data.Group" name="tourma.data.RosterType getRoster(int)" map="u"/>
  <method class="tourma.data.Group" name="void setPoints(int)" map="v"/>
  <method class="tourma.data.Group" name="void pullOpponentGroupModifierPoints(tourma.data.Group)" map="B"/>
  <method class="tourma.data.Group" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.Group" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.Group" name="void setOpponentModificationPoints(tourma.data.Group, tourma.data.GroupPoints)" map="A"/>
  <method class="tourma.data.Group" name="tourma.data.GroupPoints getOpponentModificationPoints(tourma.data.Group)" map="C"/>
  <method class="tourma.data.Group" name="int getRosterCount()" map="&#x0113;"/>
  <method class="tourma.data.Group" name="int getPoints()" map="&#x0114;"/>
  <method class="tourma.data.Group" name="boolean containsRoster(tourma.data.RosterType)" map="D"/>
  <method class="tourma.data.Group" name="void setXMLElementForPoints(org.jdom.Element)" map="D"/>
  <method class="tourma.data.Group" name="void setName(java.lang.String)" map="S"/>
  <method class="tourma.data.Group" name="java.lang.String getName()" map="&#x0115;"/>
  <method class="tourma.data.Group" name="void delOpponentModificationPoints(tourma.data.Group)" map="D"/>
  <method class="tourma.data.Group" name="void addRoster(tourma.data.RosterType)" map="E"/>
  <method class="tourma.data.Group" name="void removeRoster(tourma.data.RosterType)" map="F"/>
  <method class="tourma.data.Group" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.Group" name="org.jdom.Element getXMLElementForPoints()" map="&#x0116;"/>
  <method class="tourma.data.Group" name="void pull(tourma.data.Group)" map="E"/>
  <method class="tourma.data.Group" name="int getUID()" map="&#x0117;"/>
  <class name="tourma.data.Ranking" map="T"/>
  <field class="tourma.data.Ranking" name="mObjectsRanked" map="&#x0139;"/>
  <field class="tourma.data.Ranking" name="UID" map="&#x013a;"/>
  <field class="tourma.data.Ranking" name="mRankings" map="&#x013b;"/>
  <field class="tourma.data.Ranking" name="mRank" map="&#x013c;"/>
  <field class="tourma.data.Ranking" name="mValueType" map="&#x013d;"/>
  <field class="tourma.data.Ranking" name="mType" map="&#x013e;"/>
  <field class="tourma.data.Ranking" name="sGenUID" map="&#x013f;"/>
  <field class="tourma.data.Ranking" name="mCriteria" map="&#x0140;"/>
  <field class="tourma.data.Ranking" name="mName" map="&#x0141;"/>
  <field class="tourma.data.Ranking" name="LOG" map="&#x0142;"/>
  <method class="tourma.data.Ranking" name="java.lang.String getValueType()" map="&#x0126;"/>
  <method class="tourma.data.Ranking" name="java.lang.String getType()" map="&#x0127;"/>
  <method class="tourma.data.Ranking" name="tourma.data.Criteria getCriteria()" map="&#x0128;"/>
  <method class="tourma.data.Ranking" name="void setCriteria(tourma.data.Criteria)" map="D"/>
  <method class="tourma.data.Ranking" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.Ranking" name="java.lang.String getName()" map="&#x0129;"/>
  <method class="tourma.data.Ranking" name="tourma.tableModel.MjtRanking getRank()" map="&#x012a;"/>
  <method class="tourma.data.Ranking" name="int getRowCount()" map="getRowCount"/>
  <method class="tourma.data.Ranking" name="int getSortedValue(int, int)" map="A"/>
  <method class="tourma.data.Ranking" name="tourma.data.ObjectRanking getSortedObject(int)" map="w"/>
  <method class="tourma.data.Ranking" name="java.lang.String getDetail()" map="&#x0118;"/>
  <class name="tourma.data.Parameters$1" map="1"/>
  <field class="tourma.data.Parameters$1" name="$SwitchMap$tourma$data$EIndivPairing" map="A"/>
  <field class="tourma.data.Parameters$1" name="$SwitchMap$tourma$data$ETeamPairing" map="B"/>
  <class name="tourma.data.Parameters" map="U"/>
  <field class="tourma.data.Parameters" name="mTableBonusPerRound" map="&#x0143;"/>
  <field class="tourma.data.Parameters" name="mAvoidClansMatch" map="&#x0144;"/>
  <field class="tourma.data.Parameters" name="mPointsTeamVictory" map="&#x0145;"/>
  <field class="tourma.data.Parameters" name="mPortugal" map="&#x0146;"/>
  <field class="tourma.data.Parameters" name="mApplyToAnnexTeam" map="&#x0147;"/>
  <field class="tourma.data.Parameters" name="mPointsTeamVictoryBonus" map="&#x0148;"/>
  <field class="tourma.data.Parameters" name="mTeamMatesClansNumber" map="&#x0149;"/>
  <field class="tourma.data.Parameters" name="mPointsIndivDraw" map="&#x014a;"/>
  <field class="tourma.data.Parameters" name="mUseLittleLoss" map="&#x014b;"/>
  <field class="tourma.data.Parameters" name="mPlace" map="&#x014c;"/>
  <field class="tourma.data.Parameters" name="UID" map="&#x014d;"/>
  <field class="tourma.data.Parameters" name="mBestResultsTeam" map="&#x014e;"/>
  <field class="tourma.data.Parameters" name="useColor" map="&#x014f;"/>
  <field class="tourma.data.Parameters" name="mDisplayRoster" map="&#x0150;"/>
  <field class="tourma.data.Parameters" name="mUseBestResultsIndiv" map="&#x0151;"/>
  <field class="tourma.data.Parameters" name="mGapLargeVictory" map="&#x0152;"/>
  <field class="tourma.data.Parameters" name="mApplyToAnnexIndiv" map="&#x0153;"/>
  <field class="tourma.data.Parameters" name="mTournamentName" map="&#x0154;"/>
  <field class="tourma.data.Parameters" name="mPointsTeamLost" map="&#x0155;"/>
  <field class="tourma.data.Parameters" name="mExceptBestAndWorstIndiv" map="&#x0156;"/>
  <field class="tourma.data.Parameters" name="mBestResultsIndiv" map="&#x0157;"/>
  <field class="tourma.data.Parameters" name="mUseTeamLargeVictory" map="&#x0158;"/>
  <field class="tourma.data.Parameters" name="mTeamPairing" map="&#x0159;"/>
  <field class="tourma.data.Parameters" name="mUseBestResultsTeam" map="&#x015a;"/>
  <field class="tourma.data.Parameters" name="mPointsIndivVictory" map="&#x015b;"/>
  <field class="tourma.data.Parameters" name="mPointsRefused" map="&#x015c;"/>
  <field class="tourma.data.Parameters" name="mGapTeamLargeVictory" map="&#x015d;"/>
  <field class="tourma.data.Parameters" name="LOG" map="&#x015e;"/>
  <field class="tourma.data.Parameters" name="mTableBonusCoef" map="&#x015f;"/>
  <field class="tourma.data.Parameters" name="mGapLittleLost" map="&#x0160;"/>
  <field class="tourma.data.Parameters" name="mIndivPairingTeamBalanced" map="&#x0161;"/>
  <field class="tourma.data.Parameters" name="mPointsIndivLargeVictory" map="&#x0162;"/>
  <field class="tourma.data.Parameters" name="mExceptBestAndWorstTeam" map="&#x0163;"/>
  <field class="tourma.data.Parameters" name="mAvoidClansFirstMatch" map="&#x0164;"/>
  <field class="tourma.data.Parameters" name="mPointsIndivLost" map="&#x0165;"/>
  <field class="tourma.data.Parameters" name="mFormulas" map="&#x0166;"/>
  <field class="tourma.data.Parameters" name="mTableBonus" map="&#x0167;"/>
  <field class="tourma.data.Parameters" name="mIndivPairingIndivBalanced" map="&#x0168;"/>
  <field class="tourma.data.Parameters" name="sGenUID" map="&#x0169;"/>
  <field class="tourma.data.Parameters" name="mTeamTournament" map="&#x016a;"/>
  <field class="tourma.data.Parameters" name="mSubstitutes" map="&#x016b;"/>
  <field class="tourma.data.Parameters" name="mRankingIndiv5" map="&#x016c;"/>
  <field class="tourma.data.Parameters" name="mRankingIndiv4" map="&#x016d;"/>
  <field class="tourma.data.Parameters" name="mMultiRoster" map="&#x016e;"/>
  <field class="tourma.data.Parameters" name="mRankingIndiv3" map="&#x016f;"/>
  <field class="tourma.data.Parameters" name="mRankingIndiv2" map="&#x0170;"/>
  <field class="tourma.data.Parameters" name="mRankingIndiv1" map="&#x0171;"/>
  <field class="tourma.data.Parameters" name="mRankingTeam5" map="&#x0172;"/>
  <field class="tourma.data.Parameters" name="mRankingTeam4" map="&#x0173;"/>
  <field class="tourma.data.Parameters" name="mRankingTeam3" map="&#x0174;"/>
  <field class="tourma.data.Parameters" name="mGapTeamHugeVictory" map="&#x0175;"/>
  <field class="tourma.data.Parameters" name="mRankingTeam2" map="&#x0176;"/>
  <field class="tourma.data.Parameters" name="mUseLargeVictory" map="&#x0177;"/>
  <field class="tourma.data.Parameters" name="mRankingTeam1" map="&#x0178;"/>
  <field class="tourma.data.Parameters" name="mPointsTeamLargeVictory" map="&#x0179;"/>
  <field class="tourma.data.Parameters" name="mTeamMatesNumber" map="&#x017a;"/>
  <field class="tourma.data.Parameters" name="mGapTeamHugeLost" map="&#x017b;"/>
  <field class="tourma.data.Parameters" name="mWebEdit" map="&#x017c;"/>
  <field class="tourma.data.Parameters" name="useImage" map="&#x017d;"/>
  <field class="tourma.data.Parameters" name="mTeamVictoryOnly" map="&#x017e;"/>
  <field class="tourma.data.Parameters" name="mClansMembersNumber" map="&#x017f;"/>
  <field class="tourma.data.Parameters" name="mTournamentOrga" map="&#x0180;"/>
  <field class="tourma.data.Parameters" name="mGapTeamLittleLost" map="&#x0181;"/>
  <field class="tourma.data.Parameters" name="mColor2" map="&#x0182;"/>
  <field class="tourma.data.Parameters" name="mColor1" map="&#x0183;"/>
  <field class="tourma.data.Parameters" name="_webport" map="&#x0184;"/>
  <field class="tourma.data.Parameters" name="mPointsTeamHugeLost" map="&#x0185;"/>
  <field class="tourma.data.Parameters" name="mCrossPoolMatch" map="&#x0186;"/>
  <field class="tourma.data.Parameters" name="mUseTeamHugeVictory" map="&#x0187;"/>
  <field class="tourma.data.Parameters" name="mPointsTeamDraw" map="&#x0188;"/>
  <field class="tourma.data.Parameters" name="mDate" map="&#x0189;"/>
  <field class="tourma.data.Parameters" name="mGroupsEnable" map="&#x018a;"/>
  <field class="tourma.data.Parameters" name="mCriterias" map="&#x018b;"/>
  <field class="tourma.data.Parameters" name="mPointsTeamLittleLost" map="&#x018c;"/>
  <field class="tourma.data.Parameters" name="mEnableClans" map="&#x018d;"/>
  <field class="tourma.data.Parameters" name="mUseTeamLittleLoss" map="&#x018e;"/>
  <field class="tourma.data.Parameters" name="mPointsConcedeed" map="&#x018f;"/>
  <field class="tourma.data.Parameters" name="mPointsTeamHugeVictory" map="&#x0190;"/>
  <field class="tourma.data.Parameters" name="mTeamIndivPairing" map="&#x0191;"/>
  <field class="tourma.data.Parameters" name="mPointsIndivLittleLost" map="&#x0192;"/>
  <field class="tourma.data.Parameters" name="mForeColor" map="&#x0193;"/>
  <field class="tourma.data.Parameters" name="mBorderColor" map="&#x0194;"/>
  <field class="tourma.data.Parameters" name="mUseTeamHugeLoss" map="&#x0195;"/>
  <field class="tourma.data.Parameters" name="mPointsTeamDrawBonus" map="&#x0196;"/>
  <method class="tourma.data.Parameters" name="boolean isUseBestResultIndiv()" map="&#x012b;"/>
  <method class="tourma.data.Parameters" name="tourma.data.Criteria getCriteria(java.lang.String)" map="U"/>
  <method class="tourma.data.Parameters" name="int getTeamRankingNumber()" map="&#x012c;"/>
  <method class="tourma.data.Parameters" name="void setPointsTeamLost(int)" map="&#x00a4;"/>
  <method class="tourma.data.Parameters" name="void setPointsTeamDraw(int)" map="&#x00a5;"/>
  <method class="tourma.data.Parameters" name="boolean isSubstitutes()" map="&#x012d;"/>
  <method class="tourma.data.Parameters" name="tourma.data.EIndivPairing getTeamIndivPairing()" map="&#x012e;"/>
  <method class="tourma.data.Parameters" name="void setUseBestResultTeam(boolean)" map="V"/>
  <method class="tourma.data.Parameters" name="float getGapTeamHugeVictory()" map="&#x012f;"/>
  <method class="tourma.data.Parameters" name="void setWebEdit(boolean)" map="W"/>
  <method class="tourma.data.Parameters" name="void setPointsIndivDraw(int)" map="&#x00aa;"/>
  <method class="tourma.data.Parameters" name="boolean isTeamVictoryOnly()" map="&#x0130;"/>
  <method class="tourma.data.Parameters" name="void setBorderColor(java.awt.Color)" map="C"/>
  <method class="tourma.data.Parameters" name="java.lang.String getStringColor2()" map="&#x0131;"/>
  <method class="tourma.data.Parameters" name="void setGapLittleLost(int)" map="&#x00b5;"/>
  <method class="tourma.data.Parameters" name="boolean isUseLargeVictory()" map="&#x0132;"/>
  <method class="tourma.data.Parameters" name="void setTeamMatesNumber(int)" map="&#x00ba;"/>
  <method class="tourma.data.Parameters" name="void setExceptBestAndWorstTeam(boolean)" map="X"/>
  <method class="tourma.data.Parameters" name="int getRankingTeam5()" map="&#x0133;"/>
  <method class="tourma.data.Parameters" name="void setRankingIndiv3(int)" map="&#x00c0;"/>
  <method class="tourma.data.Parameters" name="int getFormulaCount()" map="&#x0134;"/>
  <method class="tourma.data.Parameters" name="int getRankingIndiv4()" map="&#x0135;"/>
  <method class="tourma.data.Parameters" name="int getGapLargeVictory()" map="&#x0136;"/>
  <method class="tourma.data.Parameters" name="float getGapTeamHugeLost()" map="&#x0137;"/>
  <method class="tourma.data.Parameters" name="boolean isUseTeamLargeVictory()" map="&#x0138;"/>
  <method class="tourma.data.Parameters" name="void setRankingTeam5(int)" map="&#x00c1;"/>
  <method class="tourma.data.Parameters" name="void clearFormulas()" map="&#x0139;"/>
  <method class="tourma.data.Parameters" name="int getGapLittleLost()" map="&#x013a;"/>
  <method class="tourma.data.Parameters" name="int getTeamRankingType(int)" map="&#x00c2;"/>
  <method class="tourma.data.Parameters" name="void setUseLargeVictory(boolean)" map="Y"/>
  <method class="tourma.data.Parameters" name="void setBestResultTeam(int)" map="&#x00c3;"/>
  <method class="tourma.data.Parameters" name="boolean isExceptBestAndWorstIndiv()" map="&#x013b;"/>
  <method class="tourma.data.Parameters" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.Parameters" name="int getBestResultIndiv()" map="&#x013c;"/>
  <method class="tourma.data.Parameters" name="int getPointsTeamHugeVictory()" map="&#x013d;"/>
  <method class="tourma.data.Parameters" name="void setClansMembersNumber(int)" map="&#x00c4;"/>
  <method class="tourma.data.Parameters" name="void setGroupsEnable(boolean)" map="Z"/>
  <method class="tourma.data.Parameters" name="void setPointsTeamDrawBonus(int)" map="&#x00c5;"/>
  <method class="tourma.data.Parameters" name="void setTableBonusPerRound(boolean)" map="_"/>
  <method class="tourma.data.Parameters" name="void setTeamIndivPairing(tourma.data.EIndivPairing)" map="A"/>
  <method class="tourma.data.Parameters" name="int getPointsIndivLargeVictory()" map="&#x013e;"/>
  <method class="tourma.data.Parameters" name="int getPointsConcedeed()" map="&#x013f;"/>
  <method class="tourma.data.Parameters" name="int getTeamMatesNumber()" map="&#x0140;"/>
  <method class="tourma.data.Parameters" name="int getPointsTeamLost()" map="&#x0141;"/>
  <method class="tourma.data.Parameters" name="void setSubstitutes(boolean)" map="a"/>
  <method class="tourma.data.Parameters" name="boolean isEnableClans()" map="&#x0142;"/>
  <method class="tourma.data.Parameters" name="int getPointsIndivLost()" map="&#x0143;"/>
  <method class="tourma.data.Parameters" name="void setForeColor(java.awt.Color)" map="D"/>
  <method class="tourma.data.Parameters" name="java.lang.String getStringBorderColor()" map="&#x0144;"/>
  <method class="tourma.data.Parameters" name="void pull(tourma.data.Parameters)" map="A"/>
  <method class="tourma.data.Parameters" name="boolean isAvoidClansFirstMatch()" map="&#x0145;"/>
  <method class="tourma.data.Parameters" name="void setDate(java.util.Date)" map="A"/>
  <method class="tourma.data.Parameters" name="int getClansMembersNumber()" map="&#x0146;"/>
  <method class="tourma.data.Parameters" name="void setApplyToAnnexIndiv(boolean)" map="b"/>
  <method class="tourma.data.Parameters" name="java.lang.String toString()" map="toString"/>
  <method class="tourma.data.Parameters" name="java.lang.String getStringColor1()" map="&#x0147;"/>
  <method class="tourma.data.Parameters" name="int getRankingTeam1()" map="&#x0148;"/>
  <method class="tourma.data.Parameters" name="java.lang.String getStringForeColor()" map="&#x0149;"/>
  <method class="tourma.data.Parameters" name="void setRankingTeam1(int)" map="&#x00c6;"/>
  <method class="tourma.data.Parameters" name="void setTableBonusCoef(double)" map="E"/>
  <method class="tourma.data.Parameters" name="boolean isMultiRoster()" map="&#x014a;"/>
  <method class="tourma.data.Parameters" name="int getPointsTeamHugeLost()" map="&#x014b;"/>
  <method class="tourma.data.Parameters" name="void setUseBestResultIndiv(boolean)" map="c"/>
  <method class="tourma.data.Parameters" name="int getRankingIndiv5()" map="&#x014c;"/>
  <method class="tourma.data.Parameters" name="void addCriteria(tourma.data.Criteria)" map="E"/>
  <method class="tourma.data.Parameters" name="void setIndivPairingIndivBalanced(boolean)" map="d"/>
  <method class="tourma.data.Parameters" name="void setGapTeamLargeVictory(float)" map="A"/>
  <method class="tourma.data.Parameters" name="void setUseLittleLoss(boolean)" map="e"/>
  <method class="tourma.data.Parameters" name="int getPointsTeamLittleLost()" map="&#x014d;"/>
  <method class="tourma.data.Parameters" name="boolean isIndivPairingTeamBalanced()" map="&#x014e;"/>
  <method class="tourma.data.Parameters" name="void setRankingIndiv2(int)" map="&#x00c7;"/>
  <method class="tourma.data.Parameters" name="double getTableBonusCoef()" map="&#x014f;"/>
  <method class="tourma.data.Parameters" name="void setUseTeamLittleLoss(boolean)" map="f"/>
  <method class="tourma.data.Parameters" name="void setEnableClans(boolean)" map="g"/>
  <method class="tourma.data.Parameters" name="boolean isIndivPairingIndivBalanced()" map="&#x0150;"/>
  <method class="tourma.data.Parameters" name="void setRankingTeam4(int)" map="&#x00c8;"/>
  <method class="tourma.data.Parameters" name="void setIndivPairingTeamBalanced(boolean)" map="h"/>
  <method class="tourma.data.Parameters" name="boolean isWebEdit()" map="&#x0151;"/>
  <method class="tourma.data.Parameters" name="java.awt.Color getForeColor()" map="&#x0152;"/>
  <method class="tourma.data.Parameters" name="int getPointsTeamVictoryBonus()" map="&#x0153;"/>
  <method class="tourma.data.Parameters" name="void setPointsTeamLargeVictory(int)" map="&#x00c9;"/>
  <method class="tourma.data.Parameters" name="java.awt.Color getBorderColor()" map="&#x0154;"/>
  <method class="tourma.data.Parameters" name="boolean isUseTeamHugeVictory()" map="&#x0155;"/>
  <method class="tourma.data.Parameters" name="int getPointsTeamDrawBonus()" map="&#x0156;"/>
  <method class="tourma.data.Parameters" name="int getRankingTeam2()" map="&#x0157;"/>
  <method class="tourma.data.Parameters" name="void addFormula(tourma.data.Formula)" map="D"/>
  <method class="tourma.data.Parameters" name="int getRankingIndiv1()" map="&#x0158;"/>
  <method class="tourma.data.Parameters" name="int getIndivRankingType(int)" map="&#x00ca;"/>
  <method class="tourma.data.Parameters" name="void setMultiRoster(boolean)" map="i"/>
  <method class="tourma.data.Parameters" name="boolean isUseColor()" map="&#x0159;"/>
  <method class="tourma.data.Parameters" name="void setGapTeamLittleLost(float)" map="B"/>
  <method class="tourma.data.Parameters" name="float getGapTeamLittleLost()" map="&#x015a;"/>
  <method class="tourma.data.Parameters" name="boolean isUseTeamLittleLoss()" map="&#x015b;"/>
  <method class="tourma.data.Parameters" name="void setAvoidClansMatch(boolean)" map="j"/>
  <method class="tourma.data.Parameters" name="void setExceptBestAndWorstIndiv(boolean)" map="k"/>
  <method class="tourma.data.Parameters" name="int getPointsTeamLargeVictory()" map="&#x015c;"/>
  <method class="tourma.data.Parameters" name="int gemRankingTeam2()" map="&#x015d;"/>
  <method class="tourma.data.Parameters" name="void setPointsTeamLittleLost(int)" map="&#x00cb;"/>
  <method class="tourma.data.Parameters" name="void setUseTeamHugeVictory(boolean)" map="l"/>
  <method class="tourma.data.Parameters" name="boolean isUseLittleLoss()" map="&#x015e;"/>
  <method class="tourma.data.Parameters" name="java.awt.Color getColor1()" map="&#x015f;"/>
  <method class="tourma.data.Parameters" name="void setPointsIndivLittleLost(int)" map="&#x00cc;"/>
  <method class="tourma.data.Parameters" name="void setGapTeamHugeLost(float)" map="C"/>
  <method class="tourma.data.Parameters" name="void setCrossPoolMatch(boolean)" map="m"/>
  <method class="tourma.data.Parameters" name="int getPointsRefused()" map="&#x0160;"/>
  <method class="tourma.data.Parameters" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.Parameters" name="void setRankingIndiv5(int)" map="&#x00cd;"/>
  <method class="tourma.data.Parameters" name="void setDisplayRoster(boolean)" map="n"/>
  <method class="tourma.data.Parameters" name="void removeCriteria(int)" map="&#x00ce;"/>
  <method class="tourma.data.Parameters" name="void setPointsTeamHugeLost(int)" map="&#x00cf;"/>
  <method class="tourma.data.Parameters" name="void setPointsConcedeed(int)" map="&#x00d0;"/>
  <method class="tourma.data.Parameters" name="boolean isAvoidClansMatch()" map="&#x0161;"/>
  <method class="tourma.data.Parameters" name="boolean isUseBestResultTeam()" map="&#x0162;"/>
  <method class="tourma.data.Parameters" name="long getDateTime()" map="&#x0163;"/>
  <method class="tourma.data.Parameters" name="tourma.data.Formula getFormula(int)" map="&#x00d1;"/>
  <method class="tourma.data.Parameters" name="void setBestResultIndiv(int)" map="&#x00d2;"/>
  <method class="tourma.data.Parameters" name="boolean isCrossPoolMatch()" map="&#x0164;"/>
  <method class="tourma.data.Parameters" name="int getPointsIndivLittleLost()" map="&#x0165;"/>
  <method class="tourma.data.Parameters" name="void setPortugal(boolean)" map="o"/>
  <method class="tourma.data.Parameters" name="void removeFormula(int)" map="&#x00d3;"/>
  <method class="tourma.data.Parameters" name="void setUseColor(boolean)" map="p"/>
  <method class="tourma.data.Parameters" name="boolean isApplyToAnnexTeam()" map="&#x0166;"/>
  <method class="tourma.data.Parameters" name="void setPlace(java.lang.String)" map="V"/>
  <method class="tourma.data.Parameters" name="void setUseTeamLargeVictory(boolean)" map="q"/>
  <method class="tourma.data.Parameters" name="int getRankingTeam3()" map="&#x0167;"/>
  <method class="tourma.data.Parameters" name="void setRankingIndiv1(int)" map="&#x00d4;"/>
  <method class="tourma.data.Parameters" name="void setTeamPairing(tourma.data.ETeamPairing)" map="A"/>
  <method class="tourma.data.Parameters" name="int getRankingIndiv2()" map="&#x0168;"/>
  <method class="tourma.data.Parameters" name="int getWebServerPort()" map="&#x0169;"/>
  <method class="tourma.data.Parameters" name="boolean isExceptBestAndWorstTeam()" map="&#x016a;"/>
  <method class="tourma.data.Parameters" name="int getBestResultTeam()" map="&#x016b;"/>
  <method class="tourma.data.Parameters" name="void setRankingTeam3(int)" map="&#x00d5;"/>
  <method class="tourma.data.Parameters" name="void setPointsIndivLargeVictory(int)" map="&#x00d6;"/>
  <method class="tourma.data.Parameters" name="void setTableBonus(boolean)" map="r"/>
  <method class="tourma.data.Parameters" name="int getIndivRankingNumber()" map="&#x016c;"/>
  <method class="tourma.data.Parameters" name="void setTeamVictoryOnly(boolean)" map="s"/>
  <method class="tourma.data.Parameters" name="void setGapLargeVictory(int)" map="&#x00d8;"/>
  <method class="tourma.data.Parameters" name="void setUseTeamHugeLoss(boolean)" map="t"/>
  <method class="tourma.data.Parameters" name="float getGapTeamLargeVictory()" map="&#x016d;"/>
  <method class="tourma.data.Parameters" name="boolean isDisplayRoster()" map="&#x016e;"/>
  <method class="tourma.data.Parameters" name="int getPointsTeamVictory()" map="&#x016f;"/>
  <method class="tourma.data.Parameters" name="boolean isTableBonus()" map="&#x0170;"/>
  <method class="tourma.data.Parameters" name="void setPointsTeamVictory(int)" map="&#x00d9;"/>
  <method class="tourma.data.Parameters" name="void setAvoidClansFirstMatch(boolean)" map="u"/>
  <method class="tourma.data.Parameters" name="void setPointsIndivVictory(int)" map="&#x00da;"/>
  <method class="tourma.data.Parameters" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.Parameters" name="void setColor1(java.awt.Color)" map="E"/>
  <method class="tourma.data.Parameters" name="java.lang.String getTournamentOrga()" map="&#x0171;"/>
  <method class="tourma.data.Parameters" name="boolean isUseTeamHugeLoss()" map="&#x0172;"/>
  <method class="tourma.data.Parameters" name="void setApplyToAnnexTeam(boolean)" map="v"/>
  <method class="tourma.data.Parameters" name="int getCriteriaCount()" map="&#x0173;"/>
  <method class="tourma.data.Parameters" name="void setTeamTournament(boolean)" map="w"/>
  <method class="tourma.data.Parameters" name="void setPointsRefused(int)" map="&#x00db;"/>
  <method class="tourma.data.Parameters" name="void clearCiterias()" map="&#x0174;"/>
  <method class="tourma.data.Parameters" name="void semTournamentOrga(java.lang.String)" map="W"/>
  <method class="tourma.data.Parameters" name="int getTeamMatesClansNumber()" map="&#x0175;"/>
  <method class="tourma.data.Parameters" name="void setUseImage(boolean)" map="x"/>
  <method class="tourma.data.Parameters" name="int getPointsIndivVictory()" map="&#x0176;"/>
  <method class="tourma.data.Parameters" name="void setGapTeamHugeVictory(float)" map="D"/>
  <method class="tourma.data.Parameters" name="void setRankingIndiv4(int)" map="&#x00dc;"/>
  <method class="tourma.data.Parameters" name="boolean isTeamTournament()" map="&#x0177;"/>
  <method class="tourma.data.Parameters" name="int getPointsTeamDraw()" map="&#x0178;"/>
  <method class="tourma.data.Parameters" name="void setPointsTeamHugeVictory(int)" map="&#x00dd;"/>
  <method class="tourma.data.Parameters" name="tourma.data.ETeamPairing getTeamPairing()" map="&#x0179;"/>
  <method class="tourma.data.Parameters" name="int getPointsIndivDraw()" map="&#x017a;"/>
  <method class="tourma.data.Parameters" name="void setWebServerPort(int)" map="&#x00de;"/>
  <method class="tourma.data.Parameters" name="boolean isTableBonusPerRound()" map="&#x017b;"/>
  <method class="tourma.data.Parameters" name="boolean isPortugal()" map="&#x017c;"/>
  <method class="tourma.data.Parameters" name="void setPointsTeamVictoryBonus(int)" map="&#x00df;"/>
  <method class="tourma.data.Parameters" name="tourma.data.Criteria getCriteria(int)" map="&#x00e0;"/>
  <method class="tourma.data.Parameters" name="int getRankingTeam4()" map="&#x017d;"/>
  <method class="tourma.data.Parameters" name="int getRankingIndiv3()" map="&#x017e;"/>
  <method class="tourma.data.Parameters" name="void setTeamMatesClansNumber(int)" map="&#x00e1;"/>
  <method class="tourma.data.Parameters" name="java.lang.String getStringDate(java.text.SimpleDateFormat)" map="A"/>
  <method class="tourma.data.Parameters" name="boolean isUseImage()" map="&#x017f;"/>
  <method class="tourma.data.Parameters" name="java.awt.Color getColor2()" map="&#x0180;"/>
  <method class="tourma.data.Parameters" name="java.lang.String getPlace()" map="&#x0181;"/>
  <method class="tourma.data.Parameters" name="boolean isApplyToAnnexIndiv()" map="&#x0182;"/>
  <method class="tourma.data.Parameters" name="void setColor2(java.awt.Color)" map="F"/>
  <method class="tourma.data.Parameters" name="void setRankingTeam2(int)" map="&#x00e2;"/>
  <method class="tourma.data.Parameters" name="void setPointsIndivLost(int)" map="&#x00e3;"/>
  <method class="tourma.data.Parameters" name="void setTournamentName(java.lang.String)" map="X"/>
  <method class="tourma.data.Parameters" name="java.lang.String getTournamentName()" map="&#x0183;"/>
  <method class="tourma.data.Parameters" name="boolean isGroupsEnable()" map="&#x0184;"/>
  <class name="tourma.data.Category" map="V"/>
  <field class="tourma.data.Category" name="sCategoryMap" map="&#x0197;"/>
  <field class="tourma.data.Category" name="UID" map="&#x0198;"/>
  <field class="tourma.data.Category" name="sGenUID" map="&#x0199;"/>
  <field class="tourma.data.Category" name="mName" map="&#x019a;"/>
  <method class="tourma.data.Category" name="void setName(java.lang.String)" map="Y"/>
  <method class="tourma.data.Category" name="int hashCode()" map="hashCode"/>
  <method class="tourma.data.Category" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.Category" name="void newCategoryMap()" map="&#x0185;"/>
  <method class="tourma.data.Category" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.Category" name="int getUID()" map="&#x0186;"/>
  <method class="tourma.data.Category" name="void delCategory(java.lang.String)" map="Z"/>
  <method class="tourma.data.Category" name="void pull(tourma.data.Category)" map="F"/>
  <method class="tourma.data.Category" name="java.lang.String getName()" map="&#x0187;"/>
  <method class="tourma.data.Category" name="java.lang.String toString()" map="toString"/>
  <method class="tourma.data.Category" name="void putCategory(java.lang.String, tourma.data.Category)" map="A"/>
  <method class="tourma.data.Category" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <method class="tourma.data.Category" name="tourma.data.Category getCategory(java.lang.String)" map="_"/>
  <class name="tourma.data.Tournament" map="W"/>
  <field class="tourma.data.Tournament" name="roundsUpdated" map="P"/>
  <field class="tourma.data.Tournament" name="mRosterTypes" map="Q"/>
  <field class="tourma.data.Tournament" name="clansUpdated" map="R"/>
  <field class="tourma.data.Tournament" name="myLock" map="S"/>
  <field class="tourma.data.Tournament" name="mSingleton" map="T"/>
  <field class="tourma.data.Tournament" name="mGroups" map="U"/>
  <field class="tourma.data.Tournament" name="mParams" map="V"/>
  <field class="tourma.data.Tournament" name="LOG" map="W"/>
  <field class="tourma.data.Tournament" name="mClans" map="X"/>
  <field class="tourma.data.Tournament" name="mTeams" map="Y"/>
  <field class="tourma.data.Tournament" name="coachsUpdated" map="Z"/>
  <field class="tourma.data.Tournament" name="mDescription" map="_"/>
  <field class="tourma.data.Tournament" name="mRoundRobin" map="a"/>
  <field class="tourma.data.Tournament" name="mCoachs" map="b"/>
  <field class="tourma.data.Tournament" name="isClient" map="c"/>
  <field class="tourma.data.Tournament" name="teamsUpdated" map="d"/>
  <field class="tourma.data.Tournament" name="mCup" map="e"/>
  <field class="tourma.data.Tournament" name="mRounds" map="f"/>
  <field class="tourma.data.Tournament" name="mCategories" map="g"/>
  <field class="tourma.data.Tournament" name="mPools" map="h"/>
  <method class="tourma.data.Tournament" name="void pull(tourma.data.Tournament)" map="A"/>
  <method class="tourma.data.Tournament" name="void loadRosters(org.jdom.Element)" map="B"/>
  <method class="tourma.data.Tournament" name="java.lang.String[] getTeamsNames()" map="R"/>
  <method class="tourma.data.Tournament" name="void push(tourma.data.Tournament)" map="B"/>
  <method class="tourma.data.Tournament" name="boolean isClient()" map="S"/>
  <method class="tourma.data.Tournament" name="boolean containsTeam(tourma.data.Team)" map="A"/>
  <method class="tourma.data.Tournament" name="void addCoach(tourma.data.Coach)" map="A"/>
  <method class="tourma.data.Tournament" name="void pushClans(java.util.ArrayList)" map="A"/>
  <method class="tourma.data.Tournament" name="void addPool(tourma.data.Pool)" map="A"/>
  <method class="tourma.data.Tournament" name="java.util.ArrayList getDisplayClans()" map="T"/>
  <method class="tourma.data.Tournament" name="void pullRounds(java.util.ArrayList)" map="B"/>
  <method class="tourma.data.Tournament" name="void saveXML(java.io.File)" map="A"/>
  <method class="tourma.data.Tournament" name="void pullCoachs(java.util.ArrayList)" map="C"/>
  <method class="tourma.data.Tournament" name="java.util.ArrayList getCoachs()" map="U"/>
  <method class="tourma.data.Tournament" name="void setIsClient(boolean)" map="D"/>
  <method class="tourma.data.Tournament" name="void clearRounds()" map="V"/>
  <method class="tourma.data.Tournament" name="tourma.data.Coach getCoach(int)" map="C"/>
  <method class="tourma.data.Tournament" name="void setDescription(java.lang.String)" map="D"/>
  <method class="tourma.data.Tournament" name="tourma.data.Coach getCoach(java.lang.String)" map="E"/>
  <method class="tourma.data.Tournament" name="void removeRound(tourma.data.Round)" map="B"/>
  <method class="tourma.data.Tournament" name="tourma.data.Team getTeam(java.lang.String)" map="F"/>
  <method class="tourma.data.Tournament" name="tourma.data.Cup getCup()" map="W"/>
  <method class="tourma.data.Tournament" name="tourma.data.Group getGroup(java.lang.String)" map="G"/>
  <method class="tourma.data.Tournament" name="tourma.data.Round getRound(int)" map="D"/>
  <method class="tourma.data.Tournament" name="java.util.ArrayList getRankingTypes(boolean)" map="E"/>
  <method class="tourma.data.Tournament" name="tourma.data.Pool getPool(int)" map="E"/>
  <method class="tourma.data.Tournament" name="void addGroup(tourma.data.Group)" map="A"/>
  <method class="tourma.data.Tournament" name="void removeClan(int)" map="F"/>
  <method class="tourma.data.Tournament" name="void recomputeAll()" map="X"/>
  <method class="tourma.data.Tournament" name="java.util.ArrayList getActiveCoaches()" map="Y"/>
  <method class="tourma.data.Tournament" name="void loadXMLv3(org.jdom.Element)" map="C"/>
  <method class="tourma.data.Tournament" name="int getCoachsCount()" map="Q"/>
  <method class="tourma.data.Tournament" name="void removeRound(int)" map="G"/>
  <method class="tourma.data.Tournament" name="int getRoundIndex(tourma.data.Round)" map="C"/>
  <method class="tourma.data.Tournament" name="void clearGroups()" map="Z"/>
  <method class="tourma.data.Tournament" name="int getTeamsCount()" map="_"/>
  <method class="tourma.data.Tournament" name="void setCoachsUpdated(boolean)" map="F"/>
  <method class="tourma.data.Tournament" name="void removeGroup(int)" map="H"/>
  <method class="tourma.data.Tournament" name="void removeCoach(tourma.data.Coach)" map="B"/>
  <method class="tourma.data.Tournament" name="void addTeam(tourma.data.Team)" map="B"/>
  <method class="tourma.data.Tournament" name="tourma.data.Clan getClan(java.lang.String)" map="H"/>
  <method class="tourma.data.Tournament" name="void pullClans(java.util.ArrayList)" map="D"/>
  <method class="tourma.data.Tournament" name="boolean isRoundRobin()" map="a"/>
  <method class="tourma.data.Tournament" name="int getActiveCoachNumber()" map="b"/>
  <method class="tourma.data.Tournament" name="void pullGroups(java.util.ArrayList)" map="E"/>
  <method class="tourma.data.Tournament" name="int getClansCount()" map="c"/>
  <method class="tourma.data.Tournament" name="tourma.data.Team getTeam(int)" map="I"/>
  <method class="tourma.data.Tournament" name="int getGroupsCount()" map="d"/>
  <method class="tourma.data.Tournament" name="int getCategoriesCount()" map="e"/>
  <method class="tourma.data.Tournament" name="void exportFullFBB(java.io.File)" map="B"/>
  <method class="tourma.data.Tournament" name="void addCategory(tourma.data.Category)" map="D"/>
  <method class="tourma.data.Tournament" name="void addClan(tourma.data.Clan)" map="D"/>
  <method class="tourma.data.Tournament" name="tourma.data.Tournament resetTournament()" map="f"/>
  <method class="tourma.data.Tournament" name="tourma.data.Tournament getTournament()" map="g"/>
  <method class="tourma.data.Tournament" name="void clearPools()" map="h"/>
  <method class="tourma.data.Tournament" name="void exportNAF(java.io.File)" map="C"/>
  <method class="tourma.data.Tournament" name="java.lang.String getDescription()" map="i"/>
  <method class="tourma.data.Tournament" name="void pullCategories(java.util.ArrayList)" map="F"/>
  <method class="tourma.data.Tournament" name="void pushTeams(java.util.ArrayList)" map="G"/>
  <method class="tourma.data.Tournament" name="void removeCategory(tourma.data.Category)" map="E"/>
  <method class="tourma.data.Tournament" name="void loadXML(java.io.File)" map="D"/>
  <method class="tourma.data.Tournament" name="void pushRounds(java.util.ArrayList)" map="H"/>
  <method class="tourma.data.Tournament" name="void setRoundRobin(boolean)" map="G"/>
  <method class="tourma.data.Tournament" name="java.lang.String generateCSVRanking(int, boolean, boolean)" map="A"/>
  <method class="tourma.data.Tournament" name="tourma.data.Group getGroup(int)" map="J"/>
  <method class="tourma.data.Tournament" name="int getRoundsCount()" map="j"/>
  <method class="tourma.data.Tournament" name="void setClansUpdated(boolean)" map="H"/>
  <method class="tourma.data.Tournament" name="java.awt.image.RenderedImage generateRankingQRCode(int)" map="K"/>
  <method class="tourma.data.Tournament" name="int getPoolCount()" map="k"/>
  <method class="tourma.data.Tournament" name="tourma.data.Category getCategory(int)" map="L"/>
  <method class="tourma.data.Tournament" name="void saveXML(java.io.File, boolean)" map="A"/>
  <method class="tourma.data.Tournament" name="tourma.data.Clan getClan(int)" map="M"/>
  <method class="tourma.data.Tournament" name="void setRoundsUpdated(boolean)" map="I"/>
  <method class="tourma.data.Tournament" name="tourma.data.Parameters getParams()" map="l"/>
  <method class="tourma.data.Tournament" name="int getActiveCompetitorsCount()" map="m"/>
  <method class="tourma.data.Tournament" name="void pushCoachs(java.util.ArrayList)" map="I"/>
  <method class="tourma.data.Tournament" name="void exportFBB(java.io.File)" map="E"/>
  <method class="tourma.data.Tournament" name="void addRound(tourma.data.Round)" map="D"/>
  <method class="tourma.data.Tournament" name="tourma.data.Group getGroup(tourma.data.Coach)" map="C"/>
  <method class="tourma.data.Tournament" name="void setTeamsUpdated(boolean)" map="J"/>
  <method class="tourma.data.Tournament" name="tourma.data.Category getCategory(java.lang.String)" map="I"/>
  <method class="tourma.data.Tournament" name="java.util.HashMap getRosterType()" map="n"/>
  <method class="tourma.data.Tournament" name="void setCup(tourma.data.Cup)" map="A"/>
  <method class="tourma.data.Tournament" name="void pullTeams(java.util.ArrayList)" map="J"/>
  <method class="tourma.data.Tournament" name="void resetUpdated()" map="o"/>
  <method class="tourma.data.Tournament" name="void removeTeam(tourma.data.Team)" map="C"/>
  <method class="tourma.data.Tournament" name="void removeCategory(int)" map="N"/>
  <class name="tourma.data.CupTable" map="X"/>
  <field class="tourma.data.CupTable" name="mCupRounds" map="&#x019b;"/>
  <method class="tourma.data.CupTable" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.CupTable" name="java.util.ArrayList getCupRounds()" map="&#x0188;"/>
  <method class="tourma.data.CupTable" name="org.jdom.Element getXMLElement()" map="A"/>
  <class name="tourma.data.IWithNameAndPicture" map="Y"/>
  <method class="tourma.data.IWithNameAndPicture" name="javax.swing.ImageIcon getPicture()" map="B"/>
  <method class="tourma.data.IWithNameAndPicture" name="java.lang.String getName()" map="C"/>
  <class name="tourma.data.ObjectAnnexRanking" map="Z"/>
  <field class="tourma.data.ObjectAnnexRanking" name="LOG" map="&#x01a8;"/>
  <field class="tourma.data.ObjectAnnexRanking" name="mValue" map="&#x01a9;"/>
  <method class="tourma.data.ObjectAnnexRanking" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.ObjectAnnexRanking" name="int getValue()" map="&#x0192;"/>
  <method class="tourma.data.ObjectAnnexRanking" name="int hashCode()" map="hashCode"/>
  <method class="tourma.data.ObjectAnnexRanking" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.ObjectAnnexRanking" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <class name="tourma.data.Pool" map="_"/>
  <field class="tourma.data.Pool" name="UID" map="&#x019c;"/>
  <field class="tourma.data.Pool" name="LOG" map="&#x019d;"/>
  <field class="tourma.data.Pool" name="sGenUID" map="&#x019e;"/>
  <field class="tourma.data.Pool" name="mName" map="&#x019f;"/>
  <field class="tourma.data.Pool" name="mCompetitors" map="&#x01a0;"/>
  <method class="tourma.data.Pool" name="java.util.ArrayList getCompetitors()" map="&#x0189;"/>
  <method class="tourma.data.Pool" name="void setName(java.lang.String)" map="a"/>
  <method class="tourma.data.Pool" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.Pool" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.Pool" name="void addCompetitor(tourma.data.Competitor)" map="I"/>
  <method class="tourma.data.Pool" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.Pool" name="int getCompetitorCount()" map="&#x018a;"/>
  <method class="tourma.data.Pool" name="java.lang.String getName()" map="&#x018b;"/>
  <method class="tourma.data.Pool" name="tourma.data.Competitor getCompetitor(int)" map="&#x00e4;"/>
  <class name="tourma.data.ObjectRanking" map="a"/>
  <field class="tourma.data.ObjectRanking" name="mValue2" map="&#x01a1;"/>
  <field class="tourma.data.ObjectRanking" name="mValue1" map="&#x01a2;"/>
  <field class="tourma.data.ObjectRanking" name="mObject" map="&#x01a3;"/>
  <field class="tourma.data.ObjectRanking" name="LOG" map="&#x01a4;"/>
  <field class="tourma.data.ObjectRanking" name="mValue5" map="&#x01a5;"/>
  <field class="tourma.data.ObjectRanking" name="mValue4" map="&#x01a6;"/>
  <field class="tourma.data.ObjectRanking" name="mValue3" map="&#x01a7;"/>
  <method class="tourma.data.ObjectRanking" name="int getValue2()" map="&#x018c;"/>
  <method class="tourma.data.ObjectRanking" name="void setValue5(int)" map="&#x00e5;"/>
  <method class="tourma.data.ObjectRanking" name="int hashCode()" map="hashCode"/>
  <method class="tourma.data.ObjectRanking" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="tourma.data.ObjectRanking" name="void setValue4(int)" map="&#x00e6;"/>
  <method class="tourma.data.ObjectRanking" name="int getValue5()" map="&#x018d;"/>
  <method class="tourma.data.ObjectRanking" name="int getValue1()" map="&#x018e;"/>
  <method class="tourma.data.ObjectRanking" name="void setValue3(int)" map="&#x00e7;"/>
  <method class="tourma.data.ObjectRanking" name="void setValue2(int)" map="&#x00e8;"/>
  <method class="tourma.data.ObjectRanking" name="java.lang.Comparable getObject()" map="&#x018f;"/>
  <method class="tourma.data.ObjectRanking" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.ObjectRanking" name="void setValue1(int)" map="&#x00e9;"/>
  <method class="tourma.data.ObjectRanking" name="int getValue4()" map="&#x0190;"/>
  <method class="tourma.data.ObjectRanking" name="void setValue(int, int)" map="B"/>
  <method class="tourma.data.ObjectRanking" name="int getValue3()" map="&#x0191;"/>
  <method class="tourma.data.ObjectRanking" name="int getValue(int)" map="&#x00ea;"/>
  <method class="tourma.data.ObjectRanking" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <class name="tourma.data.CupRound" map="b"/>
  <field class="tourma.data.CupRound" name="mNbMatchs" map="&#x01aa;"/>
  <field class="tourma.data.CupRound" name="mMatchs" map="&#x01ab;"/>
  <method class="tourma.data.CupRound" name="int getNbMatchs()" map="&#x0193;"/>
  <method class="tourma.data.CupRound" name="void setXMLElement(org.jdom.Element)" map="A"/>
  <method class="tourma.data.CupRound" name="java.util.ArrayList getMatchs()" map="&#x0194;"/>
  <method class="tourma.data.CupRound" name="void generateEmptyMatchs()" map="&#x0195;"/>
  <method class="tourma.data.CupRound" name="org.jdom.Element getXMLElement()" map="A"/>
  <class name="tourma.data.Value$e_ValueType" map="_A"/>
  <field class="tourma.data.Value$e_ValueType" name="E_CRITERIA" map="A"/>
  <field class="tourma.data.Value$e_ValueType" name="E_FORMULA" map="B"/>
  <field class="tourma.data.Value$e_ValueType" name="$VALUES" map="C"/>
  <method class="tourma.data.Value$e_ValueType" name="tourma.data.Value$e_ValueType valueOf(java.lang.String)" map="valueOf"/>
  <method class="tourma.data.Value$e_ValueType" name="tourma.data.Value$e_ValueType[] values()" map="values"/>
  <class name="tourma.data.Value" map="c"/>
  <field class="tourma.data.Value" name="mValue2" map="A"/>
  <field class="tourma.data.Value" name="mValue1" map="B"/>
  <field class="tourma.data.Value" name="updated" map="C"/>
  <field class="tourma.data.Value" name="UID" map="D"/>
  <field class="tourma.data.Value" name="mCriteria" map="E"/>
  <field class="tourma.data.Value" name="sGenUID" map="F"/>
  <field class="tourma.data.Value" name="_valueType" map="G"/>
  <field class="tourma.data.Value" name="mFormula" map="H"/>
  <method class="tourma.data.Value" name="boolean isUpdated()" map="A"/>
  <method class="tourma.data.Value" name="int getValue2()" map="B"/>
  <method class="tourma.data.Value" name="void setUpdated(boolean)" map="A"/>
  <method class="tourma.data.Value" name="tourma.data.Criteria getCriteria()" map="C"/>
  <method class="tourma.data.Value" name="int getValue1()" map="D"/>
  <method class="tourma.data.Value" name="void setValue2(int)" map="A"/>
  <method class="tourma.data.Value" name="void setValue1(int)" map="B"/>
  <method class="tourma.data.Value" name="void pull(tourma.data.Value)" map="A"/>
  <method class="tourma.data.Value" name="tourma.data.Formula getFormula()" map="E"/>
  <method class="tourma.data.Value" name="void push(tourma.data.Value)" map="B"/>
  <class name="tourma.data.RosterType" map="d"/>
  <field class="tourma.data.RosterType" name="mRostersNames" map="&#x01ac;"/>
  <field class="tourma.data.RosterType" name="UID" map="&#x01ad;"/>
  <field class="tourma.data.RosterType" name="LOG" map="&#x01ae;"/>
  <field class="tourma.data.RosterType" name="sGenUID" map="&#x01af;"/>
  <field class="tourma.data.RosterType" name="mName" map="&#x01b0;"/>
  <field class="tourma.data.RosterType" name="mRosterTypes" map="&#x01b1;"/>
  <field class="tourma.data.RosterType" name="sBundle" map="&#x01b2;"/>
  <method class="tourma.data.RosterType" name="void initCollection()" map="&#x0196;"/>
  <method class="tourma.data.RosterType" name="java.lang.String getRosterTranslation(java.lang.String)" map="b"/>
  <method class="tourma.data.RosterType" name="void setUID(int)" map="&#x00eb;"/>
  <method class="tourma.data.RosterType" name="void addRosterName(java.lang.String)" map="c"/>
  <method class="tourma.data.RosterType" name="tourma.data.RosterType getRosterType(int)" map="&#x00ec;"/>
  <method class="tourma.data.RosterType" name="void putRosterType(java.lang.String, tourma.data.RosterType)" map="A"/>
  <method class="tourma.data.RosterType" name="java.lang.String translate(java.lang.String)" map="d"/>
  <method class="tourma.data.RosterType" name="java.util.HashMap getRosters()" map="&#x0197;"/>
  <method class="tourma.data.RosterType" name="void setName(java.lang.String)" map="e"/>
  <method class="tourma.data.RosterType" name="void pull(java.util.HashMap)" map="B"/>
  <method class="tourma.data.RosterType" name="java.lang.String getRostersName(int)" map="&#x00ed;"/>
  <method class="tourma.data.RosterType" name="java.lang.String getName()" map="&#x0198;"/>
  <method class="tourma.data.RosterType" name="java.lang.String[] getRostersNames()" map="&#x0199;"/>
  <method class="tourma.data.RosterType" name="tourma.data.RosterType getRosterType(java.lang.String)" map="f"/>
  <method class="tourma.data.RosterType" name="javax.swing.DefaultComboBoxModel getRostersNamesModel()" map="&#x019a;"/>
  <method class="tourma.data.RosterType" name="int getRostersNamesCount()" map="&#x019b;"/>
  <method class="tourma.data.RosterType" name="void newRostersTypes()" map="&#x019c;"/>
  <method class="tourma.data.RosterType" name="org.jdom.Element getXMLElement()" map="A"/>
  <method class="tourma.data.RosterType" name="java.lang.String getRosterName(java.lang.String)" map="g"/>
  <method class="tourma.data.RosterType" name="void newRostersNames()" map="&#x019d;"/>
  <method class="tourma.data.RosterType" name="int getUID()" map="&#x019e;"/>
  <package name="tourma.rmi" map="E"/>
  <class name="tourma.rmi.RMITournament" map="A"/>
  <field class="tourma.rmi.RMITournament" name="mSingleton" map="A"/>
  <method class="tourma.rmi.RMITournament" name="java.util.HashMap getRosterTypes()" map="A"/>
  <method class="tourma.rmi.RMITournament" name="tourma.data.Tournament getTournament()" map="B"/>
  <method class="tourma.rmi.RMITournament" name="tourma.rmi.RMITournament getInstance()" map="C"/>
  <method class="tourma.rmi.RMITournament" name="void setTournament(tourma.data.Tournament)" map="A"/>
  <class name="tourma.rmi.RMIThread" map="B"/>
  <field class="tourma.rmi.RMIThread" name="mStop" map="A"/>
  <field class="tourma.rmi.RMIThread" name="mHostAddress" map="B"/>
  <field class="tourma.rmi.RMIThread" name="period" map="C"/>
  <method class="tourma.rmi.RMIThread" name="void stop()" map="A"/>
  <method class="tourma.rmi.RMIThread" name="void run()" map="run"/>
  <package name="tourma.languages" map="F"/>
  <class name="tourma.languages.Translate" map="A"/>
  <field class="tourma.languages.Translate" name="sBundle" map="A"/>
  <method class="tourma.languages.Translate" name="java.lang.String translate(java.lang.String)" map="A"/>
  <package name="tourma.tableModel" map="G"/>
  <class name="tourma.tableModel.MjtFormulas" map="A"/>
  <field class="tourma.tableModel.MjtFormulas" name="mParams" map="A"/>
  <method class="tourma.tableModel.MjtFormulas" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <method class="tourma.tableModel.MjtFormulas" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="tourma.tableModel.MjtFormulas" name="void setValueAt(java.lang.Object, int, int)" map="setValueAt"/>
  <method class="tourma.tableModel.MjtFormulas" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtFormulas" name="int getRowCount()" map="getRowCount"/>
  <method class="tourma.tableModel.MjtFormulas" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtFormulas" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtFormulas" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.tableModel.MjtMatches" map="B"/>
  <field class="tourma.tableModel.MjtMatches" name="mLocked" map="A"/>
  <field class="tourma.tableModel.MjtMatches" name="mNafOnly" map="B"/>
  <field class="tourma.tableModel.MjtMatches" name="mFull" map="C"/>
  <field class="tourma.tableModel.MjtMatches" name="mTeamTournament" map="D"/>
  <field class="tourma.tableModel.MjtMatches" name="mMatchs" map="E"/>
  <method class="tourma.tableModel.MjtMatches" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtMatches" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="tourma.tableModel.MjtMatches" name="void updateFormulasValues(int, int)" map="A"/>
  <method class="tourma.tableModel.MjtMatches" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtMatches" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <method class="tourma.tableModel.MjtMatches" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtMatches" name="int getRowCount()" map="getRowCount"/>
  <method class="tourma.tableModel.MjtMatches" name="void setValueAt(java.lang.Object, int, int)" map="setValueAt"/>
  <method class="tourma.tableModel.MjtMatches" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <class name="tourma.tableModel.MjtRanking" map="C"/>
  <field class="tourma.tableModel.MjtRanking" name="mDetails" map="&#x0122;"/>
  <field class="tourma.tableModel.MjtRanking" name="mRound" map="&#x0123;"/>
  <field class="tourma.tableModel.MjtRanking" name="mRoundOnly" map="&#x0124;"/>
  <field class="tourma.tableModel.MjtRanking" name="mRankingType5" map="&#x0125;"/>
  <field class="tourma.tableModel.MjtRanking" name="mRankingType4" map="&#x0126;"/>
  <field class="tourma.tableModel.MjtRanking" name="mRankingType3" map="&#x0127;"/>
  <field class="tourma.tableModel.MjtRanking" name="mRankingType2" map="&#x0128;"/>
  <field class="tourma.tableModel.MjtRanking" name="mRankingType1" map="&#x0129;"/>
  <field class="tourma.tableModel.MjtRanking" name="mDatas" map="&#x012a;"/>
  <field class="tourma.tableModel.MjtRanking" name="mObjects" map="&#x012b;"/>
  <method class="tourma.tableModel.MjtRanking" name="tourma.data.Criteria getCriteriaByValue(int)" map="x"/>
  <method class="tourma.tableModel.MjtRanking" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtRanking" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <method class="tourma.tableModel.MjtRanking" name="int getRound()" map="&#x0119;"/>
  <method class="tourma.tableModel.MjtRanking" name="java.lang.String getDetail()" map="&#x0118;"/>
  <method class="tourma.tableModel.MjtRanking" name="int getSubtypeByValue(int)" map="y"/>
  <method class="tourma.tableModel.MjtRanking" name="tourma.data.Formula getFormulaByValue(int)" map="z"/>
  <method class="tourma.tableModel.MjtRanking" name="tourma.data.ObjectRanking getSortedObject(int)" map="w"/>
  <method class="tourma.tableModel.MjtRanking" name="int getSortedValue(int, int)" map="A"/>
  <method class="tourma.tableModel.MjtRanking" name="void setDetail(java.lang.String)" map="T"/>
  <method class="tourma.tableModel.MjtRanking" name="int getValueFromArray(int, java.util.ArrayList)" map="A"/>
  <method class="tourma.tableModel.MjtRanking" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtRanking" name="java.lang.String convertVND(int)" map="&#x00a2;"/>
  <method class="tourma.tableModel.MjtRanking" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtRanking" name="void removeMinValue(java.util.ArrayList)" map="L"/>
  <method class="tourma.tableModel.MjtRanking" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="tourma.tableModel.MjtRanking" name="java.lang.String getRankingString(int)" map="&#x00a3;"/>
  <method class="tourma.tableModel.MjtRanking" name="void removeMaxValue(java.util.ArrayList)" map="M"/>
  <method class="tourma.tableModel.MjtRanking" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <method class="tourma.tableModel.MjtRanking" name="int getRowCount()" map="getRowCount"/>
  <class name="tourma.tableModel.MjtAnnexRankTeam" map="D"/>
  <method class="tourma.tableModel.MjtAnnexRankTeam" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtAnnexRankTeam" name="void updateHeadByHeadValue(int, int, tourma.data.ObjectAnnexRanking, tourma.data.ObjectAnnexRanking)" map="A"/>
  <method class="tourma.tableModel.MjtAnnexRankTeam" name="void sortDatas()" map="&#x011c;"/>
  <method class="tourma.tableModel.MjtAnnexRankTeam" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtAnnexRankTeam" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtAnnexRankTeam" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.tableModel.MjtRankingTeam" map="E"/>
  <field class="tourma.tableModel.MjtRankingTeam" name="LOG" map="&#x012c;"/>
  <field class="tourma.tableModel.MjtRankingTeam" name="mTeamVictory" map="&#x012d;"/>
  <method class="tourma.tableModel.MjtRankingTeam" name="void updateHeadByHeadValue(int, int, tourma.data.ObjectRanking, tourma.data.ObjectRanking)" map="A"/>
  <method class="tourma.tableModel.MjtRankingTeam" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtRankingTeam" name="void sortDatas()" map="&#x011a;"/>
  <method class="tourma.tableModel.MjtRankingTeam" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtRankingTeam" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtRankingTeam" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.tableModel.MjtMatchTeams" map="F"/>
  <field class="tourma.tableModel.MjtMatchTeams" name="mRound" map="A"/>
  <field class="tourma.tableModel.MjtMatchTeams" name="mTeams" map="B"/>
  <method class="tourma.tableModel.MjtMatchTeams" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <method class="tourma.tableModel.MjtMatchTeams" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="tourma.tableModel.MjtMatchTeams" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtMatchTeams" name="int getRowCount()" map="getRowCount"/>
  <method class="tourma.tableModel.MjtMatchTeams" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtMatchTeams" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtMatchTeams" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.tableModel.MjtAnnexRank" map="G"/>
  <field class="tourma.tableModel.MjtAnnexRank" name="mSubtype" map="&#x012e;"/>
  <field class="tourma.tableModel.MjtAnnexRank" name="mCriteria" map="&#x012f;"/>
  <field class="tourma.tableModel.MjtAnnexRank" name="mType" map="&#x0130;"/>
  <field class="tourma.tableModel.MjtAnnexRank" name="mFormula" map="&#x0131;"/>
  <field class="tourma.tableModel.MjtAnnexRank" name="mFullRanking" map="&#x0132;"/>
  <method class="tourma.tableModel.MjtAnnexRank" name="tourma.data.Criteria getCriteria()" map="&#x011b;"/>
  <method class="tourma.tableModel.MjtAnnexRank" name="void setDetail(java.lang.String)" map="T"/>
  <method class="tourma.tableModel.MjtAnnexRank" name="int getRowCount()" map="getRowCount"/>
  <method class="tourma.tableModel.MjtAnnexRank" name="java.lang.String getDetail()" map="&#x0118;"/>
  <method class="tourma.tableModel.MjtAnnexRank" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtAnnexRank" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.tableModel.MjtCriterias" map="H"/>
  <field class="tourma.tableModel.MjtCriterias" name="mParams" map="A"/>
  <method class="tourma.tableModel.MjtCriterias" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <method class="tourma.tableModel.MjtCriterias" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="tourma.tableModel.MjtCriterias" name="void setValueAt(java.lang.Object, int, int)" map="setValueAt"/>
  <method class="tourma.tableModel.MjtCriterias" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtCriterias" name="int getRowCount()" map="getRowCount"/>
  <method class="tourma.tableModel.MjtCriterias" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtCriterias" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtCriterias" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.tableModel.MjtManualMatchs" map="I"/>
  <field class="tourma.tableModel.MjtManualMatchs" name="mComps" map="A"/>
  <method class="tourma.tableModel.MjtManualMatchs" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <method class="tourma.tableModel.MjtManualMatchs" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="tourma.tableModel.MjtManualMatchs" name="void setValueAt(java.lang.Object, int, int)" map="setValueAt"/>
  <method class="tourma.tableModel.MjtManualMatchs" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtManualMatchs" name="int getRowCount()" map="getRowCount"/>
  <method class="tourma.tableModel.MjtManualMatchs" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtManualMatchs" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtManualMatchs" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.tableModel.MjtAnnexRankIndiv" map="J"/>
  <field class="tourma.tableModel.MjtAnnexRankIndiv" name="mTeamTournament" map="&#x0133;"/>
  <method class="tourma.tableModel.MjtAnnexRankIndiv" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtAnnexRankIndiv" name="void updateHeadByHeadValue(int, int, tourma.data.ObjectAnnexRanking, tourma.data.ObjectAnnexRanking)" map="B"/>
  <method class="tourma.tableModel.MjtAnnexRankIndiv" name="void sortDatas()" map="&#x011d;"/>
  <method class="tourma.tableModel.MjtAnnexRankIndiv" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtAnnexRankIndiv" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.tableModel.MjtAnnexRankClan" map="K"/>
  <field class="tourma.tableModel.MjtAnnexRankClan" name="LOG" map="&#x0134;"/>
  <method class="tourma.tableModel.MjtAnnexRankClan" name="void sortDatasCoach()" map="&#x011e;"/>
  <method class="tourma.tableModel.MjtAnnexRankClan" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtAnnexRankClan" name="void sortDatasTeam()" map="&#x011f;"/>
  <method class="tourma.tableModel.MjtAnnexRankClan" name="void sortDatas()" map="&#x0120;"/>
  <method class="tourma.tableModel.MjtAnnexRankClan" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtAnnexRankClan" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtAnnexRankClan" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.tableModel.MjtCriteriasTeamBonus" map="L"/>
  <field class="tourma.tableModel.MjtCriteriasTeamBonus" name="mTour" map="A"/>
  <field class="tourma.tableModel.MjtCriteriasTeamBonus" name="mParams" map="B"/>
  <method class="tourma.tableModel.MjtCriteriasTeamBonus" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <method class="tourma.tableModel.MjtCriteriasTeamBonus" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="tourma.tableModel.MjtCriteriasTeamBonus" name="void setValueAt(java.lang.Object, int, int)" map="setValueAt"/>
  <method class="tourma.tableModel.MjtCriteriasTeamBonus" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtCriteriasTeamBonus" name="int getRowCount()" map="getRowCount"/>
  <method class="tourma.tableModel.MjtCriteriasTeamBonus" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtCriteriasTeamBonus" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtCriteriasTeamBonus" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.tableModel.MjtCriteriasIndivBonus" map="M"/>
  <field class="tourma.tableModel.MjtCriteriasIndivBonus" name="mTour" map="A"/>
  <field class="tourma.tableModel.MjtCriteriasIndivBonus" name="mParams" map="B"/>
  <method class="tourma.tableModel.MjtCriteriasIndivBonus" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <method class="tourma.tableModel.MjtCriteriasIndivBonus" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="tourma.tableModel.MjtCriteriasIndivBonus" name="void setValueAt(java.lang.Object, int, int)" map="setValueAt"/>
  <method class="tourma.tableModel.MjtCriteriasIndivBonus" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtCriteriasIndivBonus" name="int getRowCount()" map="getRowCount"/>
  <method class="tourma.tableModel.MjtCriteriasIndivBonus" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtCriteriasIndivBonus" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtCriteriasIndivBonus" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.tableModel.MjtRankingClan" map="N"/>
  <method class="tourma.tableModel.MjtRankingClan" name="void sortDatasCoach()" map="&#x0121;"/>
  <method class="tourma.tableModel.MjtRankingClan" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtRankingClan" name="void sortDatasTeam()" map="&#x0122;"/>
  <method class="tourma.tableModel.MjtRankingClan" name="void sortDatas()" map="&#x0123;"/>
  <method class="tourma.tableModel.MjtRankingClan" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtRankingClan" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtRankingClan" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.tableModel.MjtTeams" map="O"/>
  <field class="tourma.tableModel.MjtTeams" name="mTeams" map="A"/>
  <method class="tourma.tableModel.MjtTeams" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <method class="tourma.tableModel.MjtTeams" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="tourma.tableModel.MjtTeams" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtTeams" name="int getRowCount()" map="getRowCount"/>
  <method class="tourma.tableModel.MjtTeams" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtTeams" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtTeams" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.tableModel.MjtRankingIndiv" map="P"/>
  <field class="tourma.tableModel.MjtRankingIndiv" name="mForPool" map="&#x0135;"/>
  <field class="tourma.tableModel.MjtRankingIndiv" name="mTeamTournament" map="&#x0136;"/>
  <field class="tourma.tableModel.MjtRankingIndiv" name="mForCup" map="&#x0137;"/>
  <method class="tourma.tableModel.MjtRankingIndiv" name="void updateHeadByHeadValue(int, int, tourma.data.ObjectRanking, tourma.data.ObjectRanking)" map="B"/>
  <method class="tourma.tableModel.MjtRankingIndiv" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtRankingIndiv" name="void sortDatas()" map="&#x0124;"/>
  <method class="tourma.tableModel.MjtRankingIndiv" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtRankingIndiv" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtRankingIndiv" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.tableModel.mjtTeamsAndCoaches" map="Q"/>
  <field class="tourma.tableModel.mjtTeamsAndCoaches" name="_tour" map="A"/>
  <field class="tourma.tableModel.mjtTeamsAndCoaches" name="_byTeam" map="B"/>
  <method class="tourma.tableModel.mjtTeamsAndCoaches" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.mjtTeamsAndCoaches" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="tourma.tableModel.mjtTeamsAndCoaches" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.mjtTeamsAndCoaches" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <method class="tourma.tableModel.mjtTeamsAndCoaches" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.mjtTeamsAndCoaches" name="void setLabelLF(int, int, boolean, boolean, javax.swing.JLabel)" map="A"/>
  <method class="tourma.tableModel.mjtTeamsAndCoaches" name="int getRowCount()" map="getRowCount"/>
  <method class="tourma.tableModel.mjtTeamsAndCoaches" name="void setValueAt(java.lang.Object, int, int)" map="setValueAt"/>
  <method class="tourma.tableModel.mjtTeamsAndCoaches" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <class name="tourma.tableModel.MjtRankingManual" map="R"/>
  <field class="tourma.tableModel.MjtRankingManual" name="LOG" map="&#x0138;"/>
  <method class="tourma.tableModel.MjtRankingManual" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtRankingManual" name="void addData(tourma.data.Competitor)" map="H"/>
  <method class="tourma.tableModel.MjtRankingManual" name="void sortDatas()" map="&#x0125;"/>
  <method class="tourma.tableModel.MjtRankingManual" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtRankingManual" name="void addDatas(java.util.ArrayList)" map="N"/>
  <method class="tourma.tableModel.MjtRankingManual" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtRankingManual" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.tableModel.MjtCoaches" map="S"/>
  <field class="tourma.tableModel.MjtCoaches" name="t" map="A"/>
  <method class="tourma.tableModel.MjtCoaches" name="boolean isCellEditable(int, int)" map="isCellEditable"/>
  <method class="tourma.tableModel.MjtCoaches" name="java.lang.Class getColumnClass(int)" map="getColumnClass"/>
  <method class="tourma.tableModel.MjtCoaches" name="java.lang.String getColumnName(int)" map="getColumnName"/>
  <method class="tourma.tableModel.MjtCoaches" name="int getRowCount()" map="getRowCount"/>
  <method class="tourma.tableModel.MjtCoaches" name="int getColumnCount()" map="getColumnCount"/>
  <method class="tourma.tableModel.MjtCoaches" name="java.awt.Component getTableCellRendererComponent(javax.swing.JTable, java.lang.Object, boolean, boolean, int, int)" map="getTableCellRendererComponent"/>
  <method class="tourma.tableModel.MjtCoaches" name="java.lang.Object getValueAt(int, int)" map="getValueAt"/>
  <class name="tourma.JdgCupOptions$9" map="9"/>
  <field class="tourma.JdgCupOptions$9" name="this$0" map="A"/>
  <method class="tourma.JdgCupOptions$9" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCupOptions$8" map="8"/>
  <field class="tourma.JdgCupOptions$8" name="this$0" map="A"/>
  <method class="tourma.JdgCupOptions$8" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCupOptions$7" map="7"/>
  <field class="tourma.JdgCupOptions$7" name="this$0" map="A"/>
  <method class="tourma.JdgCupOptions$7" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCupOptions$6" map="6"/>
  <field class="tourma.JdgCupOptions$6" name="this$0" map="A"/>
  <method class="tourma.JdgCupOptions$6" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCupOptions$15" map="15"/>
  <field class="tourma.JdgCupOptions$15" name="this$0" map="A"/>
  <method class="tourma.JdgCupOptions$15" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCupOptions$5" map="5"/>
  <field class="tourma.JdgCupOptions$5" name="this$0" map="A"/>
  <method class="tourma.JdgCupOptions$5" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCupOptions$14" map="14"/>
  <field class="tourma.JdgCupOptions$14" name="this$0" map="A"/>
  <method class="tourma.JdgCupOptions$14" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCupOptions$13" map="13"/>
  <field class="tourma.JdgCupOptions$13" name="this$0" map="A"/>
  <method class="tourma.JdgCupOptions$13" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCupOptions$4" map="4"/>
  <field class="tourma.JdgCupOptions$4" name="this$0" map="A"/>
  <method class="tourma.JdgCupOptions$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCupOptions$12" map="12"/>
  <field class="tourma.JdgCupOptions$12" name="this$0" map="A"/>
  <method class="tourma.JdgCupOptions$12" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCupOptions$3" map="3"/>
  <field class="tourma.JdgCupOptions$3" name="this$0" map="A"/>
  <method class="tourma.JdgCupOptions$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCupOptions$2" map="2"/>
  <field class="tourma.JdgCupOptions$2" name="this$0" map="A"/>
  <method class="tourma.JdgCupOptions$2" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="tourma.JdgCupOptions$11" map="11"/>
  <field class="tourma.JdgCupOptions$11" name="this$0" map="A"/>
  <method class="tourma.JdgCupOptions$11" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCupOptions$10" map="10"/>
  <field class="tourma.JdgCupOptions$10" name="this$0" map="A"/>
  <method class="tourma.JdgCupOptions$10" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCupOptions$1" map="1"/>
  <field class="tourma.JdgCupOptions$1" name="this$0" map="A"/>
  <method class="tourma.JdgCupOptions$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCupOptions" map="A"/>
  <field class="tourma.JdgCupOptions" name="jPanel7" map="A"/>
  <field class="tourma.JdgCupOptions" name="jPanel6" map="B"/>
  <field class="tourma.JdgCupOptions" name="jPanel5" map="C"/>
  <field class="tourma.JdgCupOptions" name="jrbTypeClassic" map="D"/>
  <field class="tourma.JdgCupOptions" name="jPanel4" map="E"/>
  <field class="tourma.JdgCupOptions" name="jrbRankingOrder" map="F"/>
  <field class="tourma.JdgCupOptions" name="jPanel3" map="G"/>
  <field class="tourma.JdgCupOptions" name="bgCupType" map="H"/>
  <field class="tourma.JdgCupOptions" name="jrbClassic3rd" map="I"/>
  <field class="tourma.JdgCupOptions" name="jPanel2" map="J"/>
  <field class="tourma.JdgCupOptions" name="jPanel1" map="K"/>
  <field class="tourma.JdgCupOptions" name="bgInitialDraw" map="L"/>
  <field class="tourma.JdgCupOptions" name="jrbCategoriesCrossed" map="M"/>
  <field class="tourma.JdgCupOptions" name="jrbCategoriesAbsoluteRanking" map="N"/>
  <field class="tourma.JdgCupOptions" name="jspNumberOfCupRounds" map="O"/>
  <field class="tourma.JdgCupOptions" name="jbtOK" map="P"/>
  <field class="tourma.JdgCupOptions" name="jrbCategoriesMixed" map="Q"/>
  <field class="tourma.JdgCupOptions" name="jcxSwissForOthers" map="R"/>
  <field class="tourma.JdgCupOptions" name="jrbDrawRandom" map="S"/>
  <field class="tourma.JdgCupOptions" name="jcxShuffle" map="T"/>
  <field class="tourma.JdgCupOptions" name="mCup" map="U"/>
  <field class="tourma.JdgCupOptions" name="jrbCategoriesNotMixed" map="V"/>
  <field class="tourma.JdgCupOptions" name="jrbRankingMatchs" map="W"/>
  <field class="tourma.JdgCupOptions" name="jLabel3" map="X"/>
  <field class="tourma.JdgCupOptions" name="jLabel2" map="Y"/>
  <field class="tourma.JdgCupOptions" name="jrbLooserCup" map="Z"/>
  <field class="tourma.JdgCupOptions" name="jLabel1" map="_"/>
  <field class="tourma.JdgCupOptions" name="jrbManualChoice" map="a"/>
  <method class="tourma.JdgCupOptions" name="void access$300(tourma.JdgCupOptions, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgCupOptions" name="void jspNumberOfCupRoundsStateChanged(javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.JdgCupOptions" name="void access$700(tourma.JdgCupOptions, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgCupOptions" name="void access$1000(tourma.JdgCupOptions, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgCupOptions" name="void jrbTypeClassicActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgCupOptions" name="void access$200(tourma.JdgCupOptions, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgCupOptions" name="void access$600(tourma.JdgCupOptions, java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.JdgCupOptions" name="void initComponents()" map="A"/>
  <method class="tourma.JdgCupOptions" name="void access$500(tourma.JdgCupOptions, java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.JdgCupOptions" name="void jrbCategoriesNotMixedActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgCupOptions" name="void jrbManualChoiceActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgCupOptions" name="void access$000(tourma.JdgCupOptions, java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.JdgCupOptions" name="void jrbRankingOrderActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgCupOptions" name="void readObject(java.io.ObjectInputStream)" map="A"/>
  <method class="tourma.JdgCupOptions" name="void jrbRankingMatchsActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.JdgCupOptions" name="void access$100(tourma.JdgCupOptions, javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.JdgCupOptions" name="void jcxShuffleActionPerformed(java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.JdgCupOptions" name="void jrbLooserCupActionPerformed(java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.JdgCupOptions" name="void jrbCategoriesAbsoluteRankingActionPerformed(java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.JdgCupOptions" name="void access$1400(tourma.JdgCupOptions, java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.JdgCupOptions" name="void jrbCategoriesCrossedActionPerformed(java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.JdgCupOptions" name="void access$1300(tourma.JdgCupOptions, java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.JdgCupOptions" name="void jcxSwissForOthersActionPerformed(java.awt.event.ActionEvent)" map="J"/>
  <method class="tourma.JdgCupOptions" name="void jrbClassic3rdActionPerformed(java.awt.event.ActionEvent)" map="K"/>
  <method class="tourma.JdgCupOptions" name="void access$900(tourma.JdgCupOptions, java.awt.event.ActionEvent)" map="J"/>
  <method class="tourma.JdgCupOptions" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="L"/>
  <method class="tourma.JdgCupOptions" name="void access$1200(tourma.JdgCupOptions, java.awt.event.ActionEvent)" map="K"/>
  <method class="tourma.JdgCupOptions" name="void jrbCategoriesMixedActionPerformed(java.awt.event.ActionEvent)" map="M"/>
  <method class="tourma.JdgCupOptions" name="void writeObject(java.io.ObjectOutputStream)" map="A"/>
  <method class="tourma.JdgCupOptions" name="void access$400(tourma.JdgCupOptions, java.awt.event.ActionEvent)" map="L"/>
  <method class="tourma.JdgCupOptions" name="void update()" map="B"/>
  <method class="tourma.JdgCupOptions" name="void access$800(tourma.JdgCupOptions, java.awt.event.ActionEvent)" map="M"/>
  <method class="tourma.JdgCupOptions" name="void access$1100(tourma.JdgCupOptions, java.awt.event.ActionEvent)" map="N"/>
  <method class="tourma.JdgCupOptions" name="void jrbDrawRandomActionPerformed(java.awt.event.ActionEvent)" map="N"/>
  <class name="tourma.JdgChangePairing$2" map="2"/>
  <field class="tourma.JdgChangePairing$2" name="this$0" map="A"/>
  <method class="tourma.JdgChangePairing$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgChangePairing$1" map="1"/>
  <field class="tourma.JdgChangePairing$1" name="this$0" map="A"/>
  <method class="tourma.JdgChangePairing$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgChangePairing" map="B"/>
  <field class="tourma.JdgChangePairing" name="jPanel1" map="A"/>
  <field class="tourma.JdgChangePairing" name="jsp" map="B"/>
  <field class="tourma.JdgChangePairing" name="mRound" map="C"/>
  <field class="tourma.JdgChangePairing" name="mPlayersSelected" map="D"/>
  <field class="tourma.JdgChangePairing" name="jbtCancel" map="E"/>
  <field class="tourma.JdgChangePairing" name="mPlayers" map="F"/>
  <field class="tourma.JdgChangePairing" name="jbtOK" map="G"/>
  <field class="tourma.JdgChangePairing" name="jpnMatchs" map="H"/>
  <field class="tourma.JdgChangePairing" name="mPlayersTmp" map="I"/>
  <method class="tourma.JdgChangePairing" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="tourma.JdgChangePairing" name="void readObject(java.io.ObjectInputStream)" map="A"/>
  <method class="tourma.JdgChangePairing" name="void access$100(tourma.JdgChangePairing, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgChangePairing" name="void initComponents()" map="A"/>
  <method class="tourma.JdgChangePairing" name="void jbtCancelActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgChangePairing" name="void writeObject(java.io.ObjectOutputStream)" map="A"/>
  <method class="tourma.JdgChangePairing" name="void access$000(tourma.JdgChangePairing, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgChangePairing" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgChangePairing" name="void update()" map="B"/>
  <class name="tourma.JdgTeam$9" map="9"/>
  <field class="tourma.JdgTeam$9" name="this$0" map="A"/>
  <field class="tourma.JdgTeam$9" name="strings" map="B"/>
  <method class="tourma.JdgTeam$9" name="java.lang.Object getElementAt(int)" map="getElementAt"/>
  <method class="tourma.JdgTeam$9" name="int getSize()" map="getSize"/>
  <class name="tourma.JdgTeam$8" map="8"/>
  <field class="tourma.JdgTeam$8" name="this$0" map="A"/>
  <method class="tourma.JdgTeam$8" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgTeam$7" map="7"/>
  <field class="tourma.JdgTeam$7" name="this$0" map="A"/>
  <method class="tourma.JdgTeam$7" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgTeam$6" map="6"/>
  <field class="tourma.JdgTeam$6" name="this$0" map="A"/>
  <method class="tourma.JdgTeam$6" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgTeam$5" map="5"/>
  <field class="tourma.JdgTeam$5" name="this$0" map="A"/>
  <method class="tourma.JdgTeam$5" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgTeam$4" map="4"/>
  <field class="tourma.JdgTeam$4" name="this$0" map="A"/>
  <method class="tourma.JdgTeam$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgTeam$3" map="3"/>
  <field class="tourma.JdgTeam$3" name="this$0" map="A"/>
  <method class="tourma.JdgTeam$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgTeam$2" map="2"/>
  <field class="tourma.JdgTeam$2" name="this$0" map="A"/>
  <method class="tourma.JdgTeam$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgTeam$1" map="1"/>
  <field class="tourma.JdgTeam$1" name="this$0" map="A"/>
  <method class="tourma.JdgTeam$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgTeam" map="C"/>
  <field class="tourma.JdgTeam" name="jPanel7" map="A"/>
  <field class="tourma.JdgTeam" name="jcbClan" map="B"/>
  <field class="tourma.JdgTeam" name="jPanel5" map="C"/>
  <field class="tourma.JdgTeam" name="jbtAddCategory" map="D"/>
  <field class="tourma.JdgTeam" name="jPanel3" map="E"/>
  <field class="tourma.JdgTeam" name="jpnBtns1" map="F"/>
  <field class="tourma.JdgTeam" name="jPanel2" map="G"/>
  <field class="tourma.JdgTeam" name="jPanel1" map="H"/>
  <field class="tourma.JdgTeam" name="jbtAvatar" map="I"/>
  <field class="tourma.JdgTeam" name="newTeam" map="J"/>
  <field class="tourma.JdgTeam" name="jbtRemove" map="K"/>
  <field class="tourma.JdgTeam" name="jbtModify" map="L"/>
  <field class="tourma.JdgTeam" name="jScrollPane3" map="M"/>
  <field class="tourma.JdgTeam" name="mTeam" map="N"/>
  <field class="tourma.JdgTeam" name="jtfNom" map="O"/>
  <field class="tourma.JdgTeam" name="jScrollPane1" map="P"/>
  <field class="tourma.JdgTeam" name="LOG" map="Q"/>
  <field class="tourma.JdgTeam" name="jlsCategories" map="R"/>
  <field class="tourma.JdgTeam" name="jbtOK" map="S"/>
  <field class="tourma.JdgTeam" name="jbtCancel" map="T"/>
  <field class="tourma.JdgTeam" name="mTour" map="U"/>
  <field class="tourma.JdgTeam" name="jbtAdd" map="V"/>
  <field class="tourma.JdgTeam" name="jtbCoachs" map="W"/>
  <field class="tourma.JdgTeam" name="jLabel2" map="X"/>
  <field class="tourma.JdgTeam" name="jLabel1" map="Y"/>
  <field class="tourma.JdgTeam" name="jbtDelCategory" map="Z"/>
  <field class="tourma.JdgTeam" name="jpnCoachButtons" map="_"/>
  <method class="tourma.JdgTeam" name="void access$100(tourma.JdgTeam, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgTeam" name="javax.swing.ImageIcon resize(javax.swing.ImageIcon, int, int)" map="A"/>
  <method class="tourma.JdgTeam" name="void access$200(tourma.JdgTeam, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgTeam" name="void jbtAddActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgTeam" name="void initComponents()" map="A"/>
  <method class="tourma.JdgTeam" name="void access$300(tourma.JdgTeam, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgTeam" name="void jbtAvatarActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgTeam" name="void jbtCancelActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgTeam" name="java.util.List getImagesResources(java.lang.String)" map="A"/>
  <method class="tourma.JdgTeam" name="void access$400(tourma.JdgTeam, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgTeam" name="void access$500(tourma.JdgTeam, java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.JdgTeam" name="void access$000(tourma.JdgTeam, java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.JdgTeam" name="void access$600(tourma.JdgTeam, java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.JdgTeam" name="void readObject(java.io.ObjectInputStream)" map="A"/>
  <method class="tourma.JdgTeam" name="void jbtModifyActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgTeam" name="void access$700(tourma.JdgTeam, java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.JdgTeam" name="void jbtAddCategoryActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.JdgTeam" name="void jbtDelCategoryActionPerformed(java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.JdgTeam" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.JdgTeam" name="void writeObject(java.io.ObjectOutputStream)" map="A"/>
  <method class="tourma.JdgTeam" name="void update()" map="B"/>
  <method class="tourma.JdgTeam" name="void jbtRemoveActionPerformed(java.awt.event.ActionEvent)" map="H"/>
  <class name="tourma.MainFrame$59" map="59"/>
  <field class="tourma.MainFrame$59" name="this$0" map="A"/>
  <method class="tourma.MainFrame$59" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$58" map="58"/>
  <field class="tourma.MainFrame$58" name="this$0" map="A"/>
  <method class="tourma.MainFrame$58" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$57" map="57"/>
  <field class="tourma.MainFrame$57" name="this$0" map="A"/>
  <method class="tourma.MainFrame$57" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$56" map="56"/>
  <field class="tourma.MainFrame$56" name="this$0" map="A"/>
  <method class="tourma.MainFrame$56" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$55" map="55"/>
  <field class="tourma.MainFrame$55" name="this$0" map="A"/>
  <method class="tourma.MainFrame$55" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$54" map="54"/>
  <field class="tourma.MainFrame$54" name="this$0" map="A"/>
  <method class="tourma.MainFrame$54" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$53" map="53"/>
  <field class="tourma.MainFrame$53" name="this$0" map="A"/>
  <method class="tourma.MainFrame$53" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$52" map="52"/>
  <field class="tourma.MainFrame$52" name="this$0" map="A"/>
  <method class="tourma.MainFrame$52" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$51" map="51"/>
  <field class="tourma.MainFrame$51" name="this$0" map="A"/>
  <method class="tourma.MainFrame$51" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$50" map="50"/>
  <field class="tourma.MainFrame$50" name="this$0" map="A"/>
  <method class="tourma.MainFrame$50" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$49" map="49"/>
  <field class="tourma.MainFrame$49" name="this$0" map="A"/>
  <method class="tourma.MainFrame$49" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$48" map="48"/>
  <field class="tourma.MainFrame$48" name="this$0" map="A"/>
  <method class="tourma.MainFrame$48" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$47" map="47"/>
  <field class="tourma.MainFrame$47" name="this$0" map="A"/>
  <method class="tourma.MainFrame$47" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$46" map="46"/>
  <field class="tourma.MainFrame$46" name="this$0" map="A"/>
  <method class="tourma.MainFrame$46" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$45" map="45"/>
  <field class="tourma.MainFrame$45" name="this$0" map="A"/>
  <method class="tourma.MainFrame$45" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$44" map="44"/>
  <field class="tourma.MainFrame$44" name="this$0" map="A"/>
  <method class="tourma.MainFrame$44" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$43" map="43"/>
  <field class="tourma.MainFrame$43" name="this$0" map="A"/>
  <method class="tourma.MainFrame$43" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$42" map="42"/>
  <field class="tourma.MainFrame$42" name="this$0" map="A"/>
  <method class="tourma.MainFrame$42" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$41" map="41"/>
  <field class="tourma.MainFrame$41" name="this$0" map="A"/>
  <method class="tourma.MainFrame$41" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$40" map="40"/>
  <field class="tourma.MainFrame$40" name="this$0" map="A"/>
  <method class="tourma.MainFrame$40" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$39" map="39"/>
  <field class="tourma.MainFrame$39" name="this$0" map="A"/>
  <method class="tourma.MainFrame$39" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$38" map="38"/>
  <field class="tourma.MainFrame$38" name="this$0" map="A"/>
  <method class="tourma.MainFrame$38" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$37" map="37"/>
  <field class="tourma.MainFrame$37" name="this$0" map="A"/>
  <method class="tourma.MainFrame$37" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$36" map="36"/>
  <field class="tourma.MainFrame$36" name="this$0" map="A"/>
  <method class="tourma.MainFrame$36" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$35" map="35"/>
  <field class="tourma.MainFrame$35" name="this$0" map="A"/>
  <method class="tourma.MainFrame$35" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$34" map="34"/>
  <field class="tourma.MainFrame$34" name="this$0" map="A"/>
  <method class="tourma.MainFrame$34" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$33" map="33"/>
  <field class="tourma.MainFrame$33" name="this$0" map="A"/>
  <method class="tourma.MainFrame$33" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$32" map="32"/>
  <field class="tourma.MainFrame$32" name="this$0" map="A"/>
  <method class="tourma.MainFrame$32" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$31" map="31"/>
  <field class="tourma.MainFrame$31" name="this$0" map="A"/>
  <method class="tourma.MainFrame$31" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$30" map="30"/>
  <field class="tourma.MainFrame$30" name="this$0" map="A"/>
  <method class="tourma.MainFrame$30" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$29" map="29"/>
  <field class="tourma.MainFrame$29" name="this$0" map="A"/>
  <method class="tourma.MainFrame$29" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$28" map="28"/>
  <field class="tourma.MainFrame$28" name="this$0" map="A"/>
  <method class="tourma.MainFrame$28" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$27" map="27"/>
  <field class="tourma.MainFrame$27" name="this$0" map="A"/>
  <method class="tourma.MainFrame$27" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$26" map="26"/>
  <field class="tourma.MainFrame$26" name="this$0" map="A"/>
  <method class="tourma.MainFrame$26" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$25" map="25"/>
  <field class="tourma.MainFrame$25" name="this$0" map="A"/>
  <method class="tourma.MainFrame$25" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$24" map="24"/>
  <field class="tourma.MainFrame$24" name="this$0" map="A"/>
  <method class="tourma.MainFrame$24" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$23" map="23"/>
  <field class="tourma.MainFrame$23" name="this$0" map="A"/>
  <method class="tourma.MainFrame$23" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$22" map="22"/>
  <field class="tourma.MainFrame$22" name="this$0" map="A"/>
  <method class="tourma.MainFrame$22" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$21" map="21"/>
  <field class="tourma.MainFrame$21" name="this$0" map="A"/>
  <method class="tourma.MainFrame$21" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$20" map="20"/>
  <field class="tourma.MainFrame$20" name="this$0" map="A"/>
  <method class="tourma.MainFrame$20" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$9" map="9"/>
  <field class="tourma.MainFrame$9" name="this$0" map="A"/>
  <method class="tourma.MainFrame$9" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$8" map="8"/>
  <field class="tourma.MainFrame$8" name="this$0" map="A"/>
  <method class="tourma.MainFrame$8" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$7" map="7"/>
  <field class="tourma.MainFrame$7" name="this$0" map="A"/>
  <method class="tourma.MainFrame$7" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$6" map="6"/>
  <field class="tourma.MainFrame$6" name="this$0" map="A"/>
  <method class="tourma.MainFrame$6" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$5" map="5"/>
  <field class="tourma.MainFrame$5" name="this$0" map="A"/>
  <method class="tourma.MainFrame$5" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$4" map="4"/>
  <field class="tourma.MainFrame$4" name="this$0" map="A"/>
  <method class="tourma.MainFrame$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$3" map="3"/>
  <field class="tourma.MainFrame$3" name="this$0" map="A"/>
  <method class="tourma.MainFrame$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$2" map="2"/>
  <field class="tourma.MainFrame$2" name="this$0" map="A"/>
  <method class="tourma.MainFrame$2" name="void valueChanged(javax.swing.event.TreeSelectionEvent)" map="valueChanged"/>
  <class name="tourma.MainFrame$1" map="1"/>
  <field class="tourma.MainFrame$1" name="this$0" map="A"/>
  <method class="tourma.MainFrame$1" name="void windowClosing(java.awt.event.WindowEvent)" map="windowClosing"/>
  <method class="tourma.MainFrame$1" name="void windowClosed(java.awt.event.WindowEvent)" map="windowClosed"/>
  <class name="tourma.MainFrame$19" map="19"/>
  <field class="tourma.MainFrame$19" name="this$0" map="A"/>
  <method class="tourma.MainFrame$19" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$18" map="18"/>
  <field class="tourma.MainFrame$18" name="this$0" map="A"/>
  <method class="tourma.MainFrame$18" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$17" map="17"/>
  <field class="tourma.MainFrame$17" name="this$0" map="A"/>
  <method class="tourma.MainFrame$17" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$16" map="16"/>
  <field class="tourma.MainFrame$16" name="this$0" map="A"/>
  <method class="tourma.MainFrame$16" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$15" map="15"/>
  <field class="tourma.MainFrame$15" name="this$0" map="A"/>
  <method class="tourma.MainFrame$15" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$14" map="14"/>
  <field class="tourma.MainFrame$14" name="this$0" map="A"/>
  <method class="tourma.MainFrame$14" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$13" map="13"/>
  <field class="tourma.MainFrame$13" name="this$0" map="A"/>
  <method class="tourma.MainFrame$13" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$12" map="12"/>
  <field class="tourma.MainFrame$12" name="this$0" map="A"/>
  <method class="tourma.MainFrame$12" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$11" map="11"/>
  <field class="tourma.MainFrame$11" name="this$0" map="A"/>
  <method class="tourma.MainFrame$11" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$10" map="10"/>
  <field class="tourma.MainFrame$10" name="this$0" map="A"/>
  <method class="tourma.MainFrame$10" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$73" map="73"/>
  <method class="tourma.MainFrame$73" name="void run()" map="run"/>
  <class name="tourma.MainFrame$72" map="72"/>
  <field class="tourma.MainFrame$72" name="this$0" map="A"/>
  <field class="tourma.MainFrame$72" name="val$jbtForeColor" map="B"/>
  <method class="tourma.MainFrame$72" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$71" map="71"/>
  <field class="tourma.MainFrame$71" name="this$0" map="A"/>
  <field class="tourma.MainFrame$71" name="val$jbtBorderColor" map="B"/>
  <method class="tourma.MainFrame$71" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$70" map="70"/>
  <field class="tourma.MainFrame$70" name="this$0" map="A"/>
  <field class="tourma.MainFrame$70" name="val$jbtColor2" map="B"/>
  <method class="tourma.MainFrame$70" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$69" map="69"/>
  <field class="tourma.MainFrame$69" name="this$0" map="A"/>
  <field class="tourma.MainFrame$69" name="val$jbtColor1" map="B"/>
  <method class="tourma.MainFrame$69" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$68" map="68"/>
  <field class="tourma.MainFrame$68" name="this$0" map="A"/>
  <method class="tourma.MainFrame$68" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$67" map="67"/>
  <field class="tourma.MainFrame$67" name="this$0" map="A"/>
  <method class="tourma.MainFrame$67" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$66" map="66"/>
  <field class="tourma.MainFrame$66" name="this$0" map="A"/>
  <method class="tourma.MainFrame$66" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$65" map="65"/>
  <field class="tourma.MainFrame$65" name="this$0" map="A"/>
  <method class="tourma.MainFrame$65" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$64" map="64"/>
  <field class="tourma.MainFrame$64" name="this$0" map="A"/>
  <method class="tourma.MainFrame$64" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$63" map="63"/>
  <field class="tourma.MainFrame$63" name="this$0" map="A"/>
  <method class="tourma.MainFrame$63" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$62" map="62"/>
  <field class="tourma.MainFrame$62" name="this$0" map="A"/>
  <method class="tourma.MainFrame$62" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$61" map="61"/>
  <field class="tourma.MainFrame$61" name="this$0" map="A"/>
  <method class="tourma.MainFrame$61" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.MainFrame$60" map="60"/>
  <field class="tourma.MainFrame$60" name="this$0" map="A"/>
  <method class="tourma.MainFrame$60" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <field class="tourma.MainFrame" name="mSingleton" map="A"/>
  <field class="tourma.MainFrame" name="jmiTeamReport" map="B"/>
  <field class="tourma.MainFrame" name="jmiExportFbb1" map="C"/>
  <field class="tourma.MainFrame" name="jmiEditRosterList" map="D"/>
  <field class="tourma.MainFrame" name="jmiPrintLabels" map="E"/>
  <field class="tourma.MainFrame" name="jmiNouveau" map="F"/>
  <field class="tourma.MainFrame" name="jmiDelFreeMatch" map="G"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankAnnexIndiv" map="H"/>
  <field class="tourma.MainFrame" name="jcxUseImage" map="I"/>
  <field class="tourma.MainFrame" name="jmiExportWebServerToSite" map="J"/>
  <field class="tourma.MainFrame" name="splashProgressArea" map="K"/>
  <field class="tourma.MainFrame" name="jmiFullScreenMatchsClash" map="L"/>
  <field class="tourma.MainFrame" name="jmiMassAdd" map="M"/>
  <field class="tourma.MainFrame" name="jmiConceedMatch" map="N"/>
  <field class="tourma.MainFrame" name="jmiClanReport" map="O"/>
  <field class="tourma.MainFrame" name="jcxDisplayRosters" map="P"/>
  <field class="tourma.MainFrame" name="jSeparator21" map="Q"/>
  <field class="tourma.MainFrame" name="jmiEditWebPort" map="R"/>
  <field class="tourma.MainFrame" name="jSeparator20" map="S"/>
  <field class="tourma.MainFrame" name="server" map="T"/>
  <field class="tourma.MainFrame" name="jtrPanels" map="U"/>
  <field class="tourma.MainFrame" name="jmiExportWebServerAsZIP" map="V"/>
  <field class="tourma.MainFrame" name="jmiChangePairing" map="W"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankAnnexTeam" map="X"/>
  <field class="tourma.MainFrame" name="jmiAideEnLigne" map="Y"/>
  <field class="tourma.MainFrame" name="jSeparator9" map="Z"/>
  <field class="tourma.MainFrame" name="jSeparator8" map="_"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankAnnexIndiv1" map="a"/>
  <field class="tourma.MainFrame" name="jSeparator7" map="b"/>
  <field class="tourma.MainFrame" name="jSeparator6" map="c"/>
  <field class="tourma.MainFrame" name="splashGraphics" map="d"/>
  <field class="tourma.MainFrame" name="jSeparator5" map="e"/>
  <field class="tourma.MainFrame" name="jmiSaveAs" map="f"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankTeam" map="g"/>
  <field class="tourma.MainFrame" name="jSeparator4" map="h"/>
  <field class="tourma.MainFrame" name="jSeparator3" map="i"/>
  <field class="tourma.MainFrame" name="jSeparator2" map="j"/>
  <field class="tourma.MainFrame" name="jSeparator1" map="k"/>
  <field class="tourma.MainFrame" name="jSeparator19" map="l"/>
  <field class="tourma.MainFrame" name="jmiIndivReport" map="m"/>
  <field class="tourma.MainFrame" name="jSeparator18" map="n"/>
  <field class="tourma.MainFrame" name="jmiEditTeam" map="o"/>
  <field class="tourma.MainFrame" name="jSeparator17" map="p"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankAnnexPool1" map="q"/>
  <field class="tourma.MainFrame" name="jmiExport" map="r"/>
  <field class="tourma.MainFrame" name="jSeparator16" map="s"/>
  <field class="tourma.MainFrame" name="jSeparator15" map="t"/>
  <field class="tourma.MainFrame" name="jSeparator14" map="u"/>
  <field class="tourma.MainFrame" name="jSeparator13" map="v"/>
  <field class="tourma.MainFrame" name="jSeparator12" map="w"/>
  <field class="tourma.MainFrame" name="jSeparator11" map="z"/>
  <field class="tourma.MainFrame" name="web" map="&#x00a2;"/>
  <field class="tourma.MainFrame" name="jSeparator10" map="&#x00a3;"/>
  <field class="tourma.MainFrame" name="jmiNafLoad" map="&#x00a4;"/>
  <field class="tourma.MainFrame" name="jckmiRoundOnly" map="&#x00a5;"/>
  <field class="tourma.MainFrame" name="LOG" map="&#x00aa;"/>
  <field class="tourma.MainFrame" name="jmiSubstitutePlayer" map="&#x00b5;"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankAnnexCategory" map="&#x00ba;"/>
  <field class="tourma.MainFrame" name="currentPath" map="&#x00c0;"/>
  <field class="tourma.MainFrame" name="jmiExportFbb" map="&#x00c1;"/>
  <field class="tourma.MainFrame" name="jcxAllowSpecialSkill" map="&#x00c2;"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankAnnexPool" map="&#x00c3;"/>
  <field class="tourma.MainFrame" name="jmnRound" map="&#x00c4;"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankAnnexTeam1" map="&#x00c5;"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankAnnexClan" map="&#x00c6;"/>
  <field class="tourma.MainFrame" name="jcxUseColor" map="&#x00c7;"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankAnnexCategory1" map="&#x00c8;"/>
  <field class="tourma.MainFrame" name="jScrollPane1" map="&#x00c9;"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankCategory" map="&#x00ca;"/>
  <field class="tourma.MainFrame" name="jspSplit" map="&#x00cb;"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankClan" map="&#x00cc;"/>
  <field class="tourma.MainFrame" name="jMenuBar1" map="&#x00cd;"/>
  <field class="tourma.MainFrame" name="jmiAbout" map="&#x00ce;"/>
  <field class="tourma.MainFrame" name="jmnTools" map="&#x00cf;"/>
  <field class="tourma.MainFrame" name="jcxmiRemoteEdit" map="&#x00d0;"/>
  <field class="tourma.MainFrame" name="jmiRefuseMatch" map="&#x00d1;"/>
  <field class="tourma.MainFrame" name="jmiDelRound" map="&#x00d2;"/>
  <field class="tourma.MainFrame" name="splashThanksTo" map="&#x00d3;"/>
  <field class="tourma.MainFrame" name="jmiExit" map="&#x00d4;"/>
  <field class="tourma.MainFrame" name="jmiGenerateNextRound" map="&#x00d5;"/>
  <field class="tourma.MainFrame" name="jmiCancelConceedMatch" map="&#x00d6;"/>
  <field class="tourma.MainFrame" name="jmiAddFreeMatch" map="&#x00d8;"/>
  <field class="tourma.MainFrame" name="jmnParameters" map="&#x00d9;"/>
  <field class="tourma.MainFrame" name="jckmiHideNonNaf" map="&#x00da;"/>
  <field class="tourma.MainFrame" name="mySplash" map="&#x00db;"/>
  <field class="tourma.MainFrame" name="jmiSave" map="&#x00dc;"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankGroups" map="&#x00dd;"/>
  <field class="tourma.MainFrame" name="font" map="&#x00de;"/>
  <field class="tourma.MainFrame" name="jcxmiAsServer" map="&#x00df;"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankAnnexGroups" map="&#x00e0;"/>
  <field class="tourma.MainFrame" name="task" map="&#x00e1;"/>
  <field class="tourma.MainFrame" name="jmiFullScreenMatchs" map="&#x00e2;"/>
  <field class="tourma.MainFrame" name="jmiEditDescription" map="&#x00e3;"/>
  <field class="tourma.MainFrame" name="jmnFile" map="&#x00e4;"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankAnnexClan1" map="&#x00e5;"/>
  <field class="tourma.MainFrame" name="mTournament" map="&#x00e6;"/>
  <field class="tourma.MainFrame" name="jmiCancelMatchRefuse" map="&#x00e7;"/>
  <field class="tourma.MainFrame" name="progressMonitor" map="&#x00e8;"/>
  <field class="tourma.MainFrame" name="jcxPatchPortugal" map="&#x00e9;"/>
  <field class="tourma.MainFrame" name="jmiEditColors" map="&#x00ea;"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankGeneral" map="&#x00eb;"/>
  <field class="tourma.MainFrame" name="splashTextArea" map="&#x00ec;"/>
  <field class="tourma.MainFrame" name="jpnContent" map="&#x00ed;"/>
  <field class="tourma.MainFrame" name="jmnHelp" map="&#x00ee;"/>
  <field class="tourma.MainFrame" name="jmiGenerateFirstRound" map="&#x00ef;"/>
  <field class="tourma.MainFrame" name="mFile" map="&#x00f0;"/>
  <field class="tourma.MainFrame" name="jmiCharger" map="&#x00f1;"/>
  <field class="tourma.MainFrame" name="jmiEditCoef" map="&#x00f2;"/>
  <field class="tourma.MainFrame" name="jMenu2" map="&#x00f3;"/>
  <field class="tourma.MainFrame" name="jmiRevisions" map="&#x00f4;"/>
  <field class="tourma.MainFrame" name="jMenu1" map="&#x00f5;"/>
  <field class="tourma.MainFrame" name="CS_EditWebPort" map="&#x00f6;"/>
  <field class="tourma.MainFrame" name="jcxIgnoreCaps" map="&#x00f8;"/>
  <field class="tourma.MainFrame" name="jmiFullScreenPool" map="&#x00f9;"/>
  <field class="tourma.MainFrame" name="jmiFullScreenRankAnnexGroups1" map="&#x00fa;"/>
  <method class="tourma.MainFrame" name="void access$3900(tourma.MainFrame, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.MainFrame" name="void access$4800(tourma.MainFrame, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.MainFrame" name="void access$5700(tourma.MainFrame, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.MainFrame" name="void jmiDelRoundActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.MainFrame" name="void jcxmiRemoteEditActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.MainFrame" name="void jcxmiAsServerActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankAnnexCategory1ActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankGeneralActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.MainFrame" name="void access$1000(tourma.MainFrame, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.MainFrame" name="void jckmiHideNonNafActionPerformed(java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.MainFrame" name="void access$6000(tourma.MainFrame, java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.MainFrame" name="void access$1600(tourma.MainFrame, java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.MainFrame" name="void access$2500(tourma.MainFrame, java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.MainFrame" name="void access$6600(tourma.MainFrame, java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankAnnexGroupsActionPerformed(java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.MainFrame" name="void appInit()" map="A"/>
  <method class="tourma.MainFrame" name="void jmiCancelConceedMatchActionPerformed(java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.MainFrame" name="void jmiGenerateNextRoundActionPerformed(java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.MainFrame" name="void jmiPrintLabelsActionPerformed(java.awt.event.ActionEvent)" map="J"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankAnnexTeamActionPerformed(java.awt.event.ActionEvent)" map="K"/>
  <method class="tourma.MainFrame" name="void formWindowClosed(java.awt.event.WindowEvent)" map="A"/>
  <method class="tourma.MainFrame" name="void jmiRevisionsActionPerformed(java.awt.event.ActionEvent)" map="L"/>
  <method class="tourma.MainFrame" name="void access$800(tourma.MainFrame, java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.MainFrame" name="void access$3400(tourma.MainFrame, java.awt.event.ActionEvent)" map="J"/>
  <method class="tourma.MainFrame" name="void access$4300(tourma.MainFrame, java.awt.event.ActionEvent)" map="K"/>
  <method class="tourma.MainFrame" name="void access$5200(tourma.MainFrame, java.awt.event.ActionEvent)" map="L"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankAnnexCategoryActionPerformed(java.awt.event.ActionEvent)" map="M"/>
  <method class="tourma.MainFrame" name="void access$6100(tourma.MainFrame, java.awt.event.ActionEvent)" map="M"/>
  <method class="tourma.MainFrame" name="void jcxIgnoreCapsActionPerformed(java.awt.event.ActionEvent)" map="N"/>
  <method class="tourma.MainFrame" name="void access$4900(tourma.MainFrame, java.awt.event.ActionEvent)" map="N"/>
  <method class="tourma.MainFrame" name="void access$5800(tourma.MainFrame, java.awt.event.ActionEvent)" map="O"/>
  <method class="tourma.MainFrame" name="void access$6700(tourma.MainFrame, java.awt.event.ActionEvent)" map="P"/>
  <method class="tourma.MainFrame" name="boolean areRulesValid()" map="B"/>
  <method class="tourma.MainFrame" name="void jmiExportFbb1ActionPerformed(java.awt.event.ActionEvent)" map="O"/>
  <method class="tourma.MainFrame" name="void jmiTeamReportActionPerformed(java.awt.event.ActionEvent)" map="P"/>
  <method class="tourma.MainFrame" name="void writeObject(java.io.ObjectOutputStream)" map="A"/>
  <method class="tourma.MainFrame" name="void updateMenus()" map="C"/>
  <method class="tourma.MainFrame" name="void jmiAideEnLigneActionPerformed(java.awt.event.ActionEvent)" map="Q"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankAnnexTeam1ActionPerformed(java.awt.event.ActionEvent)" map="R"/>
  <method class="tourma.MainFrame" name="boolean isRoundOnly()" map="D"/>
  <method class="tourma.MainFrame" name="void jmiEditRosterListActionPerformed(java.awt.event.ActionEvent)" map="S"/>
  <method class="tourma.MainFrame" name="void jmiEditTeamActionPerformed(java.awt.event.ActionEvent)" map="T"/>
  <method class="tourma.MainFrame" name="void jmiSaveAsActionPerformed(java.awt.event.ActionEvent)" map="U"/>
  <method class="tourma.MainFrame" name="void access$1100(tourma.MainFrame, java.awt.event.ActionEvent)" map="Q"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenMatchsClashActionPerformed(java.awt.event.ActionEvent)" map="V"/>
  <method class="tourma.MainFrame" name="void access$2000(tourma.MainFrame, java.awt.event.ActionEvent)" map="R"/>
  <method class="tourma.MainFrame" name="void access$1700(tourma.MainFrame, java.awt.event.ActionEvent)" map="S"/>
  <method class="tourma.MainFrame" name="void readObject(java.io.ObjectInputStream)" map="A"/>
  <method class="tourma.MainFrame" name="void splashProgress(int)" map="A"/>
  <method class="tourma.MainFrame" name="void access$2600(tourma.MainFrame, java.awt.event.ActionEvent)" map="T"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankCategoryActionPerformed(java.awt.event.ActionEvent)" map="W"/>
  <method class="tourma.MainFrame" name="void access$3500(tourma.MainFrame, java.awt.event.ActionEvent)" map="U"/>
  <method class="tourma.MainFrame" name="void jmiExitActionPerformed(java.awt.event.ActionEvent)" map="X"/>
  <method class="tourma.MainFrame" name="void access$4400(tourma.MainFrame, java.awt.event.ActionEvent)" map="V"/>
  <method class="tourma.MainFrame" name="void jmiEditDescriptionActionPerformed(java.awt.event.ActionEvent)" map="Y"/>
  <method class="tourma.MainFrame" name="void jmiMassAddActionPerformed(java.awt.event.ActionEvent)" map="Z"/>
  <method class="tourma.MainFrame" name="void access$000(tourma.MainFrame, java.awt.event.WindowEvent)" map="A"/>
  <method class="tourma.MainFrame" name="void jmiEditWebPortActionPerformed(java.awt.event.ActionEvent)" map="_"/>
  <method class="tourma.MainFrame" name="void jmiSubstitutePlayerActionPerformed(java.awt.event.ActionEvent)" map="a"/>
  <method class="tourma.MainFrame" name="void access$300(tourma.MainFrame, java.awt.event.ActionEvent)" map="W"/>
  <method class="tourma.MainFrame" name="void initComponents()" map="E"/>
  <method class="tourma.MainFrame" name="void jmiExportWebServerToSiteActionPerformed(java.awt.event.ActionEvent)" map="b"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankClanActionPerformed(java.awt.event.ActionEvent)" map="c"/>
  <method class="tourma.MainFrame" name="void access$900(tourma.MainFrame, java.awt.event.ActionEvent)" map="X"/>
  <method class="tourma.MainFrame" name="javax.swing.JPanel access$6900(tourma.MainFrame)" map="A"/>
  <method class="tourma.MainFrame" name="void jckmiRoundOnlyActionPerformed(java.awt.event.ActionEvent)" map="d"/>
  <method class="tourma.MainFrame" name="void jmiDelFreeMatchActionPerformed(java.awt.event.ActionEvent)" map="e"/>
  <method class="tourma.MainFrame" name="void access$5300(tourma.MainFrame, java.awt.event.ActionEvent)" map="Y"/>
  <method class="tourma.MainFrame" name="void access$6200(tourma.MainFrame, java.awt.event.ActionEvent)" map="Z"/>
  <method class="tourma.MainFrame" name="void access$1800(tourma.MainFrame, java.awt.event.ActionEvent)" map="_"/>
  <method class="tourma.MainFrame" name="void access$5900(tourma.MainFrame, java.awt.event.ActionEvent)" map="a"/>
  <method class="tourma.MainFrame" name="void access$6800(tourma.MainFrame, java.awt.event.ActionEvent)" map="b"/>
  <method class="tourma.MainFrame" name="void propertyChange(java.beans.PropertyChangeEvent)" map="propertyChange"/>
  <method class="tourma.MainFrame" name="void jmiExportActionPerformed(java.awt.event.ActionEvent)" map="f"/>
  <method class="tourma.MainFrame" name="void jcxUseColorActionPerformed(java.awt.event.ActionEvent)" map="g"/>
  <method class="tourma.MainFrame" name="void jmiEditCoefActionPerformed(java.awt.event.ActionEvent)" map="h"/>
  <method class="tourma.MainFrame" name="void access$100(tourma.MainFrame, java.awt.event.WindowEvent)" map="B"/>
  <method class="tourma.MainFrame" name="void splashInit()" map="F"/>
  <method class="tourma.MainFrame" name="void access$1200(tourma.MainFrame, java.awt.event.ActionEvent)" map="c"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankAnnexPoolActionPerformed(java.awt.event.ActionEvent)" map="i"/>
  <method class="tourma.MainFrame" name="void access$2100(tourma.MainFrame, java.awt.event.ActionEvent)" map="d"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankAnnexPool1ActionPerformed(java.awt.event.ActionEvent)" map="j"/>
  <method class="tourma.MainFrame" name="void access$3000(tourma.MainFrame, java.awt.event.ActionEvent)" map="e"/>
  <method class="tourma.MainFrame" name="void jtrPanelsValueChanged(javax.swing.event.TreeSelectionEvent)" map="A"/>
  <method class="tourma.MainFrame" name="void access$2700(tourma.MainFrame, java.awt.event.ActionEvent)" map="f"/>
  <method class="tourma.MainFrame" name="void formWindowClosing(java.awt.event.WindowEvent)" map="B"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankAnnexGroups1ActionPerformed(java.awt.event.ActionEvent)" map="k"/>
  <method class="tourma.MainFrame" name="void access$3600(tourma.MainFrame, java.awt.event.ActionEvent)" map="g"/>
  <method class="tourma.MainFrame" name="void access$4500(tourma.MainFrame, java.awt.event.ActionEvent)" map="h"/>
  <method class="tourma.MainFrame" name="void access$5400(tourma.MainFrame, java.awt.event.ActionEvent)" map="i"/>
  <method class="tourma.MainFrame" name="tourma.MainFrame getMainFrame(int)" map="B"/>
  <method class="tourma.MainFrame" name="void jmiEditColorsActionPerformed(java.awt.event.ActionEvent)" map="l"/>
  <method class="tourma.MainFrame" name="void jmiChangePairingActionPerformed(java.awt.event.ActionEvent)" map="m"/>
  <method class="tourma.MainFrame" name="void jmiSaveActionPerformed(java.awt.event.ActionEvent)" map="n"/>
  <method class="tourma.MainFrame" name="void access$200(tourma.MainFrame, javax.swing.event.TreeSelectionEvent)" map="A"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankGroupsActionPerformed(java.awt.event.ActionEvent)" map="o"/>
  <method class="tourma.MainFrame" name="void access$400(tourma.MainFrame, java.awt.event.ActionEvent)" map="j"/>
  <method class="tourma.MainFrame" name="void jmiNafLoadActionPerformed(java.awt.event.ActionEvent)" map="p"/>
  <method class="tourma.MainFrame" name="tourma.MainFrame getMainFrame()" map="G"/>
  <method class="tourma.MainFrame" name="void access$1300(tourma.MainFrame, java.awt.event.ActionEvent)" map="k"/>
  <method class="tourma.MainFrame" name="void access$2200(tourma.MainFrame, java.awt.event.ActionEvent)" map="l"/>
  <method class="tourma.MainFrame" name="void updateTree()" map="H"/>
  <method class="tourma.MainFrame" name="void access$6300(tourma.MainFrame, java.awt.event.ActionEvent)" map="m"/>
  <method class="tourma.MainFrame" name="void access$1900(tourma.MainFrame, java.awt.event.ActionEvent)" map="n"/>
  <method class="tourma.MainFrame" name="void jmiAboutActionPerformed(java.awt.event.ActionEvent)" map="q"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankTeamActionPerformed(java.awt.event.ActionEvent)" map="r"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankAnnexIndiv1ActionPerformed(java.awt.event.ActionEvent)" map="s"/>
  <method class="tourma.MainFrame" name="void access$2800(tourma.MainFrame, java.awt.event.ActionEvent)" map="o"/>
  <method class="tourma.MainFrame" name="void editRoundCoef(tourma.data.Round)" map="A"/>
  <method class="tourma.MainFrame" name="java.lang.String getCurrentPath()" map="I"/>
  <method class="tourma.MainFrame" name="void access$500(tourma.MainFrame, java.awt.event.ActionEvent)" map="p"/>
  <method class="tourma.MainFrame" name="void access$3100(tourma.MainFrame, java.awt.event.ActionEvent)" map="q"/>
  <method class="tourma.MainFrame" name="void access$4000(tourma.MainFrame, java.awt.event.ActionEvent)" map="r"/>
  <method class="tourma.MainFrame" name="void jmiRefuseMatchActionPerformed(java.awt.event.ActionEvent)" map="t"/>
  <method class="tourma.MainFrame" name="void access$3700(tourma.MainFrame, java.awt.event.ActionEvent)" map="s"/>
  <method class="tourma.MainFrame" name="void access$4600(tourma.MainFrame, java.awt.event.ActionEvent)" map="t"/>
  <method class="tourma.MainFrame" name="void access$5500(tourma.MainFrame, java.awt.event.ActionEvent)" map="u"/>
  <method class="tourma.MainFrame" name="void access$6400(tourma.MainFrame, java.awt.event.ActionEvent)" map="v"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankAnnexClan1ActionPerformed(java.awt.event.ActionEvent)" map="u"/>
  <method class="tourma.MainFrame" name="void jmiExportWebServerAsZIPActionPerformed(java.awt.event.ActionEvent)" map="v"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankAnnexIndivActionPerformed(java.awt.event.ActionEvent)" map="w"/>
  <method class="tourma.MainFrame" name="void jcxDisplayRostersActionPerformed(java.awt.event.ActionEvent)" map="x"/>
  <method class="tourma.MainFrame" name="void jmiCancelMatchRefuseActionPerformed(java.awt.event.ActionEvent)" map="y"/>
  <method class="tourma.MainFrame" name="void jmiConceedMatchActionPerformed(java.awt.event.ActionEvent)" map="z"/>
  <method class="tourma.MainFrame" name="void access$1400(tourma.MainFrame, java.awt.event.ActionEvent)" map="w"/>
  <method class="tourma.MainFrame" name="void jmiExportFbbActionPerformed(java.awt.event.ActionEvent)" map="&#x00a2;"/>
  <method class="tourma.MainFrame" name="void jmiClanReportActionPerformed(java.awt.event.ActionEvent)" map="&#x00a3;"/>
  <method class="tourma.MainFrame" name="void access$2300(tourma.MainFrame, java.awt.event.ActionEvent)" map="x"/>
  <method class="tourma.MainFrame" name="void update()" map="J"/>
  <method class="tourma.MainFrame" name="void access$3200(tourma.MainFrame, java.awt.event.ActionEvent)" map="y"/>
  <method class="tourma.MainFrame" name="void access$2900(tourma.MainFrame, java.awt.event.ActionEvent)" map="z"/>
  <method class="tourma.MainFrame" name="void jmiChargerActionPerformed(java.awt.event.ActionEvent)" map="&#x00a4;"/>
  <method class="tourma.MainFrame" name="void access$3800(tourma.MainFrame, java.awt.event.ActionEvent)" map="&#x00a2;"/>
  <method class="tourma.MainFrame" name="void access$4700(tourma.MainFrame, java.awt.event.ActionEvent)" map="&#x00a3;"/>
  <method class="tourma.MainFrame" name="void jmiNouveauActionPerformed(java.awt.event.ActionEvent)" map="&#x00a5;"/>
  <method class="tourma.MainFrame" name="void jmiGenerateFirstRoundActionPerformed(java.awt.event.ActionEvent)" map="&#x00aa;"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenPoolActionPerformed(java.awt.event.ActionEvent)" map="&#x00b5;"/>
  <method class="tourma.MainFrame" name="void splashText(java.lang.String)" map="A"/>
  <method class="tourma.MainFrame" name="void access$600(tourma.MainFrame, java.awt.event.ActionEvent)" map="&#x00a4;"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenMatchsActionPerformed(java.awt.event.ActionEvent)" map="&#x00ba;"/>
  <method class="tourma.MainFrame" name="void access$4100(tourma.MainFrame, java.awt.event.ActionEvent)" map="&#x00a5;"/>
  <method class="tourma.MainFrame" name="void access$5000(tourma.MainFrame, java.awt.event.ActionEvent)" map="&#x00aa;"/>
  <method class="tourma.MainFrame" name="void access$1500(tourma.MainFrame, java.awt.event.ActionEvent)" map="&#x00b5;"/>
  <method class="tourma.MainFrame" name="void jcxPatchPortugalActionPerformed(java.awt.event.ActionEvent)" map="&#x00c0;"/>
  <method class="tourma.MainFrame" name="void access$5600(tourma.MainFrame, java.awt.event.ActionEvent)" map="&#x00ba;"/>
  <method class="tourma.MainFrame" name="void jmiAddFreeMatchActionPerformed(java.awt.event.ActionEvent)" map="&#x00c1;"/>
  <method class="tourma.MainFrame" name="void access$6500(tourma.MainFrame, java.awt.event.ActionEvent)" map="&#x00c0;"/>
  <method class="tourma.MainFrame" name="void jcxAllowSpecialSkillActionPerformed(java.awt.event.ActionEvent)" map="&#x00c2;"/>
  <method class="tourma.MainFrame" name="void jmiFullScreenRankAnnexClanActionPerformed(java.awt.event.ActionEvent)" map="&#x00c3;"/>
  <method class="tourma.MainFrame" name="void jcxUseImageActionPerformed(java.awt.event.ActionEvent)" map="&#x00c4;"/>
  <method class="tourma.MainFrame" name="void jmiIndivReportActionPerformed(java.awt.event.ActionEvent)" map="&#x00c5;"/>
  <method class="tourma.MainFrame" name="void access$2400(tourma.MainFrame, java.awt.event.ActionEvent)" map="&#x00c1;"/>
  <method class="tourma.MainFrame" name="void access$700(tourma.MainFrame, java.awt.event.ActionEvent)" map="&#x00c2;"/>
  <method class="tourma.MainFrame" name="void access$3300(tourma.MainFrame, java.awt.event.ActionEvent)" map="&#x00c3;"/>
  <method class="tourma.MainFrame" name="boolean isNafOnly()" map="K"/>
  <method class="tourma.MainFrame" name="void access$4200(tourma.MainFrame, java.awt.event.ActionEvent)" map="&#x00c4;"/>
  <method class="tourma.MainFrame" name="void access$5100(tourma.MainFrame, java.awt.event.ActionEvent)" map="&#x00c5;"/>
  <class name="tourma.JdgManualCupDraw$5" map="5"/>
  <field class="tourma.JdgManualCupDraw$5" name="this$0" map="A"/>
  <method class="tourma.JdgManualCupDraw$5" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgManualCupDraw$4" map="4"/>
  <field class="tourma.JdgManualCupDraw$4" name="this$0" map="A"/>
  <method class="tourma.JdgManualCupDraw$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgManualCupDraw$3" map="3"/>
  <field class="tourma.JdgManualCupDraw$3" name="this$0" map="A"/>
  <method class="tourma.JdgManualCupDraw$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgManualCupDraw$2" map="2"/>
  <field class="tourma.JdgManualCupDraw$2" name="this$0" map="A"/>
  <method class="tourma.JdgManualCupDraw$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgManualCupDraw$1" map="1"/>
  <field class="tourma.JdgManualCupDraw$1" name="this$0" map="A"/>
  <method class="tourma.JdgManualCupDraw$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgManualCupDraw" map="D"/>
  <field class="tourma.JdgManualCupDraw" name="jPanel6" map="A"/>
  <field class="tourma.JdgManualCupDraw" name="mTargetComps" map="B"/>
  <field class="tourma.JdgManualCupDraw" name="jPanel5" map="C"/>
  <field class="tourma.JdgManualCupDraw" name="bgCupType" map="D"/>
  <field class="tourma.JdgManualCupDraw" name="jcbRight" map="E"/>
  <field class="tourma.JdgManualCupDraw" name="jcbLeft" map="F"/>
  <field class="tourma.JdgManualCupDraw" name="jPanel2" map="G"/>
  <field class="tourma.JdgManualCupDraw" name="jpnDel" map="H"/>
  <field class="tourma.JdgManualCupDraw" name="jPanel1" map="I"/>
  <field class="tourma.JdgManualCupDraw" name="mComps" map="J"/>
  <field class="tourma.JdgManualCupDraw" name="bgInitialDraw" map="K"/>
  <field class="tourma.JdgManualCupDraw" name="jpnMain" map="L"/>
  <field class="tourma.JdgManualCupDraw" name="jsp" map="M"/>
  <field class="tourma.JdgManualCupDraw" name="jbtDel" map="N"/>
  <field class="tourma.JdgManualCupDraw" name="jbtOK" map="O"/>
  <field class="tourma.JdgManualCupDraw" name="jbtAdd" map="P"/>
  <field class="tourma.JdgManualCupDraw" name="jtbMatches" map="Q"/>
  <field class="tourma.JdgManualCupDraw" name="jLabel1" map="R"/>
  <method class="tourma.JdgManualCupDraw" name="void access$300(tourma.JdgManualCupDraw, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgManualCupDraw" name="void jbtDelActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgManualCupDraw" name="void initComponents()" map="A"/>
  <method class="tourma.JdgManualCupDraw" name="void access$100(tourma.JdgManualCupDraw, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgManualCupDraw" name="void jcbRightActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgManualCupDraw" name="void jbtAddActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgManualCupDraw" name="void access$400(tourma.JdgManualCupDraw, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgManualCupDraw" name="void access$200(tourma.JdgManualCupDraw, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgManualCupDraw" name="void jcbLeftActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgManualCupDraw" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.JdgManualCupDraw" name="void update()" map="B"/>
  <method class="tourma.JdgManualCupDraw" name="void access$000(tourma.JdgManualCupDraw, java.awt.event.ActionEvent)" map="E"/>
  <class name="tourma.MainTreeModel" map="E"/>
  <field class="tourma.MainTreeModel" name="mRounds" map="A"/>
  <field class="tourma.MainTreeModel" name="mStats" map="B"/>
  <field class="tourma.MainTreeModel" name="mRoot" map="C"/>
  <field class="tourma.MainTreeModel" name="mListeners" map="D"/>
  <field class="tourma.MainTreeModel" name="mTournament" map="E"/>
  <field class="tourma.MainTreeModel" name="mParams" map="F"/>
  <field class="tourma.MainTreeModel" name="mCup" map="G"/>
  <method class="tourma.MainTreeModel" name="void valueForPathChanged(javax.swing.tree.TreePath, java.lang.Object)" map="valueForPathChanged"/>
  <method class="tourma.MainTreeModel" name="javax.swing.tree.DefaultMutableTreeNode getParams()" map="A"/>
  <method class="tourma.MainTreeModel" name="int getChildCount(java.lang.Object)" map="getChildCount"/>
  <method class="tourma.MainTreeModel" name="java.lang.Object getChild(java.lang.Object, int)" map="getChild"/>
  <method class="tourma.MainTreeModel" name="int getIndexOfChild(java.lang.Object, java.lang.Object)" map="getIndexOfChild"/>
  <method class="tourma.MainTreeModel" name="java.lang.Object getRoot()" map="getRoot"/>
  <method class="tourma.MainTreeModel" name="boolean isLeaf(java.lang.Object)" map="isLeaf"/>
  <method class="tourma.MainTreeModel" name="void addTreeModelListener(javax.swing.event.TreeModelListener)" map="addTreeModelListener"/>
  <method class="tourma.MainTreeModel" name="java.awt.Component getTreeCellRendererComponent(javax.swing.JTree, java.lang.Object, boolean, boolean, boolean, int, boolean)" map="getTreeCellRendererComponent"/>
  <method class="tourma.MainTreeModel" name="void removeTreeModelListener(javax.swing.event.TreeModelListener)" map="removeTreeModelListener"/>
  <class name="tourma.JdgMassAdd$6" map="6"/>
  <field class="tourma.JdgMassAdd$6" name="this$0" map="A"/>
  <method class="tourma.JdgMassAdd$6" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgMassAdd$5" map="5"/>
  <field class="tourma.JdgMassAdd$5" name="this$0" map="A"/>
  <method class="tourma.JdgMassAdd$5" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgMassAdd$4" map="4"/>
  <field class="tourma.JdgMassAdd$4" name="this$0" map="A"/>
  <method class="tourma.JdgMassAdd$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgMassAdd$3" map="3"/>
  <field class="tourma.JdgMassAdd$3" name="this$0" map="A"/>
  <method class="tourma.JdgMassAdd$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgMassAdd$2" map="2"/>
  <field class="tourma.JdgMassAdd$2" name="this$0" map="A"/>
  <method class="tourma.JdgMassAdd$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgMassAdd$1" map="1"/>
  <field class="tourma.JdgMassAdd$1" name="this$0" map="A"/>
  <method class="tourma.JdgMassAdd$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgMassAdd" map="F"/>
  <field class="tourma.JdgMassAdd" name="jbtNAF" map="A"/>
  <field class="tourma.JdgMassAdd" name="jPanel1" map="B"/>
  <field class="tourma.JdgMassAdd" name="jsp" map="C"/>
  <field class="tourma.JdgMassAdd" name="task" map="D"/>
  <field class="tourma.JdgMassAdd" name="_clans" map="E"/>
  <field class="tourma.JdgMassAdd" name="jbtCancel" map="F"/>
  <field class="tourma.JdgMassAdd" name="jScrollPane1" map="G"/>
  <field class="tourma.JdgMassAdd" name="jbtImportExcel" map="H"/>
  <field class="tourma.JdgMassAdd" name="jbtOK" map="I"/>
  <field class="tourma.JdgMassAdd" name="jpnMatchs" map="J"/>
  <field class="tourma.JdgMassAdd" name="jbtAdd" map="K"/>
  <field class="tourma.JdgMassAdd" name="jtTeamsAndCoaches" map="L"/>
  <field class="tourma.JdgMassAdd" name="progressMonitor" map="M"/>
  <field class="tourma.JdgMassAdd" name="jbtMinus" map="N"/>
  <field class="tourma.JdgMassAdd" name="jPanel2" map="O"/>
  <method class="tourma.JdgMassAdd" name="void access$000(tourma.JdgMassAdd, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgMassAdd" name="void access$300(tourma.JdgMassAdd, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgMassAdd" name="void initComponents()" map="A"/>
  <method class="tourma.JdgMassAdd" name="void loadExcelFile(java.io.File)" map="A"/>
  <method class="tourma.JdgMassAdd" name="void jbtAddActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgMassAdd" name="void access$100(tourma.JdgMassAdd, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgMassAdd" name="void access$400(tourma.JdgMassAdd, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgMassAdd" name="void propertyChange(java.beans.PropertyChangeEvent)" map="propertyChange"/>
  <method class="tourma.JdgMassAdd" name="void jbtCancelActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgMassAdd" name="void jbtImportExcelActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgMassAdd" name="void jbtNAFActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgMassAdd" name="void jbtMinusActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.JdgMassAdd" name="void access$200(tourma.JdgMassAdd, java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.JdgMassAdd" name="void access$500(tourma.JdgMassAdd, java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.JdgMassAdd" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.JdgMassAdd" name="void update()" map="B"/>
  <class name="tourma.JdgPairing$5" map="5"/>
  <field class="tourma.JdgPairing$5" name="this$0" map="A"/>
  <method class="tourma.JdgPairing$5" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgPairing$4" map="4"/>
  <field class="tourma.JdgPairing$4" name="this$0" map="A"/>
  <method class="tourma.JdgPairing$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgPairing$3" map="3"/>
  <field class="tourma.JdgPairing$3" name="this$0" map="A"/>
  <method class="tourma.JdgPairing$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgPairing$2" map="2"/>
  <field class="tourma.JdgPairing$2" name="this$0" map="A"/>
  <method class="tourma.JdgPairing$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgPairing$1" map="1"/>
  <field class="tourma.JdgPairing$1" name="this$0" map="A"/>
  <method class="tourma.JdgPairing$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgPairing" map="G"/>
  <field class="tourma.JdgPairing" name="jbtSwiss" map="A"/>
  <field class="tourma.JdgPairing" name="jPanel4" map="B"/>
  <field class="tourma.JdgPairing" name="jPanel3" map="C"/>
  <field class="tourma.JdgPairing" name="jPanel2" map="D"/>
  <field class="tourma.JdgPairing" name="mItems2" map="E"/>
  <field class="tourma.JdgPairing" name="mItems1" map="F"/>
  <field class="tourma.JdgPairing" name="jbtRemove" map="G"/>
  <field class="tourma.JdgPairing" name="jbtRandom" map="H"/>
  <field class="tourma.JdgPairing" name="jScrollPane1" map="I"/>
  <field class="tourma.JdgPairing" name="jbtOK" map="J"/>
  <field class="tourma.JdgPairing" name="teamMatch" map="K"/>
  <field class="tourma.JdgPairing" name="mRound" map="L"/>
  <field class="tourma.JdgPairing" name="jcbTeam2" map="M"/>
  <field class="tourma.JdgPairing" name="jcbTeam1" map="N"/>
  <field class="tourma.JdgPairing" name="jbtAdd" map="O"/>
  <field class="tourma.JdgPairing" name="mMatchs" map="P"/>
  <field class="tourma.JdgPairing" name="mCoachs" map="Q"/>
  <field class="tourma.JdgPairing" name="jtbMatches" map="R"/>
  <field class="tourma.JdgPairing" name="jLabel1" map="S"/>
  <field class="tourma.JdgPairing" name="mTeam2" map="T"/>
  <field class="tourma.JdgPairing" name="mTeam1" map="U"/>
  <method class="tourma.JdgPairing" name="void readObject(java.io.ObjectInputStream)" map="A"/>
  <method class="tourma.JdgPairing" name="void initComponents()" map="A"/>
  <method class="tourma.JdgPairing" name="void jbtSwissActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgPairing" name="void jbtRemoveActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgPairing" name="void access$200(tourma.JdgPairing, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgPairing" name="void access$000(tourma.JdgPairing, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgPairing" name="void jbtAddActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgPairing" name="void writeObject(java.io.ObjectOutputStream)" map="A"/>
  <method class="tourma.JdgPairing" name="void access$300(tourma.JdgPairing, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgPairing" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgPairing" name="void update()" map="B"/>
  <method class="tourma.JdgPairing" name="void access$100(tourma.JdgPairing, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgPairing" name="void jbtRandomActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.JdgPairing" name="void access$400(tourma.JdgPairing, java.awt.event.ActionEvent)" map="E"/>
  <class name="tourma.JdgCoach$9" map="9"/>
  <field class="tourma.JdgCoach$9" name="this$0" map="A"/>
  <field class="tourma.JdgCoach$9" name="strings" map="B"/>
  <method class="tourma.JdgCoach$9" name="java.lang.Object getElementAt(int)" map="getElementAt"/>
  <method class="tourma.JdgCoach$9" name="int getSize()" map="getSize"/>
  <class name="tourma.JdgCoach$8" map="8"/>
  <field class="tourma.JdgCoach$8" name="this$0" map="A"/>
  <method class="tourma.JdgCoach$8" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCoach$17" map="17"/>
  <field class="tourma.JdgCoach$17" name="this$0" map="A"/>
  <method class="tourma.JdgCoach$17" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCoach$7" map="7"/>
  <field class="tourma.JdgCoach$7" name="this$0" map="A"/>
  <method class="tourma.JdgCoach$7" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCoach$16" map="16"/>
  <field class="tourma.JdgCoach$16" name="this$0" map="A"/>
  <method class="tourma.JdgCoach$16" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCoach$6" map="6"/>
  <field class="tourma.JdgCoach$6" name="this$0" map="A"/>
  <field class="tourma.JdgCoach$6" name="strings" map="B"/>
  <method class="tourma.JdgCoach$6" name="java.lang.Object getElementAt(int)" map="getElementAt"/>
  <method class="tourma.JdgCoach$6" name="int getSize()" map="getSize"/>
  <class name="tourma.JdgCoach$15" map="15"/>
  <field class="tourma.JdgCoach$15" name="this$0" map="A"/>
  <method class="tourma.JdgCoach$15" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCoach$14" map="14"/>
  <field class="tourma.JdgCoach$14" name="this$0" map="A"/>
  <method class="tourma.JdgCoach$14" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCoach$5" map="5"/>
  <field class="tourma.JdgCoach$5" name="this$0" map="A"/>
  <method class="tourma.JdgCoach$5" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCoach$13" map="13"/>
  <field class="tourma.JdgCoach$13" name="this$0" map="A"/>
  <method class="tourma.JdgCoach$13" name="void propertyChange(java.beans.PropertyChangeEvent)" map="propertyChange"/>
  <class name="tourma.JdgCoach$4" map="4"/>
  <field class="tourma.JdgCoach$4" name="this$0" map="A"/>
  <method class="tourma.JdgCoach$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCoach$12" map="12"/>
  <field class="tourma.JdgCoach$12" name="this$0" map="A"/>
  <method class="tourma.JdgCoach$12" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCoach$3" map="3"/>
  <field class="tourma.JdgCoach$3" name="this$0" map="A"/>
  <method class="tourma.JdgCoach$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCoach$11" map="11"/>
  <field class="tourma.JdgCoach$11" name="this$0" map="A"/>
  <method class="tourma.JdgCoach$11" name="void keyPressed(java.awt.event.KeyEvent)" map="keyPressed"/>
  <class name="tourma.JdgCoach$2" map="2"/>
  <field class="tourma.JdgCoach$2" name="this$0" map="A"/>
  <method class="tourma.JdgCoach$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCoach$10" map="10"/>
  <field class="tourma.JdgCoach$10" name="this$0" map="A"/>
  <method class="tourma.JdgCoach$10" name="void propertyChange(java.beans.PropertyChangeEvent)" map="propertyChange"/>
  <class name="tourma.JdgCoach$1" map="1"/>
  <field class="tourma.JdgCoach$1" name="this$0" map="A"/>
  <method class="tourma.JdgCoach$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgCoach" map="H"/>
  <field class="tourma.JdgCoach" name="jbtPinCode" map="A"/>
  <field class="tourma.JdgCoach" name="jpnBtns1" map="B"/>
  <field class="tourma.JdgCoach" name="mTeam" map="C"/>
  <field class="tourma.JdgCoach" name="jbtOK" map="D"/>
  <field class="tourma.JdgCoach" name="jbtAdd" map="E"/>
  <field class="tourma.JdgCoach" name="jbtDownloadFromNaf" map="F"/>
  <field class="tourma.JdgCoach" name="jbtUpdateFromDb" map="G"/>
  <field class="tourma.JdgCoach" name="jtfNom" map="H"/>
  <field class="tourma.JdgCoach" name="jtfEquipe" map="I"/>
  <field class="tourma.JdgCoach" name="mNew" map="J"/>
  <field class="tourma.JdgCoach" name="jpnBtns" map="K"/>
  <field class="tourma.JdgCoach" name="jckActive" map="L"/>
  <field class="tourma.JdgCoach" name="jlsCategories" map="M"/>
  <field class="tourma.JdgCoach" name="jbtDel" map="N"/>
  <field class="tourma.JdgCoach" name="jlbHandicap" map="O"/>
  <field class="tourma.JdgCoach" name="jtfRank" map="P"/>
  <field class="tourma.JdgCoach" name="jPanel7" map="Q"/>
  <field class="tourma.JdgCoach" name="jtfPinCode" map="R"/>
  <field class="tourma.JdgCoach" name="jLabel7" map="S"/>
  <field class="tourma.JdgCoach" name="jPanel6" map="T"/>
  <field class="tourma.JdgCoach" name="jLabel6" map="U"/>
  <field class="tourma.JdgCoach" name="jPanel5" map="V"/>
  <field class="tourma.JdgCoach" name="jLabel5" map="W"/>
  <field class="tourma.JdgCoach" name="jPanel4" map="X"/>
  <field class="tourma.JdgCoach" name="LOG" map="Y"/>
  <field class="tourma.JdgCoach" name="jLabel4" map="Z"/>
  <field class="tourma.JdgCoach" name="jPanel3" map="_"/>
  <field class="tourma.JdgCoach" name="jLabel3" map="a"/>
  <field class="tourma.JdgCoach" name="jPanel2" map="b"/>
  <field class="tourma.JdgCoach" name="jLabel2" map="c"/>
  <field class="tourma.JdgCoach" name="jPanel1" map="d"/>
  <field class="tourma.JdgCoach" name="jLabel1" map="e"/>
  <field class="tourma.JdgCoach" name="jcbRoster" map="f"/>
  <field class="tourma.JdgCoach" name="jlsCompositions" map="g"/>
  <field class="tourma.JdgCoach" name="jcbClan" map="h"/>
  <field class="tourma.JdgCoach" name="jlbNafRanking" map="i"/>
  <field class="tourma.JdgCoach" name="jbtCancel" map="j"/>
  <field class="tourma.JdgCoach" name="jbtEditRoster" map="k"/>
  <field class="tourma.JdgCoach" name="jtfNAF" map="l"/>
  <field class="tourma.JdgCoach" name="jbtDelCategory" map="m"/>
  <field class="tourma.JdgCoach" name="mCoach" map="n"/>
  <field class="tourma.JdgCoach" name="jScrollPane3" map="o"/>
  <field class="tourma.JdgCoach" name="jScrollPane1" map="p"/>
  <field class="tourma.JdgCoach" name="jtfHandicap" map="q"/>
  <field class="tourma.JdgCoach" name="jbtAvatar" map="r"/>
  <field class="tourma.JdgCoach" name="jbtAddCategory" map="s"/>
  <field class="tourma.JdgCoach" name="mTeamTournament" map="t"/>
  <method class="tourma.JdgCoach" name="void jbtPinCodeActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgCoach" name="void jbtDownloadFromNafActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgCoach" name="void updatelist()" map="A"/>
  <method class="tourma.JdgCoach" name="void access$900(tourma.JdgCoach, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgCoach" name="void jbtUpdateFromDbActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgCoach" name="void jbtEditRosterActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgCoach" name="void jbtCancelActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.JdgCoach" name="void access$500(tourma.JdgCoach, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgCoach" name="void access$600(tourma.JdgCoach, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgCoach" name="void readObject(java.io.ObjectInputStream)" map="A"/>
  <method class="tourma.JdgCoach" name="void access$400(tourma.JdgCoach, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgCoach" name="void access$300(tourma.JdgCoach, java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.JdgCoach" name="void access$200(tourma.JdgCoach, java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.JdgCoach" name="void jtfNomKeyPressed(java.awt.event.KeyEvent)" map="A"/>
  <method class="tourma.JdgCoach" name="void access$100(tourma.JdgCoach, java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.JdgCoach" name="void access$000(tourma.JdgCoach, java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.JdgCoach" name="void jbtAddCategoryActionPerformed(java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.JdgCoach" name="void jbtDelActionPerformed(java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.JdgCoach" name="void initComponents()" map="B"/>
  <method class="tourma.JdgCoach" name="java.util.List getImagesResources(java.lang.String)" map="A"/>
  <method class="tourma.JdgCoach" name="void jbtDelCategoryActionPerformed(java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.JdgCoach" name="void access$1400(tourma.JdgCoach, java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.JdgCoach" name="void jtfNomPropertyChange(java.beans.PropertyChangeEvent)" map="A"/>
  <method class="tourma.JdgCoach" name="void access$800(tourma.JdgCoach, java.awt.event.KeyEvent)" map="A"/>
  <method class="tourma.JdgCoach" name="void access$1300(tourma.JdgCoach, java.awt.event.ActionEvent)" map="J"/>
  <method class="tourma.JdgCoach" name="void access$1200(tourma.JdgCoach, java.awt.event.ActionEvent)" map="K"/>
  <method class="tourma.JdgCoach" name="void access$1100(tourma.JdgCoach, java.awt.event.ActionEvent)" map="L"/>
  <method class="tourma.JdgCoach" name="void jbtAvatarActionPerformed(java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.JdgCoach" name="void access$1000(tourma.JdgCoach, java.beans.PropertyChangeEvent)" map="A"/>
  <method class="tourma.JdgCoach" name="void jcbRosterPropertyChange(java.beans.PropertyChangeEvent)" map="B"/>
  <method class="tourma.JdgCoach" name="javax.swing.ImageIcon resize(javax.swing.ImageIcon, int, int)" map="A"/>
  <method class="tourma.JdgCoach" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="J"/>
  <method class="tourma.JdgCoach" name="void writeObject(java.io.ObjectOutputStream)" map="A"/>
  <method class="tourma.JdgCoach" name="void jbtAddActionPerformed(java.awt.event.ActionEvent)" map="K"/>
  <method class="tourma.JdgCoach" name="void access$700(tourma.JdgCoach, java.beans.PropertyChangeEvent)" map="B"/>
  <method class="tourma.JdgCoach" name="void jcbRosterActionPerformed(java.awt.event.ActionEvent)" map="L"/>
  <class name="tourma.JdgRosters$6" map="6"/>
  <field class="tourma.JdgRosters$6" name="this$0" map="A"/>
  <field class="tourma.JdgRosters$6" name="strings" map="B"/>
  <method class="tourma.JdgRosters$6" name="java.lang.Object getElementAt(int)" map="getElementAt"/>
  <method class="tourma.JdgRosters$6" name="int getSize()" map="getSize"/>
  <class name="tourma.JdgRosters$5" map="5"/>
  <field class="tourma.JdgRosters$5" name="this$0" map="A"/>
  <method class="tourma.JdgRosters$5" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgRosters$4" map="4"/>
  <field class="tourma.JdgRosters$4" name="this$0" map="A"/>
  <method class="tourma.JdgRosters$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgRosters$3" map="3"/>
  <field class="tourma.JdgRosters$3" name="this$0" map="A"/>
  <method class="tourma.JdgRosters$3" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgRosters$2" map="2"/>
  <field class="tourma.JdgRosters$2" name="this$0" map="A"/>
  <method class="tourma.JdgRosters$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgRosters$1" map="1"/>
  <field class="tourma.JdgRosters$1" name="this$0" map="A"/>
  <method class="tourma.JdgRosters$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgRosters" map="I"/>
  <field class="tourma.JdgRosters" name="jlsRosters" map="A"/>
  <field class="tourma.JdgRosters" name="jbtCancel" map="B"/>
  <field class="tourma.JdgRosters" name="jScrollPane1" map="C"/>
  <field class="tourma.JdgRosters" name="jbtRemoveAll" map="D"/>
  <field class="tourma.JdgRosters" name="jbtOK" map="E"/>
  <field class="tourma.JdgRosters" name="mModel" map="F"/>
  <field class="tourma.JdgRosters" name="jbtAdd" map="G"/>
  <field class="tourma.JdgRosters" name="jbtRemove" map="H"/>
  <field class="tourma.JdgRosters" name="jPanel4" map="I"/>
  <field class="tourma.JdgRosters" name="jLabel1" map="J"/>
  <field class="tourma.JdgRosters" name="jPanel3" map="K"/>
  <field class="tourma.JdgRosters" name="jPanel2" map="L"/>
  <method class="tourma.JdgRosters" name="void access$100(tourma.JdgRosters, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgRosters" name="void access$400(tourma.JdgRosters, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgRosters" name="void initComponents()" map="A"/>
  <method class="tourma.JdgRosters" name="void jbtRemoveActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgRosters" name="void jbtAddActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgRosters" name="void access$200(tourma.JdgRosters, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgRosters" name="void jbtCancelActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgRosters" name="void access$000(tourma.JdgRosters, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgRosters" name="void access$300(tourma.JdgRosters, java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.JdgRosters" name="void jbtRemoveAllActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgRosters" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.JdgRosters" name="void update()" map="B"/>
  <class name="tourma.JdgParameters$9" map="9"/>
  <field class="tourma.JdgParameters$9" name="this$0" map="A"/>
  <method class="tourma.JdgParameters$9" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgParameters$8" map="8"/>
  <field class="tourma.JdgParameters$8" name="this$0" map="A"/>
  <method class="tourma.JdgParameters$8" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgParameters$7" map="7"/>
  <field class="tourma.JdgParameters$7" name="this$0" map="A"/>
  <method class="tourma.JdgParameters$7" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgParameters$6" map="6"/>
  <field class="tourma.JdgParameters$6" name="this$0" map="A"/>
  <method class="tourma.JdgParameters$6" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgParameters$5" map="5"/>
  <field class="tourma.JdgParameters$5" name="this$0" map="A"/>
  <method class="tourma.JdgParameters$5" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgParameters$13" map="13"/>
  <field class="tourma.JdgParameters$13" name="$SwitchMap$tourma$data$EIndivPairing" map="A"/>
  <class name="tourma.JdgParameters$4" map="4"/>
  <field class="tourma.JdgParameters$4" name="this$0" map="A"/>
  <method class="tourma.JdgParameters$4" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgParameters$3" map="3"/>
  <field class="tourma.JdgParameters$3" name="this$0" map="A"/>
  <method class="tourma.JdgParameters$3" name="void stateChanged(javax.swing.event.ChangeEvent)" map="stateChanged"/>
  <class name="tourma.JdgParameters$12" map="12"/>
  <field class="tourma.JdgParameters$12" name="this$0" map="A"/>
  <method class="tourma.JdgParameters$12" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgParameters$2" map="2"/>
  <field class="tourma.JdgParameters$2" name="this$0" map="A"/>
  <method class="tourma.JdgParameters$2" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgParameters$11" map="11"/>
  <field class="tourma.JdgParameters$11" name="this$0" map="A"/>
  <method class="tourma.JdgParameters$11" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgParameters$10" map="10"/>
  <field class="tourma.JdgParameters$10" name="this$0" map="A"/>
  <method class="tourma.JdgParameters$10" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgParameters$1" map="1"/>
  <field class="tourma.JdgParameters$1" name="this$0" map="A"/>
  <method class="tourma.JdgParameters$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="tourma.JdgParameters" map="J"/>
  <field class="tourma.JdgParameters" name="jlbNbCoachs" map="A"/>
  <field class="tourma.JdgParameters" name="btgTeam" map="B"/>
  <field class="tourma.JdgParameters" name="btgTeamPairing" map="C"/>
  <field class="tourma.JdgParameters" name="jPanel5" map="D"/>
  <field class="tourma.JdgParameters" name="jPanel3" map="E"/>
  <field class="tourma.JdgParameters" name="btgGame" map="F"/>
  <field class="tourma.JdgParameters" name="jPanel2" map="G"/>
  <field class="tourma.JdgParameters" name="jckSubstitutes" map="H"/>
  <field class="tourma.JdgParameters" name="jpnIndivTeamRanking" map="I"/>
  <field class="tourma.JdgParameters" name="jrbIndividualTeamPairing" map="J"/>
  <field class="tourma.JdgParameters" name="jrbIndivPairingRandom" map="K"/>
  <field class="tourma.JdgParameters" name="jpnOK" map="L"/>
  <field class="tourma.JdgParameters" name="jrbIndivPairingManual" map="M"/>
  <field class="tourma.JdgParameters" name="mParams" map="N"/>
  <field class="tourma.JdgParameters" name="jrbTeamPairing" map="O"/>
  <field class="tourma.JdgParameters" name="jrbIndividual" map="P"/>
  <field class="tourma.JdgParameters" name="jrbIndivPairingNaf" map="Q"/>
  <field class="tourma.JdgParameters" name="jpnMisc" map="R"/>
  <field class="tourma.JdgParameters" name="jspCoachNumber" map="S"/>
  <field class="tourma.JdgParameters" name="jpnNbCoachs" map="T"/>
  <field class="tourma.JdgParameters" name="btgIndivTeamPairing" map="U"/>
  <field class="tourma.JdgParameters" name="jbtOK" map="V"/>
  <field class="tourma.JdgParameters" name="jcxMultipleRoster" map="W"/>
  <field class="tourma.JdgParameters" name="jrbTeam" map="X"/>
  <field class="tourma.JdgParameters" name="jrbIndivPairingByRanking" map="Y"/>
  <field class="tourma.JdgParameters" name="jpnTeam" map="Z"/>
  <field class="tourma.JdgParameters" name="jLabel3" map="_"/>
  <field class="tourma.JdgParameters" name="jcbMultiroster" map="a"/>
  <field class="tourma.JdgParameters" name="jpnByTeam" map="b"/>
  <field class="tourma.JdgParameters" name="jpnPairing" map="c"/>
  <method class="tourma.JdgParameters" name="void access$1000(tourma.JdgParameters, java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgParameters" name="void jrbIndivPairingByRankingActionPerformed(java.awt.event.ActionEvent)" map="A"/>
  <method class="tourma.JdgParameters" name="void jrbIndivPairingRandomActionPerformed(java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgParameters" name="void initComponents()" map="A"/>
  <method class="tourma.JdgParameters" name="void jcxMultipleRosterActionPerformed(java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgParameters" name="void access$100(tourma.JdgParameters, java.awt.event.ActionEvent)" map="B"/>
  <method class="tourma.JdgParameters" name="void access$200(tourma.JdgParameters, javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.JdgParameters" name="void jrbTeamPairingActionPerformed(java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgParameters" name="void jckSubstitutesActionPerformed(java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.JdgParameters" name="void jrbIndivPairingManualActionPerformed(java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.JdgParameters" name="void access$000(tourma.JdgParameters, java.awt.event.ActionEvent)" map="C"/>
  <method class="tourma.JdgParameters" name="void access$900(tourma.JdgParameters, java.awt.event.ActionEvent)" map="D"/>
  <method class="tourma.JdgParameters" name="void jrbIndivPairingNafActionPerformed(java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.JdgParameters" name="void access$800(tourma.JdgParameters, java.awt.event.ActionEvent)" map="E"/>
  <method class="tourma.JdgParameters" name="void readObject(java.io.ObjectInputStream)" map="A"/>
  <method class="tourma.JdgParameters" name="void access$700(tourma.JdgParameters, java.awt.event.ActionEvent)" map="F"/>
  <method class="tourma.JdgParameters" name="void access$600(tourma.JdgParameters, java.awt.event.ActionEvent)" map="G"/>
  <method class="tourma.JdgParameters" name="void access$500(tourma.JdgParameters, java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.JdgParameters" name="void jrbIndividualTeamPairingActionPerformed(java.awt.event.ActionEvent)" map="H"/>
  <method class="tourma.JdgParameters" name="void jbtOKActionPerformed(java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.JdgParameters" name="void jspCoachNumberStateChanged(javax.swing.event.ChangeEvent)" map="A"/>
  <method class="tourma.JdgParameters" name="void access$400(tourma.JdgParameters, java.awt.event.ActionEvent)" map="I"/>
  <method class="tourma.JdgParameters" name="void jrbTeamActionPerformed(java.awt.event.ActionEvent)" map="J"/>
  <method class="tourma.JdgParameters" name="void writeObject(java.io.ObjectOutputStream)" map="A"/>
  <method class="tourma.JdgParameters" name="void update()" map="B"/>
  <method class="tourma.JdgParameters" name="void jrbIndividualActionPerformed(java.awt.event.ActionEvent)" map="K"/>
  <method class="tourma.JdgParameters" name="void access$1100(tourma.JdgParameters, java.awt.event.ActionEvent)" map="J"/>
  <method class="tourma.JdgParameters" name="void access$300(tourma.JdgParameters, java.awt.event.ActionEvent)" map="K"/>
  <package name="edu" map="E"/>
  <package name="edu.umd" map="A"/>
  <package name="edu.umd.cs" map="A"/>
  <package name="edu.umd.cs.findbugs" map="A"/>
  <package name="edu.umd.cs.findbugs.internalAnnotations" map="A"/>
  <class name="edu.umd.cs.findbugs.internalAnnotations.AnalysisContextContained" map="A"/>
  <package name="edu.umd.cs.findbugs.bcel" map="B"/>
  <package name="edu.umd.cs.findbugs.bcel.generic" map="A"/>
  <class name="edu.umd.cs.findbugs.bcel.generic.package-info" map="package-info"/>
  <class name="edu.umd.cs.findbugs.bcel.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.annotations" map="C"/>
  <class name="edu.umd.cs.findbugs.annotations.SuppressFBWarnings" map="A"/>
  <method class="edu.umd.cs.findbugs.annotations.SuppressFBWarnings" name="java.lang.String justification()" map="A"/>
  <method class="edu.umd.cs.findbugs.annotations.SuppressFBWarnings" name="java.lang.String[] value()" map="B"/>
  <class name="edu.umd.cs.findbugs.annotations.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.classfile" map="D"/>
  <package name="edu.umd.cs.findbugs.classfile.impl" map="A"/>
  <class name="edu.umd.cs.findbugs.classfile.impl.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.classfile.engine" map="B"/>
  <package name="edu.umd.cs.findbugs.classfile.engine.asm" map="A"/>
  <class name="edu.umd.cs.findbugs.classfile.engine.asm.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.classfile.engine.bcel" map="B"/>
  <class name="edu.umd.cs.findbugs.classfile.engine.bcel.package-info" map="package-info"/>
  <class name="edu.umd.cs.findbugs.classfile.engine.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.classfile.analysis" map="C"/>
  <class name="edu.umd.cs.findbugs.classfile.analysis.package-info" map="package-info"/>
  <class name="edu.umd.cs.findbugs.classfile.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.ba" map="E"/>
  <package name="edu.umd.cs.findbugs.ba.ch" map="A"/>
  <class name="edu.umd.cs.findbugs.ba.ch.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.ba.vna" map="B"/>
  <class name="edu.umd.cs.findbugs.ba.vna.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.ba.deref" map="C"/>
  <class name="edu.umd.cs.findbugs.ba.deref.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.ba.heap" map="D"/>
  <class name="edu.umd.cs.findbugs.ba.heap.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.ba.obl" map="E"/>
  <class name="edu.umd.cs.findbugs.ba.obl.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.ba.ca" map="F"/>
  <class name="edu.umd.cs.findbugs.ba.ca.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.ba.interproc" map="G"/>
  <class name="edu.umd.cs.findbugs.ba.interproc.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.ba.npe" map="H"/>
  <class name="edu.umd.cs.findbugs.ba.npe.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.ba.constant" map="I"/>
  <class name="edu.umd.cs.findbugs.ba.constant.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.ba.type" map="J"/>
  <class name="edu.umd.cs.findbugs.ba.type.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.ba.generic" map="K"/>
  <class name="edu.umd.cs.findbugs.ba.generic.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.ba.jsr305" map="L"/>
  <class name="edu.umd.cs.findbugs.ba.jsr305.package-info" map="package-info"/>
  <package name="edu.umd.cs.findbugs.ba.bcp" map="M"/>
  <class name="edu.umd.cs.findbugs.ba.bcp.package-info" map="package-info"/>
  <class name="edu.umd.cs.findbugs.ba.package-info" map="package-info"/>
  <package name="org" map="F"/>
  <package name="org.xml" map="A"/>
  <package name="org.xml.sax" map="A"/>
  <package name="org.xml.sax.ext" map="A"/>
  <class name="org.xml.sax.ext.Locator2" map="A"/>
  <class name="org.xml.sax.ext.LexicalHandler" map="B"/>
  <method class="org.xml.sax.ext.LexicalHandler" name="void comment(char[], int, int)" map="A"/>
  <method class="org.xml.sax.ext.LexicalHandler" name="void startCDATA()" map="A"/>
  <method class="org.xml.sax.ext.LexicalHandler" name="void startEntity(java.lang.String)" map="A"/>
  <method class="org.xml.sax.ext.LexicalHandler" name="void endDTD()" map="B"/>
  <method class="org.xml.sax.ext.LexicalHandler" name="void endCDATA()" map="C"/>
  <method class="org.xml.sax.ext.LexicalHandler" name="void endEntity(java.lang.String)" map="B"/>
  <method class="org.xml.sax.ext.LexicalHandler" name="void startDTD(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <class name="org.xml.sax.ext.Attributes2Impl" map="C"/>
  <class name="org.xml.sax.ext.Attributes2" map="D"/>
  <class name="org.xml.sax.ext.EntityResolver2" map="E"/>
  <method class="org.xml.sax.ext.EntityResolver2" name="org.xml.sax.InputSource getExternalSubset(java.lang.String, java.lang.String)" map="B"/>
  <method class="org.xml.sax.ext.EntityResolver2" name="org.xml.sax.InputSource resolveEntity(java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <class name="org.xml.sax.ext.DeclHandler" map="F"/>
  <method class="org.xml.sax.ext.DeclHandler" name="void internalEntityDecl(java.lang.String, java.lang.String)" map="E"/>
  <method class="org.xml.sax.ext.DeclHandler" name="void attributeDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.xml.sax.ext.DeclHandler" name="void externalEntityDecl(java.lang.String, java.lang.String, java.lang.String)" map="D"/>
  <method class="org.xml.sax.ext.DeclHandler" name="void elementDecl(java.lang.String, java.lang.String)" map="F"/>
  <class name="org.xml.sax.ext.Locator2Impl" map="G"/>
  <field class="org.xml.sax.ext.Locator2Impl" name="version" map="F"/>
  <method class="org.xml.sax.ext.Locator2Impl" name="void setXMLVersion(java.lang.String)" map="C"/>
  <package name="org.xml.sax.helpers" map="B"/>
  <class name="org.xml.sax.helpers.SecuritySupport$4" map="4"/>
  <field class="org.xml.sax.helpers.SecuritySupport$4" name="val$name" map="val$name"/>
  <field class="org.xml.sax.helpers.SecuritySupport$4" name="val$cl" map="val$cl"/>
  <method class="org.xml.sax.helpers.SecuritySupport$4" name="java.lang.Object run()" map="run"/>
  <class name="org.xml.sax.helpers.SecuritySupport$2" map="2"/>
  <field class="org.xml.sax.helpers.SecuritySupport$2" name="val$propName" map="val$propName"/>
  <method class="org.xml.sax.helpers.SecuritySupport$2" name="java.lang.Object run()" map="run"/>
  <class name="org.xml.sax.helpers.SecuritySupport$1" map="1"/>
  <method class="org.xml.sax.helpers.SecuritySupport$1" name="java.lang.Object run()" map="run"/>
  <class name="org.xml.sax.helpers.SecuritySupport" map="A"/>
  <method class="org.xml.sax.helpers.SecuritySupport" name="java.io.InputStream getResourceAsStream(java.lang.ClassLoader, java.lang.String)" map="A"/>
  <method class="org.xml.sax.helpers.SecuritySupport" name="java.lang.ClassLoader getContextClassLoader()" map="A"/>
  <method class="org.xml.sax.helpers.SecuritySupport" name="java.lang.String getSystemProperty(java.lang.String)" map="A"/>
  <class name="org.xml.sax.helpers.NewInstance" map="B"/>
  <field class="org.xml.sax.helpers.NewInstance" name="class$org$xml$sax$helpers$NewInstance" map="class$F$A$A$B$B"/>
  <method class="org.xml.sax.helpers.NewInstance" name="java.lang.ClassLoader getClassLoader()" map="A"/>
  <method class="org.xml.sax.helpers.NewInstance" name="java.lang.Object newInstance(java.lang.ClassLoader, java.lang.String)" map="A"/>
  <method class="org.xml.sax.helpers.NewInstance" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <class name="org.xml.sax.helpers.DefaultHandler" map="C"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void warning(org.xml.sax.SAXParseException)" map="B"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void endElement(java.lang.String, java.lang.String, java.lang.String)" map="C"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void unparsedEntityDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void fatalError(org.xml.sax.SAXParseException)" map="C"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void processingInstruction(java.lang.String, java.lang.String)" map="C"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void setDocumentLocator(org.xml.sax.Locator)" map="A"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="org.xml.sax.InputSource resolveEntity(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void ignorableWhitespace(char[], int, int)" map="B"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void error(org.xml.sax.SAXParseException)" map="A"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void skippedEntity(java.lang.String)" map="C"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)" map="A"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void endDocument()" map="D"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void startPrefixMapping(java.lang.String, java.lang.String)" map="D"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void endPrefixMapping(java.lang.String)" map="D"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void characters(char[], int, int)" map="C"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void startDocument()" map="E"/>
  <method class="org.xml.sax.helpers.DefaultHandler" name="void notationDecl(java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <class name="org.xml.sax.helpers.ParserAdapter$AttributeListAdapter" map="_A"/>
  <field class="org.xml.sax.helpers.ParserAdapter$AttributeListAdapter" name="this$0" map="this$0"/>
  <field class="org.xml.sax.helpers.ParserAdapter$AttributeListAdapter" name="qAtts" map="D"/>
  <method class="org.xml.sax.helpers.ParserAdapter$AttributeListAdapter" name="java.lang.String getQName(int)" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter$AttributeListAdapter" name="java.lang.String getURI(int)" map="B"/>
  <method class="org.xml.sax.helpers.ParserAdapter$AttributeListAdapter" name="java.lang.String getValue(int)" map="C"/>
  <method class="org.xml.sax.helpers.ParserAdapter$AttributeListAdapter" name="java.lang.String getLocalName(int)" map="D"/>
  <method class="org.xml.sax.helpers.ParserAdapter$AttributeListAdapter" name="void setAttributeList(org.xml.sax.AttributeList)" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter$AttributeListAdapter" name="int getLength()" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter$AttributeListAdapter" name="java.lang.String getType(int)" map="E"/>
  <class name="org.xml.sax.helpers.ParserAdapter" map="D"/>
  <field class="org.xml.sax.helpers.ParserAdapter" name="parser" map="&#x0452;"/>
  <field class="org.xml.sax.helpers.ParserAdapter" name="namespaces" map="&#x0453;"/>
  <field class="org.xml.sax.helpers.ParserAdapter" name="nsSupport" map="&#x0454;"/>
  <field class="org.xml.sax.helpers.ParserAdapter" name="contentHandler" map="&#x0455;"/>
  <field class="org.xml.sax.helpers.ParserAdapter" name="prefixes" map="&#x0456;"/>
  <field class="org.xml.sax.helpers.ParserAdapter" name="nameParts" map="&#x0457;"/>
  <field class="org.xml.sax.helpers.ParserAdapter" name="locator" map="&#x0458;"/>
  <field class="org.xml.sax.helpers.ParserAdapter" name="errorHandler" map="&#x0459;"/>
  <field class="org.xml.sax.helpers.ParserAdapter" name="attAdapter" map="&#x045a;"/>
  <field class="org.xml.sax.helpers.ParserAdapter" name="atts" map="&#x045b;"/>
  <field class="org.xml.sax.helpers.ParserAdapter" name="parsing" map="&#x045c;"/>
  <field class="org.xml.sax.helpers.ParserAdapter" name="uris" map="&#x045e;"/>
  <field class="org.xml.sax.helpers.ParserAdapter" name="entityResolver" map="&#x045f;"/>
  <field class="org.xml.sax.helpers.ParserAdapter" name="dtdHandler" map="&#x0460;"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void setDocumentLocator(org.xml.sax.Locator)" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void checkNotParsing(java.lang.String, java.lang.String)" map="O"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void endElement(java.lang.String)" map="u"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void reportError(java.lang.String)" map="v"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void setProperty(java.lang.String, java.lang.Object)" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void parse(org.xml.sax.InputSource)" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void setup(org.xml.sax.Parser)" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void startDocument()" map="&#x0100;"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void characters(char[], int, int)" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void setEntityResolver(org.xml.sax.EntityResolver)" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void processingInstruction(java.lang.String, java.lang.String)" map="N"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void setDTDHandler(org.xml.sax.DTDHandler)" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void setContentHandler(org.xml.sax.ContentHandler)" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="java.lang.String[] processName(java.lang.String, boolean, boolean)" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="boolean getFeature(java.lang.String)" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void ignorableWhitespace(char[], int, int)" map="B"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void startElement(java.lang.String, org.xml.sax.AttributeList)" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="org.xml.sax.SAXParseException makeException(java.lang.String)" map="w"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void setErrorHandler(org.xml.sax.ErrorHandler)" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void setFeature(java.lang.String, boolean)" map="A"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void setupParser()" map="&#x0101;"/>
  <method class="org.xml.sax.helpers.ParserAdapter" name="void endDocument()" map="&#x00ff;"/>
  <class name="org.xml.sax.helpers.LocatorImpl" map="E"/>
  <field class="org.xml.sax.helpers.LocatorImpl" name="lineNumber" map="A"/>
  <field class="org.xml.sax.helpers.LocatorImpl" name="systemId" map="B"/>
  <field class="org.xml.sax.helpers.LocatorImpl" name="columnNumber" map="C"/>
  <field class="org.xml.sax.helpers.LocatorImpl" name="publicId" map="D"/>
  <method class="org.xml.sax.helpers.LocatorImpl" name="java.lang.String getPublicId()" map="A"/>
  <method class="org.xml.sax.helpers.LocatorImpl" name="void setLineNumber(int)" map="A"/>
  <method class="org.xml.sax.helpers.LocatorImpl" name="void setSystemId(java.lang.String)" map="A"/>
  <method class="org.xml.sax.helpers.LocatorImpl" name="int getColumnNumber()" map="B"/>
  <method class="org.xml.sax.helpers.LocatorImpl" name="int getLineNumber()" map="C"/>
  <method class="org.xml.sax.helpers.LocatorImpl" name="java.lang.String getSystemId()" map="D"/>
  <method class="org.xml.sax.helpers.LocatorImpl" name="void setColumnNumber(int)" map="B"/>
  <method class="org.xml.sax.helpers.LocatorImpl" name="void setPublicId(java.lang.String)" map="B"/>
  <class name="org.xml.sax.helpers.AttributesImpl" map="F"/>
  <field class="org.xml.sax.helpers.AttributesImpl" name="length" map="A"/>
  <field class="org.xml.sax.helpers.AttributesImpl" name="data" map="B"/>
  <method class="org.xml.sax.helpers.AttributesImpl" name="java.lang.String getType(int)" map="E"/>
  <method class="org.xml.sax.helpers.AttributesImpl" name="java.lang.String getURI(int)" map="B"/>
  <method class="org.xml.sax.helpers.AttributesImpl" name="int getLength()" map="A"/>
  <method class="org.xml.sax.helpers.AttributesImpl" name="java.lang.String getLocalName(int)" map="D"/>
  <method class="org.xml.sax.helpers.AttributesImpl" name="java.lang.String getQName(int)" map="A"/>
  <method class="org.xml.sax.helpers.AttributesImpl" name="void clear()" map="B"/>
  <method class="org.xml.sax.helpers.AttributesImpl" name="void addAttribute(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.xml.sax.helpers.AttributesImpl" name="void ensureCapacity(int)" map="F"/>
  <method class="org.xml.sax.helpers.AttributesImpl" name="java.lang.String getValue(int)" map="C"/>
  <class name="org.xml.sax.helpers.NamespaceSupport$Context" map="_A"/>
  <field class="org.xml.sax.helpers.NamespaceSupport$Context" name="elementNameTable" map="A"/>
  <field class="org.xml.sax.helpers.NamespaceSupport$Context" name="attributeNameTable" map="B"/>
  <field class="org.xml.sax.helpers.NamespaceSupport$Context" name="declSeen" map="C"/>
  <field class="org.xml.sax.helpers.NamespaceSupport$Context" name="prefixTable" map="D"/>
  <field class="org.xml.sax.helpers.NamespaceSupport$Context" name="defaultNS" map="E"/>
  <field class="org.xml.sax.helpers.NamespaceSupport$Context" name="this$0" map="this$0"/>
  <field class="org.xml.sax.helpers.NamespaceSupport$Context" name="uriTable" map="F"/>
  <field class="org.xml.sax.helpers.NamespaceSupport$Context" name="parent" map="G"/>
  <field class="org.xml.sax.helpers.NamespaceSupport$Context" name="declarations" map="H"/>
  <method class="org.xml.sax.helpers.NamespaceSupport$Context" name="void declarePrefix(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.xml.sax.helpers.NamespaceSupport$Context" name="java.util.Enumeration getDeclaredPrefixes()" map="A"/>
  <method class="org.xml.sax.helpers.NamespaceSupport$Context" name="void clear()" map="B"/>
  <method class="org.xml.sax.helpers.NamespaceSupport$Context" name="void setParent(org.xml.sax.helpers.NamespaceSupport$Context)" map="A"/>
  <method class="org.xml.sax.helpers.NamespaceSupport$Context" name="void copyTables()" map="C"/>
  <method class="org.xml.sax.helpers.NamespaceSupport$Context" name="java.lang.String[] processName(java.lang.String, boolean)" map="A"/>
  <class name="org.xml.sax.helpers.NamespaceSupport" map="G"/>
  <field class="org.xml.sax.helpers.NamespaceSupport" name="namespaceDeclUris" map="A"/>
  <field class="org.xml.sax.helpers.NamespaceSupport" name="currentContext" map="B"/>
  <field class="org.xml.sax.helpers.NamespaceSupport" name="EMPTY_ENUMERATION" map="C"/>
  <field class="org.xml.sax.helpers.NamespaceSupport" name="contextPos" map="D"/>
  <field class="org.xml.sax.helpers.NamespaceSupport" name="contexts" map="E"/>
  <method class="org.xml.sax.helpers.NamespaceSupport" name="void popContext()" map="A"/>
  <method class="org.xml.sax.helpers.NamespaceSupport" name="void reset()" map="B"/>
  <method class="org.xml.sax.helpers.NamespaceSupport" name="java.util.Enumeration access$100()" map="access$100"/>
  <method class="org.xml.sax.helpers.NamespaceSupport" name="boolean declarePrefix(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.xml.sax.helpers.NamespaceSupport" name="java.util.Enumeration getDeclaredPrefixes()" map="C"/>
  <method class="org.xml.sax.helpers.NamespaceSupport" name="java.lang.String[] processName(java.lang.String, java.lang.String[], boolean)" map="A"/>
  <method class="org.xml.sax.helpers.NamespaceSupport" name="boolean access$000(org.xml.sax.helpers.NamespaceSupport)" map="access$000"/>
  <method class="org.xml.sax.helpers.NamespaceSupport" name="void setNamespaceDeclUris(boolean)" map="A"/>
  <method class="org.xml.sax.helpers.NamespaceSupport" name="void pushContext()" map="D"/>
  <class name="org.xml.sax.helpers.ParserFactory" map="H"/>
  <method class="org.xml.sax.helpers.ParserFactory" name="org.xml.sax.Parser makeParser(java.lang.String)" map="A"/>
  <method class="org.xml.sax.helpers.ParserFactory" name="org.xml.sax.Parser makeParser()" map="A"/>
  <class name="org.xml.sax.helpers.XMLReaderFactory" map="I"/>
  <field class="org.xml.sax.helpers.XMLReaderFactory" name="class$org$xml$sax$helpers$XMLReaderFactory" map="class$F$A$A$B$I"/>
  <method class="org.xml.sax.helpers.XMLReaderFactory" name="org.xml.sax.XMLReader createXMLReader(java.lang.String)" map="A"/>
  <method class="org.xml.sax.helpers.XMLReaderFactory" name="org.xml.sax.XMLReader createXMLReader()" map="A"/>
  <method class="org.xml.sax.helpers.XMLReaderFactory" name="org.xml.sax.XMLReader loadClass(java.lang.ClassLoader, java.lang.String)" map="A"/>
  <method class="org.xml.sax.helpers.XMLReaderFactory" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <class name="org.xml.sax.XMLReader" map="A"/>
  <method class="org.xml.sax.XMLReader" name="void setProperty(java.lang.String, java.lang.Object)" map="A"/>
  <method class="org.xml.sax.XMLReader" name="void setDTDHandler(org.xml.sax.DTDHandler)" map="A"/>
  <method class="org.xml.sax.XMLReader" name="void setFeature(java.lang.String, boolean)" map="A"/>
  <method class="org.xml.sax.XMLReader" name="void setEntityResolver(org.xml.sax.EntityResolver)" map="A"/>
  <method class="org.xml.sax.XMLReader" name="boolean getFeature(java.lang.String)" map="A"/>
  <method class="org.xml.sax.XMLReader" name="void parse(org.xml.sax.InputSource)" map="A"/>
  <method class="org.xml.sax.XMLReader" name="void setErrorHandler(org.xml.sax.ErrorHandler)" map="A"/>
  <method class="org.xml.sax.XMLReader" name="void setContentHandler(org.xml.sax.ContentHandler)" map="A"/>
  <class name="org.xml.sax.DocumentHandler" map="B"/>
  <method class="org.xml.sax.DocumentHandler" name="void startElement(java.lang.String, org.xml.sax.AttributeList)" map="A"/>
  <method class="org.xml.sax.DocumentHandler" name="void endElement(java.lang.String)" map="u"/>
  <method class="org.xml.sax.DocumentHandler" name="void endDocument()" map="&#x00ff;"/>
  <method class="org.xml.sax.DocumentHandler" name="void characters(char[], int, int)" map="A"/>
  <method class="org.xml.sax.DocumentHandler" name="void startDocument()" map="&#x0100;"/>
  <method class="org.xml.sax.DocumentHandler" name="void setDocumentLocator(org.xml.sax.Locator)" map="A"/>
  <method class="org.xml.sax.DocumentHandler" name="void processingInstruction(java.lang.String, java.lang.String)" map="N"/>
  <method class="org.xml.sax.DocumentHandler" name="void ignorableWhitespace(char[], int, int)" map="B"/>
  <class name="org.xml.sax.SAXException" map="C"/>
  <field class="org.xml.sax.SAXException" name="exception" map="A"/>
  <method class="org.xml.sax.SAXException" name="java.lang.Exception getException()" map="A"/>
  <method class="org.xml.sax.SAXException" name="java.lang.String getMessage()" map="getMessage"/>
  <method class="org.xml.sax.SAXException" name="java.lang.String toString()" map="toString"/>
  <class name="org.xml.sax.ErrorHandler" map="D"/>
  <method class="org.xml.sax.ErrorHandler" name="void error(org.xml.sax.SAXParseException)" map="A"/>
  <method class="org.xml.sax.ErrorHandler" name="void warning(org.xml.sax.SAXParseException)" map="B"/>
  <method class="org.xml.sax.ErrorHandler" name="void fatalError(org.xml.sax.SAXParseException)" map="C"/>
  <class name="org.xml.sax.SAXParseException" map="E"/>
  <field class="org.xml.sax.SAXParseException" name="lineNumber" map="B"/>
  <field class="org.xml.sax.SAXParseException" name="systemId" map="C"/>
  <field class="org.xml.sax.SAXParseException" name="columnNumber" map="D"/>
  <field class="org.xml.sax.SAXParseException" name="publicId" map="E"/>
  <method class="org.xml.sax.SAXParseException" name="java.lang.String getPublicId()" map="B"/>
  <method class="org.xml.sax.SAXParseException" name="void init(java.lang.String, java.lang.String, int, int)" map="A"/>
  <method class="org.xml.sax.SAXParseException" name="int getColumnNumber()" map="C"/>
  <method class="org.xml.sax.SAXParseException" name="int getLineNumber()" map="D"/>
  <method class="org.xml.sax.SAXParseException" name="java.lang.String getSystemId()" map="E"/>
  <class name="org.xml.sax.Attributes" map="F"/>
  <method class="org.xml.sax.Attributes" name="java.lang.String getQName(int)" map="A"/>
  <method class="org.xml.sax.Attributes" name="java.lang.String getURI(int)" map="B"/>
  <method class="org.xml.sax.Attributes" name="java.lang.String getValue(int)" map="C"/>
  <method class="org.xml.sax.Attributes" name="java.lang.String getLocalName(int)" map="D"/>
  <method class="org.xml.sax.Attributes" name="int getLength()" map="A"/>
  <method class="org.xml.sax.Attributes" name="java.lang.String getType(int)" map="E"/>
  <class name="org.xml.sax.Parser" map="G"/>
  <method class="org.xml.sax.Parser" name="void setDTDHandler(org.xml.sax.DTDHandler)" map="A"/>
  <method class="org.xml.sax.Parser" name="void setEntityResolver(org.xml.sax.EntityResolver)" map="A"/>
  <method class="org.xml.sax.Parser" name="void parse(org.xml.sax.InputSource)" map="A"/>
  <method class="org.xml.sax.Parser" name="void setErrorHandler(org.xml.sax.ErrorHandler)" map="A"/>
  <method class="org.xml.sax.Parser" name="void setDocumentHandler(org.xml.sax.DocumentHandler)" map="A"/>
  <class name="org.xml.sax.ContentHandler" map="H"/>
  <method class="org.xml.sax.ContentHandler" name="void endElement(java.lang.String, java.lang.String, java.lang.String)" map="C"/>
  <method class="org.xml.sax.ContentHandler" name="void processingInstruction(java.lang.String, java.lang.String)" map="C"/>
  <method class="org.xml.sax.ContentHandler" name="void setDocumentLocator(org.xml.sax.Locator)" map="A"/>
  <method class="org.xml.sax.ContentHandler" name="void ignorableWhitespace(char[], int, int)" map="B"/>
  <method class="org.xml.sax.ContentHandler" name="void skippedEntity(java.lang.String)" map="C"/>
  <method class="org.xml.sax.ContentHandler" name="void startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)" map="A"/>
  <method class="org.xml.sax.ContentHandler" name="void endDocument()" map="D"/>
  <method class="org.xml.sax.ContentHandler" name="void startPrefixMapping(java.lang.String, java.lang.String)" map="D"/>
  <method class="org.xml.sax.ContentHandler" name="void endPrefixMapping(java.lang.String)" map="D"/>
  <method class="org.xml.sax.ContentHandler" name="void characters(char[], int, int)" map="C"/>
  <method class="org.xml.sax.ContentHandler" name="void startDocument()" map="E"/>
  <class name="org.xml.sax.SAXNotRecognizedException" map="I"/>
  <class name="org.xml.sax.SAXNotSupportedException" map="J"/>
  <class name="org.xml.sax.XMLFilter" map="K"/>
  <method class="org.xml.sax.XMLFilter" name="void setParent(org.xml.sax.XMLReader)" map="A"/>
  <method class="org.xml.sax.XMLFilter" name="org.xml.sax.XMLReader getParent()" map="A"/>
  <class name="org.xml.sax.DTDHandler" map="L"/>
  <method class="org.xml.sax.DTDHandler" name="void unparsedEntityDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="org.xml.sax.DTDHandler" name="void notationDecl(java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <class name="org.xml.sax.InputSource" map="M"/>
  <field class="org.xml.sax.InputSource" name="systemId" map="A"/>
  <field class="org.xml.sax.InputSource" name="characterStream" map="B"/>
  <field class="org.xml.sax.InputSource" name="byteStream" map="C"/>
  <field class="org.xml.sax.InputSource" name="encoding" map="D"/>
  <field class="org.xml.sax.InputSource" name="publicId" map="E"/>
  <method class="org.xml.sax.InputSource" name="java.lang.String getPublicId()" map="A"/>
  <method class="org.xml.sax.InputSource" name="java.io.InputStream getByteStream()" map="B"/>
  <method class="org.xml.sax.InputSource" name="java.lang.String getEncoding()" map="C"/>
  <method class="org.xml.sax.InputSource" name="void setByteStream(java.io.InputStream)" map="A"/>
  <method class="org.xml.sax.InputSource" name="java.io.Reader getCharacterStream()" map="D"/>
  <method class="org.xml.sax.InputSource" name="void setSystemId(java.lang.String)" map="A"/>
  <method class="org.xml.sax.InputSource" name="java.lang.String getSystemId()" map="E"/>
  <method class="org.xml.sax.InputSource" name="void setCharacterStream(java.io.Reader)" map="A"/>
  <class name="org.xml.sax.EntityResolver" map="N"/>
  <method class="org.xml.sax.EntityResolver" name="org.xml.sax.InputSource resolveEntity(java.lang.String, java.lang.String)" map="A"/>
  <class name="org.xml.sax.Locator" map="O"/>
  <method class="org.xml.sax.Locator" name="java.lang.String getPublicId()" map="A"/>
  <method class="org.xml.sax.Locator" name="int getColumnNumber()" map="B"/>
  <method class="org.xml.sax.Locator" name="int getLineNumber()" map="C"/>
  <method class="org.xml.sax.Locator" name="java.lang.String getSystemId()" map="D"/>
  <class name="org.xml.sax.AttributeList" map="P"/>
  <method class="org.xml.sax.AttributeList" name="java.lang.String getValue(int)" map="C"/>
  <method class="org.xml.sax.AttributeList" name="int getLength()" map="A"/>
  <method class="org.xml.sax.AttributeList" name="java.lang.String getType(int)" map="E"/>
  <method class="org.xml.sax.AttributeList" name="java.lang.String getName(int)" map="G"/>
  <package name="org.jfree" map="B"/>
  <package name="org.jfree.base" map="A"/>
  <package name="org.jfree.base.modules" map="A"/>
  <class name="org.jfree.base.modules.SubSystem" map="A"/>
  <class name="org.jfree.base.modules.PackageManager$PackageConfiguration" map="_A"/>
  <method class="org.jfree.base.modules.PackageManager$PackageConfiguration" name="void insertConfiguration(org.jfree.base.config.HierarchicalConfiguration)" map="A"/>
  <class name="org.jfree.base.modules.PackageManager" map="B"/>
  <field class="org.jfree.base.modules.PackageManager" name="initSections" map="A"/>
  <field class="org.jfree.base.modules.PackageManager" name="booter" map="B"/>
  <field class="org.jfree.base.modules.PackageManager" name="modules" map="C"/>
  <field class="org.jfree.base.modules.PackageManager" name="packageConfiguration" map="D"/>
  <field class="org.jfree.base.modules.PackageManager" name="instances" map="E"/>
  <method class="org.jfree.base.modules.PackageManager" name="org.jfree.base.modules.PackageManager createInstance(org.jfree.base.AbstractBoot)" map="A"/>
  <method class="org.jfree.base.modules.PackageManager" name="org.jfree.base.modules.PackageManager$PackageConfiguration getPackageConfiguration()" map="A"/>
  <package name="org.jfree.base.config" map="B"/>
  <class name="org.jfree.base.config.HierarchicalConfiguration" map="A"/>
  <field class="org.jfree.base.config.HierarchicalConfiguration" name="parentConfiguration" map="&#x0425;"/>
  <field class="org.jfree.base.config.HierarchicalConfiguration" name="configuration" map="&#x0426;"/>
  <method class="org.jfree.base.config.HierarchicalConfiguration" name="java.util.Properties getConfiguration()" map="&#x01ab;"/>
  <method class="org.jfree.base.config.HierarchicalConfiguration" name="void insertConfiguration(org.jfree.base.config.HierarchicalConfiguration)" map="A"/>
  <method class="org.jfree.base.config.HierarchicalConfiguration" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.base.config.HierarchicalConfiguration" name="org.jfree.util.Configuration getParentConfig()" map="&#x01ac;"/>
  <method class="org.jfree.base.config.HierarchicalConfiguration" name="java.lang.String getConfigProperty(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.jfree.base.config.HierarchicalConfiguration" name="boolean isRootConfig()" map="&#x01ad;"/>
  <method class="org.jfree.base.config.HierarchicalConfiguration" name="void setParentConfig(org.jfree.util.Configuration)" map="A"/>
  <class name="org.jfree.base.config.SystemPropertyConfiguration" map="B"/>
  <method class="org.jfree.base.config.SystemPropertyConfiguration" name="java.lang.String getConfigProperty(java.lang.String, java.lang.String)" map="A"/>
  <class name="org.jfree.base.config.ModifiableConfiguration" map="C"/>
  <class name="org.jfree.base.config.PropertyFileConfiguration" map="D"/>
  <method class="org.jfree.base.config.PropertyFileConfiguration" name="void load(java.lang.String, java.lang.Class)" map="A"/>
  <method class="org.jfree.base.config.PropertyFileConfiguration" name="void load(java.io.InputStream)" map="A"/>
  <class name="org.jfree.base.BaseBoot" map="A"/>
  <field class="org.jfree.base.BaseBoot" name="class$org$jfree$base$BaseBoot" map="class$F$B$A$A"/>
  <field class="org.jfree.base.BaseBoot" name="bootableProjectInfo" map="C"/>
  <field class="org.jfree.base.BaseBoot" name="singleton" map="D"/>
  <method class="org.jfree.base.BaseBoot" name="org.jfree.util.Configuration loadConfiguration()" map="A"/>
  <method class="org.jfree.base.BaseBoot" name="org.jfree.base.AbstractBoot getInstance()" map="D"/>
  <method class="org.jfree.base.BaseBoot" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <class name="org.jfree.base.Library" map="B"/>
  <field class="org.jfree.base.Library" name="version" map="A"/>
  <field class="org.jfree.base.Library" name="name" map="B"/>
  <field class="org.jfree.base.Library" name="licenceName" map="C"/>
  <field class="org.jfree.base.Library" name="info" map="D"/>
  <method class="org.jfree.base.Library" name="java.lang.String getVersion()" map="A"/>
  <method class="org.jfree.base.Library" name="java.lang.String getInfo()" map="B"/>
  <method class="org.jfree.base.Library" name="void setVersion(java.lang.String)" map="A"/>
  <method class="org.jfree.base.Library" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.base.Library" name="void setName(java.lang.String)" map="B"/>
  <method class="org.jfree.base.Library" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.base.Library" name="void setInfo(java.lang.String)" map="C"/>
  <method class="org.jfree.base.Library" name="java.lang.String getName()" map="C"/>
  <method class="org.jfree.base.Library" name="void setLicenceName(java.lang.String)" map="D"/>
  <class name="org.jfree.base.BasicProjectInfo$OptionalLibraryHolder" map="_A"/>
  <field class="org.jfree.base.BasicProjectInfo$OptionalLibraryHolder" name="library" map="A"/>
  <field class="org.jfree.base.BasicProjectInfo$OptionalLibraryHolder" name="libraryClass" map="B"/>
  <class name="org.jfree.base.BasicProjectInfo" map="C"/>
  <field class="org.jfree.base.BasicProjectInfo" name="libraries" map="E"/>
  <field class="org.jfree.base.BasicProjectInfo" name="copyright" map="F"/>
  <field class="org.jfree.base.BasicProjectInfo" name="optionalLibraries" map="G"/>
  <method class="org.jfree.base.BasicProjectInfo" name="void setVersion(java.lang.String)" map="A"/>
  <method class="org.jfree.base.BasicProjectInfo" name="void setName(java.lang.String)" map="B"/>
  <method class="org.jfree.base.BasicProjectInfo" name="void setInfo(java.lang.String)" map="C"/>
  <method class="org.jfree.base.BasicProjectInfo" name="void addOptionalLibrary(org.jfree.base.Library)" map="A"/>
  <method class="org.jfree.base.BasicProjectInfo" name="org.jfree.base.Library[] getLibraries()" map="D"/>
  <method class="org.jfree.base.BasicProjectInfo" name="void addLibrary(org.jfree.base.Library)" map="B"/>
  <method class="org.jfree.base.BasicProjectInfo" name="void setCopyright(java.lang.String)" map="E"/>
  <method class="org.jfree.base.BasicProjectInfo" name="void setLicenceName(java.lang.String)" map="D"/>
  <method class="org.jfree.base.BasicProjectInfo" name="java.lang.String getCopyright()" map="E"/>
  <class name="org.jfree.base.BootableProjectInfo" map="D"/>
  <field class="org.jfree.base.BootableProjectInfo" name="autoBoot" map="H"/>
  <field class="org.jfree.base.BootableProjectInfo" name="bootClass" map="I"/>
  <method class="org.jfree.base.BootableProjectInfo" name="void setBootClass(java.lang.String)" map="F"/>
  <class name="org.jfree.base.AbstractBoot" map="E"/>
  <field class="org.jfree.base.AbstractBoot" name="packageManager" map="A"/>
  <field class="org.jfree.base.AbstractBoot" name="globalConfig" map="B"/>
  <method class="org.jfree.base.AbstractBoot" name="org.jfree.util.Configuration loadConfiguration()" map="A"/>
  <method class="org.jfree.base.AbstractBoot" name="org.jfree.util.Configuration createDefaultHierarchicalConfiguration(java.lang.String, java.lang.String, boolean, java.lang.Class)" map="A"/>
  <method class="org.jfree.base.AbstractBoot" name="org.jfree.util.Configuration getGlobalConfig()" map="B"/>
  <method class="org.jfree.base.AbstractBoot" name="org.jfree.base.modules.PackageManager getPackageManager()" map="C"/>
  <package name="org.jfree.resources" map="B"/>
  <class name="org.jfree.resources.JCommonResources" map="A"/>
  <field class="org.jfree.resources.JCommonResources" name="CONTENTS" map="A"/>
  <method class="org.jfree.resources.JCommonResources" name="java.lang.Object[][] getContents()" map="getContents"/>
  <package name="org.jfree.data" map="C"/>
  <package name="org.jfree.data.general" map="A"/>
  <class name="org.jfree.data.general.DefaultValueDataset" map="A"/>
  <class name="org.jfree.data.general.DefaultKeyedValues2DDataset" map="B"/>
  <class name="org.jfree.data.general.DefaultKeyedValuesDataset" map="C"/>
  <class name="org.jfree.data.general.SubSeriesDataset" map="D"/>
  <method class="org.jfree.data.general.SubSeriesDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.general.SubSeriesDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.general.SubSeriesDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.general.SubSeriesDataset" name="double getLowValue(int, int)" map="O"/>
  <method class="org.jfree.data.general.SubSeriesDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.general.SubSeriesDataset" name="double getHighValue(int, int)" map="P"/>
  <method class="org.jfree.data.general.SubSeriesDataset" name="int getItemCount(int)" map="G"/>
  <class name="org.jfree.data.general.DatasetChangeEvent" map="E"/>
  <field class="org.jfree.data.general.DatasetChangeEvent" name="dataset" map="A"/>
  <class name="org.jfree.data.general.CombinationDataset" map="F"/>
  <class name="org.jfree.data.general.DatasetChangeListener" map="G"/>
  <method class="org.jfree.data.general.DatasetChangeListener" name="void datasetChanged(org.jfree.data.general.DatasetChangeEvent)" map="B"/>
  <class name="org.jfree.data.general.SeriesException" map="H"/>
  <class name="org.jfree.data.general.Series" map="I"/>
  <field class="org.jfree.data.general.Series" name="notify" map="A"/>
  <field class="org.jfree.data.general.Series" name="propertyChangeSupport" map="B"/>
  <field class="org.jfree.data.general.Series" name="key" map="C"/>
  <field class="org.jfree.data.general.Series" name="listeners" map="D"/>
  <field class="org.jfree.data.general.Series" name="description" map="E"/>
  <field class="org.jfree.data.general.Series" name="vetoableChangeSupport" map="F"/>
  <field class="org.jfree.data.general.Series" name="class$org$jfree$data$general$SeriesChangeListener" map="class$F$B$C$A$M"/>
  <method class="org.jfree.data.general.Series" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.data.general.Series" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jfree.data.general.Series" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.data.general.Series" name="void fireSeriesChanged()" map="A"/>
  <method class="org.jfree.data.general.Series" name="void notifyListeners(org.jfree.data.general.SeriesChangeEvent)" map="A"/>
  <method class="org.jfree.data.general.Series" name="java.lang.String getDescription()" map="B"/>
  <method class="org.jfree.data.general.Series" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.general.Series" name="void addVetoableChangeListener(java.beans.VetoableChangeListener)" map="A"/>
  <method class="org.jfree.data.general.Series" name="void addChangeListener(org.jfree.data.general.SeriesChangeListener)" map="A"/>
  <method class="org.jfree.data.general.Series" name="java.lang.Comparable getKey()" map="C"/>
  <class name="org.jfree.data.general.SeriesDataset" map="J"/>
  <method class="org.jfree.data.general.SeriesDataset" name="int indexOf(java.lang.Comparable)" map="A"/>
  <method class="org.jfree.data.general.SeriesDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.general.SeriesDataset" name="int getSeriesCount()" map="A"/>
  <class name="org.jfree.data.general.SeriesChangeEvent" map="K"/>
  <class name="org.jfree.data.general.ValueDataset" map="L"/>
  <class name="org.jfree.data.general.SeriesChangeListener" map="M"/>
  <method class="org.jfree.data.general.SeriesChangeListener" name="void seriesChanged(org.jfree.data.general.SeriesChangeEvent)" map="A"/>
  <class name="org.jfree.data.general.DatasetGroup" map="N"/>
  <field class="org.jfree.data.general.DatasetGroup" name="id" map="A"/>
  <method class="org.jfree.data.general.DatasetGroup" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.data.general.DatasetGroup" name="java.lang.Object clone()" map="clone"/>
  <class name="org.jfree.data.general.KeyedValuesDataset" map="O"/>
  <class name="org.jfree.data.general.CombinedDataset" map="P"/>
  <method class="org.jfree.data.general.CombinedDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.general.CombinedDataset" name="double getLowValue(int, int)" map="O"/>
  <method class="org.jfree.data.general.CombinedDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.general.CombinedDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.general.CombinedDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.general.CombinedDataset" name="double getHighValue(int, int)" map="P"/>
  <method class="org.jfree.data.general.CombinedDataset" name="int getItemCount(int)" map="G"/>
  <class name="org.jfree.data.general.KeyedValues2DDataset" map="Q"/>
  <class name="org.jfree.data.general.PieDataset" map="R"/>
  <class name="org.jfree.data.general.DatasetUtilities" map="S"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="org.jfree.data.Range findStackedRangeBounds(org.jfree.data.category.CategoryDataset, double)" map="A"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="org.jfree.data.Range iterateToFindDomainBounds(org.jfree.data.xy.XYDataset, java.util.List, boolean)" map="A"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="org.jfree.data.Range iterateRangeBounds(org.jfree.data.category.CategoryDataset, boolean)" map="A"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="org.jfree.data.Range findDomainBounds(org.jfree.data.xy.XYDataset)" map="A"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="org.jfree.data.Range iterateRangeBounds(org.jfree.data.xy.XYDataset, boolean)" map="A"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="boolean isEmptyOrNull(org.jfree.data.category.CategoryDataset)" map="A"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="org.jfree.data.Range findRangeBounds(org.jfree.data.xy.XYDataset)" map="B"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="org.jfree.data.Range iterateToFindRangeBounds(org.jfree.data.xy.XYDataset, java.util.List, org.jfree.data.Range, boolean)" map="A"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="org.jfree.data.Range findRangeBounds(org.jfree.data.category.CategoryDataset, java.util.List, boolean)" map="A"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="org.jfree.data.Range findRangeBounds(org.jfree.data.category.CategoryDataset, boolean)" map="B"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="org.jfree.data.Range findDomainBounds(org.jfree.data.xy.XYDataset, java.util.List, boolean)" map="B"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="boolean isEmptyOrNull(org.jfree.data.general.PieDataset)" map="A"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="org.jfree.data.Range iterateDomainBounds(org.jfree.data.xy.XYDataset, boolean)" map="B"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="org.jfree.data.Range findDomainBounds(org.jfree.data.xy.XYDataset, boolean)" map="C"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="boolean isEmptyOrNull(org.jfree.data.xy.XYDataset)" map="C"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="org.jfree.data.Range iterateToFindRangeBounds(org.jfree.data.category.CategoryDataset, java.util.List, boolean)" map="B"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="double calculatePieDatasetTotal(org.jfree.data.general.PieDataset)" map="B"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="org.jfree.data.Range findRangeBounds(org.jfree.data.xy.XYDataset, java.util.List, org.jfree.data.Range, boolean)" map="B"/>
  <method class="org.jfree.data.general.DatasetUtilities" name="org.jfree.data.Range findRangeBounds(org.jfree.data.xy.XYDataset, boolean)" map="D"/>
  <class name="org.jfree.data.general.DefaultPieDataset" map="T"/>
  <field class="org.jfree.data.general.DefaultPieDataset" name="data" map="F"/>
  <method class="org.jfree.data.general.DefaultPieDataset" name="java.lang.Number getValue(int)" map="B"/>
  <method class="org.jfree.data.general.DefaultPieDataset" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.data.general.DefaultPieDataset" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.data.general.DefaultPieDataset" name="int getItemCount()" map="C"/>
  <method class="org.jfree.data.general.DefaultPieDataset" name="java.lang.Number getValue(java.lang.Comparable)" map="C"/>
  <method class="org.jfree.data.general.DefaultPieDataset" name="java.lang.Comparable getKey(int)" map="C"/>
  <method class="org.jfree.data.general.DefaultPieDataset" name="int getIndex(java.lang.Comparable)" map="B"/>
  <method class="org.jfree.data.general.DefaultPieDataset" name="void setValue(java.lang.Comparable, double)" map="A"/>
  <method class="org.jfree.data.general.DefaultPieDataset" name="java.util.List getKeys()" map="D"/>
  <method class="org.jfree.data.general.DefaultPieDataset" name="void remove(java.lang.Comparable)" map="E"/>
  <method class="org.jfree.data.general.DefaultPieDataset" name="void setValue(java.lang.Comparable, java.lang.Number)" map="C"/>
  <method class="org.jfree.data.general.DefaultPieDataset" name="java.lang.Object clone()" map="clone"/>
  <class name="org.jfree.data.general.AbstractDataset" map="U"/>
  <field class="org.jfree.data.general.AbstractDataset" name="class$org$jfree$data$general$DatasetChangeListener" map="class$F$B$C$A$G"/>
  <field class="org.jfree.data.general.AbstractDataset" name="group" map="A"/>
  <field class="org.jfree.data.general.AbstractDataset" name="listenerList" map="B"/>
  <method class="org.jfree.data.general.AbstractDataset" name="void notifyListeners(org.jfree.data.general.DatasetChangeEvent)" map="A"/>
  <method class="org.jfree.data.general.AbstractDataset" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.general.AbstractDataset" name="void fireDatasetChanged()" map="B"/>
  <method class="org.jfree.data.general.AbstractDataset" name="void addChangeListener(org.jfree.data.general.DatasetChangeListener)" map="A"/>
  <method class="org.jfree.data.general.AbstractDataset" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jfree.data.general.AbstractDataset" name="void validateObject()" map="validateObject"/>
  <class name="org.jfree.data.general.AbstractSeriesDataset" map="V"/>
  <method class="org.jfree.data.general.AbstractSeriesDataset" name="int indexOf(java.lang.Comparable)" map="A"/>
  <method class="org.jfree.data.general.AbstractSeriesDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.general.AbstractSeriesDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.general.AbstractSeriesDataset" name="void seriesChanged(org.jfree.data.general.SeriesChangeEvent)" map="A"/>
  <class name="org.jfree.data.general.Dataset" map="W"/>
  <method class="org.jfree.data.general.Dataset" name="void addChangeListener(org.jfree.data.general.DatasetChangeListener)" map="A"/>
  <package name="org.jfree.data.gantt" map="B"/>
  <class name="org.jfree.data.gantt.XYTaskDataset" map="A"/>
  <method class="org.jfree.data.gantt.XYTaskDataset" name="double getStartXValue(int, int)" map="I"/>
  <method class="org.jfree.data.gantt.XYTaskDataset" name="double getXValue(int, int)" map="F"/>
  <method class="org.jfree.data.gantt.XYTaskDataset" name="double getEndXValue(int, int)" map="M"/>
  <method class="org.jfree.data.gantt.XYTaskDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.gantt.XYTaskDataset" name="int getItemCount(int)" map="G"/>
  <method class="org.jfree.data.gantt.XYTaskDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.gantt.XYTaskDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.gantt.XYTaskDataset" name="void datasetChanged(org.jfree.data.general.DatasetChangeEvent)" map="B"/>
  <method class="org.jfree.data.gantt.XYTaskDataset" name="double getStartYValue(int, int)" map="J"/>
  <method class="org.jfree.data.gantt.XYTaskDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.gantt.XYTaskDataset" name="double getYValue(int, int)" map="C"/>
  <method class="org.jfree.data.gantt.XYTaskDataset" name="double getEndYValue(int, int)" map="G"/>
  <class name="org.jfree.data.gantt.SlidingGanttCategoryDataset" map="B"/>
  <method class="org.jfree.data.gantt.SlidingGanttCategoryDataset" name="int getColumnIndex(java.lang.Comparable)" map="G"/>
  <method class="org.jfree.data.gantt.SlidingGanttCategoryDataset" name="int getColumnCount()" map="F"/>
  <method class="org.jfree.data.gantt.SlidingGanttCategoryDataset" name="java.util.List getColumnKeys()" map="H"/>
  <method class="org.jfree.data.gantt.SlidingGanttCategoryDataset" name="java.lang.Comparable getColumnKey(int)" map="F"/>
  <method class="org.jfree.data.gantt.SlidingGanttCategoryDataset" name="java.util.List getRowKeys()" map="I"/>
  <method class="org.jfree.data.gantt.SlidingGanttCategoryDataset" name="int getRowIndex(java.lang.Comparable)" map="F"/>
  <method class="org.jfree.data.gantt.SlidingGanttCategoryDataset" name="java.lang.Number getValue(int, int)" map="A"/>
  <method class="org.jfree.data.gantt.SlidingGanttCategoryDataset" name="java.lang.Comparable getRowKey(int)" map="E"/>
  <method class="org.jfree.data.gantt.SlidingGanttCategoryDataset" name="java.lang.Number getEndValue(int, int)" map="Y"/>
  <method class="org.jfree.data.gantt.SlidingGanttCategoryDataset" name="java.lang.Number getStartValue(int, int)" map="Z"/>
  <method class="org.jfree.data.gantt.SlidingGanttCategoryDataset" name="int getRowCount()" map="G"/>
  <class name="org.jfree.data.gantt.TaskSeriesCollection" map="C"/>
  <method class="org.jfree.data.gantt.TaskSeriesCollection" name="int getColumnIndex(java.lang.Comparable)" map="G"/>
  <method class="org.jfree.data.gantt.TaskSeriesCollection" name="int getColumnCount()" map="F"/>
  <method class="org.jfree.data.gantt.TaskSeriesCollection" name="java.util.List getColumnKeys()" map="H"/>
  <method class="org.jfree.data.gantt.TaskSeriesCollection" name="java.util.List getRowKeys()" map="I"/>
  <method class="org.jfree.data.gantt.TaskSeriesCollection" name="java.lang.Comparable getColumnKey(int)" map="F"/>
  <method class="org.jfree.data.gantt.TaskSeriesCollection" name="int getRowIndex(java.lang.Comparable)" map="F"/>
  <method class="org.jfree.data.gantt.TaskSeriesCollection" name="java.lang.Number getValue(int, int)" map="A"/>
  <method class="org.jfree.data.gantt.TaskSeriesCollection" name="java.lang.Comparable getRowKey(int)" map="E"/>
  <method class="org.jfree.data.gantt.TaskSeriesCollection" name="java.lang.Number getEndValue(int, int)" map="Y"/>
  <method class="org.jfree.data.gantt.TaskSeriesCollection" name="java.lang.Number getStartValue(int, int)" map="Z"/>
  <method class="org.jfree.data.gantt.TaskSeriesCollection" name="int getRowCount()" map="G"/>
  <method class="org.jfree.data.gantt.TaskSeriesCollection" name="java.lang.Object clone()" map="clone"/>
  <class name="org.jfree.data.gantt.GanttCategoryDataset" map="D"/>
  <package name="org.jfree.data.contour" map="C"/>
  <class name="org.jfree.data.contour.DefaultContourDataset" map="A"/>
  <method class="org.jfree.data.contour.DefaultContourDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.contour.DefaultContourDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.contour.DefaultContourDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.contour.DefaultContourDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.contour.DefaultContourDataset" name="int getItemCount(int)" map="G"/>
  <class name="org.jfree.data.contour.ContourDataset" map="B"/>
  <package name="org.jfree.data.jdbc" map="D"/>
  <class name="org.jfree.data.jdbc.JDBCXYDataset" map="A"/>
  <method class="org.jfree.data.jdbc.JDBCXYDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.jdbc.JDBCXYDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.jdbc.JDBCXYDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.jdbc.JDBCXYDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.jdbc.JDBCXYDataset" name="org.jfree.data.Range getRangeBounds(boolean)" map="A"/>
  <method class="org.jfree.data.jdbc.JDBCXYDataset" name="int getItemCount(int)" map="G"/>
  <package name="org.jfree.data.category" map="E"/>
  <class name="org.jfree.data.category.CategoryToPieDataset" map="A"/>
  <method class="org.jfree.data.category.CategoryToPieDataset" name="int getItemCount()" map="C"/>
  <method class="org.jfree.data.category.CategoryToPieDataset" name="void datasetChanged(org.jfree.data.general.DatasetChangeEvent)" map="B"/>
  <method class="org.jfree.data.category.CategoryToPieDataset" name="int getIndex(java.lang.Comparable)" map="B"/>
  <method class="org.jfree.data.category.CategoryToPieDataset" name="java.lang.Number getValue(int)" map="B"/>
  <method class="org.jfree.data.category.CategoryToPieDataset" name="java.lang.Comparable getKey(int)" map="C"/>
  <method class="org.jfree.data.category.CategoryToPieDataset" name="java.lang.Number getValue(java.lang.Comparable)" map="C"/>
  <method class="org.jfree.data.category.CategoryToPieDataset" name="java.util.List getKeys()" map="D"/>
  <class name="org.jfree.data.category.IntervalCategoryDataset" map="B"/>
  <method class="org.jfree.data.category.IntervalCategoryDataset" name="java.lang.Number getEndValue(int, int)" map="Y"/>
  <method class="org.jfree.data.category.IntervalCategoryDataset" name="java.lang.Number getStartValue(int, int)" map="Z"/>
  <class name="org.jfree.data.category.CategoryRangeInfo" map="C"/>
  <method class="org.jfree.data.category.CategoryRangeInfo" name="org.jfree.data.Range getRangeBounds(java.util.List, boolean)" map="A"/>
  <class name="org.jfree.data.category.CategoryDataset" map="D"/>
  <class name="org.jfree.data.category.SlidingCategoryDataset" map="E"/>
  <method class="org.jfree.data.category.SlidingCategoryDataset" name="int getColumnIndex(java.lang.Comparable)" map="G"/>
  <method class="org.jfree.data.category.SlidingCategoryDataset" name="int getColumnCount()" map="F"/>
  <method class="org.jfree.data.category.SlidingCategoryDataset" name="java.util.List getColumnKeys()" map="H"/>
  <method class="org.jfree.data.category.SlidingCategoryDataset" name="java.lang.Comparable getColumnKey(int)" map="F"/>
  <method class="org.jfree.data.category.SlidingCategoryDataset" name="java.util.List getRowKeys()" map="I"/>
  <method class="org.jfree.data.category.SlidingCategoryDataset" name="int getRowIndex(java.lang.Comparable)" map="F"/>
  <method class="org.jfree.data.category.SlidingCategoryDataset" name="java.lang.Number getValue(int, int)" map="A"/>
  <method class="org.jfree.data.category.SlidingCategoryDataset" name="java.lang.Comparable getRowKey(int)" map="E"/>
  <method class="org.jfree.data.category.SlidingCategoryDataset" name="int getRowCount()" map="G"/>
  <class name="org.jfree.data.category.DefaultIntervalCategoryDataset" map="F"/>
  <method class="org.jfree.data.category.DefaultIntervalCategoryDataset" name="int getColumnIndex(java.lang.Comparable)" map="G"/>
  <method class="org.jfree.data.category.DefaultIntervalCategoryDataset" name="int getColumnCount()" map="F"/>
  <method class="org.jfree.data.category.DefaultIntervalCategoryDataset" name="java.util.List getColumnKeys()" map="H"/>
  <method class="org.jfree.data.category.DefaultIntervalCategoryDataset" name="java.lang.Comparable getColumnKey(int)" map="F"/>
  <method class="org.jfree.data.category.DefaultIntervalCategoryDataset" name="java.util.List getRowKeys()" map="I"/>
  <method class="org.jfree.data.category.DefaultIntervalCategoryDataset" name="int getRowIndex(java.lang.Comparable)" map="F"/>
  <method class="org.jfree.data.category.DefaultIntervalCategoryDataset" name="java.lang.Number getValue(int, int)" map="A"/>
  <method class="org.jfree.data.category.DefaultIntervalCategoryDataset" name="java.lang.Comparable getRowKey(int)" map="E"/>
  <method class="org.jfree.data.category.DefaultIntervalCategoryDataset" name="java.lang.Number getStartValue(int, int)" map="Z"/>
  <method class="org.jfree.data.category.DefaultIntervalCategoryDataset" name="java.lang.Number getEndValue(int, int)" map="Y"/>
  <method class="org.jfree.data.category.DefaultIntervalCategoryDataset" name="int getRowCount()" map="G"/>
  <class name="org.jfree.data.category.DefaultCategoryDataset" map="G"/>
  <field class="org.jfree.data.category.DefaultCategoryDataset" name="data" map="K"/>
  <method class="org.jfree.data.category.DefaultCategoryDataset" name="int getColumnIndex(java.lang.Comparable)" map="G"/>
  <method class="org.jfree.data.category.DefaultCategoryDataset" name="java.util.List getColumnKeys()" map="H"/>
  <method class="org.jfree.data.category.DefaultCategoryDataset" name="int getColumnCount()" map="F"/>
  <method class="org.jfree.data.category.DefaultCategoryDataset" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.data.category.DefaultCategoryDataset" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.data.category.DefaultCategoryDataset" name="java.util.List getRowKeys()" map="I"/>
  <method class="org.jfree.data.category.DefaultCategoryDataset" name="java.lang.Comparable getColumnKey(int)" map="F"/>
  <method class="org.jfree.data.category.DefaultCategoryDataset" name="int getRowIndex(java.lang.Comparable)" map="F"/>
  <method class="org.jfree.data.category.DefaultCategoryDataset" name="java.lang.Number getValue(int, int)" map="A"/>
  <method class="org.jfree.data.category.DefaultCategoryDataset" name="void addValue(double, java.lang.Comparable, java.lang.Comparable)" map="A"/>
  <method class="org.jfree.data.category.DefaultCategoryDataset" name="java.lang.Comparable getRowKey(int)" map="E"/>
  <method class="org.jfree.data.category.DefaultCategoryDataset" name="void addValue(java.lang.Number, java.lang.Comparable, java.lang.Comparable)" map="C"/>
  <method class="org.jfree.data.category.DefaultCategoryDataset" name="int getRowCount()" map="G"/>
  <method class="org.jfree.data.category.DefaultCategoryDataset" name="java.lang.Object clone()" map="clone"/>
  <package name="org.jfree.data.xy" map="F"/>
  <class name="org.jfree.data.xy.DefaultTableXYDataset" map="A"/>
  <method class="org.jfree.data.xy.DefaultTableXYDataset" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.xy.DefaultTableXYDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.xy.DefaultTableXYDataset" name="org.jfree.data.Range getDomainBounds(boolean)" map="B"/>
  <method class="org.jfree.data.xy.DefaultTableXYDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.xy.DefaultTableXYDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.xy.DefaultTableXYDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.xy.DefaultTableXYDataset" name="int getItemCount(int)" map="G"/>
  <class name="org.jfree.data.xy.WindDataset" map="B"/>
  <class name="org.jfree.data.xy.XYDataItem" map="C"/>
  <field class="org.jfree.data.xy.XYDataItem" name="x" map="A"/>
  <field class="org.jfree.data.xy.XYDataItem" name="y" map="B"/>
  <method class="org.jfree.data.xy.XYDataItem" name="java.lang.Number getX()" map="A"/>
  <method class="org.jfree.data.xy.XYDataItem" name="double getYValue()" map="B"/>
  <method class="org.jfree.data.xy.XYDataItem" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.data.xy.XYDataItem" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.data.xy.XYDataItem" name="double getXValue()" map="C"/>
  <method class="org.jfree.data.xy.XYDataItem" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.xy.XYDataItem" name="java.lang.String toString()" map="toString"/>
  <method class="org.jfree.data.xy.XYDataItem" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <method class="org.jfree.data.xy.XYDataItem" name="java.lang.Number getY()" map="D"/>
  <class name="org.jfree.data.xy.XYZDataset" map="D"/>
  <class name="org.jfree.data.xy.XYDataset" map="E"/>
  <method class="org.jfree.data.xy.XYDataset" name="double getYValue(int, int)" map="C"/>
  <method class="org.jfree.data.xy.XYDataset" name="org.jfree.data.DomainOrder getDomainOrder()" map="J"/>
  <method class="org.jfree.data.xy.XYDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.xy.XYDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.xy.XYDataset" name="double getXValue(int, int)" map="F"/>
  <method class="org.jfree.data.xy.XYDataset" name="int getItemCount(int)" map="G"/>
  <class name="org.jfree.data.xy.XYRangeInfo" map="F"/>
  <method class="org.jfree.data.xy.XYRangeInfo" name="org.jfree.data.Range getRangeBounds(java.util.List, org.jfree.data.Range, boolean)" map="A"/>
  <class name="org.jfree.data.xy.IntervalXYDelegate" map="G"/>
  <field class="org.jfree.data.xy.IntervalXYDelegate" name="fixedIntervalWidth" map="L"/>
  <field class="org.jfree.data.xy.IntervalXYDelegate" name="intervalPositionFactor" map="M"/>
  <field class="org.jfree.data.xy.IntervalXYDelegate" name="dataset" map="N"/>
  <field class="org.jfree.data.xy.IntervalXYDelegate" name="autoWidth" map="O"/>
  <field class="org.jfree.data.xy.IntervalXYDelegate" name="autoIntervalWidth" map="P"/>
  <method class="org.jfree.data.xy.IntervalXYDelegate" name="double recalculateInterval()" map="K"/>
  <method class="org.jfree.data.xy.IntervalXYDelegate" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.data.xy.IntervalXYDelegate" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.data.xy.IntervalXYDelegate" name="double calculateIntervalForSeries(int)" map="H"/>
  <method class="org.jfree.data.xy.IntervalXYDelegate" name="boolean isAutoWidth()" map="L"/>
  <method class="org.jfree.data.xy.IntervalXYDelegate" name="org.jfree.data.Range getDomainBounds(boolean)" map="B"/>
  <method class="org.jfree.data.xy.IntervalXYDelegate" name="void datasetChanged(org.jfree.data.general.DatasetChangeEvent)" map="B"/>
  <method class="org.jfree.data.xy.IntervalXYDelegate" name="double getIntervalPositionFactor()" map="M"/>
  <method class="org.jfree.data.xy.IntervalXYDelegate" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.xy.IntervalXYDelegate" name="java.lang.Number getEndX(int, int)" map="Q"/>
  <method class="org.jfree.data.xy.IntervalXYDelegate" name="java.lang.Number getStartX(int, int)" map="R"/>
  <method class="org.jfree.data.xy.IntervalXYDelegate" name="double getIntervalWidth()" map="N"/>
  <class name="org.jfree.data.xy.AbstractXYDataset" map="H"/>
  <method class="org.jfree.data.xy.AbstractXYDataset" name="double getYValue(int, int)" map="C"/>
  <method class="org.jfree.data.xy.AbstractXYDataset" name="org.jfree.data.DomainOrder getDomainOrder()" map="J"/>
  <method class="org.jfree.data.xy.AbstractXYDataset" name="double getXValue(int, int)" map="F"/>
  <class name="org.jfree.data.xy.DefaultXYZDataset" map="I"/>
  <method class="org.jfree.data.xy.DefaultXYZDataset" name="org.jfree.data.DomainOrder getDomainOrder()" map="J"/>
  <method class="org.jfree.data.xy.DefaultXYZDataset" name="double getXValue(int, int)" map="F"/>
  <method class="org.jfree.data.xy.DefaultXYZDataset" name="int indexOf(java.lang.Comparable)" map="A"/>
  <method class="org.jfree.data.xy.DefaultXYZDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.xy.DefaultXYZDataset" name="int getItemCount(int)" map="G"/>
  <method class="org.jfree.data.xy.DefaultXYZDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.xy.DefaultXYZDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.xy.DefaultXYZDataset" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.xy.DefaultXYZDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.xy.DefaultXYZDataset" name="double getYValue(int, int)" map="C"/>
  <class name="org.jfree.data.xy.DefaultHighLowDataset" map="J"/>
  <method class="org.jfree.data.xy.DefaultHighLowDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.xy.DefaultHighLowDataset" name="double getLowValue(int, int)" map="O"/>
  <method class="org.jfree.data.xy.DefaultHighLowDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.xy.DefaultHighLowDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.xy.DefaultHighLowDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.xy.DefaultHighLowDataset" name="double getHighValue(int, int)" map="P"/>
  <method class="org.jfree.data.xy.DefaultHighLowDataset" name="int getItemCount(int)" map="G"/>
  <class name="org.jfree.data.xy.AbstractIntervalXYDataset" map="K"/>
  <method class="org.jfree.data.xy.AbstractIntervalXYDataset" name="double getEndYValue(int, int)" map="G"/>
  <method class="org.jfree.data.xy.AbstractIntervalXYDataset" name="double getStartXValue(int, int)" map="I"/>
  <method class="org.jfree.data.xy.AbstractIntervalXYDataset" name="double getStartYValue(int, int)" map="J"/>
  <method class="org.jfree.data.xy.AbstractIntervalXYDataset" name="double getEndXValue(int, int)" map="M"/>
  <class name="org.jfree.data.xy.XYSeriesCollection" map="L"/>
  <field class="org.jfree.data.xy.XYSeriesCollection" name="intervalDelegate" map="Q"/>
  <field class="org.jfree.data.xy.XYSeriesCollection" name="data" map="R"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="java.lang.Number getStartY(int, int)" map="L"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="void addSeries(org.jfree.data.xy.XYSeries)" map="A"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="org.jfree.data.Range getRangeBounds(boolean)" map="A"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="org.jfree.data.Range getDomainBounds(boolean)" map="B"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="int getItemCount(int)" map="G"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="org.jfree.data.xy.XYSeries getSeries(int)" map="I"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="int getSeriesIndex(java.lang.Comparable)" map="H"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="void vetoableChange(java.beans.PropertyChangeEvent)" map="vetoableChange"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="org.jfree.data.DomainOrder getDomainOrder()" map="J"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="java.lang.Number getEndY(int, int)" map="K"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="java.lang.Number getStartX(int, int)" map="H"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.xy.XYSeriesCollection" name="java.lang.Number getEndX(int, int)" map="N"/>
  <class name="org.jfree.data.xy.XYBarDataset" map="M"/>
  <method class="org.jfree.data.xy.XYBarDataset" name="double getStartXValue(int, int)" map="I"/>
  <method class="org.jfree.data.xy.XYBarDataset" name="double getXValue(int, int)" map="F"/>
  <method class="org.jfree.data.xy.XYBarDataset" name="double getEndXValue(int, int)" map="M"/>
  <method class="org.jfree.data.xy.XYBarDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.xy.XYBarDataset" name="int getItemCount(int)" map="G"/>
  <method class="org.jfree.data.xy.XYBarDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.xy.XYBarDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.xy.XYBarDataset" name="void datasetChanged(org.jfree.data.general.DatasetChangeEvent)" map="B"/>
  <method class="org.jfree.data.xy.XYBarDataset" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.xy.XYBarDataset" name="double getStartYValue(int, int)" map="J"/>
  <method class="org.jfree.data.xy.XYBarDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.xy.XYBarDataset" name="double getYValue(int, int)" map="C"/>
  <method class="org.jfree.data.xy.XYBarDataset" name="double getEndYValue(int, int)" map="G"/>
  <class name="org.jfree.data.xy.XYSeries" map="N"/>
  <field class="org.jfree.data.xy.XYSeries" name="minX" map="G"/>
  <field class="org.jfree.data.xy.XYSeries" name="autoSort" map="H"/>
  <field class="org.jfree.data.xy.XYSeries" name="maxY" map="I"/>
  <field class="org.jfree.data.xy.XYSeries" name="data" map="J"/>
  <field class="org.jfree.data.xy.XYSeries" name="maxX" map="K"/>
  <field class="org.jfree.data.xy.XYSeries" name="minY" map="L"/>
  <field class="org.jfree.data.xy.XYSeries" name="allowDuplicateXValues" map="M"/>
  <field class="org.jfree.data.xy.XYSeries" name="maximumItemCount" map="N"/>
  <method class="org.jfree.data.xy.XYSeries" name="java.lang.Number getX(int)" map="A"/>
  <method class="org.jfree.data.xy.XYSeries" name="double getMinX()" map="D"/>
  <method class="org.jfree.data.xy.XYSeries" name="double maxIgnoreNaN(double, double)" map="A"/>
  <method class="org.jfree.data.xy.XYSeries" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.xy.XYSeries" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.data.xy.XYSeries" name="void add(double, double)" map="B"/>
  <method class="org.jfree.data.xy.XYSeries" name="double getMinY()" map="E"/>
  <method class="org.jfree.data.xy.XYSeries" name="double getMaxX()" map="F"/>
  <method class="org.jfree.data.xy.XYSeries" name="java.lang.Number getY(int)" map="B"/>
  <method class="org.jfree.data.xy.XYSeries" name="int indexOf(java.lang.Number)" map="A"/>
  <method class="org.jfree.data.xy.XYSeries" name="double getMaxY()" map="G"/>
  <method class="org.jfree.data.xy.XYSeries" name="boolean getAutoSort()" map="H"/>
  <method class="org.jfree.data.xy.XYSeries" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.data.xy.XYSeries" name="void findBoundsByIteration()" map="I"/>
  <method class="org.jfree.data.xy.XYSeries" name="void add(java.lang.Number, java.lang.Number, boolean)" map="A"/>
  <method class="org.jfree.data.xy.XYSeries" name="double minIgnoreNaN(double, double)" map="C"/>
  <method class="org.jfree.data.xy.XYSeries" name="void updateBoundsForAddedItem(org.jfree.data.xy.XYDataItem)" map="A"/>
  <method class="org.jfree.data.xy.XYSeries" name="void updateBoundsForRemovedItem(org.jfree.data.xy.XYDataItem)" map="B"/>
  <method class="org.jfree.data.xy.XYSeries" name="org.jfree.data.xy.XYDataItem getRawDataItem(int)" map="C"/>
  <method class="org.jfree.data.xy.XYSeries" name="int getItemCount()" map="J"/>
  <method class="org.jfree.data.xy.XYSeries" name="void add(org.jfree.data.xy.XYDataItem, boolean)" map="A"/>
  <class name="org.jfree.data.xy.TableXYDataset" map="O"/>
  <class name="org.jfree.data.xy.XYIntervalSeriesCollection" map="P"/>
  <method class="org.jfree.data.xy.XYIntervalSeriesCollection" name="double getStartXValue(int, int)" map="I"/>
  <method class="org.jfree.data.xy.XYIntervalSeriesCollection" name="double getEndXValue(int, int)" map="M"/>
  <method class="org.jfree.data.xy.XYIntervalSeriesCollection" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.xy.XYIntervalSeriesCollection" name="int getItemCount(int)" map="G"/>
  <method class="org.jfree.data.xy.XYIntervalSeriesCollection" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.xy.XYIntervalSeriesCollection" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.xy.XYIntervalSeriesCollection" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.xy.XYIntervalSeriesCollection" name="double getStartYValue(int, int)" map="J"/>
  <method class="org.jfree.data.xy.XYIntervalSeriesCollection" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.xy.XYIntervalSeriesCollection" name="double getYValue(int, int)" map="C"/>
  <method class="org.jfree.data.xy.XYIntervalSeriesCollection" name="double getEndYValue(int, int)" map="G"/>
  <class name="org.jfree.data.xy.XYDomainInfo" map="Q"/>
  <method class="org.jfree.data.xy.XYDomainInfo" name="org.jfree.data.Range getDomainBounds(java.util.List, boolean)" map="A"/>
  <class name="org.jfree.data.xy.MatrixSeriesCollection" map="R"/>
  <method class="org.jfree.data.xy.MatrixSeriesCollection" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.xy.MatrixSeriesCollection" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.xy.MatrixSeriesCollection" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.xy.MatrixSeriesCollection" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.xy.MatrixSeriesCollection" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.xy.MatrixSeriesCollection" name="int getItemCount(int)" map="G"/>
  <class name="org.jfree.data.xy.DefaultWindDataset" map="S"/>
  <method class="org.jfree.data.xy.DefaultWindDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.xy.DefaultWindDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.xy.DefaultWindDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.xy.DefaultWindDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.xy.DefaultWindDataset" name="int getItemCount(int)" map="G"/>
  <class name="org.jfree.data.xy.AbstractXYZDataset" map="T"/>
  <class name="org.jfree.data.xy.XIntervalSeriesCollection" map="U"/>
  <method class="org.jfree.data.xy.XIntervalSeriesCollection" name="double getStartXValue(int, int)" map="I"/>
  <method class="org.jfree.data.xy.XIntervalSeriesCollection" name="double getEndXValue(int, int)" map="M"/>
  <method class="org.jfree.data.xy.XIntervalSeriesCollection" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.xy.XIntervalSeriesCollection" name="int getItemCount(int)" map="G"/>
  <method class="org.jfree.data.xy.XIntervalSeriesCollection" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.xy.XIntervalSeriesCollection" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.xy.XIntervalSeriesCollection" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.xy.XIntervalSeriesCollection" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.xy.XIntervalSeriesCollection" name="double getYValue(int, int)" map="C"/>
  <class name="org.jfree.data.xy.YIntervalSeriesCollection" map="V"/>
  <method class="org.jfree.data.xy.YIntervalSeriesCollection" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.xy.YIntervalSeriesCollection" name="int getItemCount(int)" map="G"/>
  <method class="org.jfree.data.xy.YIntervalSeriesCollection" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.xy.YIntervalSeriesCollection" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.xy.YIntervalSeriesCollection" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.xy.YIntervalSeriesCollection" name="double getStartYValue(int, int)" map="J"/>
  <method class="org.jfree.data.xy.YIntervalSeriesCollection" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.xy.YIntervalSeriesCollection" name="double getYValue(int, int)" map="C"/>
  <method class="org.jfree.data.xy.YIntervalSeriesCollection" name="double getEndYValue(int, int)" map="G"/>
  <class name="org.jfree.data.xy.VectorXYDataset" map="W"/>
  <class name="org.jfree.data.xy.OHLCDataset" map="X"/>
  <method class="org.jfree.data.xy.OHLCDataset" name="double getLowValue(int, int)" map="O"/>
  <method class="org.jfree.data.xy.OHLCDataset" name="double getHighValue(int, int)" map="P"/>
  <class name="org.jfree.data.xy.CategoryTableXYDataset" map="Y"/>
  <method class="org.jfree.data.xy.CategoryTableXYDataset" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.xy.CategoryTableXYDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.xy.CategoryTableXYDataset" name="org.jfree.data.Range getDomainBounds(boolean)" map="B"/>
  <method class="org.jfree.data.xy.CategoryTableXYDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.xy.CategoryTableXYDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.xy.CategoryTableXYDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.xy.CategoryTableXYDataset" name="int getItemCount(int)" map="G"/>
  <class name="org.jfree.data.xy.DefaultXYDataset" map="Z"/>
  <method class="org.jfree.data.xy.DefaultXYDataset" name="org.jfree.data.DomainOrder getDomainOrder()" map="J"/>
  <method class="org.jfree.data.xy.DefaultXYDataset" name="double getXValue(int, int)" map="F"/>
  <method class="org.jfree.data.xy.DefaultXYDataset" name="int indexOf(java.lang.Comparable)" map="A"/>
  <method class="org.jfree.data.xy.DefaultXYDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.xy.DefaultXYDataset" name="int getItemCount(int)" map="G"/>
  <method class="org.jfree.data.xy.DefaultXYDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.xy.DefaultXYDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.xy.DefaultXYDataset" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.xy.DefaultXYDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.xy.DefaultXYDataset" name="double getYValue(int, int)" map="C"/>
  <class name="org.jfree.data.xy.IntervalXYDataset" map="_"/>
  <method class="org.jfree.data.xy.IntervalXYDataset" name="double getEndYValue(int, int)" map="G"/>
  <method class="org.jfree.data.xy.IntervalXYDataset" name="java.lang.Number getStartX(int, int)" map="H"/>
  <method class="org.jfree.data.xy.IntervalXYDataset" name="double getStartXValue(int, int)" map="I"/>
  <method class="org.jfree.data.xy.IntervalXYDataset" name="double getStartYValue(int, int)" map="J"/>
  <method class="org.jfree.data.xy.IntervalXYDataset" name="java.lang.Number getEndY(int, int)" map="K"/>
  <method class="org.jfree.data.xy.IntervalXYDataset" name="java.lang.Number getStartY(int, int)" map="L"/>
  <method class="org.jfree.data.xy.IntervalXYDataset" name="double getEndXValue(int, int)" map="M"/>
  <method class="org.jfree.data.xy.IntervalXYDataset" name="java.lang.Number getEndX(int, int)" map="N"/>
  <class name="org.jfree.data.xy.VectorSeriesCollection" map="a"/>
  <method class="org.jfree.data.xy.VectorSeriesCollection" name="double getYValue(int, int)" map="C"/>
  <method class="org.jfree.data.xy.VectorSeriesCollection" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.xy.VectorSeriesCollection" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.xy.VectorSeriesCollection" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.xy.VectorSeriesCollection" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.xy.VectorSeriesCollection" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.xy.VectorSeriesCollection" name="double getXValue(int, int)" map="F"/>
  <method class="org.jfree.data.xy.VectorSeriesCollection" name="int getItemCount(int)" map="G"/>
  <class name="org.jfree.data.xy.DefaultOHLCDataset" map="b"/>
  <method class="org.jfree.data.xy.DefaultOHLCDataset" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.xy.DefaultOHLCDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.xy.DefaultOHLCDataset" name="double getLowValue(int, int)" map="O"/>
  <method class="org.jfree.data.xy.DefaultOHLCDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.xy.DefaultOHLCDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.xy.DefaultOHLCDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.xy.DefaultOHLCDataset" name="double getHighValue(int, int)" map="P"/>
  <method class="org.jfree.data.xy.DefaultOHLCDataset" name="int getItemCount(int)" map="G"/>
  <package name="org.jfree.data.time" map="G"/>
  <package name="org.jfree.data.time.ohlc" map="A"/>
  <class name="org.jfree.data.time.ohlc.OHLCSeriesCollection" map="A"/>
  <method class="org.jfree.data.time.ohlc.OHLCSeriesCollection" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.time.ohlc.OHLCSeriesCollection" name="double getLowValue(int, int)" map="O"/>
  <method class="org.jfree.data.time.ohlc.OHLCSeriesCollection" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.time.ohlc.OHLCSeriesCollection" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.time.ohlc.OHLCSeriesCollection" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.time.ohlc.OHLCSeriesCollection" name="double getHighValue(int, int)" map="P"/>
  <method class="org.jfree.data.time.ohlc.OHLCSeriesCollection" name="double getXValue(int, int)" map="F"/>
  <method class="org.jfree.data.time.ohlc.OHLCSeriesCollection" name="int getItemCount(int)" map="G"/>
  <class name="org.jfree.data.time.TimeSeries" map="A"/>
  <method class="org.jfree.data.time.TimeSeries" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <class name="org.jfree.data.time.TimeSeriesCollection" map="B"/>
  <method class="org.jfree.data.time.TimeSeriesCollection" name="org.jfree.data.DomainOrder getDomainOrder()" map="J"/>
  <method class="org.jfree.data.time.TimeSeriesCollection" name="double getXValue(int, int)" map="F"/>
  <method class="org.jfree.data.time.TimeSeriesCollection" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.time.TimeSeriesCollection" name="int getItemCount(int)" map="G"/>
  <method class="org.jfree.data.time.TimeSeriesCollection" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.time.TimeSeriesCollection" name="org.jfree.data.Range getDomainBounds(boolean)" map="B"/>
  <method class="org.jfree.data.time.TimeSeriesCollection" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.time.TimeSeriesCollection" name="org.jfree.data.Range getDomainBounds(java.util.List, boolean)" map="A"/>
  <method class="org.jfree.data.time.TimeSeriesCollection" name="org.jfree.data.Range getRangeBounds(java.util.List, org.jfree.data.Range, boolean)" map="A"/>
  <method class="org.jfree.data.time.TimeSeriesCollection" name="java.lang.Number getX(int, int)" map="E"/>
  <class name="org.jfree.data.time.DynamicTimeSeriesCollection" map="C"/>
  <method class="org.jfree.data.time.DynamicTimeSeriesCollection" name="org.jfree.data.Range getRangeBounds(boolean)" map="A"/>
  <method class="org.jfree.data.time.DynamicTimeSeriesCollection" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jfree.data.time.DynamicTimeSeriesCollection" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.time.DynamicTimeSeriesCollection" name="int getItemCount(int)" map="G"/>
  <method class="org.jfree.data.time.DynamicTimeSeriesCollection" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.time.DynamicTimeSeriesCollection" name="org.jfree.data.Range getDomainBounds(boolean)" map="B"/>
  <method class="org.jfree.data.time.DynamicTimeSeriesCollection" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.time.DynamicTimeSeriesCollection" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.time.DynamicTimeSeriesCollection" name="double getYValue(int, int)" map="C"/>
  <class name="org.jfree.data.time.TimeTableXYDataset" map="D"/>
  <method class="org.jfree.data.time.TimeTableXYDataset" name="double getStartXValue(int, int)" map="I"/>
  <method class="org.jfree.data.time.TimeTableXYDataset" name="double getXValue(int, int)" map="F"/>
  <method class="org.jfree.data.time.TimeTableXYDataset" name="double getEndXValue(int, int)" map="M"/>
  <method class="org.jfree.data.time.TimeTableXYDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.time.TimeTableXYDataset" name="int getItemCount(int)" map="G"/>
  <method class="org.jfree.data.time.TimeTableXYDataset" name="org.jfree.data.Range getDomainBounds(boolean)" map="B"/>
  <method class="org.jfree.data.time.TimeTableXYDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.time.TimeTableXYDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.time.TimeTableXYDataset" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.time.TimeTableXYDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <class name="org.jfree.data.time.TimePeriodValuesCollection" map="E"/>
  <method class="org.jfree.data.time.TimePeriodValuesCollection" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.time.TimePeriodValuesCollection" name="org.jfree.data.Range getDomainBounds(boolean)" map="B"/>
  <method class="org.jfree.data.time.TimePeriodValuesCollection" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.time.TimePeriodValuesCollection" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.time.TimePeriodValuesCollection" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.time.TimePeriodValuesCollection" name="int getItemCount(int)" map="G"/>
  <package name="org.jfree.data.statistics" map="H"/>
  <class name="org.jfree.data.statistics.BoxAndWhiskerXYDataset" map="A"/>
  <method class="org.jfree.data.statistics.BoxAndWhiskerXYDataset" name="java.lang.Number getMinRegularValue(int, int)" map="S"/>
  <method class="org.jfree.data.statistics.BoxAndWhiskerXYDataset" name="java.lang.Number getMaxRegularValue(int, int)" map="T"/>
  <class name="org.jfree.data.statistics.MultiValueCategoryDataset" map="B"/>
  <method class="org.jfree.data.statistics.MultiValueCategoryDataset" name="java.util.List getValues(int, int)" map="B"/>
  <class name="org.jfree.data.statistics.BoxAndWhiskerCategoryDataset" map="C"/>
  <method class="org.jfree.data.statistics.BoxAndWhiskerCategoryDataset" name="java.lang.Number getMinRegularValue(int, int)" map="U"/>
  <method class="org.jfree.data.statistics.BoxAndWhiskerCategoryDataset" name="java.lang.Number getMaxRegularValue(int, int)" map="V"/>
  <class name="org.jfree.data.statistics.HistogramDataset" map="D"/>
  <method class="org.jfree.data.statistics.HistogramDataset" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.statistics.HistogramDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.statistics.HistogramDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.statistics.HistogramDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.statistics.HistogramDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.statistics.HistogramDataset" name="int getItemCount(int)" map="G"/>
  <class name="org.jfree.data.statistics.StatisticalCategoryDataset" map="E"/>
  <method class="org.jfree.data.statistics.StatisticalCategoryDataset" name="java.lang.Number getStdDevValue(int, int)" map="W"/>
  <method class="org.jfree.data.statistics.StatisticalCategoryDataset" name="java.lang.Number getMeanValue(int, int)" map="X"/>
  <class name="org.jfree.data.statistics.SimpleHistogramDataset" map="F"/>
  <method class="org.jfree.data.statistics.SimpleHistogramDataset" name="org.jfree.data.DomainOrder getDomainOrder()" map="J"/>
  <method class="org.jfree.data.statistics.SimpleHistogramDataset" name="double getStartXValue(int, int)" map="I"/>
  <method class="org.jfree.data.statistics.SimpleHistogramDataset" name="double getXValue(int, int)" map="F"/>
  <method class="org.jfree.data.statistics.SimpleHistogramDataset" name="double getEndXValue(int, int)" map="M"/>
  <method class="org.jfree.data.statistics.SimpleHistogramDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.statistics.SimpleHistogramDataset" name="int getItemCount(int)" map="G"/>
  <method class="org.jfree.data.statistics.SimpleHistogramDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.statistics.SimpleHistogramDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.statistics.SimpleHistogramDataset" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.statistics.SimpleHistogramDataset" name="double getStartYValue(int, int)" map="J"/>
  <method class="org.jfree.data.statistics.SimpleHistogramDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.statistics.SimpleHistogramDataset" name="double getYValue(int, int)" map="C"/>
  <method class="org.jfree.data.statistics.SimpleHistogramDataset" name="double getEndYValue(int, int)" map="G"/>
  <class name="org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset" map="G"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset" name="org.jfree.data.Range getRangeBounds(boolean)" map="A"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset" name="int getColumnIndex(java.lang.Comparable)" map="G"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset" name="java.lang.Number getMaxRegularValue(int, int)" map="V"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset" name="int getColumnCount()" map="F"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset" name="java.util.List getColumnKeys()" map="H"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset" name="java.lang.Comparable getColumnKey(int)" map="F"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset" name="java.util.List getRowKeys()" map="I"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset" name="int getRowIndex(java.lang.Comparable)" map="F"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset" name="java.lang.Number getValue(int, int)" map="A"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset" name="java.lang.Comparable getRowKey(int)" map="E"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset" name="java.lang.Number getMinRegularValue(int, int)" map="U"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset" name="int getRowCount()" map="G"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset" name="java.lang.Object clone()" map="clone"/>
  <class name="org.jfree.data.statistics.DefaultStatisticalCategoryDataset" map="H"/>
  <method class="org.jfree.data.statistics.DefaultStatisticalCategoryDataset" name="org.jfree.data.Range getRangeBounds(boolean)" map="A"/>
  <method class="org.jfree.data.statistics.DefaultStatisticalCategoryDataset" name="int getColumnIndex(java.lang.Comparable)" map="G"/>
  <method class="org.jfree.data.statistics.DefaultStatisticalCategoryDataset" name="int getColumnCount()" map="F"/>
  <method class="org.jfree.data.statistics.DefaultStatisticalCategoryDataset" name="java.util.List getColumnKeys()" map="H"/>
  <method class="org.jfree.data.statistics.DefaultStatisticalCategoryDataset" name="java.util.List getRowKeys()" map="I"/>
  <method class="org.jfree.data.statistics.DefaultStatisticalCategoryDataset" name="java.lang.Comparable getColumnKey(int)" map="F"/>
  <method class="org.jfree.data.statistics.DefaultStatisticalCategoryDataset" name="int getRowIndex(java.lang.Comparable)" map="F"/>
  <method class="org.jfree.data.statistics.DefaultStatisticalCategoryDataset" name="java.lang.Number getValue(int, int)" map="A"/>
  <method class="org.jfree.data.statistics.DefaultStatisticalCategoryDataset" name="java.lang.Number getMeanValue(int, int)" map="X"/>
  <method class="org.jfree.data.statistics.DefaultStatisticalCategoryDataset" name="java.lang.Comparable getRowKey(int)" map="E"/>
  <method class="org.jfree.data.statistics.DefaultStatisticalCategoryDataset" name="java.lang.Number getStdDevValue(int, int)" map="W"/>
  <method class="org.jfree.data.statistics.DefaultStatisticalCategoryDataset" name="int getRowCount()" map="G"/>
  <method class="org.jfree.data.statistics.DefaultStatisticalCategoryDataset" name="java.lang.Object clone()" map="clone"/>
  <class name="org.jfree.data.statistics.DefaultMultiValueCategoryDataset" map="I"/>
  <method class="org.jfree.data.statistics.DefaultMultiValueCategoryDataset" name="org.jfree.data.Range getRangeBounds(boolean)" map="A"/>
  <method class="org.jfree.data.statistics.DefaultMultiValueCategoryDataset" name="int getColumnIndex(java.lang.Comparable)" map="G"/>
  <method class="org.jfree.data.statistics.DefaultMultiValueCategoryDataset" name="int getColumnCount()" map="F"/>
  <method class="org.jfree.data.statistics.DefaultMultiValueCategoryDataset" name="java.util.List getColumnKeys()" map="H"/>
  <method class="org.jfree.data.statistics.DefaultMultiValueCategoryDataset" name="java.lang.Comparable getColumnKey(int)" map="F"/>
  <method class="org.jfree.data.statistics.DefaultMultiValueCategoryDataset" name="java.util.List getRowKeys()" map="I"/>
  <method class="org.jfree.data.statistics.DefaultMultiValueCategoryDataset" name="int getRowIndex(java.lang.Comparable)" map="F"/>
  <method class="org.jfree.data.statistics.DefaultMultiValueCategoryDataset" name="java.lang.Number getValue(int, int)" map="A"/>
  <method class="org.jfree.data.statistics.DefaultMultiValueCategoryDataset" name="java.util.List getValues(int, int)" map="B"/>
  <method class="org.jfree.data.statistics.DefaultMultiValueCategoryDataset" name="java.lang.Comparable getRowKey(int)" map="E"/>
  <method class="org.jfree.data.statistics.DefaultMultiValueCategoryDataset" name="int getRowCount()" map="G"/>
  <method class="org.jfree.data.statistics.DefaultMultiValueCategoryDataset" name="java.lang.Object clone()" map="clone"/>
  <class name="org.jfree.data.statistics.DefaultBoxAndWhiskerXYDataset" map="J"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerXYDataset" name="java.lang.Number getY(int, int)" map="D"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerXYDataset" name="java.lang.Number getX(int, int)" map="E"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerXYDataset" name="java.lang.Comparable getSeriesKey(int)" map="A"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerXYDataset" name="int getSeriesCount()" map="A"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerXYDataset" name="org.jfree.data.Range getRangeBounds(boolean)" map="A"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerXYDataset" name="java.lang.Number getMinRegularValue(int, int)" map="S"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerXYDataset" name="int getItemCount(int)" map="G"/>
  <method class="org.jfree.data.statistics.DefaultBoxAndWhiskerXYDataset" name="java.lang.Number getMaxRegularValue(int, int)" map="T"/>
  <class name="org.jfree.data.DefaultKeyedValues" map="A"/>
  <field class="org.jfree.data.DefaultKeyedValues" name="values" map="C"/>
  <field class="org.jfree.data.DefaultKeyedValues" name="indexMap" map="D"/>
  <field class="org.jfree.data.DefaultKeyedValues" name="keys" map="E"/>
  <method class="org.jfree.data.DefaultKeyedValues" name="java.lang.Number getValue(int)" map="B"/>
  <method class="org.jfree.data.DefaultKeyedValues" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.data.DefaultKeyedValues" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.data.DefaultKeyedValues" name="int getItemCount()" map="C"/>
  <method class="org.jfree.data.DefaultKeyedValues" name="java.lang.Number getValue(java.lang.Comparable)" map="C"/>
  <method class="org.jfree.data.DefaultKeyedValues" name="java.lang.Comparable getKey(int)" map="C"/>
  <method class="org.jfree.data.DefaultKeyedValues" name="int getIndex(java.lang.Comparable)" map="B"/>
  <method class="org.jfree.data.DefaultKeyedValues" name="java.util.List getKeys()" map="D"/>
  <method class="org.jfree.data.DefaultKeyedValues" name="void removeValue(int)" map="D"/>
  <method class="org.jfree.data.DefaultKeyedValues" name="void rebuildIndex()" map="E"/>
  <method class="org.jfree.data.DefaultKeyedValues" name="void setValue(java.lang.Comparable, java.lang.Number)" map="A"/>
  <method class="org.jfree.data.DefaultKeyedValues" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.data.DefaultKeyedValues" name="void addValue(java.lang.Comparable, java.lang.Number)" map="B"/>
  <method class="org.jfree.data.DefaultKeyedValues" name="void removeValue(java.lang.Comparable)" map="D"/>
  <class name="org.jfree.data.RangeInfo" map="B"/>
  <method class="org.jfree.data.RangeInfo" name="org.jfree.data.Range getRangeBounds(boolean)" map="A"/>
  <class name="org.jfree.data.Values" map="C"/>
  <method class="org.jfree.data.Values" name="int getItemCount()" map="C"/>
  <method class="org.jfree.data.Values" name="java.lang.Number getValue(int)" map="B"/>
  <class name="org.jfree.data.KeyedValues2D" map="D"/>
  <method class="org.jfree.data.KeyedValues2D" name="java.util.List getColumnKeys()" map="H"/>
  <method class="org.jfree.data.KeyedValues2D" name="int getRowIndex(java.lang.Comparable)" map="F"/>
  <method class="org.jfree.data.KeyedValues2D" name="int getColumnIndex(java.lang.Comparable)" map="G"/>
  <method class="org.jfree.data.KeyedValues2D" name="java.lang.Comparable getRowKey(int)" map="E"/>
  <method class="org.jfree.data.KeyedValues2D" name="java.lang.Comparable getColumnKey(int)" map="F"/>
  <method class="org.jfree.data.KeyedValues2D" name="java.util.List getRowKeys()" map="I"/>
  <class name="org.jfree.data.DefaultKeyedValues2D" map="E"/>
  <field class="org.jfree.data.DefaultKeyedValues2D" name="sortRowKeys" map="G"/>
  <field class="org.jfree.data.DefaultKeyedValues2D" name="columnKeys" map="H"/>
  <field class="org.jfree.data.DefaultKeyedValues2D" name="rowKeys" map="I"/>
  <field class="org.jfree.data.DefaultKeyedValues2D" name="rows" map="J"/>
  <method class="org.jfree.data.DefaultKeyedValues2D" name="int getColumnIndex(java.lang.Comparable)" map="G"/>
  <method class="org.jfree.data.DefaultKeyedValues2D" name="java.util.List getColumnKeys()" map="H"/>
  <method class="org.jfree.data.DefaultKeyedValues2D" name="int getColumnCount()" map="F"/>
  <method class="org.jfree.data.DefaultKeyedValues2D" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.data.DefaultKeyedValues2D" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.data.DefaultKeyedValues2D" name="java.util.List getRowKeys()" map="I"/>
  <method class="org.jfree.data.DefaultKeyedValues2D" name="java.lang.Comparable getColumnKey(int)" map="F"/>
  <method class="org.jfree.data.DefaultKeyedValues2D" name="int getRowIndex(java.lang.Comparable)" map="F"/>
  <method class="org.jfree.data.DefaultKeyedValues2D" name="java.lang.Number getValue(int, int)" map="A"/>
  <method class="org.jfree.data.DefaultKeyedValues2D" name="java.lang.Comparable getRowKey(int)" map="E"/>
  <method class="org.jfree.data.DefaultKeyedValues2D" name="void setValue(java.lang.Number, java.lang.Comparable, java.lang.Comparable)" map="A"/>
  <method class="org.jfree.data.DefaultKeyedValues2D" name="void addValue(java.lang.Number, java.lang.Comparable, java.lang.Comparable)" map="B"/>
  <method class="org.jfree.data.DefaultKeyedValues2D" name="int getRowCount()" map="G"/>
  <method class="org.jfree.data.DefaultKeyedValues2D" name="java.lang.Object clone()" map="clone"/>
  <class name="org.jfree.data.DomainOrder" map="F"/>
  <field class="org.jfree.data.DomainOrder" name="DESCENDING" map="A"/>
  <field class="org.jfree.data.DomainOrder" name="name" map="B"/>
  <field class="org.jfree.data.DomainOrder" name="ASCENDING" map="C"/>
  <field class="org.jfree.data.DomainOrder" name="NONE" map="D"/>
  <method class="org.jfree.data.DomainOrder" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.data.DomainOrder" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.data.DomainOrder" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.data.UnknownKeyException" map="G"/>
  <class name="org.jfree.data.Range" map="H"/>
  <field class="org.jfree.data.Range" name="lower" map="A"/>
  <field class="org.jfree.data.Range" name="upper" map="B"/>
  <method class="org.jfree.data.Range" name="double shiftWithNoZeroCrossing(double, double)" map="A"/>
  <method class="org.jfree.data.Range" name="double getUpperBound()" map="A"/>
  <method class="org.jfree.data.Range" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.data.Range" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.data.Range" name="double getCentralValue()" map="B"/>
  <method class="org.jfree.data.Range" name="org.jfree.data.Range expandToInclude(org.jfree.data.Range, double)" map="A"/>
  <method class="org.jfree.data.Range" name="double getLowerBound()" map="C"/>
  <method class="org.jfree.data.Range" name="boolean intersects(double, double)" map="B"/>
  <method class="org.jfree.data.Range" name="org.jfree.data.Range combine(org.jfree.data.Range, org.jfree.data.Range)" map="A"/>
  <method class="org.jfree.data.Range" name="double constrain(double)" map="A"/>
  <method class="org.jfree.data.Range" name="boolean contains(double)" map="B"/>
  <method class="org.jfree.data.Range" name="double getLength()" map="D"/>
  <method class="org.jfree.data.Range" name="org.jfree.data.Range shift(org.jfree.data.Range, double, boolean)" map="A"/>
  <method class="org.jfree.data.Range" name="java.lang.String toString()" map="toString"/>
  <method class="org.jfree.data.Range" name="org.jfree.data.Range shift(org.jfree.data.Range, double)" map="B"/>
  <class name="org.jfree.data.DomainInfo" map="I"/>
  <method class="org.jfree.data.DomainInfo" name="org.jfree.data.Range getDomainBounds(boolean)" map="B"/>
  <class name="org.jfree.data.KeyedValues" map="J"/>
  <method class="org.jfree.data.KeyedValues" name="int getIndex(java.lang.Comparable)" map="B"/>
  <method class="org.jfree.data.KeyedValues" name="java.lang.Comparable getKey(int)" map="C"/>
  <method class="org.jfree.data.KeyedValues" name="java.lang.Number getValue(java.lang.Comparable)" map="C"/>
  <method class="org.jfree.data.KeyedValues" name="java.util.List getKeys()" map="D"/>
  <class name="org.jfree.data.Values2D" map="K"/>
  <method class="org.jfree.data.Values2D" name="java.lang.Number getValue(int, int)" map="A"/>
  <method class="org.jfree.data.Values2D" name="int getColumnCount()" map="F"/>
  <method class="org.jfree.data.Values2D" name="int getRowCount()" map="G"/>
  <class name="org.jfree.data.RangeType" map="L"/>
  <field class="org.jfree.data.RangeType" name="name" map="A"/>
  <field class="org.jfree.data.RangeType" name="POSITIVE" map="B"/>
  <field class="org.jfree.data.RangeType" name="FULL" map="C"/>
  <field class="org.jfree.data.RangeType" name="NEGATIVE" map="D"/>
  <method class="org.jfree.data.RangeType" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.data.RangeType" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.data.RangeType" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.data.Value" map="M"/>
  <class name="org.jfree.data.DataUtilities" map="N"/>
  <method class="org.jfree.data.DataUtilities" name="double calculateColumnTotal(org.jfree.data.Values2D, int)" map="A"/>
  <method class="org.jfree.data.DataUtilities" name="double calculateColumnTotal(org.jfree.data.Values2D, int, int[])" map="A"/>
  <package name="org.jfree.util" map="D"/>
  <class name="org.jfree.util.LogContext" map="A"/>
  <field class="org.jfree.util.LogContext" name="contextPrefix" map="A"/>
  <method class="org.jfree.util.LogContext" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.util.LogContext" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.util.LogContext" name="boolean isDebugEnabled()" map="A"/>
  <method class="org.jfree.util.LogContext" name="void debug(java.lang.Object)" map="A"/>
  <method class="org.jfree.util.LogContext" name="void log(int, java.lang.Object)" map="A"/>
  <class name="org.jfree.util.AbstractObjectList" map="B"/>
  <field class="org.jfree.util.AbstractObjectList" name="increment" map="A"/>
  <field class="org.jfree.util.AbstractObjectList" name="size" map="B"/>
  <field class="org.jfree.util.AbstractObjectList" name="objects" map="C"/>
  <method class="org.jfree.util.AbstractObjectList" name="void clear()" map="A"/>
  <method class="org.jfree.util.AbstractObjectList" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.util.AbstractObjectList" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.util.AbstractObjectList" name="int indexOf(java.lang.Object)" map="A"/>
  <method class="org.jfree.util.AbstractObjectList" name="int size()" map="B"/>
  <method class="org.jfree.util.AbstractObjectList" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.util.AbstractObjectList" name="void set(int, java.lang.Object)" map="A"/>
  <method class="org.jfree.util.AbstractObjectList" name="java.lang.Object get(int)" map="A"/>
  <class name="org.jfree.util.Rotation" map="C"/>
  <field class="org.jfree.util.Rotation" name="name" map="A"/>
  <field class="org.jfree.util.Rotation" name="factor" map="B"/>
  <field class="org.jfree.util.Rotation" name="ANTICLOCKWISE" map="C"/>
  <field class="org.jfree.util.Rotation" name="CLOCKWISE" map="D"/>
  <method class="org.jfree.util.Rotation" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.util.Rotation" name="double getFactor()" map="A"/>
  <method class="org.jfree.util.Rotation" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.util.Rotation" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.util.PaintList" map="D"/>
  <method class="org.jfree.util.PaintList" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.util.PaintList" name="void setPaint(int, java.awt.Paint)" map="A"/>
  <method class="org.jfree.util.PaintList" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.util.PaintList" name="java.awt.Paint getPaint(int)" map="B"/>
  <class name="org.jfree.util.PaintUtilities" map="E"/>
  <method class="org.jfree.util.PaintUtilities" name="boolean equal(java.awt.Paint, java.awt.Paint)" map="A"/>
  <class name="org.jfree.util.Configuration" map="F"/>
  <method class="org.jfree.util.Configuration" name="java.lang.String getConfigProperty(java.lang.String, java.lang.String)" map="A"/>
  <class name="org.jfree.util.BooleanUtilities" map="G"/>
  <method class="org.jfree.util.BooleanUtilities" name="java.lang.Boolean valueOf(boolean)" map="A"/>
  <class name="org.jfree.util.ObjectUtilities" map="H"/>
  <field class="org.jfree.util.ObjectUtilities" name="classLoader" map="A"/>
  <field class="org.jfree.util.ObjectUtilities" name="class$org$jfree$util$ObjectUtilities" map="class$F$B$D$H"/>
  <field class="org.jfree.util.ObjectUtilities" name="classLoaderSource" map="B"/>
  <method class="org.jfree.util.ObjectUtilities" name="boolean isJDK14()" map="A"/>
  <method class="org.jfree.util.ObjectUtilities" name="java.net.URL getResourceRelative(java.lang.String, java.lang.Class)" map="A"/>
  <method class="org.jfree.util.ObjectUtilities" name="java.lang.Object clone(java.lang.Object)" map="A"/>
  <method class="org.jfree.util.ObjectUtilities" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jfree.util.ObjectUtilities" name="java.lang.String[] parseVersions(java.lang.String)" map="A"/>
  <method class="org.jfree.util.ObjectUtilities" name="boolean equal(java.lang.Object, java.lang.Object)" map="A"/>
  <method class="org.jfree.util.ObjectUtilities" name="int hashCode(java.lang.Object)" map="B"/>
  <method class="org.jfree.util.ObjectUtilities" name="java.lang.ClassLoader getClassLoader(java.lang.Class)" map="A"/>
  <method class="org.jfree.util.ObjectUtilities" name="java.io.InputStream getResourceRelativeAsStream(java.lang.String, java.lang.Class)" map="B"/>
  <method class="org.jfree.util.ObjectUtilities" name="java.lang.String convertName(java.lang.String, java.lang.Class)" map="C"/>
  <method class="org.jfree.util.ObjectUtilities" name="java.util.Collection deepClone(java.util.Collection)" map="A"/>
  <class name="org.jfree.util.ResourceBundleWrapper" map="I"/>
  <field class="org.jfree.util.ResourceBundleWrapper" name="noCodeBaseClassLoader" map="A"/>
  <method class="org.jfree.util.ResourceBundleWrapper" name="java.util.ResourceBundle getBundle(java.lang.String)" map="A"/>
  <class name="org.jfree.util.ShapeUtilities" map="J"/>
  <field class="org.jfree.util.ShapeUtilities" name="SQRT2" map="A"/>
  <method class="org.jfree.util.ShapeUtilities" name="boolean equal(java.awt.geom.Ellipse2D, java.awt.geom.Ellipse2D)" map="A"/>
  <method class="org.jfree.util.ShapeUtilities" name="boolean equal(java.awt.Polygon, java.awt.Polygon)" map="A"/>
  <method class="org.jfree.util.ShapeUtilities" name="java.awt.Shape rotateShape(java.awt.Shape, double, float, float)" map="A"/>
  <method class="org.jfree.util.ShapeUtilities" name="java.awt.Shape createTranslatedShape(java.awt.Shape, double, double)" map="A"/>
  <method class="org.jfree.util.ShapeUtilities" name="boolean equal(java.awt.geom.Line2D, java.awt.geom.Line2D)" map="A"/>
  <method class="org.jfree.util.ShapeUtilities" name="java.awt.geom.Point2D getPointInRectangle(double, double, java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.util.ShapeUtilities" name="boolean equal(java.awt.geom.Arc2D, java.awt.geom.Arc2D)" map="A"/>
  <method class="org.jfree.util.ShapeUtilities" name="java.awt.Shape createTranslatedShape(java.awt.Shape, org.jfree.ui.RectangleAnchor, double, double)" map="A"/>
  <method class="org.jfree.util.ShapeUtilities" name="boolean equal(java.awt.geom.GeneralPath, java.awt.geom.GeneralPath)" map="A"/>
  <method class="org.jfree.util.ShapeUtilities" name="boolean equal(java.awt.Shape, java.awt.Shape)" map="A"/>
  <method class="org.jfree.util.ShapeUtilities" name="java.awt.Shape clone(java.awt.Shape)" map="A"/>
  <class name="org.jfree.util.ArrayUtilities" map="K"/>
  <method class="org.jfree.util.ArrayUtilities" name="int compareVersionArrays(java.lang.Comparable[], java.lang.Comparable[])" map="A"/>
  <class name="org.jfree.util.StrokeList" map="L"/>
  <method class="org.jfree.util.StrokeList" name="void setStroke(int, java.awt.Stroke)" map="A"/>
  <method class="org.jfree.util.StrokeList" name="java.awt.Stroke getStroke(int)" map="C"/>
  <method class="org.jfree.util.StrokeList" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.util.StrokeList" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.util.StrokeList" name="int hashCode()" map="hashCode"/>
  <class name="org.jfree.util.PublicCloneable" map="M"/>
  <method class="org.jfree.util.PublicCloneable" name="java.lang.Object clone()" map="clone"/>
  <class name="org.jfree.util.BooleanList" map="N"/>
  <method class="org.jfree.util.BooleanList" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.util.BooleanList" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.util.BooleanList" name="java.lang.Boolean getBoolean(int)" map="D"/>
  <class name="org.jfree.util.ObjectList" map="O"/>
  <method class="org.jfree.util.ObjectList" name="int indexOf(java.lang.Object)" map="A"/>
  <method class="org.jfree.util.ObjectList" name="void set(int, java.lang.Object)" map="A"/>
  <method class="org.jfree.util.ObjectList" name="java.lang.Object get(int)" map="A"/>
  <class name="org.jfree.util.Log$SimpleMessage" map="_A"/>
  <field class="org.jfree.util.Log$SimpleMessage" name="message" map="A"/>
  <field class="org.jfree.util.Log$SimpleMessage" name="param" map="B"/>
  <method class="org.jfree.util.Log$SimpleMessage" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.util.Log" map="P"/>
  <field class="org.jfree.util.Log" name="logTargets" map="A"/>
  <field class="org.jfree.util.Log" name="logContexts" map="B"/>
  <field class="org.jfree.util.Log" name="singleton" map="C"/>
  <field class="org.jfree.util.Log" name="debuglevel" map="D"/>
  <method class="org.jfree.util.Log" name="void log(int, java.lang.Object)" map="A"/>
  <method class="org.jfree.util.Log" name="int getDebuglevel()" map="A"/>
  <method class="org.jfree.util.Log" name="boolean isDebugEnabled()" map="B"/>
  <method class="org.jfree.util.Log" name="org.jfree.util.Log getInstance()" map="C"/>
  <method class="org.jfree.util.Log" name="void doLog(int, java.lang.Object, java.lang.Exception)" map="A"/>
  <method class="org.jfree.util.Log" name="org.jfree.util.LogContext createContext(java.lang.String)" map="A"/>
  <method class="org.jfree.util.Log" name="void doLog(int, java.lang.Object)" map="B"/>
  <method class="org.jfree.util.Log" name="void warn(java.lang.Object, java.lang.Exception)" map="A"/>
  <method class="org.jfree.util.Log" name="void warn(java.lang.Object)" map="A"/>
  <method class="org.jfree.util.Log" name="void log(int, java.lang.Object, java.lang.Exception)" map="B"/>
  <method class="org.jfree.util.Log" name="void debug(java.lang.Object)" map="B"/>
  <method class="org.jfree.util.Log" name="org.jfree.util.LogContext createContext(java.lang.Class)" map="A"/>
  <method class="org.jfree.util.Log" name="org.jfree.util.LogContext internalCreateContext(java.lang.String)" map="B"/>
  <class name="org.jfree.util.UnitType" map="Q"/>
  <field class="org.jfree.util.UnitType" name="name" map="A"/>
  <field class="org.jfree.util.UnitType" name="RELATIVE" map="B"/>
  <field class="org.jfree.util.UnitType" name="ABSOLUTE" map="C"/>
  <method class="org.jfree.util.UnitType" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.util.UnitType" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.util.UnitType" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.util.ShapeList" map="R"/>
  <method class="org.jfree.util.ShapeList" name="java.awt.Shape getShape(int)" map="E"/>
  <method class="org.jfree.util.ShapeList" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.util.ShapeList" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.util.ShapeList" name="void setShape(int, java.awt.Shape)" map="A"/>
  <method class="org.jfree.util.ShapeList" name="int hashCode()" map="hashCode"/>
  <class name="org.jfree.util.SortOrder" map="S"/>
  <field class="org.jfree.util.SortOrder" name="DESCENDING" map="A"/>
  <field class="org.jfree.util.SortOrder" name="name" map="B"/>
  <field class="org.jfree.util.SortOrder" name="ASCENDING" map="C"/>
  <method class="org.jfree.util.SortOrder" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.util.SortOrder" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.util.SortOrder" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.util.LogTarget" map="T"/>
  <field class="org.jfree.util.LogTarget" name="LEVELS" map="A"/>
  <method class="org.jfree.util.LogTarget" name="void log(int, java.lang.Object, java.lang.Exception)" map="A"/>
  <method class="org.jfree.util.LogTarget" name="void log(int, java.lang.Object)" map="A"/>
  <class name="org.jfree.util.AttributedStringUtilities" map="U"/>
  <method class="org.jfree.util.AttributedStringUtilities" name="boolean equal(java.text.AttributedString, java.text.AttributedString)" map="A"/>
  <package name="org.jfree.layout" map="E"/>
  <class name="org.jfree.layout.LCBLayout" map="A"/>
  <field class="org.jfree.layout.LCBLayout" name="vGap" map="A"/>
  <field class="org.jfree.layout.LCBLayout" name="colWidth" map="B"/>
  <field class="org.jfree.layout.LCBLayout" name="buttonGap" map="C"/>
  <field class="org.jfree.layout.LCBLayout" name="rowHeight" map="D"/>
  <field class="org.jfree.layout.LCBLayout" name="labelGap" map="E"/>
  <method class="org.jfree.layout.LCBLayout" name="java.awt.Dimension minimumLayoutSize(java.awt.Container)" map="minimumLayoutSize"/>
  <method class="org.jfree.layout.LCBLayout" name="void removeLayoutComponent(java.awt.Component)" map="removeLayoutComponent"/>
  <method class="org.jfree.layout.LCBLayout" name="void layoutContainer(java.awt.Container)" map="layoutContainer"/>
  <method class="org.jfree.layout.LCBLayout" name="void addLayoutComponent(java.lang.String, java.awt.Component)" map="addLayoutComponent"/>
  <method class="org.jfree.layout.LCBLayout" name="java.awt.Dimension preferredLayoutSize(java.awt.Container)" map="preferredLayoutSize"/>
  <package name="org.jfree.io" map="F"/>
  <class name="org.jfree.io.SerialUtilities" map="A"/>
  <field class="org.jfree.io.SerialUtilities" name="class$java$io$Serializable" map="class$java$io$Serializable"/>
  <field class="org.jfree.io.SerialUtilities" name="class$java$awt$GradientPaint" map="class$java$awt$GradientPaint"/>
  <method class="org.jfree.io.SerialUtilities" name="void writePaint(java.awt.Paint, java.io.ObjectOutputStream)" map="A"/>
  <method class="org.jfree.io.SerialUtilities" name="boolean isSerializable(java.lang.Class)" map="A"/>
  <method class="org.jfree.io.SerialUtilities" name="java.awt.Paint readPaint(java.io.ObjectInputStream)" map="A"/>
  <method class="org.jfree.io.SerialUtilities" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <package name="org.jfree.chart" map="G"/>
  <package name="org.jfree.chart.panel" map="A"/>
  <class name="org.jfree.chart.panel.Overlay" map="A"/>
  <method class="org.jfree.chart.panel.Overlay" name="void paintOverlay(java.awt.Graphics2D, org.jfree.chart.ChartPanel)" map="A"/>
  <package name="org.jfree.chart.event" map="B"/>
  <class name="org.jfree.chart.event.AnnotationChangeListener" map="A"/>
  <class name="org.jfree.chart.event.AxisChangeEvent" map="B"/>
  <field class="org.jfree.chart.event.AxisChangeEvent" name="axis" map="G"/>
  <class name="org.jfree.chart.event.TitleChangeEvent" map="C"/>
  <field class="org.jfree.chart.event.TitleChangeEvent" name="title" map="C"/>
  <class name="org.jfree.chart.event.PlotChangeListener" map="D"/>
  <method class="org.jfree.chart.event.PlotChangeListener" name="void plotChanged(org.jfree.chart.event.PlotChangeEvent)" map="A"/>
  <class name="org.jfree.chart.event.RendererChangeEvent" map="E"/>
  <field class="org.jfree.chart.event.RendererChangeEvent" name="renderer" map="D"/>
  <field class="org.jfree.chart.event.RendererChangeEvent" name="seriesVisibilityChanged" map="E"/>
  <method class="org.jfree.chart.event.RendererChangeEvent" name="boolean getSeriesVisibilityChanged()" map="A"/>
  <class name="org.jfree.chart.event.PlotChangeEvent" map="F"/>
  <field class="org.jfree.chart.event.PlotChangeEvent" name="plot" map="F"/>
  <class name="org.jfree.chart.event.TitleChangeListener" map="G"/>
  <method class="org.jfree.chart.event.TitleChangeListener" name="void titleChanged(org.jfree.chart.event.TitleChangeEvent)" map="A"/>
  <class name="org.jfree.chart.event.MarkerChangeListener" map="H"/>
  <class name="org.jfree.chart.event.ChartChangeEventType" map="I"/>
  <field class="org.jfree.chart.event.ChartChangeEventType" name="DATASET_UPDATED" map="A"/>
  <field class="org.jfree.chart.event.ChartChangeEventType" name="name" map="B"/>
  <field class="org.jfree.chart.event.ChartChangeEventType" name="NEW_DATASET" map="C"/>
  <field class="org.jfree.chart.event.ChartChangeEventType" name="GENERAL" map="D"/>
  <method class="org.jfree.chart.event.ChartChangeEventType" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.event.ChartChangeEventType" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.event.ChartChangeEventType" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.event.RendererChangeListener" map="J"/>
  <method class="org.jfree.chart.event.RendererChangeListener" name="void rendererChanged(org.jfree.chart.event.RendererChangeEvent)" map="B"/>
  <class name="org.jfree.chart.event.ChartChangeListener" map="K"/>
  <method class="org.jfree.chart.event.ChartChangeListener" name="void chartChanged(org.jfree.chart.event.ChartChangeEvent)" map="A"/>
  <class name="org.jfree.chart.event.ChartProgressListener" map="L"/>
  <method class="org.jfree.chart.event.ChartProgressListener" name="void chartProgress(org.jfree.chart.event.ChartProgressEvent)" map="A"/>
  <class name="org.jfree.chart.event.OverlayChangeListener" map="M"/>
  <class name="org.jfree.chart.event.ChartChangeEvent" map="N"/>
  <field class="org.jfree.chart.event.ChartChangeEvent" name="chart" map="A"/>
  <field class="org.jfree.chart.event.ChartChangeEvent" name="type" map="B"/>
  <method class="org.jfree.chart.event.ChartChangeEvent" name="void setType(org.jfree.chart.event.ChartChangeEventType)" map="A"/>
  <method class="org.jfree.chart.event.ChartChangeEvent" name="void setChart(org.jfree.chart.JFreeChart)" map="A"/>
  <class name="org.jfree.chart.event.AxisChangeListener" map="O"/>
  <method class="org.jfree.chart.event.AxisChangeListener" name="void axisChanged(org.jfree.chart.event.AxisChangeEvent)" map="A"/>
  <class name="org.jfree.chart.event.ChartProgressEvent" map="P"/>
  <field class="org.jfree.chart.event.ChartProgressEvent" name="chart" map="A"/>
  <field class="org.jfree.chart.event.ChartProgressEvent" name="type" map="B"/>
  <field class="org.jfree.chart.event.ChartProgressEvent" name="percent" map="C"/>
  <package name="org.jfree.chart.resources" map="C"/>
  <class name="org.jfree.chart.resources.JFreeChartResources" map="A"/>
  <field class="org.jfree.chart.resources.JFreeChartResources" name="CONTENTS" map="A"/>
  <method class="org.jfree.chart.resources.JFreeChartResources" name="java.lang.Object[][] getContents()" map="getContents"/>
  <package name="org.jfree.chart.axis" map="D"/>
  <class name="org.jfree.chart.axis.Tick" map="A"/>
  <field class="org.jfree.chart.axis.Tick" name="textAnchor" map="A"/>
  <field class="org.jfree.chart.axis.Tick" name="rotationAnchor" map="B"/>
  <field class="org.jfree.chart.axis.Tick" name="angle" map="C"/>
  <field class="org.jfree.chart.axis.Tick" name="text" map="D"/>
  <method class="org.jfree.chart.axis.Tick" name="org.jfree.ui.TextAnchor getTextAnchor()" map="A"/>
  <method class="org.jfree.chart.axis.Tick" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.axis.Tick" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.Tick" name="double getAngle()" map="B"/>
  <method class="org.jfree.chart.axis.Tick" name="java.lang.String getText()" map="C"/>
  <method class="org.jfree.chart.axis.Tick" name="java.lang.String toString()" map="toString"/>
  <method class="org.jfree.chart.axis.Tick" name="org.jfree.ui.TextAnchor getRotationAnchor()" map="D"/>
  <class name="org.jfree.chart.axis.CategoryLabelPosition" map="B"/>
  <field class="org.jfree.chart.axis.CategoryLabelPosition" name="labelAnchor" map="A"/>
  <field class="org.jfree.chart.axis.CategoryLabelPosition" name="categoryAnchor" map="B"/>
  <field class="org.jfree.chart.axis.CategoryLabelPosition" name="widthType" map="C"/>
  <field class="org.jfree.chart.axis.CategoryLabelPosition" name="widthRatio" map="D"/>
  <field class="org.jfree.chart.axis.CategoryLabelPosition" name="rotationAnchor" map="E"/>
  <field class="org.jfree.chart.axis.CategoryLabelPosition" name="angle" map="F"/>
  <method class="org.jfree.chart.axis.CategoryLabelPosition" name="org.jfree.text.TextBlockAnchor getLabelAnchor()" map="A"/>
  <method class="org.jfree.chart.axis.CategoryLabelPosition" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.CategoryLabelPosition" name="float getWidthRatio()" map="B"/>
  <method class="org.jfree.chart.axis.CategoryLabelPosition" name="double getAngle()" map="C"/>
  <method class="org.jfree.chart.axis.CategoryLabelPosition" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.axis.CategoryLabelPosition" name="org.jfree.chart.axis.CategoryLabelWidthType getWidthType()" map="D"/>
  <method class="org.jfree.chart.axis.CategoryLabelPosition" name="org.jfree.ui.TextAnchor getRotationAnchor()" map="E"/>
  <method class="org.jfree.chart.axis.CategoryLabelPosition" name="org.jfree.ui.RectangleAnchor getCategoryAnchor()" map="F"/>
  <class name="org.jfree.chart.axis.CategoryAnchor" map="C"/>
  <field class="org.jfree.chart.axis.CategoryAnchor" name="MIDDLE" map="A"/>
  <field class="org.jfree.chart.axis.CategoryAnchor" name="name" map="B"/>
  <field class="org.jfree.chart.axis.CategoryAnchor" name="END" map="C"/>
  <field class="org.jfree.chart.axis.CategoryAnchor" name="START" map="D"/>
  <method class="org.jfree.chart.axis.CategoryAnchor" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.CategoryAnchor" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.axis.CategoryLabelPositions" map="D"/>
  <field class="org.jfree.chart.axis.CategoryLabelPositions" name="positionForAxisAtTop" map="A"/>
  <field class="org.jfree.chart.axis.CategoryLabelPositions" name="UP_90" map="B"/>
  <field class="org.jfree.chart.axis.CategoryLabelPositions" name="positionForAxisAtLeft" map="C"/>
  <field class="org.jfree.chart.axis.CategoryLabelPositions" name="positionForAxisAtRight" map="D"/>
  <field class="org.jfree.chart.axis.CategoryLabelPositions" name="positionForAxisAtBottom" map="E"/>
  <field class="org.jfree.chart.axis.CategoryLabelPositions" name="DOWN_45" map="F"/>
  <field class="org.jfree.chart.axis.CategoryLabelPositions" name="STANDARD" map="G"/>
  <field class="org.jfree.chart.axis.CategoryLabelPositions" name="UP_45" map="H"/>
  <field class="org.jfree.chart.axis.CategoryLabelPositions" name="DOWN_90" map="I"/>
  <method class="org.jfree.chart.axis.CategoryLabelPositions" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.CategoryLabelPositions" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.axis.CategoryLabelPositions" name="org.jfree.chart.axis.CategoryLabelPositions createDownRotationLabelPositions(double)" map="A"/>
  <method class="org.jfree.chart.axis.CategoryLabelPositions" name="org.jfree.chart.axis.CategoryLabelPosition getLabelPosition(org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.CategoryLabelPositions" name="org.jfree.chart.axis.CategoryLabelPositions createUpRotationLabelPositions(double)" map="B"/>
  <class name="org.jfree.chart.axis.LogAxis" map="E"/>
  <method class="org.jfree.chart.axis.LogAxis" name="org.jfree.chart.axis.NumberTickUnit getTickUnit()" map="&#x0190;"/>
  <method class="org.jfree.chart.axis.LogAxis" name="void setTickUnit(org.jfree.chart.axis.NumberTickUnit)" map="A"/>
  <class name="org.jfree.chart.axis.AxisSpace" map="F"/>
  <field class="org.jfree.chart.axis.AxisSpace" name="bottom" map="&#x0296;"/>
  <field class="org.jfree.chart.axis.AxisSpace" name="right" map="&#x0297;"/>
  <field class="org.jfree.chart.axis.AxisSpace" name="left" map="&#x0298;"/>
  <field class="org.jfree.chart.axis.AxisSpace" name="top" map="&#x0299;"/>
  <method class="org.jfree.chart.axis.AxisSpace" name="double getBottom()" map="&#x0161;"/>
  <method class="org.jfree.chart.axis.AxisSpace" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.axis.AxisSpace" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.AxisSpace" name="void add(double, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.AxisSpace" name="double getLeft()" map="&#x0162;"/>
  <method class="org.jfree.chart.axis.AxisSpace" name="double getTop()" map="&#x0163;"/>
  <method class="org.jfree.chart.axis.AxisSpace" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.axis.AxisSpace" name="double getRight()" map="&#x0164;"/>
  <method class="org.jfree.chart.axis.AxisSpace" name="java.lang.String toString()" map="toString"/>
  <method class="org.jfree.chart.axis.AxisSpace" name="void ensureAtLeast(double, org.jfree.ui.RectangleEdge)" map="B"/>
  <method class="org.jfree.chart.axis.AxisSpace" name="java.awt.geom.Rectangle2D shrink(java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D)" map="A"/>
  <class name="org.jfree.chart.axis.SubCategoryAxis" map="G"/>
  <method class="org.jfree.chart.axis.SubCategoryAxis" name="void setSubLabelPaint(java.awt.Paint)" map="o"/>
  <method class="org.jfree.chart.axis.SubCategoryAxis" name="void setSubLabelFont(java.awt.Font)" map="M"/>
  <class name="org.jfree.chart.axis.TickType" map="H"/>
  <field class="org.jfree.chart.axis.TickType" name="MAJOR" map="A"/>
  <field class="org.jfree.chart.axis.TickType" name="name" map="B"/>
  <field class="org.jfree.chart.axis.TickType" name="MINOR" map="C"/>
  <method class="org.jfree.chart.axis.TickType" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.TickType" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.axis.CategoryAxis" map="I"/>
  <field class="org.jfree.chart.axis.CategoryAxis" name="lowerMargin" map="&#x02e1;"/>
  <field class="org.jfree.chart.axis.CategoryAxis" name="categoryLabelToolTips" map="&#x02e2;"/>
  <field class="org.jfree.chart.axis.CategoryAxis" name="categoryLabelPositionOffset" map="&#x02e3;"/>
  <field class="org.jfree.chart.axis.CategoryAxis" name="maximumCategoryLabelLines" map="&#x02e4;"/>
  <field class="org.jfree.chart.axis.CategoryAxis" name="maximumCategoryLabelWidthRatio" map="&#x037a;"/>
  <field class="org.jfree.chart.axis.CategoryAxis" name="categoryMargin" map="&#x0386;"/>
  <field class="org.jfree.chart.axis.CategoryAxis" name="tickLabelPaintMap" map="&#x0388;"/>
  <field class="org.jfree.chart.axis.CategoryAxis" name="categoryLabelPositions" map="&#x0389;"/>
  <field class="org.jfree.chart.axis.CategoryAxis" name="tickLabelFontMap" map="&#x038a;"/>
  <field class="org.jfree.chart.axis.CategoryAxis" name="upperMargin" map="&#x038c;"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="org.jfree.chart.axis.AxisState draw(java.awt.Graphics2D, double, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="java.lang.String getCategoryLabelToolTip(java.lang.Comparable)" map="M"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="java.awt.Paint getTickLabelPaint(java.lang.Comparable)" map="N"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="double getCategoryMiddle(int, int, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="double calculateTextBlockWidth(org.jfree.text.TextBlock, org.jfree.chart.axis.CategoryLabelPosition, java.awt.Graphics2D)" map="A"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="void configure()" map="&#x0172;"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="java.util.List refreshTicks(java.awt.Graphics2D, org.jfree.chart.axis.AxisState, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="double getCategoryMiddle(java.lang.Comparable, java.util.List, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="double getCategoryMargin()" map="&#x017e;"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="org.jfree.chart.axis.AxisSpace reserveSpace(java.awt.Graphics2D, org.jfree.chart.plot.Plot, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge, org.jfree.chart.axis.AxisSpace)" map="A"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="double calculateCategorySize(int, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="double getCategoryStart(int, int, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="B"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="java.awt.Font getTickLabelFont(java.lang.Comparable)" map="O"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="double getLowerMargin()" map="&#x017f;"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="org.jfree.text.TextBlock createLabel(java.lang.Comparable, float, org.jfree.ui.RectangleEdge, java.awt.Graphics2D)" map="A"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="double getCategoryJava2DCoordinate(org.jfree.chart.axis.CategoryAnchor, int, int, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="double calculateTextBlockHeight(org.jfree.text.TextBlock, org.jfree.chart.axis.CategoryLabelPosition, java.awt.Graphics2D)" map="B"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="org.jfree.chart.axis.AxisState drawCategoryLabels(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge, org.jfree.chart.axis.AxisState, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="double calculateCategoryGapSize(int, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="B"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="double getCategoryEnd(int, int, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="C"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="void drawTickMarks(java.awt.Graphics2D, double, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge, org.jfree.chart.axis.AxisState)" map="A"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="boolean equalPaintMaps(java.util.Map, java.util.Map)" map="A"/>
  <method class="org.jfree.chart.axis.CategoryAxis" name="double getUpperMargin()" map="&#x0180;"/>
  <class name="org.jfree.chart.axis.NumberTickUnit" map="J"/>
  <field class="org.jfree.chart.axis.NumberTickUnit" name="formatter" map="C"/>
  <method class="org.jfree.chart.axis.NumberTickUnit" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.NumberTickUnit" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.axis.NumberTickUnit" name="java.lang.String valueToString(double)" map="A"/>
  <method class="org.jfree.chart.axis.NumberTickUnit" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.axis.Axis" map="K"/>
  <field class="org.jfree.chart.axis.Axis" name="labelAngle" map="&#x029a;"/>
  <field class="org.jfree.chart.axis.Axis" name="DEFAULT_TICK_MARK_STROKE" map="&#x029b;"/>
  <field class="org.jfree.chart.axis.Axis" name="tickMarkPaint" map="&#x029c;"/>
  <field class="org.jfree.chart.axis.Axis" name="DEFAULT_TICK_LABEL_FONT" map="&#x029d;"/>
  <field class="org.jfree.chart.axis.Axis" name="tickMarkOutsideLength" map="&#x029e;"/>
  <field class="org.jfree.chart.axis.Axis" name="visible" map="&#x029f;"/>
  <field class="org.jfree.chart.axis.Axis" name="DEFAULT_AXIS_LINE_STROKE" map="&#x02a0;"/>
  <field class="org.jfree.chart.axis.Axis" name="listenerList" map="&#x02a1;"/>
  <field class="org.jfree.chart.axis.Axis" name="tickLabelsVisible" map="&#x02a2;"/>
  <field class="org.jfree.chart.axis.Axis" name="fixedDimension" map="&#x02a3;"/>
  <field class="org.jfree.chart.axis.Axis" name="DEFAULT_AXIS_LABEL_INSETS" map="&#x02a4;"/>
  <field class="org.jfree.chart.axis.Axis" name="labelInsets" map="&#x02a5;"/>
  <field class="org.jfree.chart.axis.Axis" name="class$org$jfree$chart$event$AxisChangeListener" map="class$F$B$G$B$O"/>
  <field class="org.jfree.chart.axis.Axis" name="DEFAULT_AXIS_LINE_PAINT" map="&#x02a6;"/>
  <field class="org.jfree.chart.axis.Axis" name="labelFont" map="&#x02a7;"/>
  <field class="org.jfree.chart.axis.Axis" name="label" map="&#x02a8;"/>
  <field class="org.jfree.chart.axis.Axis" name="tickMarkStroke" map="&#x02b0;"/>
  <field class="org.jfree.chart.axis.Axis" name="DEFAULT_AXIS_LABEL_FONT" map="&#x02b1;"/>
  <field class="org.jfree.chart.axis.Axis" name="tickMarkInsideLength" map="&#x02b2;"/>
  <field class="org.jfree.chart.axis.Axis" name="axisLinePaint" map="&#x02b3;"/>
  <field class="org.jfree.chart.axis.Axis" name="DEFAULT_TICK_LABEL_INSETS" map="&#x02b4;"/>
  <field class="org.jfree.chart.axis.Axis" name="axisLineVisible" map="&#x02b5;"/>
  <field class="org.jfree.chart.axis.Axis" name="tickMarksVisible" map="&#x02b6;"/>
  <field class="org.jfree.chart.axis.Axis" name="DEFAULT_TICK_MARK_PAINT" map="&#x02b7;"/>
  <field class="org.jfree.chart.axis.Axis" name="plot" map="&#x02b8;"/>
  <field class="org.jfree.chart.axis.Axis" name="tickLabelPaint" map="&#x02bb;"/>
  <field class="org.jfree.chart.axis.Axis" name="DEFAULT_AXIS_LABEL_PAINT" map="&#x02bc;"/>
  <field class="org.jfree.chart.axis.Axis" name="tickLabelInsets" map="&#x02bd;"/>
  <field class="org.jfree.chart.axis.Axis" name="DEFAULT_TICK_LABEL_PAINT" map="&#x02be;"/>
  <field class="org.jfree.chart.axis.Axis" name="axisLineStroke" map="&#x02bf;"/>
  <field class="org.jfree.chart.axis.Axis" name="labelPaint" map="&#x02c0;"/>
  <field class="org.jfree.chart.axis.Axis" name="minorTickMarkInsideLength" map="&#x02c1;"/>
  <field class="org.jfree.chart.axis.Axis" name="minorTickMarksVisible" map="&#x02d0;"/>
  <field class="org.jfree.chart.axis.Axis" name="tickLabelFont" map="&#x02d1;"/>
  <field class="org.jfree.chart.axis.Axis" name="minorTickMarkOutsideLength" map="&#x02e0;"/>
  <method class="org.jfree.chart.axis.Axis" name="boolean isMinorTickMarksVisible()" map="&#x0165;"/>
  <method class="org.jfree.chart.axis.Axis" name="void notifyListeners(org.jfree.chart.event.AxisChangeEvent)" map="B"/>
  <method class="org.jfree.chart.axis.Axis" name="void createAndAddEntity(double, org.jfree.chart.axis.AxisState, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.axis.Axis" name="void setPlot(org.jfree.chart.plot.Plot)" map="A"/>
  <method class="org.jfree.chart.axis.Axis" name="java.lang.String getLabel()" map="&#x0166;"/>
  <method class="org.jfree.chart.axis.Axis" name="java.util.List refreshTicks(java.awt.Graphics2D, org.jfree.chart.axis.AxisState, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.Axis" name="java.awt.Font getTickLabelFont()" map="&#x0167;"/>
  <method class="org.jfree.chart.axis.Axis" name="void drawAxisLine(java.awt.Graphics2D, double, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.Axis" name="java.awt.Stroke getTickMarkStroke()" map="&#x0168;"/>
  <method class="org.jfree.chart.axis.Axis" name="java.awt.Stroke getAxisLineStroke()" map="&#x0169;"/>
  <method class="org.jfree.chart.axis.Axis" name="boolean isVisible()" map="&#x016a;"/>
  <method class="org.jfree.chart.axis.Axis" name="org.jfree.chart.axis.AxisState drawLabel(java.lang.String, java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge, org.jfree.chart.axis.AxisState)" map="A"/>
  <method class="org.jfree.chart.axis.Axis" name="double getFixedDimension()" map="&#x016b;"/>
  <method class="org.jfree.chart.axis.Axis" name="void addChangeListener(org.jfree.chart.event.AxisChangeListener)" map="A"/>
  <method class="org.jfree.chart.axis.Axis" name="float getMinorTickMarkInsideLength()" map="&#x016c;"/>
  <method class="org.jfree.chart.axis.Axis" name="java.awt.Paint getLabelPaint()" map="&#x016d;"/>
  <method class="org.jfree.chart.axis.Axis" name="float getMinorTickMarkOutsideLength()" map="&#x016e;"/>
  <method class="org.jfree.chart.axis.Axis" name="float getTickMarkOutsideLength()" map="&#x016f;"/>
  <method class="org.jfree.chart.axis.Axis" name="org.jfree.ui.RectangleInsets getTickLabelInsets()" map="&#x0170;"/>
  <method class="org.jfree.chart.axis.Axis" name="void setTickLabelFont(java.awt.Font)" map="K"/>
  <method class="org.jfree.chart.axis.Axis" name="void setTickMarksVisible(boolean)" map="W"/>
  <method class="org.jfree.chart.axis.Axis" name="org.jfree.ui.RectangleInsets getLabelInsets()" map="&#x0171;"/>
  <method class="org.jfree.chart.axis.Axis" name="void configure()" map="&#x0172;"/>
  <method class="org.jfree.chart.axis.Axis" name="boolean isTickMarksVisible()" map="&#x0173;"/>
  <method class="org.jfree.chart.axis.Axis" name="double getLabelAngle()" map="&#x0174;"/>
  <method class="org.jfree.chart.axis.Axis" name="void setLabel(java.lang.String)" map="D"/>
  <method class="org.jfree.chart.axis.Axis" name="boolean isTickLabelsVisible()" map="&#x0175;"/>
  <method class="org.jfree.chart.axis.Axis" name="org.jfree.chart.axis.AxisState draw(java.awt.Graphics2D, double, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.axis.Axis" name="void setLabelInsets(org.jfree.ui.RectangleInsets, boolean)" map="B"/>
  <method class="org.jfree.chart.axis.Axis" name="org.jfree.chart.plot.Plot getPlot()" map="&#x0176;"/>
  <method class="org.jfree.chart.axis.Axis" name="void setTickLabelsVisible(boolean)" map="X"/>
  <method class="org.jfree.chart.axis.Axis" name="java.awt.Paint getTickMarkPaint()" map="&#x0177;"/>
  <method class="org.jfree.chart.axis.Axis" name="java.awt.Font getLabelFont()" map="&#x0178;"/>
  <method class="org.jfree.chart.axis.Axis" name="void setTickLabelInsets(org.jfree.ui.RectangleInsets)" map="F"/>
  <method class="org.jfree.chart.axis.Axis" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jfree.chart.axis.Axis" name="java.awt.geom.Rectangle2D getLabelEnclosure(java.awt.Graphics2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.Axis" name="void fireChangeEvent()" map="&#x0179;"/>
  <method class="org.jfree.chart.axis.Axis" name="void setLabelFont(java.awt.Font)" map="L"/>
  <method class="org.jfree.chart.axis.Axis" name="void removeChangeListener(org.jfree.chart.event.AxisChangeListener)" map="B"/>
  <method class="org.jfree.chart.axis.Axis" name="void setTickLabelPaint(java.awt.Paint)" map="m"/>
  <method class="org.jfree.chart.axis.Axis" name="java.awt.Paint getAxisLinePaint()" map="&#x017a;"/>
  <method class="org.jfree.chart.axis.Axis" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.Axis" name="boolean isAxisLineVisible()" map="&#x017b;"/>
  <method class="org.jfree.chart.axis.Axis" name="java.awt.Paint getTickLabelPaint()" map="&#x017c;"/>
  <method class="org.jfree.chart.axis.Axis" name="org.jfree.chart.axis.AxisSpace reserveSpace(java.awt.Graphics2D, org.jfree.chart.plot.Plot, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge, org.jfree.chart.axis.AxisSpace)" map="A"/>
  <method class="org.jfree.chart.axis.Axis" name="void setLabelPaint(java.awt.Paint)" map="n"/>
  <method class="org.jfree.chart.axis.Axis" name="float getTickMarkInsideLength()" map="&#x017d;"/>
  <method class="org.jfree.chart.axis.Axis" name="void setLabelInsets(org.jfree.ui.RectangleInsets)" map="G"/>
  <method class="org.jfree.chart.axis.Axis" name="java.lang.Object clone()" map="clone"/>
  <class name="org.jfree.chart.axis.MarkerAxisBand" map="L"/>
  <class name="org.jfree.chart.axis.NumberTick" map="M"/>
  <field class="org.jfree.chart.axis.NumberTick" name="number" map="G"/>
  <class name="org.jfree.chart.axis.TickUnits" map="N"/>
  <field class="org.jfree.chart.axis.TickUnits" name="tickUnits" map="A"/>
  <method class="org.jfree.chart.axis.TickUnits" name="org.jfree.chart.axis.TickUnit getCeilingTickUnit(org.jfree.chart.axis.TickUnit)" map="A"/>
  <method class="org.jfree.chart.axis.TickUnits" name="void add(org.jfree.chart.axis.TickUnit)" map="C"/>
  <method class="org.jfree.chart.axis.TickUnits" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.TickUnits" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.axis.TickUnits" name="org.jfree.chart.axis.TickUnit getCeilingTickUnit(double)" map="A"/>
  <method class="org.jfree.chart.axis.TickUnits" name="org.jfree.chart.axis.TickUnit getLargerTickUnit(org.jfree.chart.axis.TickUnit)" map="B"/>
  <class name="org.jfree.chart.axis.AxisState" map="O"/>
  <field class="org.jfree.chart.axis.AxisState" name="max" map="A"/>
  <field class="org.jfree.chart.axis.AxisState" name="ticks" map="B"/>
  <field class="org.jfree.chart.axis.AxisState" name="cursor" map="C"/>
  <method class="org.jfree.chart.axis.AxisState" name="void cursorDown(double)" map="A"/>
  <method class="org.jfree.chart.axis.AxisState" name="void setTicks(java.util.List)" map="A"/>
  <method class="org.jfree.chart.axis.AxisState" name="void cursorUp(double)" map="B"/>
  <method class="org.jfree.chart.axis.AxisState" name="void setMax(double)" map="C"/>
  <method class="org.jfree.chart.axis.AxisState" name="void cursorRight(double)" map="D"/>
  <method class="org.jfree.chart.axis.AxisState" name="double getCursor()" map="A"/>
  <method class="org.jfree.chart.axis.AxisState" name="double getMax()" map="B"/>
  <method class="org.jfree.chart.axis.AxisState" name="void cursorLeft(double)" map="E"/>
  <method class="org.jfree.chart.axis.AxisState" name="java.util.List getTicks()" map="C"/>
  <class name="org.jfree.chart.axis.ValueTick" map="P"/>
  <field class="org.jfree.chart.axis.ValueTick" name="tickType" map="E"/>
  <field class="org.jfree.chart.axis.ValueTick" name="value" map="F"/>
  <method class="org.jfree.chart.axis.ValueTick" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.ValueTick" name="org.jfree.chart.axis.TickType getTickType()" map="E"/>
  <method class="org.jfree.chart.axis.ValueTick" name="double getValue()" map="F"/>
  <class name="org.jfree.chart.axis.AxisLocation" map="Q"/>
  <field class="org.jfree.chart.axis.AxisLocation" name="TOP_OR_LEFT" map="A"/>
  <field class="org.jfree.chart.axis.AxisLocation" name="BOTTOM_OR_LEFT" map="B"/>
  <field class="org.jfree.chart.axis.AxisLocation" name="name" map="C"/>
  <field class="org.jfree.chart.axis.AxisLocation" name="TOP_OR_RIGHT" map="D"/>
  <field class="org.jfree.chart.axis.AxisLocation" name="BOTTOM_OR_RIGHT" map="E"/>
  <method class="org.jfree.chart.axis.AxisLocation" name="org.jfree.chart.axis.AxisLocation getOpposite(org.jfree.chart.axis.AxisLocation)" map="A"/>
  <method class="org.jfree.chart.axis.AxisLocation" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.AxisLocation" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.axis.TickUnitSource" map="R"/>
  <method class="org.jfree.chart.axis.TickUnitSource" name="org.jfree.chart.axis.TickUnit getCeilingTickUnit(org.jfree.chart.axis.TickUnit)" map="A"/>
  <method class="org.jfree.chart.axis.TickUnitSource" name="org.jfree.chart.axis.TickUnit getCeilingTickUnit(double)" map="A"/>
  <method class="org.jfree.chart.axis.TickUnitSource" name="org.jfree.chart.axis.TickUnit getLargerTickUnit(org.jfree.chart.axis.TickUnit)" map="B"/>
  <class name="org.jfree.chart.axis.TickUnit" map="S"/>
  <field class="org.jfree.chart.axis.TickUnit" name="minorTickCount" map="A"/>
  <field class="org.jfree.chart.axis.TickUnit" name="size" map="B"/>
  <method class="org.jfree.chart.axis.TickUnit" name="double getSize()" map="A"/>
  <method class="org.jfree.chart.axis.TickUnit" name="int getMinorTickCount()" map="B"/>
  <method class="org.jfree.chart.axis.TickUnit" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.TickUnit" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.axis.TickUnit" name="java.lang.String valueToString(double)" map="A"/>
  <method class="org.jfree.chart.axis.TickUnit" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <class name="org.jfree.chart.axis.PeriodAxis" map="T"/>
  <method class="org.jfree.chart.axis.PeriodAxis" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.axis.PeriodAxis" name="void setLabelInfo(org.jfree.chart.axis.PeriodAxisLabelInfo[])" map="A"/>
  <method class="org.jfree.chart.axis.PeriodAxis" name="org.jfree.chart.axis.PeriodAxisLabelInfo[] getLabelInfo()" map="&#x0198;"/>
  <method class="org.jfree.chart.axis.PeriodAxis" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <class name="org.jfree.chart.axis.ColorBar" map="U"/>
  <method class="org.jfree.chart.axis.ColorBar" name="void setColorPalette(org.jfree.chart.plot.ColorPalette)" map="A"/>
  <method class="org.jfree.chart.axis.ColorBar" name="org.jfree.chart.plot.ColorPalette getColorPalette()" map="A"/>
  <method class="org.jfree.chart.axis.ColorBar" name="org.jfree.chart.axis.ValueAxis getAxis()" map="B"/>
  <class name="org.jfree.chart.axis.CategoryLabelWidthType" map="V"/>
  <field class="org.jfree.chart.axis.CategoryLabelWidthType" name="RANGE" map="A"/>
  <field class="org.jfree.chart.axis.CategoryLabelWidthType" name="CATEGORY" map="B"/>
  <field class="org.jfree.chart.axis.CategoryLabelWidthType" name="name" map="C"/>
  <method class="org.jfree.chart.axis.CategoryLabelWidthType" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.CategoryLabelWidthType" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.axis.SymbolAxis" map="W"/>
  <field class="org.jfree.chart.axis.SymbolAxis" name="DEFAULT_GRID_BAND_PAINT" map="&#x03a9;"/>
  <field class="org.jfree.chart.axis.SymbolAxis" name="DEFAULT_GRID_BAND_ALTERNATE_PAINT" map="&#x03aa;"/>
  <method class="org.jfree.chart.axis.SymbolAxis" name="void setGridBandPaint(java.awt.Paint)" map="p"/>
  <method class="org.jfree.chart.axis.SymbolAxis" name="void setGridBandAlternatePaint(java.awt.Paint)" map="q"/>
  <class name="org.jfree.chart.axis.NumberAxis" map="X"/>
  <field class="org.jfree.chart.axis.NumberAxis" name="autoRangeStickyZero" map="&#x03a1;"/>
  <field class="org.jfree.chart.axis.NumberAxis" name="autoRangeIncludesZero" map="&#x03a3;"/>
  <field class="org.jfree.chart.axis.NumberAxis" name="markerBand" map="&#x03a4;"/>
  <field class="org.jfree.chart.axis.NumberAxis" name="numberFormatOverride" map="&#x03a5;"/>
  <field class="org.jfree.chart.axis.NumberAxis" name="tickUnit" map="&#x03a6;"/>
  <field class="org.jfree.chart.axis.NumberAxis" name="DEFAULT_TICK_UNIT" map="&#x03a7;"/>
  <field class="org.jfree.chart.axis.NumberAxis" name="rangeType" map="&#x03a8;"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="double estimateMaximumTickLabelWidth(java.awt.Graphics2D, org.jfree.chart.axis.TickUnit)" map="A"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="double calculateLowestVisibleTickValue()" map="&#x0191;"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="void selectHorizontalAutoTickUnit(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="boolean getAutoRangeIncludesZero()" map="&#x0192;"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="void selectVerticalAutoTickUnit(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="B"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="org.jfree.chart.axis.AxisState draw(java.awt.Graphics2D, double, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="void setTickUnit(org.jfree.chart.axis.NumberTickUnit)" map="B"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="org.jfree.chart.axis.NumberTickUnit getTickUnit()" map="&#x0193;"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="void autoAdjustRange()" map="&#x018d;"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="java.util.List refreshTicksHorizontal(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="C"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="java.text.NumberFormat getNumberFormatOverride()" map="&#x0194;"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="double java2DToValue(double, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="void configure()" map="&#x0172;"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="java.util.List refreshTicks(java.awt.Graphics2D, org.jfree.chart.axis.AxisState, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="double estimateMaximumTickLabelHeight(java.awt.Graphics2D)" map="C"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="int calculateVisibleTickCount()" map="&#x0195;"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="double valueToJava2D(double, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="C"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="java.util.List refreshTicksVertical(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="D"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="void setAutoRangeIncludesZero(boolean)" map="a"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="boolean getAutoRangeStickyZero()" map="&#x0196;"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="org.jfree.chart.axis.TickUnitSource createStandardTickUnits()" map="&#x0197;"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="void selectAutoTickUnit(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="E"/>
  <method class="org.jfree.chart.axis.NumberAxis" name="void setTickUnit(org.jfree.chart.axis.NumberTickUnit, boolean, boolean)" map="A"/>
  <class name="org.jfree.chart.axis.ValueAxis" map="Y"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="DEFAULT_RANGE" map="&#x038e;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="standardTickUnits" map="&#x038f;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="autoTickUnitSelection" map="&#x0390;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="negativeArrowVisible" map="&#x0391;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="defaultAutoRange" map="&#x0392;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="minorTickCount" map="&#x0393;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="leftArrow" map="&#x0394;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="autoRangeMinimumSize" map="&#x0395;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="rightArrow" map="&#x0396;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="positiveArrowVisible" map="&#x0397;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="autoRange" map="&#x0398;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="range" map="&#x0399;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="inverted" map="&#x039a;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="upArrow" map="&#x039b;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="upperMargin" map="&#x039c;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="downArrow" map="&#x039d;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="fixedAutoRange" map="&#x039e;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="verticalTickLabels" map="&#x039f;"/>
  <field class="org.jfree.chart.axis.ValueAxis" name="lowerMargin" map="&#x03a0;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="void setRange(org.jfree.data.Range)" map="C"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="boolean isInverted()" map="&#x0181;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="double findMaximumTickLabelHeight(java.util.List, java.awt.Graphics2D, java.awt.geom.Rectangle2D, boolean)" map="A"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="org.jfree.data.Range getRange()" map="&#x0182;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="boolean isAutoTickUnitSelection()" map="&#x0183;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="void drawAxisLine(java.awt.Graphics2D, double, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="double java2DToValue(double, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="double getAutoRangeMinimumSize()" map="&#x0184;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="float[] calculateAnchorPoint(org.jfree.chart.axis.ValueTick, double, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="void setAutoRange(boolean)" map="Y"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="int getMinorTickCount()" map="&#x0185;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="double lengthToJava2D(double, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="B"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="double getFixedAutoRange()" map="&#x0186;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="void zoomRange(double, double)" map="A"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="double getUpperMargin()" map="&#x0187;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="org.jfree.chart.axis.AxisState drawTickMarksAndLabels(java.awt.Graphics2D, double, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="void resizeRange(double)" map="H"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="boolean isAutoRange()" map="&#x0188;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="void setAutoTickUnitSelection(boolean, boolean)" map="A"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="void pan(double)" map="I"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="void resizeRange2(double, double)" map="B"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="void setAutoRange(boolean, boolean)" map="B"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="void setRange(org.jfree.data.Range, boolean, boolean)" map="A"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="double valueToJava2D(double, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="C"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="org.jfree.data.Range getDefaultAutoRange()" map="&#x0189;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="double getUpperBound()" map="&#x018a;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="void resizeRange(double, double)" map="C"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="org.jfree.chart.axis.TickUnitSource getStandardTickUnits()" map="&#x018b;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="org.jfree.chart.axis.AxisSpace reserveSpace(java.awt.Graphics2D, org.jfree.chart.plot.Plot, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge, org.jfree.chart.axis.AxisSpace)" map="A"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="void setRange(double, double)" map="D"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="double getLowerMargin()" map="&#x018c;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="void autoAdjustRange()" map="&#x018d;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="void setInverted(boolean)" map="Z"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="boolean isVerticalTickLabels()" map="&#x018e;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="void setAutoTickUnitSelection(boolean)" map="_"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="double getLowerBound()" map="&#x018f;"/>
  <method class="org.jfree.chart.axis.ValueAxis" name="double findMaximumTickLabelWidth(java.util.List, java.awt.Graphics2D, java.awt.geom.Rectangle2D, boolean)" map="B"/>
  <class name="org.jfree.chart.axis.CategoryTick" map="Z"/>
  <field class="org.jfree.chart.axis.CategoryTick" name="labelAnchor" map="H"/>
  <field class="org.jfree.chart.axis.CategoryTick" name="label" map="I"/>
  <field class="org.jfree.chart.axis.CategoryTick" name="category" map="J"/>
  <method class="org.jfree.chart.axis.CategoryTick" name="org.jfree.text.TextBlock getLabel()" map="G"/>
  <method class="org.jfree.chart.axis.CategoryTick" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.CategoryTick" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.axis.CategoryTick" name="java.lang.Comparable getCategory()" map="H"/>
  <class name="org.jfree.chart.axis.PeriodAxisLabelInfo" map="_"/>
  <field class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="dividerPaint" map="A"/>
  <field class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="dateFormat" map="B"/>
  <field class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="DEFAULT_DIVIDER_STROKE" map="C"/>
  <field class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="DEFAULT_LABEL_PAINT" map="D"/>
  <field class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="DEFAULT_DIVIDER_PAINT" map="E"/>
  <field class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="DEFAULT_FONT" map="F"/>
  <field class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="labelFont" map="G"/>
  <field class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="dividerStroke" map="H"/>
  <field class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="periodClass" map="I"/>
  <field class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="padding" map="J"/>
  <field class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="drawDividers" map="K"/>
  <field class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="labelPaint" map="L"/>
  <field class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="DEFAULT_INSETS" map="M"/>
  <method class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="boolean getDrawDividers()" map="A"/>
  <method class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="java.lang.Class getPeriodClass()" map="B"/>
  <method class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="java.awt.Stroke getDividerStroke()" map="C"/>
  <method class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="java.text.DateFormat getDateFormat()" map="D"/>
  <method class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="org.jfree.ui.RectangleInsets getPadding()" map="E"/>
  <method class="org.jfree.chart.axis.PeriodAxisLabelInfo" name="java.awt.Paint getDividerPaint()" map="F"/>
  <class name="org.jfree.chart.axis.AxisCollection" map="a"/>
  <field class="org.jfree.chart.axis.AxisCollection" name="axesAtRight" map="A"/>
  <field class="org.jfree.chart.axis.AxisCollection" name="axesAtBottom" map="B"/>
  <field class="org.jfree.chart.axis.AxisCollection" name="axesAtLeft" map="C"/>
  <field class="org.jfree.chart.axis.AxisCollection" name="axesAtTop" map="D"/>
  <method class="org.jfree.chart.axis.AxisCollection" name="void add(org.jfree.chart.axis.Axis, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.axis.AxisCollection" name="java.util.List getAxesAtRight()" map="A"/>
  <method class="org.jfree.chart.axis.AxisCollection" name="java.util.List getAxesAtLeft()" map="B"/>
  <method class="org.jfree.chart.axis.AxisCollection" name="java.util.List getAxesAtBottom()" map="C"/>
  <method class="org.jfree.chart.axis.AxisCollection" name="java.util.List getAxesAtTop()" map="D"/>
  <package name="org.jfree.chart.block" map="E"/>
  <class name="org.jfree.chart.block.LabelBlock" map="A"/>
  <field class="org.jfree.chart.block.LabelBlock" name="urlText" map="&#x028d;"/>
  <field class="org.jfree.chart.block.LabelBlock" name="font" map="&#x028e;"/>
  <field class="org.jfree.chart.block.LabelBlock" name="textAnchor" map="&#x028f;"/>
  <field class="org.jfree.chart.block.LabelBlock" name="toolTipText" map="&#x0290;"/>
  <field class="org.jfree.chart.block.LabelBlock" name="paint" map="&#x0291;"/>
  <field class="org.jfree.chart.block.LabelBlock" name="DEFAULT_PAINT" map="&#x0292;"/>
  <field class="org.jfree.chart.block.LabelBlock" name="contentAlignmentPoint" map="&#x0293;"/>
  <field class="org.jfree.chart.block.LabelBlock" name="label" map="&#x0294;"/>
  <field class="org.jfree.chart.block.LabelBlock" name="text" map="&#x0295;"/>
  <method class="org.jfree.chart.block.LabelBlock" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.block.LabelBlock" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.block.LabelBlock" name="void setPaint(java.awt.Paint)" map="l"/>
  <method class="org.jfree.chart.block.LabelBlock" name="void setFont(java.awt.Font)" map="J"/>
  <method class="org.jfree.chart.block.LabelBlock" name="java.lang.Object draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.lang.Object)" map="A"/>
  <method class="org.jfree.chart.block.LabelBlock" name="org.jfree.ui.Size2D arrange(java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="A"/>
  <class name="org.jfree.chart.block.FlowArrangement" map="B"/>
  <field class="org.jfree.chart.block.FlowArrangement" name="horizontalAlignment" map="J"/>
  <field class="org.jfree.chart.block.FlowArrangement" name="verticalGap" map="K"/>
  <field class="org.jfree.chart.block.FlowArrangement" name="verticalAlignment" map="L"/>
  <field class="org.jfree.chart.block.FlowArrangement" name="horizontalGap" map="M"/>
  <method class="org.jfree.chart.block.FlowArrangement" name="org.jfree.ui.Size2D arrangeRN(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="O"/>
  <method class="org.jfree.chart.block.FlowArrangement" name="org.jfree.ui.Size2D arrangeNF(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="P"/>
  <method class="org.jfree.chart.block.FlowArrangement" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.block.FlowArrangement" name="void clear()" map="A"/>
  <method class="org.jfree.chart.block.FlowArrangement" name="void add(org.jfree.chart.block.Block, java.lang.Object)" map="A"/>
  <method class="org.jfree.chart.block.FlowArrangement" name="org.jfree.ui.Size2D arrangeFF(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="Q"/>
  <method class="org.jfree.chart.block.FlowArrangement" name="org.jfree.ui.Size2D arrangeNN(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D)" map="D"/>
  <method class="org.jfree.chart.block.FlowArrangement" name="org.jfree.ui.Size2D arrange(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="A"/>
  <method class="org.jfree.chart.block.FlowArrangement" name="org.jfree.ui.Size2D arrangeRF(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="R"/>
  <method class="org.jfree.chart.block.FlowArrangement" name="org.jfree.ui.Size2D arrangeFR(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="S"/>
  <method class="org.jfree.chart.block.FlowArrangement" name="org.jfree.ui.Size2D arrangeFN(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="T"/>
  <method class="org.jfree.chart.block.FlowArrangement" name="org.jfree.ui.Size2D arrangeRR(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="U"/>
  <class name="org.jfree.chart.block.CenterArrangement" map="C"/>
  <method class="org.jfree.chart.block.CenterArrangement" name="org.jfree.ui.Size2D arrangeRN(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="B"/>
  <method class="org.jfree.chart.block.CenterArrangement" name="org.jfree.ui.Size2D arrangeNF(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="C"/>
  <method class="org.jfree.chart.block.CenterArrangement" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.block.CenterArrangement" name="void clear()" map="A"/>
  <method class="org.jfree.chart.block.CenterArrangement" name="void add(org.jfree.chart.block.Block, java.lang.Object)" map="A"/>
  <method class="org.jfree.chart.block.CenterArrangement" name="org.jfree.ui.Size2D arrangeFF(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="D"/>
  <method class="org.jfree.chart.block.CenterArrangement" name="org.jfree.ui.Size2D arrangeNN(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D)" map="A"/>
  <method class="org.jfree.chart.block.CenterArrangement" name="org.jfree.ui.Size2D arrange(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="A"/>
  <method class="org.jfree.chart.block.CenterArrangement" name="org.jfree.ui.Size2D arrangeRF(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="E"/>
  <method class="org.jfree.chart.block.CenterArrangement" name="org.jfree.ui.Size2D arrangeFR(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="F"/>
  <method class="org.jfree.chart.block.CenterArrangement" name="org.jfree.ui.Size2D arrangeFN(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="G"/>
  <method class="org.jfree.chart.block.CenterArrangement" name="org.jfree.ui.Size2D arrangeRR(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="H"/>
  <class name="org.jfree.chart.block.EntityBlockParams" map="D"/>
  <method class="org.jfree.chart.block.EntityBlockParams" name="boolean getGenerateEntities()" map="A"/>
  <class name="org.jfree.chart.block.AbstractBlock" map="E"/>
  <field class="org.jfree.chart.block.AbstractBlock" name="height" map="S"/>
  <field class="org.jfree.chart.block.AbstractBlock" name="width" map="T"/>
  <field class="org.jfree.chart.block.AbstractBlock" name="bounds" map="U"/>
  <field class="org.jfree.chart.block.AbstractBlock" name="margin" map="V"/>
  <field class="org.jfree.chart.block.AbstractBlock" name="padding" map="W"/>
  <field class="org.jfree.chart.block.AbstractBlock" name="frame" map="X"/>
  <field class="org.jfree.chart.block.AbstractBlock" name="id" map="Y"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="void drawBorder(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="void setBounds(java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="double getWidth()" map="O"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="double getHeight()" map="P"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="org.jfree.chart.block.BlockFrame getFrame()" map="Q"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="java.awt.geom.Rectangle2D trimMargin(java.awt.geom.Rectangle2D)" map="B"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="org.jfree.data.Range trimToContentWidth(org.jfree.data.Range)" map="A"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="java.awt.geom.Rectangle2D getBounds()" map="R"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="double trimToContentHeight(double)" map="A"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="org.jfree.data.Range trimToContentHeight(org.jfree.data.Range)" map="B"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="java.awt.geom.Rectangle2D trimPadding(java.awt.geom.Rectangle2D)" map="C"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="double trimToContentWidth(double)" map="B"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="void setPadding(org.jfree.ui.RectangleInsets)" map="A"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="void setPadding(double, double, double, double)" map="A"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="void setFrame(org.jfree.chart.block.BlockFrame)" map="A"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="org.jfree.chart.block.RectangleConstraint toContentConstraint(org.jfree.chart.block.RectangleConstraint)" map="A"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="double calculateTotalHeight(double)" map="C"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="double calculateTotalWidth(double)" map="D"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="org.jfree.ui.Size2D arrange(java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="A"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="java.awt.geom.Rectangle2D trimBorder(java.awt.geom.Rectangle2D)" map="D"/>
  <method class="org.jfree.chart.block.AbstractBlock" name="void setMargin(org.jfree.ui.RectangleInsets)" map="B"/>
  <class name="org.jfree.chart.block.Arrangement" map="F"/>
  <method class="org.jfree.chart.block.Arrangement" name="org.jfree.ui.Size2D arrange(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="A"/>
  <method class="org.jfree.chart.block.Arrangement" name="void clear()" map="A"/>
  <method class="org.jfree.chart.block.Arrangement" name="void add(org.jfree.chart.block.Block, java.lang.Object)" map="A"/>
  <class name="org.jfree.chart.block.BorderArrangement" map="G"/>
  <field class="org.jfree.chart.block.BorderArrangement" name="leftBlock" map="A"/>
  <field class="org.jfree.chart.block.BorderArrangement" name="rightBlock" map="B"/>
  <field class="org.jfree.chart.block.BorderArrangement" name="centerBlock" map="C"/>
  <field class="org.jfree.chart.block.BorderArrangement" name="bottomBlock" map="D"/>
  <field class="org.jfree.chart.block.BorderArrangement" name="topBlock" map="E"/>
  <method class="org.jfree.chart.block.BorderArrangement" name="org.jfree.ui.Size2D arrangeRR(org.jfree.chart.block.BlockContainer, org.jfree.data.Range, org.jfree.data.Range, java.awt.Graphics2D)" map="A"/>
  <method class="org.jfree.chart.block.BorderArrangement" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.block.BorderArrangement" name="void clear()" map="A"/>
  <method class="org.jfree.chart.block.BorderArrangement" name="void add(org.jfree.chart.block.Block, java.lang.Object)" map="A"/>
  <method class="org.jfree.chart.block.BorderArrangement" name="org.jfree.ui.Size2D arrangeFN(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, double)" map="A"/>
  <method class="org.jfree.chart.block.BorderArrangement" name="org.jfree.ui.Size2D arrangeFF(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="I"/>
  <method class="org.jfree.chart.block.BorderArrangement" name="org.jfree.ui.Size2D arrangeNN(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D)" map="B"/>
  <method class="org.jfree.chart.block.BorderArrangement" name="org.jfree.ui.Size2D arrange(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="A"/>
  <method class="org.jfree.chart.block.BorderArrangement" name="org.jfree.ui.Size2D arrangeFR(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="J"/>
  <class name="org.jfree.chart.block.BlockBorder" map="H"/>
  <field class="org.jfree.chart.block.BlockBorder" name="insets" map="D"/>
  <field class="org.jfree.chart.block.BlockBorder" name="paint" map="E"/>
  <field class="org.jfree.chart.block.BlockBorder" name="NONE" map="F"/>
  <method class="org.jfree.chart.block.BlockBorder" name="void draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.block.BlockBorder" name="org.jfree.ui.RectangleInsets getInsets()" map="A"/>
  <method class="org.jfree.chart.block.BlockBorder" name="boolean equals(java.lang.Object)" map="equals"/>
  <class name="org.jfree.chart.block.ColumnArrangement" map="I"/>
  <field class="org.jfree.chart.block.ColumnArrangement" name="horizontalAlignment" map="F"/>
  <field class="org.jfree.chart.block.ColumnArrangement" name="verticalGap" map="G"/>
  <field class="org.jfree.chart.block.ColumnArrangement" name="verticalAlignment" map="H"/>
  <field class="org.jfree.chart.block.ColumnArrangement" name="horizontalGap" map="I"/>
  <method class="org.jfree.chart.block.ColumnArrangement" name="org.jfree.ui.Size2D arrangeNF(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="K"/>
  <method class="org.jfree.chart.block.ColumnArrangement" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.block.ColumnArrangement" name="void clear()" map="A"/>
  <method class="org.jfree.chart.block.ColumnArrangement" name="void add(org.jfree.chart.block.Block, java.lang.Object)" map="A"/>
  <method class="org.jfree.chart.block.ColumnArrangement" name="org.jfree.ui.Size2D arrangeFF(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="L"/>
  <method class="org.jfree.chart.block.ColumnArrangement" name="org.jfree.ui.Size2D arrangeNN(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D)" map="C"/>
  <method class="org.jfree.chart.block.ColumnArrangement" name="org.jfree.ui.Size2D arrange(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="A"/>
  <method class="org.jfree.chart.block.ColumnArrangement" name="org.jfree.ui.Size2D arrangeRF(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="M"/>
  <method class="org.jfree.chart.block.ColumnArrangement" name="org.jfree.ui.Size2D arrangeRR(org.jfree.chart.block.BlockContainer, java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="N"/>
  <class name="org.jfree.chart.block.BlockFrame" map="J"/>
  <method class="org.jfree.chart.block.BlockFrame" name="void draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.block.BlockFrame" name="org.jfree.ui.RectangleInsets getInsets()" map="A"/>
  <class name="org.jfree.chart.block.RectangleConstraint" map="K"/>
  <field class="org.jfree.chart.block.RectangleConstraint" name="heightRange" map="A"/>
  <field class="org.jfree.chart.block.RectangleConstraint" name="height" map="B"/>
  <field class="org.jfree.chart.block.RectangleConstraint" name="widthConstraintType" map="C"/>
  <field class="org.jfree.chart.block.RectangleConstraint" name="widthRange" map="D"/>
  <field class="org.jfree.chart.block.RectangleConstraint" name="heightConstraintType" map="E"/>
  <field class="org.jfree.chart.block.RectangleConstraint" name="width" map="F"/>
  <field class="org.jfree.chart.block.RectangleConstraint" name="NONE" map="G"/>
  <method class="org.jfree.chart.block.RectangleConstraint" name="double getWidth()" map="A"/>
  <method class="org.jfree.chart.block.RectangleConstraint" name="double getHeight()" map="B"/>
  <method class="org.jfree.chart.block.RectangleConstraint" name="org.jfree.data.Range getWidthRange()" map="C"/>
  <method class="org.jfree.chart.block.RectangleConstraint" name="org.jfree.chart.block.RectangleConstraint toFixedWidth(double)" map="A"/>
  <method class="org.jfree.chart.block.RectangleConstraint" name="org.jfree.chart.block.LengthConstraintType getWidthConstraintType()" map="D"/>
  <method class="org.jfree.chart.block.RectangleConstraint" name="org.jfree.ui.Size2D calculateConstrainedSize(org.jfree.ui.Size2D)" map="A"/>
  <method class="org.jfree.chart.block.RectangleConstraint" name="org.jfree.data.Range getHeightRange()" map="E"/>
  <method class="org.jfree.chart.block.RectangleConstraint" name="java.lang.String toString()" map="toString"/>
  <method class="org.jfree.chart.block.RectangleConstraint" name="org.jfree.chart.block.LengthConstraintType getHeightConstraintType()" map="F"/>
  <method class="org.jfree.chart.block.RectangleConstraint" name="org.jfree.chart.block.RectangleConstraint toFixedHeight(double)" map="B"/>
  <class name="org.jfree.chart.block.BlockResult" map="L"/>
  <field class="org.jfree.chart.block.BlockResult" name="entities" map="A"/>
  <method class="org.jfree.chart.block.BlockResult" name="org.jfree.chart.entity.EntityCollection getEntityCollection()" map="A"/>
  <method class="org.jfree.chart.block.BlockResult" name="void setEntityCollection(org.jfree.chart.entity.EntityCollection)" map="A"/>
  <class name="org.jfree.chart.block.EmptyBlock" map="M"/>
  <method class="org.jfree.chart.block.EmptyBlock" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.block.EmptyBlock" name="java.lang.Object draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.lang.Object)" map="A"/>
  <method class="org.jfree.chart.block.EmptyBlock" name="org.jfree.ui.Size2D arrange(java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="A"/>
  <class name="org.jfree.chart.block.Block" map="N"/>
  <method class="org.jfree.chart.block.Block" name="void setBounds(java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.block.Block" name="java.awt.geom.Rectangle2D getBounds()" map="R"/>
  <method class="org.jfree.chart.block.Block" name="java.lang.Object draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.lang.Object)" map="A"/>
  <method class="org.jfree.chart.block.Block" name="org.jfree.ui.Size2D arrange(java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="A"/>
  <class name="org.jfree.chart.block.LineBorder" map="O"/>
  <field class="org.jfree.chart.block.LineBorder" name="insets" map="A"/>
  <field class="org.jfree.chart.block.LineBorder" name="stroke" map="B"/>
  <field class="org.jfree.chart.block.LineBorder" name="paint" map="C"/>
  <method class="org.jfree.chart.block.LineBorder" name="void draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.block.LineBorder" name="org.jfree.ui.RectangleInsets getInsets()" map="A"/>
  <method class="org.jfree.chart.block.LineBorder" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.block.LineBorder" name="java.awt.Stroke getStroke()" map="B"/>
  <method class="org.jfree.chart.block.LineBorder" name="java.awt.Paint getPaint()" map="C"/>
  <class name="org.jfree.chart.block.EntityBlockResult" map="P"/>
  <method class="org.jfree.chart.block.EntityBlockResult" name="org.jfree.chart.entity.EntityCollection getEntityCollection()" map="A"/>
  <class name="org.jfree.chart.block.ColorBlock" map="Q"/>
  <method class="org.jfree.chart.block.ColorBlock" name="java.lang.Object draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.lang.Object)" map="A"/>
  <method class="org.jfree.chart.block.ColorBlock" name="org.jfree.ui.Size2D arrange(java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="A"/>
  <class name="org.jfree.chart.block.BlockContainer" map="R"/>
  <field class="org.jfree.chart.block.BlockContainer" name="arrangement" map="&#x0252;"/>
  <field class="org.jfree.chart.block.BlockContainer" name="blocks" map="&#x0253;"/>
  <method class="org.jfree.chart.block.BlockContainer" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.block.BlockContainer" name="void setArrangement(org.jfree.chart.block.Arrangement)" map="A"/>
  <method class="org.jfree.chart.block.BlockContainer" name="void clear()" map="&#x014d;"/>
  <method class="org.jfree.chart.block.BlockContainer" name="void add(org.jfree.chart.block.Block, java.lang.Object)" map="A"/>
  <method class="org.jfree.chart.block.BlockContainer" name="void add(org.jfree.chart.block.Block)" map="A"/>
  <method class="org.jfree.chart.block.BlockContainer" name="java.util.List getBlocks()" map="&#x014e;"/>
  <method class="org.jfree.chart.block.BlockContainer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.block.BlockContainer" name="java.lang.Object draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.lang.Object)" map="A"/>
  <method class="org.jfree.chart.block.BlockContainer" name="boolean isEmpty()" map="&#x014f;"/>
  <method class="org.jfree.chart.block.BlockContainer" name="org.jfree.ui.Size2D arrange(java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="A"/>
  <class name="org.jfree.chart.block.BlockParams" map="S"/>
  <field class="org.jfree.chart.block.BlockParams" name="generateEntities" map="A"/>
  <field class="org.jfree.chart.block.BlockParams" name="translateY" map="B"/>
  <field class="org.jfree.chart.block.BlockParams" name="translateX" map="C"/>
  <method class="org.jfree.chart.block.BlockParams" name="boolean getGenerateEntities()" map="A"/>
  <method class="org.jfree.chart.block.BlockParams" name="void setGenerateEntities(boolean)" map="A"/>
  <class name="org.jfree.chart.block.LengthConstraintType" map="T"/>
  <field class="org.jfree.chart.block.LengthConstraintType" name="RANGE" map="A"/>
  <field class="org.jfree.chart.block.LengthConstraintType" name="name" map="B"/>
  <field class="org.jfree.chart.block.LengthConstraintType" name="FIXED" map="C"/>
  <field class="org.jfree.chart.block.LengthConstraintType" name="NONE" map="D"/>
  <method class="org.jfree.chart.block.LengthConstraintType" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.block.LengthConstraintType" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.block.LengthConstraintType" name="java.lang.String toString()" map="toString"/>
  <package name="org.jfree.chart.encoders" map="F"/>
  <class name="org.jfree.chart.encoders.ImageEncoderFactory" map="A"/>
  <field class="org.jfree.chart.encoders.ImageEncoderFactory" name="encoders" map="A"/>
  <method class="org.jfree.chart.encoders.ImageEncoderFactory" name="org.jfree.chart.encoders.ImageEncoder newInstance(java.lang.String)" map="A"/>
  <method class="org.jfree.chart.encoders.ImageEncoderFactory" name="void init()" map="A"/>
  <class name="org.jfree.chart.encoders.EncoderUtil" map="B"/>
  <method class="org.jfree.chart.encoders.EncoderUtil" name="void writeBufferedImage(java.awt.image.BufferedImage, java.lang.String, java.io.OutputStream)" map="A"/>
  <class name="org.jfree.chart.encoders.ImageEncoder" map="C"/>
  <method class="org.jfree.chart.encoders.ImageEncoder" name="void encode(java.awt.image.BufferedImage, java.io.OutputStream)" map="A"/>
  <package name="org.jfree.chart.entity" map="G"/>
  <class name="org.jfree.chart.entity.PlotEntity" map="A"/>
  <field class="org.jfree.chart.entity.PlotEntity" name="plot" map="&#x03ae;"/>
  <method class="org.jfree.chart.entity.PlotEntity" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.entity.PlotEntity" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.entity.PlotEntity" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.entity.PlotEntity" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.entity.TitleEntity" map="B"/>
  <field class="org.jfree.chart.entity.TitleEntity" name="title" map="&#x03af;"/>
  <method class="org.jfree.chart.entity.TitleEntity" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.entity.TitleEntity" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.entity.TitleEntity" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.entity.TitleEntity" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.entity.LegendItemEntity" map="C"/>
  <field class="org.jfree.chart.entity.LegendItemEntity" name="seriesKey" map="&#x03b0;"/>
  <field class="org.jfree.chart.entity.LegendItemEntity" name="seriesIndex" map="&#x03b1;"/>
  <field class="org.jfree.chart.entity.LegendItemEntity" name="dataset" map="&#x03b2;"/>
  <method class="org.jfree.chart.entity.LegendItemEntity" name="void setSeriesKey(java.lang.Comparable)" map="P"/>
  <method class="org.jfree.chart.entity.LegendItemEntity" name="void setDataset(org.jfree.data.general.Dataset)" map="A"/>
  <method class="org.jfree.chart.entity.LegendItemEntity" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.entity.LegendItemEntity" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.entity.LegendItemEntity" name="void setSeriesIndex(int)" map="&#x00c8;"/>
  <method class="org.jfree.chart.entity.LegendItemEntity" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.entity.ChartEntity" map="D"/>
  <field class="org.jfree.chart.entity.ChartEntity" name="urlText" map="&#x03ab;"/>
  <field class="org.jfree.chart.entity.ChartEntity" name="area" map="&#x03ac;"/>
  <field class="org.jfree.chart.entity.ChartEntity" name="toolTipText" map="&#x03ad;"/>
  <method class="org.jfree.chart.entity.ChartEntity" name="java.awt.Shape getArea()" map="&#x0199;"/>
  <method class="org.jfree.chart.entity.ChartEntity" name="void setToolTipText(java.lang.String)" map="E"/>
  <method class="org.jfree.chart.entity.ChartEntity" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.entity.ChartEntity" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.entity.ChartEntity" name="java.lang.String getToolTipText()" map="&#x019a;"/>
  <method class="org.jfree.chart.entity.ChartEntity" name="java.lang.String getURLText()" map="&#x019b;"/>
  <method class="org.jfree.chart.entity.ChartEntity" name="void setURLText(java.lang.String)" map="F"/>
  <method class="org.jfree.chart.entity.ChartEntity" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.entity.ChartEntity" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.entity.XYItemEntity" map="E"/>
  <field class="org.jfree.chart.entity.XYItemEntity" name="series" map="&#x03b3;"/>
  <field class="org.jfree.chart.entity.XYItemEntity" name="item" map="&#x03b4;"/>
  <field class="org.jfree.chart.entity.XYItemEntity" name="dataset" map="&#x03b5;"/>
  <method class="org.jfree.chart.entity.XYItemEntity" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.entity.XYItemEntity" name="int getItem()" map="&#x019c;"/>
  <method class="org.jfree.chart.entity.XYItemEntity" name="org.jfree.data.xy.XYDataset getDataset()" map="&#x019d;"/>
  <method class="org.jfree.chart.entity.XYItemEntity" name="java.lang.String toString()" map="toString"/>
  <method class="org.jfree.chart.entity.XYItemEntity" name="int getSeriesIndex()" map="&#x019e;"/>
  <class name="org.jfree.chart.entity.CategoryItemEntity" map="F"/>
  <field class="org.jfree.chart.entity.CategoryItemEntity" name="series" map="&#x03b6;"/>
  <field class="org.jfree.chart.entity.CategoryItemEntity" name="category" map="&#x03b7;"/>
  <field class="org.jfree.chart.entity.CategoryItemEntity" name="categoryIndex" map="&#x03b8;"/>
  <field class="org.jfree.chart.entity.CategoryItemEntity" name="dataset" map="&#x03b9;"/>
  <field class="org.jfree.chart.entity.CategoryItemEntity" name="columnKey" map="&#x03ba;"/>
  <field class="org.jfree.chart.entity.CategoryItemEntity" name="rowKey" map="&#x03bb;"/>
  <method class="org.jfree.chart.entity.CategoryItemEntity" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.entity.CategoryItemEntity" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.entity.PieSectionEntity" map="G"/>
  <field class="org.jfree.chart.entity.PieSectionEntity" name="sectionIndex" map="&#x03bc;"/>
  <field class="org.jfree.chart.entity.PieSectionEntity" name="dataset" map="&#x03bd;"/>
  <field class="org.jfree.chart.entity.PieSectionEntity" name="sectionKey" map="&#x03be;"/>
  <field class="org.jfree.chart.entity.PieSectionEntity" name="pieIndex" map="&#x03bf;"/>
  <method class="org.jfree.chart.entity.PieSectionEntity" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.entity.PieSectionEntity" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.entity.PieSectionEntity" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.entity.TickLabelEntity" map="H"/>
  <class name="org.jfree.chart.entity.EntityCollection" map="I"/>
  <method class="org.jfree.chart.entity.EntityCollection" name="void addAll(org.jfree.chart.entity.EntityCollection)" map="A"/>
  <method class="org.jfree.chart.entity.EntityCollection" name="void clear()" map="&#x019f;"/>
  <method class="org.jfree.chart.entity.EntityCollection" name="void add(org.jfree.chart.entity.ChartEntity)" map="A"/>
  <method class="org.jfree.chart.entity.EntityCollection" name="org.jfree.chart.entity.ChartEntity getEntity(double, double)" map="E"/>
  <method class="org.jfree.chart.entity.EntityCollection" name="java.util.Collection getEntities()" map="&#x01a0;"/>
  <class name="org.jfree.chart.entity.JFreeChartEntity" map="J"/>
  <field class="org.jfree.chart.entity.JFreeChartEntity" name="chart" map="&#x03c1;"/>
  <method class="org.jfree.chart.entity.JFreeChartEntity" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.entity.JFreeChartEntity" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.entity.JFreeChartEntity" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.entity.JFreeChartEntity" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.entity.AxisEntity" map="K"/>
  <field class="org.jfree.chart.entity.AxisEntity" name="axis" map="&#x03c2;"/>
  <method class="org.jfree.chart.entity.AxisEntity" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.entity.AxisEntity" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.entity.AxisEntity" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.entity.AxisEntity" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.entity.StandardEntityCollection" map="L"/>
  <field class="org.jfree.chart.entity.StandardEntityCollection" name="entities" map="&#x03c3;"/>
  <method class="org.jfree.chart.entity.StandardEntityCollection" name="void addAll(org.jfree.chart.entity.EntityCollection)" map="A"/>
  <method class="org.jfree.chart.entity.StandardEntityCollection" name="void clear()" map="&#x019f;"/>
  <method class="org.jfree.chart.entity.StandardEntityCollection" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.entity.StandardEntityCollection" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.entity.StandardEntityCollection" name="void add(org.jfree.chart.entity.ChartEntity)" map="A"/>
  <method class="org.jfree.chart.entity.StandardEntityCollection" name="org.jfree.chart.entity.ChartEntity getEntity(double, double)" map="E"/>
  <method class="org.jfree.chart.entity.StandardEntityCollection" name="java.util.Collection getEntities()" map="&#x01a0;"/>
  <class name="org.jfree.chart.entity.CategoryLabelEntity" map="M"/>
  <field class="org.jfree.chart.entity.CategoryLabelEntity" name="key" map="&#x03c0;"/>
  <method class="org.jfree.chart.entity.CategoryLabelEntity" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.entity.CategoryLabelEntity" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.entity.CategoryLabelEntity" name="java.lang.String toString()" map="toString"/>
  <package name="org.jfree.chart.util" map="H"/>
  <class name="org.jfree.chart.util.ParamChecks" map="A"/>
  <method class="org.jfree.chart.util.ParamChecks" name="void nullNotPermitted(java.lang.Object, java.lang.String)" map="A"/>
  <class name="org.jfree.chart.util.LineUtilities" map="B"/>
  <method class="org.jfree.chart.util.LineUtilities" name="boolean clipLine(java.awt.geom.Line2D, java.awt.geom.Rectangle2D)" map="A"/>
  <class name="org.jfree.chart.util.ShadowGenerator" map="C"/>
  <method class="org.jfree.chart.util.ShadowGenerator" name="int calculateOffsetY()" map="A"/>
  <method class="org.jfree.chart.util.ShadowGenerator" name="java.awt.image.BufferedImage createDropShadow(java.awt.image.BufferedImage)" map="A"/>
  <method class="org.jfree.chart.util.ShadowGenerator" name="int calculateOffsetX()" map="B"/>
  <class name="org.jfree.chart.util.ResourceBundleWrapper" map="D"/>
  <field class="org.jfree.chart.util.ResourceBundleWrapper" name="noCodeBaseClassLoader" map="A"/>
  <method class="org.jfree.chart.util.ResourceBundleWrapper" name="java.util.ResourceBundle getBundle(java.lang.String)" map="A"/>
  <class name="org.jfree.chart.util.DefaultShadowGenerator" map="E"/>
  <field class="org.jfree.chart.util.DefaultShadowGenerator" name="shadowOpacity" map="A"/>
  <field class="org.jfree.chart.util.DefaultShadowGenerator" name="shadowSize" map="B"/>
  <field class="org.jfree.chart.util.DefaultShadowGenerator" name="shadowColor" map="C"/>
  <field class="org.jfree.chart.util.DefaultShadowGenerator" name="angle" map="D"/>
  <field class="org.jfree.chart.util.DefaultShadowGenerator" name="distance" map="E"/>
  <method class="org.jfree.chart.util.DefaultShadowGenerator" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.util.DefaultShadowGenerator" name="int calculateOffsetY()" map="A"/>
  <method class="org.jfree.chart.util.DefaultShadowGenerator" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.util.DefaultShadowGenerator" name="java.awt.image.BufferedImage createDropShadow(java.awt.image.BufferedImage)" map="A"/>
  <method class="org.jfree.chart.util.DefaultShadowGenerator" name="int calculateOffsetX()" map="B"/>
  <method class="org.jfree.chart.util.DefaultShadowGenerator" name="void applyShadow(java.awt.image.BufferedImage)" map="B"/>
  <package name="org.jfree.chart.labels" map="I"/>
  <class name="org.jfree.chart.labels.ItemLabelAnchor" map="A"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="OUTSIDE9" map="A"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="OUTSIDE8" map="B"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="OUTSIDE7" map="C"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="OUTSIDE6" map="D"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="OUTSIDE5" map="E"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="OUTSIDE4" map="F"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="OUTSIDE3" map="G"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="OUTSIDE2" map="H"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="OUTSIDE1" map="I"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="INSIDE12" map="J"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="INSIDE11" map="K"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="INSIDE10" map="L"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="OUTSIDE12" map="M"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="OUTSIDE11" map="N"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="OUTSIDE10" map="O"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="INSIDE9" map="P"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="INSIDE8" map="Q"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="INSIDE7" map="R"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="INSIDE6" map="S"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="INSIDE5" map="T"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="INSIDE4" map="U"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="INSIDE3" map="V"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="INSIDE2" map="W"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="INSIDE1" map="X"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="CENTER" map="Y"/>
  <field class="org.jfree.chart.labels.ItemLabelAnchor" name="name" map="Z"/>
  <method class="org.jfree.chart.labels.ItemLabelAnchor" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.labels.ItemLabelAnchor" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.labels.PieSectionLabelGenerator" map="B"/>
  <method class="org.jfree.chart.labels.PieSectionLabelGenerator" name="java.lang.String generateSectionLabel(org.jfree.data.general.PieDataset, java.lang.Comparable)" map="A"/>
  <class name="org.jfree.chart.labels.StandardCategoryItemLabelGenerator" map="C"/>
  <method class="org.jfree.chart.labels.StandardCategoryItemLabelGenerator" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.labels.StandardCategoryItemLabelGenerator" name="java.lang.String generateLabel(org.jfree.data.category.CategoryDataset, int, int)" map="D"/>
  <class name="org.jfree.chart.labels.StandardXYSeriesLabelGenerator" map="D"/>
  <field class="org.jfree.chart.labels.StandardXYSeriesLabelGenerator" name="formatPattern" map="&#x03c9;"/>
  <method class="org.jfree.chart.labels.StandardXYSeriesLabelGenerator" name="java.lang.String generateLabel(org.jfree.data.xy.XYDataset, int)" map="A"/>
  <method class="org.jfree.chart.labels.StandardXYSeriesLabelGenerator" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.labels.StandardXYSeriesLabelGenerator" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.labels.StandardXYSeriesLabelGenerator" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.labels.StandardXYSeriesLabelGenerator" name="java.lang.Object[] createItemArray(org.jfree.data.xy.XYDataset, int)" map="B"/>
  <class name="org.jfree.chart.labels.StandardPieSectionLabelGenerator" map="E"/>
  <field class="org.jfree.chart.labels.StandardPieSectionLabelGenerator" name="attributedLabels" map="&#x03cd;"/>
  <method class="org.jfree.chart.labels.StandardPieSectionLabelGenerator" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.labels.StandardPieSectionLabelGenerator" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.labels.StandardPieSectionLabelGenerator" name="java.lang.String generateSectionLabel(org.jfree.data.general.PieDataset, java.lang.Comparable)" map="A"/>
  <class name="org.jfree.chart.labels.ItemLabelPosition" map="F"/>
  <field class="org.jfree.chart.labels.ItemLabelPosition" name="textAnchor" map="A"/>
  <field class="org.jfree.chart.labels.ItemLabelPosition" name="rotationAnchor" map="B"/>
  <field class="org.jfree.chart.labels.ItemLabelPosition" name="itemLabelAnchor" map="C"/>
  <field class="org.jfree.chart.labels.ItemLabelPosition" name="angle" map="D"/>
  <method class="org.jfree.chart.labels.ItemLabelPosition" name="org.jfree.ui.TextAnchor getTextAnchor()" map="A"/>
  <method class="org.jfree.chart.labels.ItemLabelPosition" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.labels.ItemLabelPosition" name="double getAngle()" map="B"/>
  <method class="org.jfree.chart.labels.ItemLabelPosition" name="org.jfree.chart.labels.ItemLabelAnchor getItemLabelAnchor()" map="C"/>
  <method class="org.jfree.chart.labels.ItemLabelPosition" name="org.jfree.ui.TextAnchor getRotationAnchor()" map="D"/>
  <class name="org.jfree.chart.labels.PieToolTipGenerator" map="G"/>
  <method class="org.jfree.chart.labels.PieToolTipGenerator" name="java.lang.String generateToolTip(org.jfree.data.general.PieDataset, java.lang.Comparable)" map="C"/>
  <class name="org.jfree.chart.labels.AbstractCategoryItemLabelGenerator" map="H"/>
  <field class="org.jfree.chart.labels.AbstractCategoryItemLabelGenerator" name="dateFormat" map="&#x03c4;"/>
  <field class="org.jfree.chart.labels.AbstractCategoryItemLabelGenerator" name="numberFormat" map="&#x03c5;"/>
  <field class="org.jfree.chart.labels.AbstractCategoryItemLabelGenerator" name="nullValueString" map="&#x03c6;"/>
  <field class="org.jfree.chart.labels.AbstractCategoryItemLabelGenerator" name="percentFormat" map="&#x03c7;"/>
  <field class="org.jfree.chart.labels.AbstractCategoryItemLabelGenerator" name="labelFormat" map="&#x03c8;"/>
  <method class="org.jfree.chart.labels.AbstractCategoryItemLabelGenerator" name="java.lang.Object[] createItemArray(org.jfree.data.category.CategoryDataset, int, int)" map="A"/>
  <method class="org.jfree.chart.labels.AbstractCategoryItemLabelGenerator" name="java.lang.String generateLabelString(org.jfree.data.category.CategoryDataset, int, int)" map="B"/>
  <method class="org.jfree.chart.labels.AbstractCategoryItemLabelGenerator" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.labels.AbstractCategoryItemLabelGenerator" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.labels.AbstractCategoryItemLabelGenerator" name="int hashCode()" map="hashCode"/>
  <class name="org.jfree.chart.labels.CategoryToolTipGenerator" map="I"/>
  <method class="org.jfree.chart.labels.CategoryToolTipGenerator" name="java.lang.String generateToolTip(org.jfree.data.category.CategoryDataset, int, int)" map="C"/>
  <class name="org.jfree.chart.labels.BoxAndWhiskerXYToolTipGenerator" map="J"/>
  <class name="org.jfree.chart.labels.StandardCategoryToolTipGenerator" map="K"/>
  <method class="org.jfree.chart.labels.StandardCategoryToolTipGenerator" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.labels.StandardCategoryToolTipGenerator" name="java.lang.String generateToolTip(org.jfree.data.category.CategoryDataset, int, int)" map="C"/>
  <class name="org.jfree.chart.labels.XYZToolTipGenerator" map="L"/>
  <class name="org.jfree.chart.labels.BoxAndWhiskerToolTipGenerator" map="M"/>
  <class name="org.jfree.chart.labels.StandardCategorySeriesLabelGenerator" map="N"/>
  <field class="org.jfree.chart.labels.StandardCategorySeriesLabelGenerator" name="formatPattern" map="&#x03ce;"/>
  <method class="org.jfree.chart.labels.StandardCategorySeriesLabelGenerator" name="java.lang.Object[] createItemArray(org.jfree.data.category.CategoryDataset, int)" map="B"/>
  <method class="org.jfree.chart.labels.StandardCategorySeriesLabelGenerator" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.labels.StandardCategorySeriesLabelGenerator" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.labels.StandardCategorySeriesLabelGenerator" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.labels.StandardCategorySeriesLabelGenerator" name="java.lang.String generateLabel(org.jfree.data.category.CategoryDataset, int)" map="A"/>
  <class name="org.jfree.chart.labels.XYSeriesLabelGenerator" map="O"/>
  <method class="org.jfree.chart.labels.XYSeriesLabelGenerator" name="java.lang.String generateLabel(org.jfree.data.xy.XYDataset, int)" map="A"/>
  <class name="org.jfree.chart.labels.XYItemLabelGenerator" map="P"/>
  <method class="org.jfree.chart.labels.XYItemLabelGenerator" name="java.lang.String generateLabel(org.jfree.data.xy.XYDataset, int, int)" map="C"/>
  <class name="org.jfree.chart.labels.XYToolTipGenerator" map="Q"/>
  <method class="org.jfree.chart.labels.XYToolTipGenerator" name="java.lang.String generateToolTip(org.jfree.data.xy.XYDataset, int, int)" map="D"/>
  <class name="org.jfree.chart.labels.CategorySeriesLabelGenerator" map="R"/>
  <method class="org.jfree.chart.labels.CategorySeriesLabelGenerator" name="java.lang.String generateLabel(org.jfree.data.category.CategoryDataset, int)" map="A"/>
  <class name="org.jfree.chart.labels.StandardPieToolTipGenerator" map="S"/>
  <method class="org.jfree.chart.labels.StandardPieToolTipGenerator" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.labels.StandardPieToolTipGenerator" name="java.lang.String generateToolTip(org.jfree.data.general.PieDataset, java.lang.Comparable)" map="C"/>
  <class name="org.jfree.chart.labels.IntervalCategoryItemLabelGenerator" map="T"/>
  <class name="org.jfree.chart.labels.StandardXYToolTipGenerator" map="U"/>
  <method class="org.jfree.chart.labels.StandardXYToolTipGenerator" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.labels.StandardXYToolTipGenerator" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.labels.StandardXYToolTipGenerator" name="java.lang.String generateToolTip(org.jfree.data.xy.XYDataset, int, int)" map="D"/>
  <class name="org.jfree.chart.labels.CategoryItemLabelGenerator" map="V"/>
  <method class="org.jfree.chart.labels.CategoryItemLabelGenerator" name="java.lang.String generateLabel(org.jfree.data.category.CategoryDataset, int, int)" map="D"/>
  <class name="org.jfree.chart.labels.AbstractPieItemLabelGenerator" map="W"/>
  <field class="org.jfree.chart.labels.AbstractPieItemLabelGenerator" name="numberFormat" map="&#x03ca;"/>
  <field class="org.jfree.chart.labels.AbstractPieItemLabelGenerator" name="percentFormat" map="&#x03cb;"/>
  <field class="org.jfree.chart.labels.AbstractPieItemLabelGenerator" name="labelFormat" map="&#x03cc;"/>
  <method class="org.jfree.chart.labels.AbstractPieItemLabelGenerator" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.labels.AbstractPieItemLabelGenerator" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.labels.AbstractPieItemLabelGenerator" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.labels.AbstractPieItemLabelGenerator" name="java.lang.String generateSectionLabel(org.jfree.data.general.PieDataset, java.lang.Comparable)" map="A"/>
  <method class="org.jfree.chart.labels.AbstractPieItemLabelGenerator" name="java.lang.Object[] createItemArray(org.jfree.data.general.PieDataset, java.lang.Comparable)" map="B"/>
  <class name="org.jfree.chart.labels.AbstractXYItemLabelGenerator" map="X"/>
  <field class="org.jfree.chart.labels.AbstractXYItemLabelGenerator" name="formatString" map="&#x03d0;"/>
  <field class="org.jfree.chart.labels.AbstractXYItemLabelGenerator" name="yDateFormat" map="&#x03d1;"/>
  <field class="org.jfree.chart.labels.AbstractXYItemLabelGenerator" name="xFormat" map="&#x03d2;"/>
  <field class="org.jfree.chart.labels.AbstractXYItemLabelGenerator" name="nullYString" map="&#x03d3;"/>
  <field class="org.jfree.chart.labels.AbstractXYItemLabelGenerator" name="yFormat" map="&#x03d4;"/>
  <field class="org.jfree.chart.labels.AbstractXYItemLabelGenerator" name="xDateFormat" map="&#x03d5;"/>
  <method class="org.jfree.chart.labels.AbstractXYItemLabelGenerator" name="java.lang.String generateLabelString(org.jfree.data.xy.XYDataset, int, int)" map="A"/>
  <method class="org.jfree.chart.labels.AbstractXYItemLabelGenerator" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.labels.AbstractXYItemLabelGenerator" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.labels.AbstractXYItemLabelGenerator" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.labels.AbstractXYItemLabelGenerator" name="java.lang.Object[] createItemArray(org.jfree.data.xy.XYDataset, int, int)" map="B"/>
  <class name="org.jfree.chart.labels.BubbleXYItemLabelGenerator" map="Y"/>
  <method class="org.jfree.chart.labels.BubbleXYItemLabelGenerator" name="java.lang.String generateLabel(org.jfree.data.xy.XYDataset, int, int)" map="C"/>
  <class name="org.jfree.chart.labels.StandardXYZToolTipGenerator" map="Z"/>
  <package name="org.jfree.chart.annotations" map="J"/>
  <class name="org.jfree.chart.annotations.AbstractXYAnnotation" map="A"/>
  <method class="org.jfree.chart.annotations.AbstractXYAnnotation" name="void draw(java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, java.awt.geom.Rectangle2D, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, int, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <class name="org.jfree.chart.annotations.XYAnnotation" map="B"/>
  <method class="org.jfree.chart.annotations.XYAnnotation" name="void draw(java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, java.awt.geom.Rectangle2D, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, int, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <class name="org.jfree.chart.annotations.Annotation" map="C"/>
  <class name="org.jfree.chart.annotations.AbstractAnnotation" map="D"/>
  <class name="org.jfree.chart.annotations.XYAnnotationBoundsInfo" map="E"/>
  <method class="org.jfree.chart.annotations.XYAnnotationBoundsInfo" name="boolean getIncludeInDataBounds()" map="A"/>
  <method class="org.jfree.chart.annotations.XYAnnotationBoundsInfo" name="org.jfree.data.Range getXRange()" map="B"/>
  <method class="org.jfree.chart.annotations.XYAnnotationBoundsInfo" name="org.jfree.data.Range getYRange()" map="C"/>
  <class name="org.jfree.chart.annotations.XYTextAnnotation" map="F"/>
  <field class="org.jfree.chart.annotations.XYTextAnnotation" name="DEFAULT_FONT" map="&#x03d6;"/>
  <field class="org.jfree.chart.annotations.XYTextAnnotation" name="DEFAULT_ROTATION_ANCHOR" map="&#x03da;"/>
  <field class="org.jfree.chart.annotations.XYTextAnnotation" name="DEFAULT_PAINT" map="&#x03dc;"/>
  <field class="org.jfree.chart.annotations.XYTextAnnotation" name="DEFAULT_TEXT_ANCHOR" map="&#x03de;"/>
  <method class="org.jfree.chart.annotations.XYTextAnnotation" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.annotations.XYTextAnnotation" name="void setPaint(java.awt.Paint)" map="r"/>
  <method class="org.jfree.chart.annotations.XYTextAnnotation" name="void setFont(java.awt.Font)" map="N"/>
  <class name="org.jfree.chart.annotations.CategoryAnnotation" map="G"/>
  <method class="org.jfree.chart.annotations.CategoryAnnotation" name="void draw(java.awt.Graphics2D, org.jfree.chart.plot.CategoryPlot, java.awt.geom.Rectangle2D, org.jfree.chart.axis.CategoryAxis, org.jfree.chart.axis.ValueAxis)" map="A"/>
  <package name="org.jfree.chart.editor" map="K"/>
  <class name="org.jfree.chart.editor.PaletteChooserPanel" map="A"/>
  <field class="org.jfree.chart.editor.PaletteChooserPanel" name="selector" map="A"/>
  <method class="org.jfree.chart.editor.PaletteChooserPanel" name="org.jfree.chart.plot.ColorPalette getSelectedPalette()" map="A"/>
  <class name="org.jfree.chart.editor.DefaultTitleEditor" map="B"/>
  <field class="org.jfree.chart.editor.DefaultTitleEditor" name="titlePaint" map="A"/>
  <field class="org.jfree.chart.editor.DefaultTitleEditor" name="fontfield" map="B"/>
  <field class="org.jfree.chart.editor.DefaultTitleEditor" name="titleFont" map="C"/>
  <field class="org.jfree.chart.editor.DefaultTitleEditor" name="selectFontButton" map="D"/>
  <field class="org.jfree.chart.editor.DefaultTitleEditor" name="showTitle" map="E"/>
  <field class="org.jfree.chart.editor.DefaultTitleEditor" name="titleField" map="F"/>
  <field class="org.jfree.chart.editor.DefaultTitleEditor" name="selectPaintButton" map="G"/>
  <field class="org.jfree.chart.editor.DefaultTitleEditor" name="showTitleCheckBox" map="H"/>
  <field class="org.jfree.chart.editor.DefaultTitleEditor" name="localizationResources" map="I"/>
  <method class="org.jfree.chart.editor.DefaultTitleEditor" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="org.jfree.chart.editor.DefaultTitleEditor" name="void attemptFontSelection()" map="A"/>
  <method class="org.jfree.chart.editor.DefaultTitleEditor" name="void setTitleProperties(org.jfree.chart.JFreeChart)" map="A"/>
  <method class="org.jfree.chart.editor.DefaultTitleEditor" name="java.lang.String getTitleText()" map="B"/>
  <method class="org.jfree.chart.editor.DefaultTitleEditor" name="void attemptPaintSelection()" map="C"/>
  <method class="org.jfree.chart.editor.DefaultTitleEditor" name="void attemptModifyShowTitle()" map="D"/>
  <method class="org.jfree.chart.editor.DefaultTitleEditor" name="java.awt.Font getTitleFont()" map="E"/>
  <method class="org.jfree.chart.editor.DefaultTitleEditor" name="java.awt.Paint getTitlePaint()" map="F"/>
  <method class="org.jfree.chart.editor.DefaultTitleEditor" name="void enableOrDisableControls()" map="G"/>
  <class name="org.jfree.chart.editor.DefaultNumberAxisEditor" map="C"/>
  <field class="org.jfree.chart.editor.DefaultNumberAxisEditor" name="manualTickUnit" map="b"/>
  <field class="org.jfree.chart.editor.DefaultNumberAxisEditor" name="manualTickUnitValue" map="c"/>
  <method class="org.jfree.chart.editor.DefaultNumberAxisEditor" name="void setAxisProperties(org.jfree.chart.axis.Axis)" map="A"/>
  <method class="org.jfree.chart.editor.DefaultNumberAxisEditor" name="javax.swing.JPanel createTickUnitPanel()" map="Q"/>
  <method class="org.jfree.chart.editor.DefaultNumberAxisEditor" name="void validateTickUnit()" map="X"/>
  <method class="org.jfree.chart.editor.DefaultNumberAxisEditor" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="org.jfree.chart.editor.DefaultNumberAxisEditor" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <method class="org.jfree.chart.editor.DefaultNumberAxisEditor" name="void toggleAutoTick()" map="N"/>
  <class name="org.jfree.chart.editor.DefaultValueAxisEditor" map="D"/>
  <field class="org.jfree.chart.editor.DefaultValueAxisEditor" name="availableStrokeSamples" map="P"/>
  <field class="org.jfree.chart.editor.DefaultValueAxisEditor" name="minimumRangeValue" map="Q"/>
  <field class="org.jfree.chart.editor.DefaultValueAxisEditor" name="gridStrokeSample" map="R"/>
  <field class="org.jfree.chart.editor.DefaultValueAxisEditor" name="autoRange" map="S"/>
  <field class="org.jfree.chart.editor.DefaultValueAxisEditor" name="maximumRangeValue" map="T"/>
  <field class="org.jfree.chart.editor.DefaultValueAxisEditor" name="autoTickUnitSelection" map="U"/>
  <field class="org.jfree.chart.editor.DefaultValueAxisEditor" name="gridPaintSample" map="V"/>
  <field class="org.jfree.chart.editor.DefaultValueAxisEditor" name="minimumValue" map="W"/>
  <field class="org.jfree.chart.editor.DefaultValueAxisEditor" name="autoTickUnitSelectionCheckBox" map="X"/>
  <field class="org.jfree.chart.editor.DefaultValueAxisEditor" name="maximumValue" map="Y"/>
  <field class="org.jfree.chart.editor.DefaultValueAxisEditor" name="localizationResources" map="L"/>
  <field class="org.jfree.chart.editor.DefaultValueAxisEditor" name="autoRangeCheckBox" map="Z"/>
  <method class="org.jfree.chart.editor.DefaultValueAxisEditor" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="org.jfree.chart.editor.DefaultValueAxisEditor" name="void toggleAutoTick()" map="N"/>
  <method class="org.jfree.chart.editor.DefaultValueAxisEditor" name="boolean isAutoTickUnitSelection()" map="O"/>
  <method class="org.jfree.chart.editor.DefaultValueAxisEditor" name="void toggleAutoRange()" map="P"/>
  <method class="org.jfree.chart.editor.DefaultValueAxisEditor" name="void setAxisProperties(org.jfree.chart.axis.Axis)" map="A"/>
  <method class="org.jfree.chart.editor.DefaultValueAxisEditor" name="javax.swing.JPanel createTickUnitPanel()" map="Q"/>
  <method class="org.jfree.chart.editor.DefaultValueAxisEditor" name="void setAutoTickUnitSelectionCheckBox(javax.swing.JCheckBox)" map="A"/>
  <method class="org.jfree.chart.editor.DefaultValueAxisEditor" name="void attemptGridPaintSelection()" map="R"/>
  <method class="org.jfree.chart.editor.DefaultValueAxisEditor" name="void attemptGridStrokeSelection()" map="S"/>
  <method class="org.jfree.chart.editor.DefaultValueAxisEditor" name="void validateMaximum()" map="T"/>
  <method class="org.jfree.chart.editor.DefaultValueAxisEditor" name="void validateMinimum()" map="U"/>
  <method class="org.jfree.chart.editor.DefaultValueAxisEditor" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <method class="org.jfree.chart.editor.DefaultValueAxisEditor" name="void focusGained(java.awt.event.FocusEvent)" map="focusGained"/>
  <method class="org.jfree.chart.editor.DefaultValueAxisEditor" name="javax.swing.JCheckBox getAutoTickUnitSelectionCheckBox()" map="V"/>
  <class name="org.jfree.chart.editor.DefaultAxisEditor" map="E"/>
  <field class="org.jfree.chart.editor.DefaultAxisEditor" name="showTickLabelsCheckBox" map="A"/>
  <field class="org.jfree.chart.editor.DefaultAxisEditor" name="tickLabelFontField" map="B"/>
  <field class="org.jfree.chart.editor.DefaultAxisEditor" name="tickLabelFont" map="C"/>
  <field class="org.jfree.chart.editor.DefaultAxisEditor" name="slot2" map="D"/>
  <field class="org.jfree.chart.editor.DefaultAxisEditor" name="slot1" map="E"/>
  <field class="org.jfree.chart.editor.DefaultAxisEditor" name="labelFont" map="F"/>
  <field class="org.jfree.chart.editor.DefaultAxisEditor" name="labelPaintSample" map="G"/>
  <field class="org.jfree.chart.editor.DefaultAxisEditor" name="labelInsets" map="H"/>
  <field class="org.jfree.chart.editor.DefaultAxisEditor" name="label" map="I"/>
  <field class="org.jfree.chart.editor.DefaultAxisEditor" name="showTickMarksCheckBox" map="J"/>
  <field class="org.jfree.chart.editor.DefaultAxisEditor" name="labelFontField" map="K"/>
  <field class="org.jfree.chart.editor.DefaultAxisEditor" name="localizationResources" map="L"/>
  <field class="org.jfree.chart.editor.DefaultAxisEditor" name="otherTabs" map="M"/>
  <field class="org.jfree.chart.editor.DefaultAxisEditor" name="tickLabelInsets" map="N"/>
  <field class="org.jfree.chart.editor.DefaultAxisEditor" name="tickLabelPaintSample" map="O"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="void attemptModifyLabelPaint()" map="A"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="boolean isTickLabelsVisible()" map="B"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="void setAxisProperties(org.jfree.chart.axis.Axis)" map="A"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="void attemptTickLabelFontSelection()" map="C"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="javax.swing.JTabbedPane getOtherTabs()" map="D"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="java.lang.String getLabel()" map="E"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="java.awt.Paint getLabelPaint()" map="F"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="java.awt.Paint getTickLabelPaint()" map="G"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="void attemptLabelFontSelection()" map="H"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="org.jfree.ui.RectangleInsets getLabelInsets()" map="I"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="boolean isTickMarksVisible()" map="J"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="java.awt.Font getTickLabelFont()" map="K"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="java.awt.Font getLabelFont()" map="L"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="org.jfree.chart.editor.DefaultAxisEditor getInstance(org.jfree.chart.axis.Axis)" map="B"/>
  <method class="org.jfree.chart.editor.DefaultAxisEditor" name="org.jfree.ui.RectangleInsets getTickLabelInsets()" map="M"/>
  <class name="org.jfree.chart.editor.DefaultColorBarEditor" map="F"/>
  <field class="org.jfree.chart.editor.DefaultColorBarEditor" name="currentPalette" map="d"/>
  <field class="org.jfree.chart.editor.DefaultColorBarEditor" name="localizationResources" map="L"/>
  <field class="org.jfree.chart.editor.DefaultColorBarEditor" name="stepPalette" map="e"/>
  <field class="org.jfree.chart.editor.DefaultColorBarEditor" name="availablePaletteSamples" map="f"/>
  <field class="org.jfree.chart.editor.DefaultColorBarEditor" name="invertPalette" map="g"/>
  <field class="org.jfree.chart.editor.DefaultColorBarEditor" name="stepPaletteCheckBox" map="h"/>
  <field class="org.jfree.chart.editor.DefaultColorBarEditor" name="invertPaletteCheckBox" map="i"/>
  <method class="org.jfree.chart.editor.DefaultColorBarEditor" name="void attemptPaletteSelection()" map="Y"/>
  <method class="org.jfree.chart.editor.DefaultColorBarEditor" name="void setAxisProperties(org.jfree.chart.axis.ColorBar)" map="A"/>
  <method class="org.jfree.chart.editor.DefaultColorBarEditor" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="org.jfree.chart.editor.DefaultColorBarEditor" name="org.jfree.chart.editor.DefaultColorBarEditor getInstance(org.jfree.chart.axis.ColorBar)" map="B"/>
  <class name="org.jfree.chart.editor.ChartEditor" map="G"/>
  <method class="org.jfree.chart.editor.ChartEditor" name="void updateChart(org.jfree.chart.JFreeChart)" map="A"/>
  <class name="org.jfree.chart.editor.DefaultPolarPlotEditor" map="H"/>
  <field class="org.jfree.chart.editor.DefaultPolarPlotEditor" name="angleOffset" map="Q"/>
  <field class="org.jfree.chart.editor.DefaultPolarPlotEditor" name="angleOffsetValue" map="R"/>
  <field class="org.jfree.chart.editor.DefaultPolarPlotEditor" name="manualTickUnitValue" map="S"/>
  <field class="org.jfree.chart.editor.DefaultPolarPlotEditor" name="manualTickUnit" map="T"/>
  <method class="org.jfree.chart.editor.DefaultPolarPlotEditor" name="void updatePlotProperties(org.jfree.chart.plot.Plot)" map="B"/>
  <method class="org.jfree.chart.editor.DefaultPolarPlotEditor" name="javax.swing.JTabbedPane createPlotTabs(org.jfree.chart.plot.Plot)" map="C"/>
  <method class="org.jfree.chart.editor.DefaultPolarPlotEditor" name="javax.swing.JPanel createPlotPanel()" map="K"/>
  <method class="org.jfree.chart.editor.DefaultPolarPlotEditor" name="void validateTickUnit()" map="L"/>
  <method class="org.jfree.chart.editor.DefaultPolarPlotEditor" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="org.jfree.chart.editor.DefaultPolarPlotEditor" name="void validateAngleOffset()" map="M"/>
  <method class="org.jfree.chart.editor.DefaultPolarPlotEditor" name="void focusGained(java.awt.event.FocusEvent)" map="focusGained"/>
  <method class="org.jfree.chart.editor.DefaultPolarPlotEditor" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <class name="org.jfree.chart.editor.ChartEditorManager" map="I"/>
  <field class="org.jfree.chart.editor.ChartEditorManager" name="factory" map="A"/>
  <method class="org.jfree.chart.editor.ChartEditorManager" name="org.jfree.chart.editor.ChartEditor getChartEditor(org.jfree.chart.JFreeChart)" map="A"/>
  <class name="org.jfree.chart.editor.PaletteSample" map="J"/>
  <field class="org.jfree.chart.editor.PaletteSample" name="preferredSize" map="A"/>
  <field class="org.jfree.chart.editor.PaletteSample" name="palette" map="B"/>
  <method class="org.jfree.chart.editor.PaletteSample" name="void setPalette(org.jfree.chart.plot.ColorPalette)" map="A"/>
  <method class="org.jfree.chart.editor.PaletteSample" name="void paintComponent(java.awt.Graphics)" map="paintComponent"/>
  <method class="org.jfree.chart.editor.PaletteSample" name="org.jfree.chart.plot.ColorPalette getPalette()" map="A"/>
  <method class="org.jfree.chart.editor.PaletteSample" name="java.awt.Dimension getPreferredSize()" map="getPreferredSize"/>
  <method class="org.jfree.chart.editor.PaletteSample" name="java.awt.Component getListCellRendererComponent(javax.swing.JList, java.lang.Object, int, boolean, boolean)" map="getListCellRendererComponent"/>
  <class name="org.jfree.chart.editor.ChartEditorFactory" map="K"/>
  <method class="org.jfree.chart.editor.ChartEditorFactory" name="org.jfree.chart.editor.ChartEditor createEditor(org.jfree.chart.JFreeChart)" map="A"/>
  <class name="org.jfree.chart.editor.DefaultChartEditorFactory" map="L"/>
  <method class="org.jfree.chart.editor.DefaultChartEditorFactory" name="org.jfree.chart.editor.ChartEditor createEditor(org.jfree.chart.JFreeChart)" map="A"/>
  <class name="org.jfree.chart.editor.DefaultPlotEditor" map="M"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="plotInsets" map="A"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="availableStrokeSamples" map="B"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="plotOrientation" map="C"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="orientationNames" map="D"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="backgroundPaintSample" map="E"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="outlineStrokeSample" map="F"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="drawShapesCheckBox" map="G"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="drawShapes" map="H"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="drawLinesCheckBox" map="I"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="domainAxisPropertyPanel" map="J"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="rangeAxisPropertyPanel" map="K"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="drawLines" map="L"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="orientationCombo" map="M"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="localizationResources" map="N"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="outlinePaintSample" map="O"/>
  <field class="org.jfree.chart.editor.DefaultPlotEditor" name="colorBarAxisPropertyPanel" map="P"/>
  <method class="org.jfree.chart.editor.DefaultPlotEditor" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="org.jfree.chart.editor.DefaultPlotEditor" name="void attemptOrientationSelection()" map="A"/>
  <method class="org.jfree.chart.editor.DefaultPlotEditor" name="void attemptBackgroundPaintSelection()" map="B"/>
  <method class="org.jfree.chart.editor.DefaultPlotEditor" name="void attemptDrawLinesSelection()" map="C"/>
  <method class="org.jfree.chart.editor.DefaultPlotEditor" name="org.jfree.ui.RectangleInsets getPlotInsets()" map="D"/>
  <method class="org.jfree.chart.editor.DefaultPlotEditor" name="javax.swing.JPanel createPlotPanel(org.jfree.chart.plot.Plot)" map="A"/>
  <method class="org.jfree.chart.editor.DefaultPlotEditor" name="java.awt.Paint getOutlinePaint()" map="E"/>
  <method class="org.jfree.chart.editor.DefaultPlotEditor" name="void updatePlotProperties(org.jfree.chart.plot.Plot)" map="B"/>
  <method class="org.jfree.chart.editor.DefaultPlotEditor" name="java.awt.Stroke getOutlineStroke()" map="F"/>
  <method class="org.jfree.chart.editor.DefaultPlotEditor" name="void attemptOutlinePaintSelection()" map="G"/>
  <method class="org.jfree.chart.editor.DefaultPlotEditor" name="java.awt.Paint getBackgroundPaint()" map="H"/>
  <method class="org.jfree.chart.editor.DefaultPlotEditor" name="void attemptDrawShapesSelection()" map="I"/>
  <method class="org.jfree.chart.editor.DefaultPlotEditor" name="void attemptOutlineStrokeSelection()" map="J"/>
  <method class="org.jfree.chart.editor.DefaultPlotEditor" name="javax.swing.JTabbedPane createPlotTabs(org.jfree.chart.plot.Plot)" map="C"/>
  <class name="org.jfree.chart.editor.DefaultLogAxisEditor" map="N"/>
  <field class="org.jfree.chart.editor.DefaultLogAxisEditor" name="manualTickUnit" map="_"/>
  <field class="org.jfree.chart.editor.DefaultLogAxisEditor" name="manualTickUnitValue" map="a"/>
  <method class="org.jfree.chart.editor.DefaultLogAxisEditor" name="void setAxisProperties(org.jfree.chart.axis.Axis)" map="A"/>
  <method class="org.jfree.chart.editor.DefaultLogAxisEditor" name="javax.swing.JPanel createTickUnitPanel()" map="Q"/>
  <method class="org.jfree.chart.editor.DefaultLogAxisEditor" name="void validateTickUnit()" map="W"/>
  <method class="org.jfree.chart.editor.DefaultLogAxisEditor" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="org.jfree.chart.editor.DefaultLogAxisEditor" name="void focusLost(java.awt.event.FocusEvent)" map="focusLost"/>
  <method class="org.jfree.chart.editor.DefaultLogAxisEditor" name="void toggleAutoTick()" map="N"/>
  <class name="org.jfree.chart.editor.DefaultChartEditor" map="O"/>
  <field class="org.jfree.chart.editor.DefaultChartEditor" name="antialias" map="A"/>
  <field class="org.jfree.chart.editor.DefaultChartEditor" name="localizationResources" map="B"/>
  <field class="org.jfree.chart.editor.DefaultChartEditor" name="titleEditor" map="C"/>
  <field class="org.jfree.chart.editor.DefaultChartEditor" name="background" map="D"/>
  <field class="org.jfree.chart.editor.DefaultChartEditor" name="plotEditor" map="E"/>
  <method class="org.jfree.chart.editor.DefaultChartEditor" name="boolean getAntiAlias()" map="A"/>
  <method class="org.jfree.chart.editor.DefaultChartEditor" name="java.awt.Paint getBackgroundPaint()" map="B"/>
  <method class="org.jfree.chart.editor.DefaultChartEditor" name="void updateChart(org.jfree.chart.JFreeChart)" map="A"/>
  <method class="org.jfree.chart.editor.DefaultChartEditor" name="void attemptModifyBackgroundPaint()" map="C"/>
  <method class="org.jfree.chart.editor.DefaultChartEditor" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <package name="org.jfree.chart.plot" map="L"/>
  <class name="org.jfree.chart.plot.ValueAxisPlot" map="A"/>
  <method class="org.jfree.chart.plot.ValueAxisPlot" name="org.jfree.data.Range getDataRange(org.jfree.chart.axis.ValueAxis)" map="A"/>
  <class name="org.jfree.chart.plot.ColorPalette" map="B"/>
  <field class="org.jfree.chart.plot.ColorPalette" name="r" map="A"/>
  <field class="org.jfree.chart.plot.ColorPalette" name="minZ" map="B"/>
  <field class="org.jfree.chart.plot.ColorPalette" name="tickValues" map="C"/>
  <field class="org.jfree.chart.plot.ColorPalette" name="inverse" map="D"/>
  <field class="org.jfree.chart.plot.ColorPalette" name="paletteName" map="E"/>
  <field class="org.jfree.chart.plot.ColorPalette" name="g" map="F"/>
  <field class="org.jfree.chart.plot.ColorPalette" name="logscale" map="G"/>
  <field class="org.jfree.chart.plot.ColorPalette" name="b" map="H"/>
  <field class="org.jfree.chart.plot.ColorPalette" name="log10" map="I"/>
  <field class="org.jfree.chart.plot.ColorPalette" name="stepped" map="J"/>
  <field class="org.jfree.chart.plot.ColorPalette" name="maxZ" map="K"/>
  <method class="org.jfree.chart.plot.ColorPalette" name="void setMinZ(double)" map="A"/>
  <method class="org.jfree.chart.plot.ColorPalette" name="boolean isInverse()" map="A"/>
  <method class="org.jfree.chart.plot.ColorPalette" name="double getMaxZ()" map="B"/>
  <method class="org.jfree.chart.plot.ColorPalette" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.plot.ColorPalette" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.plot.ColorPalette" name="double getMinZ()" map="C"/>
  <method class="org.jfree.chart.plot.ColorPalette" name="java.awt.Color getColor(int)" map="A"/>
  <method class="org.jfree.chart.plot.ColorPalette" name="void initialize()" map="D"/>
  <method class="org.jfree.chart.plot.ColorPalette" name="boolean isStepped()" map="E"/>
  <method class="org.jfree.chart.plot.ColorPalette" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.plot.ColorPalette" name="void setMaxZ(double)" map="B"/>
  <method class="org.jfree.chart.plot.ColorPalette" name="void setInverse(boolean)" map="A"/>
  <method class="org.jfree.chart.plot.ColorPalette" name="void invertPalette()" map="F"/>
  <method class="org.jfree.chart.plot.ColorPalette" name="void setPaletteName(java.lang.String)" map="A"/>
  <method class="org.jfree.chart.plot.ColorPalette" name="void setStepped(boolean)" map="B"/>
  <class name="org.jfree.chart.plot.CombinedDomainXYPlot" map="C"/>
  <method class="org.jfree.chart.plot.CombinedDomainXYPlot" name="java.util.List getSubplots()" map="&#x0103;"/>
  <method class="org.jfree.chart.plot.CombinedDomainXYPlot" name="void plotChanged(org.jfree.chart.event.PlotChangeEvent)" map="A"/>
  <class name="org.jfree.chart.plot.CombinedDomainCategoryPlot" map="D"/>
  <method class="org.jfree.chart.plot.CombinedDomainCategoryPlot" name="java.util.List getSubplots()" map="&#x0129;"/>
  <method class="org.jfree.chart.plot.CombinedDomainCategoryPlot" name="void plotChanged(org.jfree.chart.event.PlotChangeEvent)" map="A"/>
  <class name="org.jfree.chart.plot.PieLabelLinkStyle" map="E"/>
  <field class="org.jfree.chart.plot.PieLabelLinkStyle" name="name" map="A"/>
  <field class="org.jfree.chart.plot.PieLabelLinkStyle" name="QUAD_CURVE" map="B"/>
  <field class="org.jfree.chart.plot.PieLabelLinkStyle" name="CUBIC_CURVE" map="C"/>
  <field class="org.jfree.chart.plot.PieLabelLinkStyle" name="STANDARD" map="D"/>
  <method class="org.jfree.chart.plot.PieLabelLinkStyle" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.plot.PieLabelLinkStyle" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.plot.PieLabelLinkStyle" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.plot.IntervalMarker" map="F"/>
  <method class="org.jfree.chart.plot.IntervalMarker" name="org.jfree.ui.GradientPaintTransformer getGradientPaintTransformer()" map="P"/>
  <method class="org.jfree.chart.plot.IntervalMarker" name="double getStartValue()" map="Q"/>
  <method class="org.jfree.chart.plot.IntervalMarker" name="double getEndValue()" map="R"/>
  <class name="org.jfree.chart.plot.RainbowPalette" map="G"/>
  <field class="org.jfree.chart.plot.RainbowPalette" name="blue" map="L"/>
  <field class="org.jfree.chart.plot.RainbowPalette" name="green" map="M"/>
  <field class="org.jfree.chart.plot.RainbowPalette" name="red" map="N"/>
  <method class="org.jfree.chart.plot.RainbowPalette" name="void initialize()" map="D"/>
  <class name="org.jfree.chart.plot.MultiplePiePlot" map="H"/>
  <method class="org.jfree.chart.plot.MultiplePiePlot" name="org.jfree.chart.JFreeChart getPieChart()" map="&#x00ce;"/>
  <class name="org.jfree.chart.plot.SeriesRenderingOrder" map="I"/>
  <field class="org.jfree.chart.plot.SeriesRenderingOrder" name="FORWARD" map="A"/>
  <field class="org.jfree.chart.plot.SeriesRenderingOrder" name="name" map="B"/>
  <field class="org.jfree.chart.plot.SeriesRenderingOrder" name="REVERSE" map="C"/>
  <method class="org.jfree.chart.plot.SeriesRenderingOrder" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.plot.SeriesRenderingOrder" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.plot.SeriesRenderingOrder" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.plot.Pannable" map="J"/>
  <method class="org.jfree.chart.plot.Pannable" name="void panRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="A"/>
  <method class="org.jfree.chart.plot.Pannable" name="boolean isDomainPannable()" map="&#x00cf;"/>
  <method class="org.jfree.chart.plot.Pannable" name="boolean isRangePannable()" map="&#x00d0;"/>
  <method class="org.jfree.chart.plot.Pannable" name="org.jfree.chart.plot.PlotOrientation getOrientation()" map="&#x00d1;"/>
  <method class="org.jfree.chart.plot.Pannable" name="void panDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="B"/>
  <class name="org.jfree.chart.plot.PiePlotState" map="K"/>
  <field class="org.jfree.chart.plot.PiePlotState" name="passesRequired" map="L"/>
  <field class="org.jfree.chart.plot.PiePlotState" name="pieHRadius" map="M"/>
  <field class="org.jfree.chart.plot.PiePlotState" name="pieWRadius" map="N"/>
  <field class="org.jfree.chart.plot.PiePlotState" name="pieCenterY" map="O"/>
  <field class="org.jfree.chart.plot.PiePlotState" name="pieCenterX" map="P"/>
  <field class="org.jfree.chart.plot.PiePlotState" name="linkArea" map="Q"/>
  <field class="org.jfree.chart.plot.PiePlotState" name="pieArea" map="R"/>
  <field class="org.jfree.chart.plot.PiePlotState" name="total" map="S"/>
  <field class="org.jfree.chart.plot.PiePlotState" name="latestAngle" map="T"/>
  <field class="org.jfree.chart.plot.PiePlotState" name="explodedPieArea" map="U"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="java.awt.geom.Rectangle2D getExplodedPieArea()" map="J"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="void setPieWRadius(double)" map="B"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="java.awt.geom.Rectangle2D getLinkArea()" map="K"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="double getPieWRadius()" map="L"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="void setTotal(double)" map="C"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="void setPassesRequired(int)" map="B"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="void setPieCenterY(double)" map="D"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="void setPieArea(java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="void setLinkArea(java.awt.geom.Rectangle2D)" map="B"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="double getPieHRadius()" map="M"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="double getTotal()" map="N"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="java.awt.geom.Rectangle2D getPieArea()" map="O"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="double getPieCenterX()" map="P"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="void setPieCenterX(double)" map="E"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="double getPieCenterY()" map="Q"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="void setPieHRadius(double)" map="F"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="double getLatestAngle()" map="R"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="void setExplodedPieArea(java.awt.geom.Rectangle2D)" map="C"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="void setLatestAngle(double)" map="G"/>
  <method class="org.jfree.chart.plot.PiePlotState" name="int getPassesRequired()" map="S"/>
  <class name="org.jfree.chart.plot.DrawingSupplier" map="L"/>
  <method class="org.jfree.chart.plot.DrawingSupplier" name="java.awt.Paint getNextFillPaint()" map="&#x01a1;"/>
  <method class="org.jfree.chart.plot.DrawingSupplier" name="java.awt.Paint getNextOutlinePaint()" map="&#x01a2;"/>
  <method class="org.jfree.chart.plot.DrawingSupplier" name="java.awt.Stroke getNextOutlineStroke()" map="&#x01a3;"/>
  <method class="org.jfree.chart.plot.DrawingSupplier" name="java.awt.Stroke getNextStroke()" map="&#x01a4;"/>
  <method class="org.jfree.chart.plot.DrawingSupplier" name="java.awt.Paint getNextPaint()" map="&#x01a5;"/>
  <method class="org.jfree.chart.plot.DrawingSupplier" name="java.awt.Shape getNextShape()" map="&#x01a6;"/>
  <class name="org.jfree.chart.plot.PlotState" map="M"/>
  <method class="org.jfree.chart.plot.PlotState" name="java.util.Map getSharedAxisStates()" map="A"/>
  <class name="org.jfree.chart.plot.CrosshairState" map="N"/>
  <field class="org.jfree.chart.plot.CrosshairState" name="distance" map="A"/>
  <field class="org.jfree.chart.plot.CrosshairState" name="rangeAxisIndex" map="B"/>
  <field class="org.jfree.chart.plot.CrosshairState" name="anchorY" map="C"/>
  <field class="org.jfree.chart.plot.CrosshairState" name="anchorX" map="D"/>
  <field class="org.jfree.chart.plot.CrosshairState" name="anchor" map="E"/>
  <field class="org.jfree.chart.plot.CrosshairState" name="calculateDistanceInDataSpace" map="F"/>
  <field class="org.jfree.chart.plot.CrosshairState" name="domainAxisIndex" map="G"/>
  <field class="org.jfree.chart.plot.CrosshairState" name="crosshairY" map="H"/>
  <field class="org.jfree.chart.plot.CrosshairState" name="crosshairX" map="I"/>
  <field class="org.jfree.chart.plot.CrosshairState" name="datasetIndex" map="J"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="double getCrosshairX()" map="A"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="void updateCrosshairX(double, int)" map="A"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="void setAnchor(java.awt.geom.Point2D)" map="A"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="void setCrosshairY(double)" map="A"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="void updateCrosshairPoint(double, double, int, int, double, double, org.jfree.chart.plot.PlotOrientation)" map="A"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="void setAnchorY(double)" map="B"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="int getRangeAxisIndex()" map="B"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="void setCrosshairX(double)" map="C"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="int getDomainAxisIndex()" map="C"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="void setAnchorX(double)" map="D"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="void updateCrosshairY(double, int)" map="B"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="void setDatasetIndex(int)" map="A"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="void setCrosshairDistance(double)" map="E"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="java.awt.geom.Point2D getAnchor()" map="D"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="int getDatasetIndex()" map="E"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="double getCrosshairY()" map="F"/>
  <method class="org.jfree.chart.plot.CrosshairState" name="double getCrosshairDistance()" map="G"/>
  <class name="org.jfree.chart.plot.Marker" map="O"/>
  <method class="org.jfree.chart.plot.Marker" name="org.jfree.ui.TextAnchor getLabelTextAnchor()" map="A"/>
  <method class="org.jfree.chart.plot.Marker" name="java.awt.Paint getPaint()" map="B"/>
  <method class="org.jfree.chart.plot.Marker" name="org.jfree.ui.RectangleAnchor getLabelAnchor()" map="C"/>
  <method class="org.jfree.chart.plot.Marker" name="java.awt.Paint getOutlinePaint()" map="D"/>
  <method class="org.jfree.chart.plot.Marker" name="java.lang.String getLabel()" map="E"/>
  <method class="org.jfree.chart.plot.Marker" name="java.awt.Paint getLabelPaint()" map="F"/>
  <method class="org.jfree.chart.plot.Marker" name="java.awt.Stroke getStroke()" map="G"/>
  <method class="org.jfree.chart.plot.Marker" name="org.jfree.ui.RectangleInsets getLabelOffset()" map="H"/>
  <method class="org.jfree.chart.plot.Marker" name="java.awt.Stroke getOutlineStroke()" map="I"/>
  <method class="org.jfree.chart.plot.Marker" name="java.awt.Font getLabelFont()" map="J"/>
  <method class="org.jfree.chart.plot.Marker" name="org.jfree.ui.LengthAdjustmentType getLabelOffsetType()" map="K"/>
  <method class="org.jfree.chart.plot.Marker" name="float getAlpha()" map="L"/>
  <class name="org.jfree.chart.plot.PlotOrientation" map="P"/>
  <field class="org.jfree.chart.plot.PlotOrientation" name="name" map="A"/>
  <field class="org.jfree.chart.plot.PlotOrientation" name="HORIZONTAL" map="B"/>
  <field class="org.jfree.chart.plot.PlotOrientation" name="VERTICAL" map="C"/>
  <method class="org.jfree.chart.plot.PlotOrientation" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.plot.PlotOrientation" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.plot.PlotOrientation" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.plot.SpiderWebPlot" map="Q"/>
  <field class="org.jfree.chart.plot.SpiderWebPlot" name="DEFAULT_LABEL_SHADOW_PAINT" map="&#x013f;"/>
  <field class="org.jfree.chart.plot.SpiderWebPlot" name="DEFAULT_LABEL_OUTLINE_PAINT" map="&#x0140;"/>
  <field class="org.jfree.chart.plot.SpiderWebPlot" name="DEFAULT_LABEL_BACKGROUND_PAINT" map="&#x0141;"/>
  <field class="org.jfree.chart.plot.SpiderWebPlot" name="DEFAULT_LABEL_PAINT" map="&#x0142;"/>
  <field class="org.jfree.chart.plot.SpiderWebPlot" name="DEFAULT_LABEL_OUTLINE_STROKE" map="&#x0143;"/>
  <field class="org.jfree.chart.plot.SpiderWebPlot" name="DEFAULT_LABEL_FONT" map="&#x0144;"/>
  <method class="org.jfree.chart.plot.SpiderWebPlot" name="void setLabelPaint(java.awt.Paint)" map="I"/>
  <method class="org.jfree.chart.plot.SpiderWebPlot" name="void setAxisLinePaint(java.awt.Paint)" map="J"/>
  <method class="org.jfree.chart.plot.SpiderWebPlot" name="void setLabelFont(java.awt.Font)" map="B"/>
  <class name="org.jfree.chart.plot.CategoryPlot" map="R"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="backgroundRangeMarkers" map="&#x0185;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="fixedRangeAxisSpace" map="&#x0186;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeCrosshairPaint" map="&#x0187;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="domainGridlinesVisible" map="&#x0188;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeGridlinesVisible" map="&#x0189;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="domainCrosshairStroke" map="&#x018a;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeMinorGridlinesVisible" map="&#x018b;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="anchorValue" map="&#x018c;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="datasetToDomainAxesMap" map="&#x018d;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="DEFAULT_CROSSHAIR_STROKE" map="&#x018e;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeZeroBaselineStroke" map="&#x018f;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="domainCrosshairColumnKey" map="&#x0190;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeCrosshairStroke" map="&#x0191;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="domainGridlineStroke" map="&#x0192;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeMinorGridlineStroke" map="&#x0193;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="domainCrosshairVisible" map="&#x0194;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeCrosshairVisible" map="&#x0195;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="renderers" map="&#x0196;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="fixedLegendItems" map="&#x0197;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="foregroundDomainMarkers" map="&#x0198;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeAxisLocations" map="&#x0199;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="orientation" map="&#x019a;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rowRenderingOrder" map="&#x019b;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="annotations" map="&#x019c;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="datasetToRangeAxesMap" map="&#x019d;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="renderingOrder" map="&#x019e;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="domainAxes" map="&#x019f;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="DEFAULT_GRIDLINE_PAINT" map="&#x01a0;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="crosshairDatasetIndex" map="&#x01a1;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="backgroundDomainMarkers" map="&#x01a2;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeAxes" map="&#x01a3;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="DEFAULT_GRIDLINE_STROKE" map="&#x01a4;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="shadowGenerator" map="&#x01a5;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="domainAxisLocations" map="&#x01a6;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="domainCrosshairPaint" map="&#x01a7;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="drawSharedDomainAxis" map="&#x01a8;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="DEFAULT_VALUE_LABEL_FONT" map="&#x01a9;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeGridlineStroke" map="&#x01aa;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="fixedDomainAxisSpace" map="&#x01ab;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="columnRenderingOrder" map="&#x01ac;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="weight" map="&#x01ad;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeCrosshairLockedOnData" map="&#x01ae;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeZeroBaselineVisible" map="&#x01af;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="datasets" map="&#x01b0;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeGridlinePaint" map="&#x01b1;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="DEFAULT_CROSSHAIR_PAINT" map="&#x01b2;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="localizationResources" map="&#x01b3;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeMinorGridlinePaint" map="&#x01b4;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="foregroundRangeMarkers" map="&#x01b5;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeZeroBaselinePaint" map="&#x01b6;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="domainGridlinePosition" map="&#x01b7;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangeCrosshairValue" map="&#x01b8;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="domainCrosshairRowKey" map="&#x01b9;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="rangePannable" map="&#x01ba;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="domainGridlinePaint" map="&#x01bb;"/>
  <field class="org.jfree.chart.plot.CategoryPlot" name="axisOffset" map="&#x01bc;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.axis.ValueAxis getRangeAxis(int)" map="&#x00a2;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.awt.Stroke getRangeMinorGridlineStroke()" map="&#x0105;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setRangeAxisLocation(org.jfree.chart.axis.AxisLocation, boolean)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setDomainAxisLocation(int, org.jfree.chart.axis.AxisLocation, boolean)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void configureRangeAxes()" map="&#x0106;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.axis.AxisLocation getDomainAxisLocation(int)" map="&#x00a3;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void datasetChanged(org.jfree.data.general.DatasetChangeEvent)" map="B"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.awt.Rectangle integerise(java.awt.geom.Rectangle2D)" map="F"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.util.Collection getDomainMarkers(int, org.jfree.ui.Layer)" map="C"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void rendererChanged(org.jfree.chart.event.RendererChangeEvent)" map="B"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.util.SortOrder getRowRenderingOrder()" map="&#x0107;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void drawZeroRangeBaseline(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="K"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.awt.Paint getDomainGridlinePaint()" map="&#x0108;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setCrosshairDatasetIndex(int, boolean)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setRangeCrosshairValue(double, boolean)" map="C"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.renderer.category.CategoryItemRenderer getRenderer(int)" map="&#x00a4;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.axis.CategoryAnchor getDomainGridlinePosition()" map="&#x0109;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setRenderer(org.jfree.chart.renderer.category.CategoryItemRenderer)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setDomainCrosshairRowKey(java.lang.Comparable, boolean)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.axis.AxisSpace calculateRangeAxisSpace(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.axis.AxisSpace)" map="C"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void zoomRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="C"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void drawRangeMarkers(java.awt.Graphics2D, java.awt.geom.Rectangle2D, int, org.jfree.ui.Layer)" map="C"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.awt.Paint getRangeGridlinePaint()" map="&#x010a;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.axis.AxisSpace calculateDomainAxisSpace(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.axis.AxisSpace)" map="D"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="int getDomainAxisCount()" map="&#x010b;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.awt.Stroke getRangeGridlineStroke()" map="&#x010c;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setDomainAxisLocation(org.jfree.chart.axis.AxisLocation, boolean)" map="B"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setRangeAxis(int, org.jfree.chart.axis.ValueAxis)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="boolean isDomainPannable()" map="&#x00cf;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void panDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="B"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void drawBackground(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="E"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.util.Map cloneMarkerMap(java.util.Map)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="boolean isRangeGridlinesVisible()" map="&#x010d;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.util.Collection getRangeMarkers(int, org.jfree.ui.Layer)" map="D"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="boolean isRangeZoomable()" map="&#x00d2;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setRangeGridlinePaint(java.awt.Paint)" map="T"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.plot.PlotOrientation getOrientation()" map="&#x00d1;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.axis.CategoryAxis getDomainAxis()" map="&#x010e;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setRangeAxisLocation(int, org.jfree.chart.axis.AxisLocation, boolean)" map="B"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.awt.Paint getRangeMinorGridlinePaint()" map="&#x010f;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="int getRendererCount()" map="&#x0110;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="boolean isRangeCrosshairLockedOnData()" map="&#x0111;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setDomainCrosshairColumnKey(java.lang.Comparable, boolean)" map="B"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void drawAnnotations(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="L"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void drawDomainCrosshair(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotOrientation, int, java.lang.Comparable, java.lang.Comparable, java.awt.Stroke, java.awt.Paint)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.awt.Paint getDomainCrosshairPaint()" map="&#x0112;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void zoomDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="D"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void zoomDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D, boolean)" map="B"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void drawDomainGridlines(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="M"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="double getRangeCrosshairValue()" map="&#x0113;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.axis.CategoryAxis getDomainAxis(int)" map="&#x00a5;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setOrientation(org.jfree.chart.plot.PlotOrientation)" map="B"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="boolean isDomainGridlinesVisible()" map="&#x0114;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setShadowGenerator(org.jfree.chart.util.ShadowGenerator)" map="B"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void mapDatasetToDomainAxis(int, int)" map="y"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void zoomRangeAxes(double, double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setDomainAxis(int, org.jfree.chart.axis.CategoryAxis, boolean)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.util.List getAnnotations()" map="&#x0115;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.ui.RectangleEdge getRangeAxisEdge(int)" map="&#x00aa;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.ui.RectangleEdge getRangeAxisEdge()" map="&#x0116;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.data.category.CategoryDataset getDataset()" map="&#x0117;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="int getRangeAxisCount()" map="&#x0118;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void mapDatasetToRangeAxis(int, int)" map="z"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.awt.Paint getRangeCrosshairPaint()" map="&#x0119;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void mapDatasetToRangeAxes(int, java.util.List)" map="C"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.lang.Comparable getDomainCrosshairColumnKey()" map="&#x011a;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setDomainGridlinePaint(java.awt.Paint)" map="U"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.lang.String getPlotType()" map="&#x00c4;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.axis.AxisLocation getRangeAxisLocation(int)" map="&#x00b5;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void configureDomainAxes()" map="&#x011b;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.awt.Stroke getRangeCrosshairStroke()" map="&#x011c;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.util.List datasetsMappedToRangeAxis(int)" map="&#x00ba;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void drawDomainMarkers(java.awt.Graphics2D, java.awt.geom.Rectangle2D, int, org.jfree.ui.Layer)" map="D"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.axis.ValueAxis getRangeAxisForDataset(int)" map="&#x00c0;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.data.Range getDataRange(org.jfree.chart.axis.ValueAxis)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.util.Map drawAxes(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo)" map="B"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.ui.RectangleEdge getDomainAxisEdge(int)" map="&#x00c1;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="boolean isDomainZoomable()" map="&#x00d3;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.axis.CategoryAxis getDomainAxisForDataset(int)" map="&#x00c2;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="boolean render(java.awt.Graphics2D, java.awt.geom.Rectangle2D, int, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.CategoryCrosshairState)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.axis.ValueAxis getRangeAxis()" map="&#x011d;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setAxisOffset(org.jfree.ui.RectangleInsets)" map="E"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="boolean isRangeMinorGridlinesVisible()" map="&#x011e;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.ui.RectangleEdge getDomainAxisEdge()" map="&#x011f;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.renderer.category.CategoryItemRenderer getRenderer()" map="&#x0120;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.axis.AxisSpace calculateAxisSpace(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="N"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="int indexOf(org.jfree.data.category.CategoryDataset)" map="B"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="boolean isRangeZeroBaselineVisible()" map="&#x0121;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void panRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.axis.AxisLocation getDomainAxisLocation()" map="&#x0122;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="int getIndexOf(org.jfree.chart.renderer.category.CategoryItemRenderer)" map="B"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="boolean isRangeCrosshairVisible()" map="&#x0123;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.awt.Stroke getDomainCrosshairStroke()" map="&#x0124;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void drawRangeCrosshair(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotOrientation, double, org.jfree.chart.axis.ValueAxis, java.awt.Stroke, java.awt.Paint)" map="C"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.lang.Comparable getDomainCrosshairRowKey()" map="&#x0125;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.awt.Stroke getDomainGridlineStroke()" map="&#x0126;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.renderer.category.CategoryItemRenderer getRendererForDataset(org.jfree.data.category.CategoryDataset)" map="C"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void zoomRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D, boolean)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.awt.geom.Point2D, org.jfree.chart.plot.PlotState, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void checkAxisIndices(java.util.List)" map="B"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.util.List datasetsMappedToDomainAxis(int)" map="&#x00c3;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void mapDatasetToDomainAxes(int, java.util.List)" map="D"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="java.util.List getCategoriesForAxis(org.jfree.chart.axis.CategoryAxis)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setRangeAxis(int, org.jfree.chart.axis.ValueAxis, boolean)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setRangeZeroBaselinePaint(java.awt.Paint)" map="V"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="boolean isDomainCrosshairVisible()" map="&#x0127;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setDomainAxis(int, org.jfree.chart.axis.CategoryAxis)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.plot.DatasetRenderingOrder getDatasetRenderingOrder()" map="&#x0128;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="boolean isRangePannable()" map="&#x00d0;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void zoomDomainAxes(double, double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="B"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void drawRangeGridlines(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.util.List)" map="E"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.chart.LegendItemCollection getLegendItems()" map="S"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="org.jfree.data.category.CategoryDataset getDataset(int)" map="&#x00c4;"/>
  <method class="org.jfree.chart.plot.CategoryPlot" name="void setRenderer(int, org.jfree.chart.renderer.category.CategoryItemRenderer, boolean)" map="A"/>
  <class name="org.jfree.chart.plot.ContourValuePlot" map="S"/>
  <class name="org.jfree.chart.plot.ThermometerPlot" map="T"/>
  <field class="org.jfree.chart.plot.ThermometerPlot" name="localizationResources" map="&#x01bd;"/>
  <field class="org.jfree.chart.plot.ThermometerPlot" name="UNITS" map="&#x01be;"/>
  <method class="org.jfree.chart.plot.ThermometerPlot" name="boolean isRangeZoomable()" map="&#x00d2;"/>
  <method class="org.jfree.chart.plot.ThermometerPlot" name="void zoomRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D, boolean)" map="A"/>
  <method class="org.jfree.chart.plot.ThermometerPlot" name="void zoomDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D, boolean)" map="B"/>
  <method class="org.jfree.chart.plot.ThermometerPlot" name="org.jfree.chart.plot.PlotOrientation getOrientation()" map="&#x00d1;"/>
  <method class="org.jfree.chart.plot.ThermometerPlot" name="void setValueFont(java.awt.Font)" map="D"/>
  <method class="org.jfree.chart.plot.ThermometerPlot" name="void setThermometerPaint(java.awt.Paint)" map="W"/>
  <method class="org.jfree.chart.plot.ThermometerPlot" name="void zoomRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="C"/>
  <method class="org.jfree.chart.plot.ThermometerPlot" name="org.jfree.chart.axis.ValueAxis getRangeAxis()" map="&#x012b;"/>
  <method class="org.jfree.chart.plot.ThermometerPlot" name="boolean isDomainZoomable()" map="&#x00d3;"/>
  <method class="org.jfree.chart.plot.ThermometerPlot" name="void zoomRangeAxes(double, double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="A"/>
  <method class="org.jfree.chart.plot.ThermometerPlot" name="void zoomDomainAxes(double, double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="B"/>
  <method class="org.jfree.chart.plot.ThermometerPlot" name="org.jfree.data.Range getDataRange(org.jfree.chart.axis.ValueAxis)" map="A"/>
  <method class="org.jfree.chart.plot.ThermometerPlot" name="void zoomDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="D"/>
  <class name="org.jfree.chart.plot.ValueMarker" map="U"/>
  <method class="org.jfree.chart.plot.ValueMarker" name="double getValue()" map="M"/>
  <class name="org.jfree.chart.plot.CombinedRangeXYPlot" map="V"/>
  <method class="org.jfree.chart.plot.CombinedRangeXYPlot" name="java.util.List getSubplots()" map="&#x0104;"/>
  <method class="org.jfree.chart.plot.CombinedRangeXYPlot" name="void plotChanged(org.jfree.chart.event.PlotChangeEvent)" map="A"/>
  <class name="org.jfree.chart.plot.ContourPlot" map="W"/>
  <field class="org.jfree.chart.plot.ContourPlot" name="localizationResources" map="&#x01c2;"/>
  <field class="org.jfree.chart.plot.ContourPlot" name="DEFAULT_INSETS" map="&#x013b;"/>
  <method class="org.jfree.chart.plot.ContourPlot" name="org.jfree.data.Range getDataRange(org.jfree.chart.axis.ValueAxis)" map="A"/>
  <method class="org.jfree.chart.plot.ContourPlot" name="org.jfree.chart.axis.ColorBar getColorBar()" map="&#x012e;"/>
  <class name="org.jfree.chart.plot.PlotRenderingInfo" map="X"/>
  <field class="org.jfree.chart.plot.PlotRenderingInfo" name="owner" map="A"/>
  <field class="org.jfree.chart.plot.PlotRenderingInfo" name="subplotInfo" map="B"/>
  <field class="org.jfree.chart.plot.PlotRenderingInfo" name="dataArea" map="C"/>
  <field class="org.jfree.chart.plot.PlotRenderingInfo" name="plotArea" map="D"/>
  <method class="org.jfree.chart.plot.PlotRenderingInfo" name="int getSubplotIndex(java.awt.geom.Point2D)" map="A"/>
  <method class="org.jfree.chart.plot.PlotRenderingInfo" name="org.jfree.chart.ChartRenderingInfo getOwner()" map="A"/>
  <method class="org.jfree.chart.plot.PlotRenderingInfo" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.plot.PlotRenderingInfo" name="java.awt.geom.Rectangle2D getDataArea()" map="B"/>
  <method class="org.jfree.chart.plot.PlotRenderingInfo" name="void setDataArea(java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.plot.PlotRenderingInfo" name="org.jfree.chart.plot.PlotRenderingInfo getSubplotInfo(int)" map="A"/>
  <method class="org.jfree.chart.plot.PlotRenderingInfo" name="void setPlotArea(java.awt.geom.Rectangle2D)" map="B"/>
  <method class="org.jfree.chart.plot.PlotRenderingInfo" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.plot.PlotRenderingInfo" name="int getSubplotCount()" map="C"/>
  <class name="org.jfree.chart.plot.PiePlot" map="Y"/>
  <field class="org.jfree.chart.plot.PiePlot" name="DEFAULT_LABEL_PAINT" map="&#x01c3;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="minimumArcAngleToDraw" map="&#x01c4;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="labelBackgroundPaint" map="&#x01c5;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="labelPaint" map="&#x01c6;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="baseSectionOutlinePaint" map="&#x01c7;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="labelLinkMargin" map="&#x01c8;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="sectionPaintMap" map="&#x01c9;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="labelFont" map="&#x01ca;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="labelPadding" map="&#x01cb;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="startAngle" map="&#x01cc;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="array$F" map="array$F"/>
  <field class="org.jfree.chart.plot.PiePlot" name="explodePercentages" map="&#x01cd;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="direction" map="&#x01ce;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="class$java$awt$geom$Point2D" map="class$java$awt$geom$Point2D"/>
  <field class="org.jfree.chart.plot.PiePlot" name="legendLabelURLGenerator" map="&#x01cf;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="labelLinksVisible" map="&#x01d0;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="shadowPaint" map="&#x01d1;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="DEFAULT_LABEL_OUTLINE_STROKE" map="&#x01d2;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="labelGenerator" map="&#x01d3;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="sectionOutlinePaint" map="&#x01d4;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="circular" map="&#x01d5;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="sectionOutlinesVisible" map="&#x01d6;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="baseSectionOutlineStroke" map="&#x01d7;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="sectionOutlineStroke" map="&#x01d8;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="DEFAULT_LABEL_FONT" map="&#x01d9;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="sectionOutlinePaintMap" map="&#x01da;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="simpleLabelOffset" map="&#x01db;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="labelLinkStroke" map="&#x01dc;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="pieIndex" map="&#x01dd;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="autoPopulateSectionOutlinePaint" map="&#x01de;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="autoPopulateSectionOutlineStroke" map="&#x01df;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="urlGenerator" map="&#x01e0;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="shadowGenerator" map="&#x01e1;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="autoPopulateSectionPaint" map="&#x01e2;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="simpleLabels" map="&#x01e3;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="labelOutlineStroke" map="&#x01e4;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="ignoreNullValues" map="&#x01e5;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="labelOutlinePaint" map="&#x01e6;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="maximumLabelWidth" map="&#x01e7;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="toolTipGenerator" map="&#x01e8;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="labelLinkStyle" map="&#x01e9;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="sectionOutlineStrokeMap" map="&#x01ea;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="shadowXOffset" map="&#x01eb;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="ignoreZeroValues" map="&#x01ec;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="labelLinkPaint" map="&#x01ed;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="shadowYOffset" map="&#x01ee;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="legendLabelToolTipGenerator" map="&#x01ef;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="interiorGap" map="&#x01f0;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="localizationResources" map="&#x01f1;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="DEFAULT_LABEL_BACKGROUND_PAINT" map="&#x01f2;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="DEFAULT_LABEL_SHADOW_PAINT" map="&#x01f3;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="DEFAULT_LABEL_OUTLINE_PAINT" map="&#x01f4;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="dataset" map="&#x01f5;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="baseSectionPaint" map="&#x01fa;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="labelGap" map="&#x01fb;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="labelShadowPaint" map="&#x01fc;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="array$Ljava$awt$Color" map="array$Ljava$awt$Color"/>
  <field class="org.jfree.chart.plot.PiePlot" name="legendItemShape" map="&#x01fd;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="legendLabelGenerator" map="&#x01fe;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="sectionPaint" map="&#x01ff;"/>
  <field class="org.jfree.chart.plot.PiePlot" name="labelDistributor" map="&#x0200;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void drawLeftLabel(java.awt.Graphics2D, org.jfree.chart.plot.PiePlotState, org.jfree.chart.plot.PieLabelRecord)" map="A"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void clearSectionOutlinePaints(boolean)" map="N"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void setShadowGenerator(org.jfree.chart.util.ShadowGenerator)" map="C"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void drawItem(java.awt.Graphics2D, int, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PiePlotState, int)" map="A"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.awt.Paint lookupSectionPaint(java.lang.Comparable, boolean)" map="C"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void clearSectionPaints(boolean)" map="O"/>
  <method class="org.jfree.chart.plot.PiePlot" name="boolean getIgnoreNullValues()" map="&#x012f;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="boolean getAutoPopulateSectionPaint()" map="&#x0130;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="boolean getIgnoreZeroValues()" map="&#x0131;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="double getStartAngle()" map="&#x0132;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.awt.geom.Rectangle2D getArcBounds(java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, double, double, double)" map="A"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.lang.String getPlotType()" map="&#x00c4;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void drawLabels(java.awt.Graphics2D, java.util.List, double, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PiePlotState)" map="A"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void setURLGenerator(org.jfree.chart.urls.PieURLGenerator)" map="A"/>
  <method class="org.jfree.chart.plot.PiePlot" name="double getExplodePercent(java.lang.Comparable)" map="I"/>
  <method class="org.jfree.chart.plot.PiePlot" name="double getMinimumArcAngleToDraw()" map="&#x0133;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="org.jfree.chart.LegendItemCollection getLegendItems()" map="S"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void setToolTipGenerator(org.jfree.chart.labels.PieToolTipGenerator)" map="A"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.awt.Stroke lookupSectionOutlineStroke(java.lang.Comparable)" map="J"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void drawPie(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo)" map="B"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.awt.geom.Point2D getArcCenter(org.jfree.chart.plot.PiePlotState, java.lang.Comparable)" map="A"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.awt.Paint lookupSectionPaint(java.lang.Comparable)" map="K"/>
  <method class="org.jfree.chart.plot.PiePlot" name="org.jfree.chart.plot.PiePlotState initialise(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PiePlot, java.lang.Integer, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.awt.Shape getLegendItemShape()" map="&#x0134;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void drawRightLabel(java.awt.Graphics2D, org.jfree.chart.plot.PiePlotState, org.jfree.chart.plot.PieLabelRecord)" map="B"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void setStartAngle(double)" map="G"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.awt.Paint lookupSectionPaint(java.lang.Comparable, org.jfree.chart.plot.PiePlotState)" map="A"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.awt.Paint lookupSectionOutlinePaint(java.lang.Comparable)" map="L"/>
  <method class="org.jfree.chart.plot.PiePlot" name="boolean getAutoPopulateSectionOutlineStroke()" map="&#x0135;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void setLabelGenerator(org.jfree.chart.labels.PieSectionLabelGenerator)" map="A"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.awt.Stroke getSectionOutlineStroke()" map="&#x0136;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void setLabelLinkPaint(java.awt.Paint)" map="Z"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.awt.Font getLabelFont()" map="&#x0137;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void setDirection(org.jfree.util.Rotation)" map="A"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void setLabelLinkStyle(org.jfree.chart.plot.PieLabelLinkStyle)" map="A"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.awt.Paint getSectionPaint()" map="&#x0138;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="org.jfree.chart.labels.PieSectionLabelGenerator getLabelGenerator()" map="&#x0139;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="double getExplodePercent(int)" map="&#x00c5;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void setLabelFont(java.awt.Font)" map="E"/>
  <method class="org.jfree.chart.plot.PiePlot" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.plot.PiePlot" name="org.jfree.util.Rotation getDirection()" map="&#x013a;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void drawSimpleLabels(java.awt.Graphics2D, java.util.List, double, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PiePlotState)" map="B"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void clearSectionOutlineStrokes(boolean)" map="P"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void drawRightLabels(org.jfree.data.KeyedValues, java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, float, org.jfree.chart.plot.PiePlotState)" map="A"/>
  <method class="org.jfree.chart.plot.PiePlot" name="org.jfree.chart.plot.PieLabelLinkStyle getLabelLinkStyle()" map="&#x013b;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.lang.Comparable getSectionKey(int)" map="&#x00c6;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void setLegendLabelGenerator(org.jfree.chart.labels.PieSectionLabelGenerator)" map="B"/>
  <method class="org.jfree.chart.plot.PiePlot" name="double getInteriorGap()" map="&#x013c;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="org.jfree.data.general.PieDataset getDataset()" map="&#x013d;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="double getLabelLinkDepth()" map="&#x013e;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.awt.Stroke lookupSectionOutlineStroke(java.lang.Comparable, boolean)" map="D"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.awt.Paint getSectionOutlinePaint()" map="&#x013f;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.awt.geom.Point2D, org.jfree.chart.plot.PlotState, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.awt.Paint lookupSectionOutlinePaint(java.lang.Comparable, boolean)" map="E"/>
  <method class="org.jfree.chart.plot.PiePlot" name="double getMaximumExplodePercent()" map="&#x0140;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="boolean getAutoPopulateSectionOutlinePaint()" map="&#x0141;"/>
  <method class="org.jfree.chart.plot.PiePlot" name="void drawLeftLabels(org.jfree.data.KeyedValues, java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, float, org.jfree.chart.plot.PiePlotState)" map="B"/>
  <method class="org.jfree.chart.plot.PiePlot" name="java.lang.Object clone()" map="clone"/>
  <class name="org.jfree.chart.plot.CategoryCrosshairState" map="Z"/>
  <field class="org.jfree.chart.plot.CategoryCrosshairState" name="columnKey" map="K"/>
  <field class="org.jfree.chart.plot.CategoryCrosshairState" name="rowKey" map="L"/>
  <method class="org.jfree.chart.plot.CategoryCrosshairState" name="void setRowKey(java.lang.Comparable)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryCrosshairState" name="java.lang.Comparable getRowKey()" map="H"/>
  <method class="org.jfree.chart.plot.CategoryCrosshairState" name="void setColumnKey(java.lang.Comparable)" map="B"/>
  <method class="org.jfree.chart.plot.CategoryCrosshairState" name="void updateCrosshairPoint(java.lang.Comparable, java.lang.Comparable, double, int, double, double, org.jfree.chart.plot.PlotOrientation)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryCrosshairState" name="void updateCrosshairX(java.lang.Comparable, java.lang.Comparable, int, double, org.jfree.chart.plot.PlotOrientation)" map="A"/>
  <method class="org.jfree.chart.plot.CategoryCrosshairState" name="java.lang.Comparable getColumnKey()" map="I"/>
  <class name="org.jfree.chart.plot.AbstractPieLabelDistributor" map="_"/>
  <field class="org.jfree.chart.plot.AbstractPieLabelDistributor" name="labels" map="A"/>
  <method class="org.jfree.chart.plot.AbstractPieLabelDistributor" name="void distributeLabels(double, double)" map="A"/>
  <method class="org.jfree.chart.plot.AbstractPieLabelDistributor" name="void clear()" map="A"/>
  <method class="org.jfree.chart.plot.AbstractPieLabelDistributor" name="int getItemCount()" map="B"/>
  <method class="org.jfree.chart.plot.AbstractPieLabelDistributor" name="void addPieLabelRecord(org.jfree.chart.plot.PieLabelRecord)" map="A"/>
  <method class="org.jfree.chart.plot.AbstractPieLabelDistributor" name="org.jfree.chart.plot.PieLabelRecord getPieLabelRecord(int)" map="A"/>
  <class name="org.jfree.chart.plot.PolarPlot" map="a"/>
  <field class="org.jfree.chart.plot.PolarPlot" name="DEFAULT_GRIDLINE_PAINT" map="&#x0145;"/>
  <field class="org.jfree.chart.plot.PolarPlot" name="localizationResources" map="&#x0146;"/>
  <field class="org.jfree.chart.plot.PolarPlot" name="DEFAULT_GRIDLINE_STROKE" map="&#x0147;"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="boolean isRangeZoomable()" map="&#x00d2;"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="void zoomRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D, boolean)" map="A"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="void rendererChanged(org.jfree.chart.event.RendererChangeEvent)" map="B"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="void zoomDomainAxes(double, double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="B"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="void zoomRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="C"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="boolean isDomainZoomable()" map="&#x00d3;"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="void zoomDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D, boolean)" map="B"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="void setAngleTickUnit(org.jfree.chart.axis.TickUnit)" map="A"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="void setAngleLabelPaint(java.awt.Paint)" map="K"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="void setRadiusGridlinePaint(java.awt.Paint)" map="L"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="org.jfree.chart.axis.ValueAxis getAxis()" map="&#x00d4;"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="org.jfree.chart.plot.PlotOrientation getOrientation()" map="&#x00d1;"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="org.jfree.chart.axis.TickUnit getAngleTickUnit()" map="&#x00d5;"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="void setAngleLabelFont(java.awt.Font)" map="C"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="double getAngleOffset()" map="&#x00d6;"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="org.jfree.data.Range getDataRange(org.jfree.chart.axis.ValueAxis)" map="A"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="void zoomRangeAxes(double, double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="A"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="void setAngleGridlinePaint(java.awt.Paint)" map="M"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="void zoomDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="D"/>
  <method class="org.jfree.chart.plot.PolarPlot" name="void setAngleOffset(double)" map="F"/>
  <class name="org.jfree.chart.plot.MeterPlot" map="b"/>
  <field class="org.jfree.chart.plot.MeterPlot" name="DEFAULT_VALUE_FONT" map="&#x0201;"/>
  <field class="org.jfree.chart.plot.MeterPlot" name="DEFAULT_DIAL_BACKGROUND_PAINT" map="&#x0202;"/>
  <field class="org.jfree.chart.plot.MeterPlot" name="localizationResources" map="&#x0203;"/>
  <field class="org.jfree.chart.plot.MeterPlot" name="DEFAULT_VALUE_PAINT" map="&#x0204;"/>
  <field class="org.jfree.chart.plot.MeterPlot" name="DEFAULT_NEEDLE_PAINT" map="&#x0205;"/>
  <field class="org.jfree.chart.plot.MeterPlot" name="DEFAULT_LABEL_FONT" map="&#x0206;"/>
  <method class="org.jfree.chart.plot.MeterPlot" name="void setTickLabelFont(java.awt.Font)" map="F"/>
  <method class="org.jfree.chart.plot.MeterPlot" name="void setDialBackgroundPaint(java.awt.Paint)" map="_"/>
  <method class="org.jfree.chart.plot.MeterPlot" name="void setTickLabelPaint(java.awt.Paint)" map="a"/>
  <method class="org.jfree.chart.plot.MeterPlot" name="void setValueFont(java.awt.Font)" map="G"/>
  <method class="org.jfree.chart.plot.MeterPlot" name="void setValuePaint(java.awt.Paint)" map="b"/>
  <method class="org.jfree.chart.plot.MeterPlot" name="void setDialOutlinePaint(java.awt.Paint)" map="c"/>
  <method class="org.jfree.chart.plot.MeterPlot" name="void setNeedlePaint(java.awt.Paint)" map="d"/>
  <class name="org.jfree.chart.plot.CategoryMarker" map="c"/>
  <method class="org.jfree.chart.plot.CategoryMarker" name="boolean getDrawAsLine()" map="N"/>
  <method class="org.jfree.chart.plot.CategoryMarker" name="java.lang.Comparable getKey()" map="O"/>
  <class name="org.jfree.chart.plot.PieLabelRecord" map="d"/>
  <field class="org.jfree.chart.plot.PieLabelRecord" name="allocatedY" map="A"/>
  <field class="org.jfree.chart.plot.PieLabelRecord" name="linkPercent" map="B"/>
  <field class="org.jfree.chart.plot.PieLabelRecord" name="label" map="C"/>
  <field class="org.jfree.chart.plot.PieLabelRecord" name="baseY" map="D"/>
  <field class="org.jfree.chart.plot.PieLabelRecord" name="key" map="E"/>
  <field class="org.jfree.chart.plot.PieLabelRecord" name="labelHeight" map="F"/>
  <field class="org.jfree.chart.plot.PieLabelRecord" name="angle" map="G"/>
  <field class="org.jfree.chart.plot.PieLabelRecord" name="gap" map="H"/>
  <method class="org.jfree.chart.plot.PieLabelRecord" name="double getAngle()" map="A"/>
  <method class="org.jfree.chart.plot.PieLabelRecord" name="double getLowerY()" map="B"/>
  <method class="org.jfree.chart.plot.PieLabelRecord" name="void setAllocatedY(double)" map="A"/>
  <method class="org.jfree.chart.plot.PieLabelRecord" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.plot.PieLabelRecord" name="double getAllocatedY()" map="C"/>
  <method class="org.jfree.chart.plot.PieLabelRecord" name="double getUpperY()" map="D"/>
  <method class="org.jfree.chart.plot.PieLabelRecord" name="org.jfree.text.TextBox getLabel()" map="E"/>
  <method class="org.jfree.chart.plot.PieLabelRecord" name="java.lang.String toString()" map="toString"/>
  <method class="org.jfree.chart.plot.PieLabelRecord" name="double getLinkPercent()" map="F"/>
  <method class="org.jfree.chart.plot.PieLabelRecord" name="double getLabelHeight()" map="G"/>
  <method class="org.jfree.chart.plot.PieLabelRecord" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <method class="org.jfree.chart.plot.PieLabelRecord" name="double getGap()" map="H"/>
  <class name="org.jfree.chart.plot.DefaultDrawingSupplier" map="e"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="DEFAULT_SHAPE_SEQUENCE" map="&#x03e0;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="DEFAULT_STROKE_SEQUENCE" map="&#x03e2;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="paintIndex" map="&#x03e3;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="fillPaintIndex" map="&#x03e4;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="shapeIndex" map="&#x03e5;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="outlinePaintSequence" map="&#x03e6;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="strokeIndex" map="&#x03e7;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="outlinePaintIndex" map="&#x03e8;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="outlineStrokeIndex" map="&#x03e9;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="DEFAULT_OUTLINE_PAINT_SEQUENCE" map="&#x03ea;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="shapeSequence" map="&#x03eb;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="strokeSequence" map="&#x03ec;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="DEFAULT_FILL_PAINT_SEQUENCE" map="&#x03ed;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="paintSequence" map="&#x03ee;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="DEFAULT_OUTLINE_STROKE_SEQUENCE" map="&#x03ef;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="fillPaintSequence" map="&#x03f0;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="DEFAULT_PAINT_SEQUENCE" map="&#x03f1;"/>
  <field class="org.jfree.chart.plot.DefaultDrawingSupplier" name="outlineStrokeSequence" map="&#x03f2;"/>
  <method class="org.jfree.chart.plot.DefaultDrawingSupplier" name="java.awt.Paint getNextOutlinePaint()" map="&#x01a2;"/>
  <method class="org.jfree.chart.plot.DefaultDrawingSupplier" name="java.awt.Paint getNextPaint()" map="&#x01a5;"/>
  <method class="org.jfree.chart.plot.DefaultDrawingSupplier" name="int[] intArray(double, double, double, double)" map="B"/>
  <method class="org.jfree.chart.plot.DefaultDrawingSupplier" name="java.awt.Shape[] createStandardSeriesShapes()" map="&#x01a7;"/>
  <method class="org.jfree.chart.plot.DefaultDrawingSupplier" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.plot.DefaultDrawingSupplier" name="java.awt.Stroke getNextOutlineStroke()" map="&#x01a3;"/>
  <method class="org.jfree.chart.plot.DefaultDrawingSupplier" name="boolean equalShapes(java.awt.Shape[], java.awt.Shape[])" map="A"/>
  <method class="org.jfree.chart.plot.DefaultDrawingSupplier" name="java.awt.Stroke getNextStroke()" map="&#x01a4;"/>
  <method class="org.jfree.chart.plot.DefaultDrawingSupplier" name="java.awt.Paint getNextFillPaint()" map="&#x01a1;"/>
  <method class="org.jfree.chart.plot.DefaultDrawingSupplier" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.plot.DefaultDrawingSupplier" name="java.awt.Shape getNextShape()" map="&#x01a6;"/>
  <method class="org.jfree.chart.plot.DefaultDrawingSupplier" name="int[] intArray(double, double, double)" map="A"/>
  <class name="org.jfree.chart.plot.Plot" map="f"/>
  <field class="org.jfree.chart.plot.Plot" name="backgroundImage" map="&#x0126;"/>
  <field class="org.jfree.chart.plot.Plot" name="outlineVisible" map="&#x0127;"/>
  <field class="org.jfree.chart.plot.Plot" name="backgroundPaint" map="&#x0128;"/>
  <field class="org.jfree.chart.plot.Plot" name="backgroundImageAlignment" map="&#x0129;"/>
  <field class="org.jfree.chart.plot.Plot" name="DEFAULT_OUTLINE_PAINT" map="&#x012a;"/>
  <field class="org.jfree.chart.plot.Plot" name="listenerList" map="&#x012b;"/>
  <field class="org.jfree.chart.plot.Plot" name="foregroundAlpha" map="&#x012c;"/>
  <field class="org.jfree.chart.plot.Plot" name="DEFAULT_BACKGROUND_PAINT" map="&#x012d;"/>
  <field class="org.jfree.chart.plot.Plot" name="noDataMessagePaint" map="&#x012e;"/>
  <field class="org.jfree.chart.plot.Plot" name="drawingSupplier" map="&#x012f;"/>
  <field class="org.jfree.chart.plot.Plot" name="class$org$jfree$chart$event$PlotChangeListener" map="class$F$B$G$B$D"/>
  <field class="org.jfree.chart.plot.Plot" name="noDataMessageFont" map="&#x0130;"/>
  <field class="org.jfree.chart.plot.Plot" name="parent" map="&#x0131;"/>
  <field class="org.jfree.chart.plot.Plot" name="noDataMessage" map="&#x0132;"/>
  <field class="org.jfree.chart.plot.Plot" name="DEFAULT_LEGEND_ITEM_CIRCLE" map="&#x0133;"/>
  <field class="org.jfree.chart.plot.Plot" name="DEFAULT_OUTLINE_STROKE" map="&#x0134;"/>
  <field class="org.jfree.chart.plot.Plot" name="notify" map="&#x0135;"/>
  <field class="org.jfree.chart.plot.Plot" name="DEFAULT_LEGEND_ITEM_BOX" map="&#x0136;"/>
  <field class="org.jfree.chart.plot.Plot" name="backgroundAlpha" map="&#x0137;"/>
  <field class="org.jfree.chart.plot.Plot" name="insets" map="&#x0138;"/>
  <field class="org.jfree.chart.plot.Plot" name="ZERO" map="&#x0139;"/>
  <field class="org.jfree.chart.plot.Plot" name="datasetGroup" map="&#x013a;"/>
  <field class="org.jfree.chart.plot.Plot" name="DEFAULT_INSETS" map="&#x013b;"/>
  <field class="org.jfree.chart.plot.Plot" name="outlineStroke" map="&#x013c;"/>
  <field class="org.jfree.chart.plot.Plot" name="outlinePaint" map="&#x013d;"/>
  <field class="org.jfree.chart.plot.Plot" name="backgroundImageAlpha" map="&#x013e;"/>
  <method class="org.jfree.chart.plot.Plot" name="java.awt.Paint getOutlinePaint()" map="&#x00c2;"/>
  <method class="org.jfree.chart.plot.Plot" name="void axisChanged(org.jfree.chart.event.AxisChangeEvent)" map="A"/>
  <method class="org.jfree.chart.plot.Plot" name="float getForegroundAlpha()" map="&#x00c3;"/>
  <method class="org.jfree.chart.plot.Plot" name="org.jfree.ui.RectangleEdge resolveDomainAxisLocation(org.jfree.chart.axis.AxisLocation, org.jfree.chart.plot.PlotOrientation)" map="A"/>
  <method class="org.jfree.chart.plot.Plot" name="void setOutlinePaint(java.awt.Paint)" map="G"/>
  <method class="org.jfree.chart.plot.Plot" name="void setDrawingSupplier(org.jfree.chart.plot.DrawingSupplier)" map="A"/>
  <method class="org.jfree.chart.plot.Plot" name="java.lang.String getPlotType()" map="&#x00c4;"/>
  <method class="org.jfree.chart.plot.Plot" name="void drawBackgroundImage(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="B"/>
  <method class="org.jfree.chart.plot.Plot" name="org.jfree.ui.RectangleInsets getInsets()" map="&#x00c5;"/>
  <method class="org.jfree.chart.plot.Plot" name="org.jfree.chart.plot.Plot getParent()" map="&#x00c6;"/>
  <method class="org.jfree.chart.plot.Plot" name="org.jfree.chart.LegendItemCollection getLegendItems()" map="S"/>
  <method class="org.jfree.chart.plot.Plot" name="void fillBackground(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="C"/>
  <method class="org.jfree.chart.plot.Plot" name="void setBackgroundPaint(java.awt.Paint)" map="H"/>
  <method class="org.jfree.chart.plot.Plot" name="void setInsets(org.jfree.ui.RectangleInsets)" map="C"/>
  <method class="org.jfree.chart.plot.Plot" name="void setForegroundAlpha(float)" map="A"/>
  <method class="org.jfree.chart.plot.Plot" name="org.jfree.ui.RectangleEdge resolveRangeAxisLocation(org.jfree.chart.axis.AxisLocation, org.jfree.chart.plot.PlotOrientation)" map="B"/>
  <method class="org.jfree.chart.plot.Plot" name="float getBackgroundAlpha()" map="&#x00c7;"/>
  <method class="org.jfree.chart.plot.Plot" name="java.awt.Paint getBackgroundPaint()" map="&#x00c8;"/>
  <method class="org.jfree.chart.plot.Plot" name="void createAndAddEntity(java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.jfree.chart.plot.Plot" name="org.jfree.chart.plot.DrawingSupplier getDrawingSupplier()" map="&#x00c9;"/>
  <method class="org.jfree.chart.plot.Plot" name="void notifyListeners(org.jfree.chart.event.PlotChangeEvent)" map="B"/>
  <method class="org.jfree.chart.plot.Plot" name="java.awt.Stroke getOutlineStroke()" map="&#x00ca;"/>
  <method class="org.jfree.chart.plot.Plot" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jfree.chart.plot.Plot" name="void fireChangeEvent()" map="&#x00cb;"/>
  <method class="org.jfree.chart.plot.Plot" name="void addChangeListener(org.jfree.chart.event.PlotChangeListener)" map="A"/>
  <method class="org.jfree.chart.plot.Plot" name="void drawOutline(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="D"/>
  <method class="org.jfree.chart.plot.Plot" name="void drawBackground(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="E"/>
  <method class="org.jfree.chart.plot.Plot" name="boolean isOutlineVisible()" map="&#x00cc;"/>
  <method class="org.jfree.chart.plot.Plot" name="void setNotify(boolean)" map="M"/>
  <method class="org.jfree.chart.plot.Plot" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.plot.Plot" name="void fillBackground(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotOrientation)" map="A"/>
  <method class="org.jfree.chart.plot.Plot" name="void setInsets(org.jfree.ui.RectangleInsets, boolean)" map="A"/>
  <method class="org.jfree.chart.plot.Plot" name="void drawNoDataMessage(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="F"/>
  <method class="org.jfree.chart.plot.Plot" name="void draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.awt.geom.Point2D, org.jfree.chart.plot.PlotState, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.plot.Plot" name="void datasetChanged(org.jfree.data.general.DatasetChangeEvent)" map="B"/>
  <method class="org.jfree.chart.plot.Plot" name="void setOutlineStroke(java.awt.Stroke)" map="A"/>
  <method class="org.jfree.chart.plot.Plot" name="boolean isNotify()" map="&#x00cd;"/>
  <method class="org.jfree.chart.plot.Plot" name="java.lang.Object clone()" map="clone"/>
  <class name="org.jfree.chart.plot.DatasetRenderingOrder" map="g"/>
  <field class="org.jfree.chart.plot.DatasetRenderingOrder" name="FORWARD" map="A"/>
  <field class="org.jfree.chart.plot.DatasetRenderingOrder" name="name" map="B"/>
  <field class="org.jfree.chart.plot.DatasetRenderingOrder" name="REVERSE" map="C"/>
  <method class="org.jfree.chart.plot.DatasetRenderingOrder" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.plot.DatasetRenderingOrder" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.plot.DatasetRenderingOrder" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.chart.plot.Zoomable" map="h"/>
  <method class="org.jfree.chart.plot.Zoomable" name="void zoomRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D, boolean)" map="A"/>
  <method class="org.jfree.chart.plot.Zoomable" name="void zoomDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D, boolean)" map="B"/>
  <method class="org.jfree.chart.plot.Zoomable" name="boolean isRangeZoomable()" map="&#x00d2;"/>
  <method class="org.jfree.chart.plot.Zoomable" name="org.jfree.chart.plot.PlotOrientation getOrientation()" map="&#x00d1;"/>
  <method class="org.jfree.chart.plot.Zoomable" name="void zoomRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="C"/>
  <method class="org.jfree.chart.plot.Zoomable" name="boolean isDomainZoomable()" map="&#x00d3;"/>
  <method class="org.jfree.chart.plot.Zoomable" name="void zoomRangeAxes(double, double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="A"/>
  <method class="org.jfree.chart.plot.Zoomable" name="void zoomDomainAxes(double, double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="B"/>
  <method class="org.jfree.chart.plot.Zoomable" name="void zoomDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="D"/>
  <class name="org.jfree.chart.plot.XYPlot" map="i"/>
  <field class="org.jfree.chart.plot.XYPlot" name="backgroundRangeMarkers" map="&#x0148;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="fixedRangeAxisSpace" map="&#x0149;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainTickBandPaint" map="&#x014a;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeCrosshairPaint" map="&#x014b;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainGridlinesVisible" map="&#x014c;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeGridlinesVisible" map="&#x014d;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainCrosshairStroke" map="&#x014e;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainCrosshairLockedOnData" map="&#x014f;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeMinorGridlinesVisible" map="&#x0150;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="datasetToDomainAxesMap" map="&#x0151;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="DEFAULT_CROSSHAIR_STROKE" map="&#x0152;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeZeroBaselineStroke" map="&#x0153;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeCrosshairStroke" map="&#x0154;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainGridlineStroke" map="&#x0155;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="quadrantPaint" map="&#x0156;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeMinorGridlineStroke" map="&#x0157;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainCrosshairVisible" map="&#x0158;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeCrosshairVisible" map="&#x0159;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="renderers" map="&#x015a;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="fixedLegendItems" map="&#x015b;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="foregroundDomainMarkers" map="&#x015c;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainMinorGridlineStroke" map="&#x015d;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeAxisLocations" map="&#x015e;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="orientation" map="&#x015f;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="annotations" map="&#x0160;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="datasetToRangeAxesMap" map="&#x0161;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="datasetRenderingOrder" map="&#x0162;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainCrosshairValue" map="&#x0163;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainMinorGridlinesVisible" map="&#x0164;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainAxes" map="&#x0165;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="DEFAULT_GRIDLINE_PAINT" map="&#x0166;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainMinorGridlinePaint" map="&#x0167;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="backgroundDomainMarkers" map="&#x0168;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeAxes" map="&#x0169;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="DEFAULT_GRIDLINE_STROKE" map="&#x016a;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="shadowGenerator" map="&#x016b;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="quadrantOrigin" map="&#x016c;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainAxisLocations" map="&#x016d;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainCrosshairPaint" map="&#x016e;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainZeroBaselinePaint" map="&#x016f;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeGridlineStroke" map="&#x0170;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="seriesRenderingOrder" map="&#x0171;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="fixedDomainAxisSpace" map="&#x0172;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="weight" map="&#x0173;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeCrosshairLockedOnData" map="&#x0174;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeZeroBaselineVisible" map="&#x0175;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="datasets" map="&#x0176;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeGridlinePaint" map="&#x0177;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainPannable" map="&#x0178;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="DEFAULT_CROSSHAIR_PAINT" map="&#x0179;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="localizationResources" map="&#x017a;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeMinorGridlinePaint" map="&#x017b;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainZeroBaselineVisible" map="&#x017c;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="foregroundRangeMarkers" map="&#x017d;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeTickBandPaint" map="&#x017e;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeZeroBaselinePaint" map="&#x017f;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangeCrosshairValue" map="&#x0180;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="rangePannable" map="&#x0181;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainZeroBaselineStroke" map="&#x0182;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="domainGridlinePaint" map="&#x0183;"/>
  <field class="org.jfree.chart.plot.XYPlot" name="axisOffset" map="&#x0184;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.axis.ValueAxis getRangeAxis(int)" map="q"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.awt.Stroke getRangeMinorGridlineStroke()" map="&#x00d8;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="double getDomainCrosshairValue()" map="&#x00d9;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void configureRangeAxes()" map="&#x00da;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.axis.AxisLocation getDomainAxisLocation(int)" map="r"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void datasetChanged(org.jfree.data.general.DatasetChangeEvent)" map="B"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.util.Collection getDomainMarkers(int, org.jfree.ui.Layer)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.awt.Rectangle integerise(java.awt.geom.Rectangle2D)" map="E"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void rendererChanged(org.jfree.chart.event.RendererChangeEvent)" map="B"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void drawZeroRangeBaseline(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="G"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.renderer.xy.XYItemRenderer getRendererForDataset(org.jfree.data.xy.XYDataset)" map="C"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.awt.Paint getDomainGridlinePaint()" map="&#x00db;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void setRangeCrosshairValue(double, boolean)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.axis.AxisLocation getRangeAxisLocation()" map="&#x00dc;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void setRenderer(int, org.jfree.chart.renderer.xy.XYItemRenderer, boolean)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.axis.AxisSpace calculateRangeAxisSpace(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.axis.AxisSpace)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void zoomRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="C"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void drawRangeMarkers(java.awt.Graphics2D, java.awt.geom.Rectangle2D, int, org.jfree.ui.Layer)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.awt.Paint getRangeGridlinePaint()" map="&#x00dd;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="int getDomainAxisCount()" map="&#x00de;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.axis.AxisSpace calculateDomainAxisSpace(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.axis.AxisSpace)" map="B"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.awt.Stroke getRangeGridlineStroke()" map="&#x00df;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.axis.ValueAxis getDomainAxis(int)" map="s"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean isDomainMinorGridlinesVisible()" map="&#x00e0;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void drawDomainCrosshair(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotOrientation, double, org.jfree.chart.axis.ValueAxis, java.awt.Stroke, java.awt.Paint)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean isDomainPannable()" map="&#x00cf;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.awt.Stroke getDomainMinorGridlineStroke()" map="&#x00e1;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean render(java.awt.Graphics2D, java.awt.geom.Rectangle2D, int, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.CrosshairState)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void panDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="B"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void drawBackground(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="E"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void setDomainCrosshairValue(double, boolean)" map="B"/>
  <method class="org.jfree.chart.plot.XYPlot" name="int getDomainAxisIndex(org.jfree.chart.axis.ValueAxis)" map="B"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.axis.ValueAxis getDomainAxisForDataset(int)" map="t"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean isRangeGridlinesVisible()" map="&#x00e2;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.util.Collection getRangeMarkers(int, org.jfree.ui.Layer)" map="B"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean isRangeZoomable()" map="&#x00d2;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void setRangeGridlinePaint(java.awt.Paint)" map="N"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.plot.PlotOrientation getOrientation()" map="&#x00d1;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.awt.Paint getRangeMinorGridlinePaint()" map="&#x00e3;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="int getRendererCount()" map="&#x00e4;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void drawRangeTickBands(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.util.List)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean isRangeCrosshairLockedOnData()" map="&#x00e5;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.plot.XYPlot" name="int getDatasetCount()" map="&#x00e6;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.awt.Paint getDomainTickBandPaint()" map="&#x00e7;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.awt.Paint getDomainCrosshairPaint()" map="&#x00e8;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void zoomDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="D"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void zoomDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D, boolean)" map="B"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void setRenderer(org.jfree.chart.renderer.xy.XYItemRenderer)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="double getRangeCrosshairValue()" map="&#x00e9;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void drawZeroDomainBaseline(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="H"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void setOrientation(org.jfree.chart.plot.PlotOrientation)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean isDomainGridlinesVisible()" map="&#x00ea;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void setShadowGenerator(org.jfree.chart.util.ShadowGenerator)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void mapDatasetToDomainAxis(int, int)" map="w"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void zoomRangeAxes(double, double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.plot.SeriesRenderingOrder getSeriesRenderingOrder()" map="&#x00eb;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.util.List getAnnotations()" map="&#x00ec;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void setDomainCrosshairPaint(java.awt.Paint)" map="O"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.ui.RectangleEdge getRangeAxisEdge(int)" map="u"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.renderer.xy.XYItemRenderer getRenderer()" map="&#x00ed;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.ui.RectangleEdge getRangeAxisEdge()" map="&#x00ee;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.awt.Paint getRangeTickBandPaint()" map="&#x00ef;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="int getRangeAxisCount()" map="&#x00f0;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void mapDatasetToRangeAxis(int, int)" map="x"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.awt.Paint getRangeCrosshairPaint()" map="&#x00f1;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.data.xy.XYDataset getDataset(int)" map="v"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void mapDatasetToRangeAxes(int, java.util.List)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void setDomainGridlinePaint(java.awt.Paint)" map="P"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void drawQuadrants(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="I"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.lang.String getPlotType()" map="&#x00c4;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.axis.AxisLocation getRangeAxisLocation(int)" map="w"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void configureDomainAxes()" map="&#x00f2;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.awt.Stroke getRangeCrosshairStroke()" map="&#x00f3;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void drawDomainMarkers(java.awt.Graphics2D, java.awt.geom.Rectangle2D, int, org.jfree.ui.Layer)" map="B"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void setRangeCrosshairPaint(java.awt.Paint)" map="Q"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.axis.ValueAxis getRangeAxisForDataset(int)" map="x"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.awt.Paint getDomainMinorGridlinePaint()" map="&#x00f4;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void drawDomainGridlines(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.util.List)" map="B"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.data.Range getDataRange(org.jfree.chart.axis.ValueAxis)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.ui.RectangleEdge getDomainAxisEdge(int)" map="y"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.util.Map drawAxes(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean isDomainZoomable()" map="&#x00d3;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.axis.ValueAxis getRangeAxis()" map="&#x00f5;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void drawAnnotations(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="int getIndexOf(org.jfree.chart.renderer.xy.XYItemRenderer)" map="B"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void setAxisOffset(org.jfree.ui.RectangleInsets)" map="D"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean isRangeMinorGridlinesVisible()" map="&#x00f6;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.ui.RectangleEdge getDomainAxisEdge()" map="&#x00f8;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean isDomainCrosshairLockedOnData()" map="&#x00f9;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.axis.AxisSpace calculateAxisSpace(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="J"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean isRangeZeroBaselineVisible()" map="&#x00fa;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void panRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="int getRangeAxisIndex(org.jfree.chart.axis.ValueAxis)" map="C"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.axis.AxisLocation getDomainAxisLocation()" map="&#x00fb;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean isRangeCrosshairVisible()" map="&#x00fc;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.awt.Stroke getDomainCrosshairStroke()" map="&#x00fd;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void drawRangeCrosshair(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotOrientation, double, org.jfree.chart.axis.ValueAxis, java.awt.Stroke, java.awt.Paint)" map="B"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.awt.Stroke getDomainGridlineStroke()" map="&#x00fe;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.axis.ValueAxis getDomainAxis()" map="&#x00ff;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void zoomRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D, boolean)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.util.List getDatasetsMappedToDomainAxis(java.lang.Integer)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void setRenderer(int, org.jfree.chart.renderer.xy.XYItemRenderer)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.awt.geom.Point2D, org.jfree.chart.plot.PlotState, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void checkAxisIndices(java.util.List)" map="A"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.renderer.xy.XYItemRenderer getRenderer(int)" map="z"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void mapDatasetToDomainAxes(int, java.util.List)" map="B"/>
  <method class="org.jfree.chart.plot.XYPlot" name="java.util.List getDatasetsMappedToRangeAxis(java.lang.Integer)" map="B"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void setDomainZeroBaselinePaint(java.awt.Paint)" map="R"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean isDomainCrosshairVisible()" map="&#x0100;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void setRangeZeroBaselinePaint(java.awt.Paint)" map="S"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.plot.DatasetRenderingOrder getDatasetRenderingOrder()" map="&#x0101;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean isRangePannable()" map="&#x00d0;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void drawDomainTickBands(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.util.List)" map="C"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void zoomDomainAxes(double, double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="B"/>
  <method class="org.jfree.chart.plot.XYPlot" name="void drawRangeGridlines(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.util.List)" map="D"/>
  <method class="org.jfree.chart.plot.XYPlot" name="boolean isDomainZeroBaselineVisible()" map="&#x0102;"/>
  <method class="org.jfree.chart.plot.XYPlot" name="org.jfree.chart.LegendItemCollection getLegendItems()" map="S"/>
  <class name="org.jfree.chart.plot.FastScatterPlot" map="j"/>
  <field class="org.jfree.chart.plot.FastScatterPlot" name="DEFAULT_GRIDLINE_PAINT" map="&#x01bf;"/>
  <field class="org.jfree.chart.plot.FastScatterPlot" name="localizationResources" map="&#x01c0;"/>
  <field class="org.jfree.chart.plot.FastScatterPlot" name="DEFAULT_GRIDLINE_STROKE" map="&#x01c1;"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="boolean isRangeZoomable()" map="&#x00d2;"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="void setRangeGridlinePaint(java.awt.Paint)" map="X"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="void zoomRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D, boolean)" map="A"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="org.jfree.chart.axis.ValueAxis getDomainAxis()" map="&#x012c;"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="void setDomainGridlinePaint(java.awt.Paint)" map="Y"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="void zoomDomainAxes(double, double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="B"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="void zoomRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="C"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="boolean isDomainZoomable()" map="&#x00d3;"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="void zoomDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D, boolean)" map="B"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="void panRangeAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="A"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="void panDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="B"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="boolean isDomainPannable()" map="&#x00cf;"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="org.jfree.chart.plot.PlotOrientation getOrientation()" map="&#x00d1;"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="org.jfree.data.Range getDataRange(org.jfree.chart.axis.ValueAxis)" map="A"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="void zoomRangeAxes(double, double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="A"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="void zoomDomainAxes(double, org.jfree.chart.plot.PlotRenderingInfo, java.awt.geom.Point2D)" map="D"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="org.jfree.chart.axis.ValueAxis getRangeAxis()" map="&#x012d;"/>
  <method class="org.jfree.chart.plot.FastScatterPlot" name="boolean isRangePannable()" map="&#x00d0;"/>
  <class name="org.jfree.chart.plot.GreyPalette" map="k"/>
  <method class="org.jfree.chart.plot.GreyPalette" name="void initialize()" map="D"/>
  <class name="org.jfree.chart.plot.PieLabelDistributor" map="l"/>
  <field class="org.jfree.chart.plot.PieLabelDistributor" name="minGap" map="B"/>
  <method class="org.jfree.chart.plot.PieLabelDistributor" name="void adjustDownwards(double, double)" map="B"/>
  <method class="org.jfree.chart.plot.PieLabelDistributor" name="void distributeLabels(double, double)" map="A"/>
  <method class="org.jfree.chart.plot.PieLabelDistributor" name="void sort()" map="C"/>
  <method class="org.jfree.chart.plot.PieLabelDistributor" name="void adjustUpwards(double, double)" map="C"/>
  <method class="org.jfree.chart.plot.PieLabelDistributor" name="void spreadEvenly(double, double)" map="D"/>
  <method class="org.jfree.chart.plot.PieLabelDistributor" name="java.lang.String toString()" map="toString"/>
  <method class="org.jfree.chart.plot.PieLabelDistributor" name="boolean isOverlap()" map="D"/>
  <class name="org.jfree.chart.plot.CombinedRangeCategoryPlot" map="m"/>
  <method class="org.jfree.chart.plot.CombinedRangeCategoryPlot" name="java.util.List getSubplots()" map="&#x012a;"/>
  <method class="org.jfree.chart.plot.CombinedRangeCategoryPlot" name="void plotChanged(org.jfree.chart.event.PlotChangeEvent)" map="A"/>
  <package name="org.jfree.chart.renderer" map="M"/>
  <package name="org.jfree.chart.renderer.category" map="A"/>
  <class name="org.jfree.chart.renderer.category.GradientBarPainter" map="A"/>
  <field class="org.jfree.chart.renderer.category.GradientBarPainter" name="g3" map="A"/>
  <field class="org.jfree.chart.renderer.category.GradientBarPainter" name="g2" map="B"/>
  <field class="org.jfree.chart.renderer.category.GradientBarPainter" name="g1" map="C"/>
  <method class="org.jfree.chart.renderer.category.GradientBarPainter" name="void paintBarShadow(java.awt.Graphics2D, org.jfree.chart.renderer.category.BarRenderer, int, int, java.awt.geom.RectangularShape, org.jfree.ui.RectangleEdge, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.category.GradientBarPainter" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.renderer.category.GradientBarPainter" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.renderer.category.GradientBarPainter" name="java.awt.geom.Rectangle2D[] splitVerticalBar(java.awt.geom.RectangularShape, double, double, double)" map="A"/>
  <method class="org.jfree.chart.renderer.category.GradientBarPainter" name="java.awt.geom.Rectangle2D createShadow(java.awt.geom.RectangularShape, double, double, org.jfree.ui.RectangleEdge, boolean)" map="B"/>
  <method class="org.jfree.chart.renderer.category.GradientBarPainter" name="java.awt.geom.Rectangle2D[] splitHorizontalBar(java.awt.geom.RectangularShape, double, double, double)" map="B"/>
  <method class="org.jfree.chart.renderer.category.GradientBarPainter" name="void paintBar(java.awt.Graphics2D, org.jfree.chart.renderer.category.BarRenderer, int, int, java.awt.geom.RectangularShape, org.jfree.ui.RectangleEdge)" map="A"/>
  <class name="org.jfree.chart.renderer.category.BarPainter" map="B"/>
  <method class="org.jfree.chart.renderer.category.BarPainter" name="void paintBarShadow(java.awt.Graphics2D, org.jfree.chart.renderer.category.BarRenderer, int, int, java.awt.geom.RectangularShape, org.jfree.ui.RectangleEdge, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.category.BarPainter" name="void paintBar(java.awt.Graphics2D, org.jfree.chart.renderer.category.BarRenderer, int, int, java.awt.geom.RectangularShape, org.jfree.ui.RectangleEdge)" map="A"/>
  <class name="org.jfree.chart.renderer.category.GroupedStackedBarRenderer" map="C"/>
  <class name="org.jfree.chart.renderer.category.BarRenderer3D" map="D"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer3D" name="DEFAULT_WALL_PAINT" map="&#x0124;"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer3D" name="void setWallPaint(java.awt.Paint)" map="D"/>
  <class name="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" map="E"/>
  <field class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="legendItemLabelGenerator" map="&#x0102;"/>
  <field class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="itemURLGeneratorList" map="&#x0103;"/>
  <field class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="itemURLGenerator" map="&#x0104;"/>
  <field class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="itemLabelGeneratorList" map="&#x0105;"/>
  <field class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="toolTipGeneratorList" map="&#x0106;"/>
  <field class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="itemLabelGenerator" map="&#x0107;"/>
  <field class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="columnCount" map="&#x0108;"/>
  <field class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="plot" map="&#x0109;"/>
  <field class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="baseToolTipGenerator" map="&#x010a;"/>
  <field class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="legendItemToolTipGenerator" map="&#x010b;"/>
  <field class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="rowCount" map="&#x010c;"/>
  <field class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="baseItemLabelGenerator" map="&#x010d;"/>
  <field class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="toolTipGenerator" map="&#x010e;"/>
  <field class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="legendItemURLGenerator" map="&#x010f;"/>
  <field class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="baseItemURLGenerator" map="&#x0110;"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="void drawRangeGridline(java.awt.Graphics2D, org.jfree.chart.plot.CategoryPlot, org.jfree.chart.axis.ValueAxis, java.awt.geom.Rectangle2D, double)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="void setPlot(org.jfree.chart.plot.CategoryPlot)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.labels.CategoryItemLabelGenerator getItemLabelGenerator(int, int)" map="s"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="double getItemMiddle(java.lang.Comparable, java.lang.Comparable, org.jfree.data.category.CategoryDataset, org.jfree.chart.axis.CategoryAxis, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="void drawOutline(java.awt.Graphics2D, org.jfree.chart.plot.CategoryPlot, java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="java.awt.geom.Point2D calculateRangeMarkerTextAnchorPoint(java.awt.Graphics2D, org.jfree.chart.plot.PlotOrientation, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleInsets, org.jfree.ui.LengthAdjustmentType, org.jfree.ui.RectangleAnchor)" map="C"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.axis.CategoryAxis getDomainAxis(org.jfree.chart.plot.CategoryPlot, int)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="int getColumnCount()" map="k"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.labels.CategoryToolTipGenerator getSeriesToolTipGenerator(int)" map="n"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.plot.CategoryPlot getPlot()" map="l"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="void drawRangeMarker(java.awt.Graphics2D, org.jfree.chart.plot.CategoryPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.plot.Marker, java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.LegendItemCollection getLegendItems()" map="S"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="void drawDomainGridline(java.awt.Graphics2D, org.jfree.chart.plot.CategoryPlot, java.awt.geom.Rectangle2D, double)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.category.CategoryDataset, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="void drawRangeLine(java.awt.Graphics2D, org.jfree.chart.plot.CategoryPlot, org.jfree.chart.axis.ValueAxis, java.awt.geom.Rectangle2D, double, java.awt.Paint, java.awt.Stroke)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.renderer.category.CategoryItemRendererState initialise(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.CategoryPlot, int, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="void drawDomainMarker(java.awt.Graphics2D, org.jfree.chart.plot.CategoryPlot, org.jfree.chart.axis.CategoryAxis, org.jfree.chart.plot.CategoryMarker, java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.plot.DrawingSupplier getDrawingSupplier()" map="U"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="void drawBackground(java.awt.Graphics2D, org.jfree.chart.plot.CategoryPlot, java.awt.geom.Rectangle2D)" map="B"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="int getRowCount()" map="m"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.renderer.category.CategoryItemRendererState createState(org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.category.CategoryDataset)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="void setBaseItemLabelGenerator(org.jfree.chart.labels.CategoryItemLabelGenerator)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="void setBaseItemURLGenerator(org.jfree.chart.urls.CategoryURLGenerator)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.urls.CategoryURLGenerator getSeriesItemURLGenerator(int)" map="o"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.labels.CategorySeriesLabelGenerator getLegendItemToolTipGenerator()" map="n"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.LegendItem getLegendItem(int, int)" map="t"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="void setBaseToolTipGenerator(org.jfree.chart.labels.CategoryToolTipGenerator)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="java.awt.geom.Point2D calculateDomainMarkerTextAnchorPoint(java.awt.Graphics2D, org.jfree.chart.plot.PlotOrientation, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleInsets, org.jfree.ui.LengthAdjustmentType, org.jfree.ui.RectangleAnchor)" map="D"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.labels.CategoryItemLabelGenerator getSeriesItemLabelGenerator(int)" map="p"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.labels.CategoryToolTipGenerator getToolTipGenerator(int, int)" map="u"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="void addItemEntity(org.jfree.chart.entity.EntityCollection, org.jfree.data.category.CategoryDataset, int, int, java.awt.Shape)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="void updateCrosshairValues(org.jfree.chart.plot.CategoryCrosshairState, java.lang.Comparable, java.lang.Comparable, double, int, double, double, org.jfree.chart.plot.PlotOrientation)" map="A"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.labels.CategorySeriesLabelGenerator getLegendItemURLGenerator()" map="o"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.labels.CategorySeriesLabelGenerator getLegendItemLabelGenerator()" map="p"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="int getPassCount()" map="T"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="org.jfree.chart.urls.CategoryURLGenerator getItemURLGenerator(int, int)" map="v"/>
  <method class="org.jfree.chart.renderer.category.AbstractCategoryItemRenderer" name="java.lang.Object clone()" map="clone"/>
  <class name="org.jfree.chart.renderer.category.StackedAreaRenderer" map="F"/>
  <class name="org.jfree.chart.renderer.category.StandardBarPainter" map="G"/>
  <method class="org.jfree.chart.renderer.category.StandardBarPainter" name="void paintBarShadow(java.awt.Graphics2D, org.jfree.chart.renderer.category.BarRenderer, int, int, java.awt.geom.RectangularShape, org.jfree.ui.RectangleEdge, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.category.StandardBarPainter" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.renderer.category.StandardBarPainter" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.renderer.category.StandardBarPainter" name="java.awt.geom.Rectangle2D createShadow(java.awt.geom.RectangularShape, double, double, org.jfree.ui.RectangleEdge, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.category.StandardBarPainter" name="void paintBar(java.awt.Graphics2D, org.jfree.chart.renderer.category.BarRenderer, int, int, java.awt.geom.RectangularShape, org.jfree.ui.RectangleEdge)" map="A"/>
  <class name="org.jfree.chart.renderer.category.BarRenderer" map="H"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="defaultBarPainter" map="&#x0111;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="shadowYOffset" map="&#x0112;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="maximumBarWidth" map="&#x0113;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="base" map="&#x0114;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="minimumBarLength" map="&#x0115;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="shadowPaint" map="&#x0116;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="negativeItemLabelPositionFallback" map="&#x0117;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="barPainter" map="&#x0118;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="includeBaseInRange" map="&#x0119;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="itemMargin" map="&#x011a;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="positiveItemLabelPositionFallback" map="&#x011b;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="gradientPaintTransformer" map="&#x011c;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="upperClip" map="&#x011d;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="drawBarOutline" map="&#x011e;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="shadowXOffset" map="&#x011f;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="defaultShadowsVisible" map="&#x0120;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="lowerClip" map="&#x0121;"/>
  <field class="org.jfree.chart.renderer.category.BarRenderer" name="shadowsVisible" map="&#x0122;"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="boolean getShadowsVisible()" map="q"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="boolean isInternalAnchor(org.jfree.chart.labels.ItemLabelAnchor)" map="A"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="void setPositiveItemLabelPositionFallback(org.jfree.chart.labels.ItemLabelPosition)" map="C"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="java.awt.geom.Point2D calculateLabelAnchorPoint(org.jfree.chart.labels.ItemLabelAnchor, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotOrientation)" map="A"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="void setBarPainter(org.jfree.chart.renderer.category.BarPainter)" map="A"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="org.jfree.chart.LegendItem getLegendItem(int, int)" map="t"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="double getShadowYOffset()" map="r"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="double calculateSeriesWidth(double, org.jfree.chart.axis.CategoryAxis, int, int)" map="A"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="double getMaximumBarWidth()" map="s"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="org.jfree.chart.labels.ItemLabelPosition getPositiveItemLabelPositionFallback()" map="t"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.category.CategoryDataset, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="org.jfree.chart.renderer.category.CategoryItemRendererState initialise(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.CategoryPlot, int, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="boolean isDrawBarOutline()" map="u"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="double getLowerClip()" map="v"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="double getMinimumBarLength()" map="w"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="double getItemMargin()" map="x"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="void setDrawBarOutline(boolean)" map="I"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="java.awt.Paint getShadowPaint()" map="y"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="double calculateBarW0(org.jfree.chart.plot.CategoryPlot, org.jfree.chart.plot.PlotOrientation, java.awt.geom.Rectangle2D, org.jfree.chart.axis.CategoryAxis, org.jfree.chart.renderer.category.CategoryItemRendererState, int, int)" map="A"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="void setShadowVisible(boolean)" map="J"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="double[] calculateBarL0L1(double)" map="E"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="org.jfree.ui.GradientPaintTransformer getGradientPaintTransformer()" map="z"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="org.jfree.chart.renderer.category.BarPainter getDefaultBarPainter()" map="&#x00a2;"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="void drawItemLabel(java.awt.Graphics2D, org.jfree.data.category.CategoryDataset, int, int, org.jfree.chart.plot.CategoryPlot, org.jfree.chart.labels.CategoryItemLabelGenerator, java.awt.geom.Rectangle2D, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="double getShadowXOffset()" map="&#x00a3;"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="org.jfree.chart.labels.ItemLabelPosition getNegativeItemLabelPositionFallback()" map="&#x00a4;"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="double getUpperClip()" map="&#x00a5;"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="void setNegativeItemLabelPositionFallback(org.jfree.chart.labels.ItemLabelPosition)" map="D"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="double getBase()" map="&#x00aa;"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="boolean getDefaultShadowsVisible()" map="&#x00b5;"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="void setShadowPaint(java.awt.Paint)" map="B"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="void calculateBarWidth(org.jfree.chart.plot.CategoryPlot, java.awt.geom.Rectangle2D, int, org.jfree.chart.renderer.category.CategoryItemRendererState)" map="A"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.category.CategoryItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.CategoryPlot, org.jfree.chart.axis.CategoryAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.category.CategoryDataset, int, int, int)" map="A"/>
  <method class="org.jfree.chart.renderer.category.BarRenderer" name="org.jfree.chart.renderer.category.BarPainter getBarPainter()" map="&#x00ba;"/>
  <class name="org.jfree.chart.renderer.category.CategoryItemRenderer" map="I"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="double getItemMiddle(java.lang.Comparable, java.lang.Comparable, org.jfree.data.category.CategoryDataset, org.jfree.chart.axis.CategoryAxis, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="boolean isSeriesVisibleInLegend(int)" map="J"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="void drawRangeMarker(java.awt.Graphics2D, org.jfree.chart.plot.CategoryPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.plot.Marker, java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="boolean isSeriesVisible(int)" map="K"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="void drawRangeGridline(java.awt.Graphics2D, org.jfree.chart.plot.CategoryPlot, org.jfree.chart.axis.ValueAxis, java.awt.geom.Rectangle2D, double)" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="void drawOutline(java.awt.Graphics2D, org.jfree.chart.plot.CategoryPlot, java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="void setBaseItemLabelPaint(java.awt.Paint)" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="org.jfree.chart.renderer.category.CategoryItemRendererState initialise(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.CategoryPlot, int, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="void removeChangeListener(org.jfree.chart.event.RendererChangeListener)" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="void setBaseItemLabelFont(java.awt.Font)" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.category.CategoryDataset)" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="void drawDomainMarker(java.awt.Graphics2D, org.jfree.chart.plot.CategoryPlot, org.jfree.chart.axis.CategoryAxis, org.jfree.chart.plot.CategoryMarker, java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="int getPassCount()" map="T"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="void drawDomainGridline(java.awt.Graphics2D, org.jfree.chart.plot.CategoryPlot, java.awt.geom.Rectangle2D, double)" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="void addChangeListener(org.jfree.chart.event.RendererChangeListener)" map="B"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="void setPlot(org.jfree.chart.plot.CategoryPlot)" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="void drawBackground(java.awt.Graphics2D, org.jfree.chart.plot.CategoryPlot, java.awt.geom.Rectangle2D)" map="B"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.category.CategoryItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.CategoryPlot, org.jfree.chart.axis.CategoryAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.category.CategoryDataset, int, int, int)" map="A"/>
  <class name="org.jfree.chart.renderer.category.LevelRenderer" map="J"/>
  <class name="org.jfree.chart.renderer.category.StackedBarRenderer" map="K"/>
  <field class="org.jfree.chart.renderer.category.StackedBarRenderer" name="renderAsPercentages" map="&#x0125;"/>
  <method class="org.jfree.chart.renderer.category.StackedBarRenderer" name="void calculateBarWidth(org.jfree.chart.plot.CategoryPlot, java.awt.geom.Rectangle2D, int, org.jfree.chart.renderer.category.CategoryItemRendererState)" map="A"/>
  <method class="org.jfree.chart.renderer.category.StackedBarRenderer" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.renderer.category.StackedBarRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.category.CategoryDataset)" map="A"/>
  <method class="org.jfree.chart.renderer.category.StackedBarRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.category.CategoryItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.CategoryPlot, org.jfree.chart.axis.CategoryAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.category.CategoryDataset, int, int, int)" map="A"/>
  <method class="org.jfree.chart.renderer.category.StackedBarRenderer" name="int getPassCount()" map="T"/>
  <class name="org.jfree.chart.renderer.category.BoxAndWhiskerRenderer" map="L"/>
  <class name="org.jfree.chart.renderer.category.CategoryItemRendererState" map="M"/>
  <field class="org.jfree.chart.renderer.category.CategoryItemRendererState" name="visibleSeries" map="B"/>
  <field class="org.jfree.chart.renderer.category.CategoryItemRendererState" name="barWidth" map="C"/>
  <field class="org.jfree.chart.renderer.category.CategoryItemRendererState" name="seriesRunningTotal" map="D"/>
  <field class="org.jfree.chart.renderer.category.CategoryItemRendererState" name="crosshairState" map="E"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRendererState" name="int getVisibleSeriesIndex(int)" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRendererState" name="int getVisibleSeriesCount()" map="C"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRendererState" name="void setCrosshairState(org.jfree.chart.plot.CategoryCrosshairState)" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRendererState" name="org.jfree.chart.plot.CategoryCrosshairState getCrosshairState()" map="D"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRendererState" name="void setBarWidth(double)" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRendererState" name="double getBarWidth()" map="E"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRendererState" name="void setVisibleSeriesArray(int[])" map="A"/>
  <method class="org.jfree.chart.renderer.category.CategoryItemRendererState" name="int[] getVisibleSeriesArray()" map="F"/>
  <class name="org.jfree.chart.renderer.category.LineAndShapeRenderer" map="N"/>
  <method class="org.jfree.chart.renderer.category.LineAndShapeRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.category.LineAndShapeRenderer" name="void setShapesVisible(boolean)" map="K"/>
  <method class="org.jfree.chart.renderer.category.LineAndShapeRenderer" name="boolean getBaseShapesVisible()" map="&#x00c0;"/>
  <method class="org.jfree.chart.renderer.category.LineAndShapeRenderer" name="boolean getBaseLinesVisible()" map="&#x00c1;"/>
  <method class="org.jfree.chart.renderer.category.LineAndShapeRenderer" name="void setLinesVisible(boolean)" map="L"/>
  <class name="org.jfree.chart.renderer.category.MinMaxCategoryRenderer" map="O"/>
  <method class="org.jfree.chart.renderer.category.MinMaxCategoryRenderer" name="void setGroupPaint(java.awt.Paint)" map="F"/>
  <class name="org.jfree.chart.renderer.category.StackedBarRenderer3D" map="P"/>
  <class name="org.jfree.chart.renderer.category.AreaRenderer" map="Q"/>
  <method class="org.jfree.chart.renderer.category.AreaRenderer" name="java.lang.Object clone()" map="clone"/>
  <class name="org.jfree.chart.renderer.category.LineRenderer3D" map="R"/>
  <field class="org.jfree.chart.renderer.category.LineRenderer3D" name="DEFAULT_WALL_PAINT" map="&#x0123;"/>
  <method class="org.jfree.chart.renderer.category.LineRenderer3D" name="void setWallPaint(java.awt.Paint)" map="C"/>
  <class name="org.jfree.chart.renderer.category.StatisticalLineAndShapeRenderer" map="S"/>
  <class name="org.jfree.chart.renderer.category.StatisticalBarRenderer" map="T"/>
  <method class="org.jfree.chart.renderer.category.StatisticalBarRenderer" name="void setErrorIndicatorPaint(java.awt.Paint)" map="E"/>
  <method class="org.jfree.chart.renderer.category.StatisticalBarRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.category.CategoryDataset)" map="A"/>
  <method class="org.jfree.chart.renderer.category.StatisticalBarRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.category.CategoryItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.CategoryPlot, org.jfree.chart.axis.CategoryAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.category.CategoryDataset, int, int, int)" map="A"/>
  <class name="org.jfree.chart.renderer.category.CategoryStepRenderer" map="U"/>
  <package name="org.jfree.chart.renderer.xy" map="B"/>
  <class name="org.jfree.chart.renderer.xy.StackedXYBarRenderer" map="A"/>
  <method class="org.jfree.chart.renderer.xy.StackedXYBarRenderer" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <class name="org.jfree.chart.renderer.xy.StandardXYItemRenderer" map="B"/>
  <method class="org.jfree.chart.renderer.xy.StandardXYItemRenderer" name="org.jfree.chart.LegendItem getLegendItem(int, int)" map="m"/>
  <method class="org.jfree.chart.renderer.xy.StandardXYItemRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.StandardXYItemRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.StandardXYItemRenderer" name="boolean getPlotLines()" map="i"/>
  <method class="org.jfree.chart.renderer.xy.StandardXYItemRenderer" name="void setBaseShapesVisible(boolean)" map="G"/>
  <method class="org.jfree.chart.renderer.xy.StandardXYItemRenderer" name="boolean getBaseShapesVisible()" map="j"/>
  <method class="org.jfree.chart.renderer.xy.StandardXYItemRenderer" name="void setPlotLines(boolean)" map="H"/>
  <method class="org.jfree.chart.renderer.xy.StandardXYItemRenderer" name="org.jfree.chart.renderer.xy.XYItemRendererState initialise(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.XYPlot, org.jfree.data.xy.XYDataset, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <class name="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" map="C"/>
  <field class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="legendItemLabelGenerator" map="&#x00e4;"/>
  <field class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="itemLabelGeneratorList" map="&#x00e5;"/>
  <field class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="foregroundAnnotations" map="&#x00e6;"/>
  <field class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="toolTipGeneratorList" map="&#x00e7;"/>
  <field class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="itemLabelGenerator" map="&#x00e8;"/>
  <field class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="plot" map="&#x00e9;"/>
  <field class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="baseToolTipGenerator" map="&#x00ea;"/>
  <field class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="legendItemToolTipGenerator" map="&#x00eb;"/>
  <field class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="urlGenerator" map="&#x00ec;"/>
  <field class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="baseItemLabelGenerator" map="&#x00ed;"/>
  <field class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="toolTipGenerator" map="&#x00ee;"/>
  <field class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="legendItemURLGenerator" map="&#x00ef;"/>
  <field class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="backgroundAnnotations" map="&#x00f0;"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="void drawDomainMarker(java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.plot.Marker, java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="java.util.Collection getAnnotations()" map="b"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="boolean isPointInRect(java.awt.geom.Rectangle2D, double, double)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="void drawAnnotations(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.ui.Layer, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="java.awt.geom.Point2D calculateDomainMarkerTextAnchorPoint(java.awt.Graphics2D, org.jfree.chart.plot.PlotOrientation, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleInsets, org.jfree.ui.LengthAdjustmentType, org.jfree.ui.RectangleAnchor)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="org.jfree.chart.LegendItem getLegendItem(int, int)" map="m"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="org.jfree.chart.labels.XYSeriesLabelGenerator getLegendItemToolTipGenerator()" map="c"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="void drawDomainLine(java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, java.awt.geom.Rectangle2D, double, java.awt.Paint, java.awt.Stroke)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="org.jfree.data.Range findDomainBounds(org.jfree.data.xy.XYDataset)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="org.jfree.chart.plot.DrawingSupplier getDrawingSupplier()" map="U"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="org.jfree.chart.labels.XYSeriesLabelGenerator getLegendItemLabelGenerator()" map="d"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.xy.XYDataset)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="void drawRangeLine(java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, java.awt.geom.Rectangle2D, double, java.awt.Paint, java.awt.Stroke)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="void setBaseToolTipGenerator(org.jfree.chart.labels.XYToolTipGenerator)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="org.jfree.chart.LegendItemCollection getLegendItems()" map="S"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="void setPlot(org.jfree.chart.plot.XYPlot)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="void drawItemLabel(java.awt.Graphics2D, org.jfree.chart.plot.PlotOrientation, org.jfree.data.xy.XYDataset, int, int, double, double, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="org.jfree.chart.urls.XYURLGenerator getURLGenerator()" map="e"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="java.awt.geom.Point2D calculateRangeMarkerTextAnchorPoint(java.awt.Graphics2D, org.jfree.chart.plot.PlotOrientation, java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, org.jfree.ui.RectangleInsets, org.jfree.ui.LengthAdjustmentType, org.jfree.ui.RectangleAnchor)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="void addEntity(org.jfree.chart.entity.EntityCollection, java.awt.Shape, org.jfree.data.xy.XYDataset, int, int, double, double)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="org.jfree.chart.labels.XYItemLabelGenerator getItemLabelGenerator(int, int)" map="n"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="int getPassCount()" map="a"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="org.jfree.chart.labels.XYSeriesLabelGenerator getLegendItemURLGenerator()" map="f"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="org.jfree.chart.renderer.xy.XYItemRendererState initialise(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.XYPlot, org.jfree.data.xy.XYDataset, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="void drawRangeMarker(java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.plot.Marker, java.awt.geom.Rectangle2D)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="void fillRangeGridBand(java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, java.awt.geom.Rectangle2D, double, double)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="org.jfree.data.Range findDomainBounds(org.jfree.data.xy.XYDataset, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="void fillDomainGridBand(java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, java.awt.geom.Rectangle2D, double, double)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="org.jfree.chart.plot.XYPlot getPlot()" map="g"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="void setURLGenerator(org.jfree.chart.urls.XYURLGenerator)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="void updateCrosshairValues(org.jfree.chart.plot.CrosshairState, double, double, int, int, double, double, org.jfree.chart.plot.PlotOrientation)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="org.jfree.chart.labels.XYToolTipGenerator getToolTipGenerator(int, int)" map="o"/>
  <method class="org.jfree.chart.renderer.xy.AbstractXYItemRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.xy.XYDataset, boolean)" map="B"/>
  <class name="org.jfree.chart.renderer.xy.XYItemRendererState" map="D"/>
  <field class="org.jfree.chart.renderer.xy.XYItemRendererState" name="processVisibleItemsOnly" map="F"/>
  <field class="org.jfree.chart.renderer.xy.XYItemRendererState" name="lastItemIndex" map="G"/>
  <field class="org.jfree.chart.renderer.xy.XYItemRendererState" name="firstItemIndex" map="H"/>
  <field class="org.jfree.chart.renderer.xy.XYItemRendererState" name="workingLine" map="I"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRendererState" name="void endSeriesPass(org.jfree.data.xy.XYDataset, int, int, int, int, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRendererState" name="int getLastItemIndex()" map="G"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRendererState" name="void startSeriesPass(org.jfree.data.xy.XYDataset, int, int, int, int, int)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRendererState" name="boolean getProcessVisibleItemsOnly()" map="H"/>
  <class name="org.jfree.chart.renderer.xy.VectorRenderer" map="E"/>
  <method class="org.jfree.chart.renderer.xy.VectorRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.VectorRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.VectorRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.xy.XYDataset)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.VectorRenderer" name="org.jfree.data.Range findDomainBounds(org.jfree.data.xy.XYDataset)" map="A"/>
  <class name="org.jfree.chart.renderer.xy.XYItemRenderer" map="F"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="void drawDomainMarker(java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.plot.Marker, java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="java.awt.Font getItemLabelFont(int, int)" map="_"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="void drawAnnotations(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.ui.Layer, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="org.jfree.chart.LegendItem getLegendItem(int, int)" map="m"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="org.jfree.data.Range findDomainBounds(org.jfree.data.xy.XYDataset)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="boolean isSeriesVisibleInLegend(int)" map="J"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="boolean isSeriesVisible(int)" map="K"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.xy.XYDataset)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="void drawRangeLine(java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, java.awt.geom.Rectangle2D, double, java.awt.Paint, java.awt.Stroke)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="void setBaseToolTipGenerator(org.jfree.chart.labels.XYToolTipGenerator)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="void setPlot(org.jfree.chart.plot.XYPlot)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="void setBaseItemLabelPaint(java.awt.Paint)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="void removeChangeListener(org.jfree.chart.event.RendererChangeListener)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="void setBaseItemLabelFont(java.awt.Font)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="org.jfree.chart.labels.ItemLabelPosition getPositiveItemLabelPosition(int, int)" map="j"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="int getPassCount()" map="a"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="org.jfree.chart.renderer.xy.XYItemRendererState initialise(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.XYPlot, org.jfree.data.xy.XYDataset, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="org.jfree.chart.labels.ItemLabelPosition getNegativeItemLabelPosition(int, int)" map="l"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="java.awt.Paint getItemLabelPaint(int, int)" map="a"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="void drawRangeMarker(java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.plot.Marker, java.awt.geom.Rectangle2D)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="void fillRangeGridBand(java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, java.awt.geom.Rectangle2D, double, double)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="void addChangeListener(org.jfree.chart.event.RendererChangeListener)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="void fillDomainGridBand(java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, java.awt.geom.Rectangle2D, double, double)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.XYItemRenderer" name="void setURLGenerator(org.jfree.chart.urls.XYURLGenerator)" map="A"/>
  <class name="org.jfree.chart.renderer.xy.XYDotRenderer" map="G"/>
  <method class="org.jfree.chart.renderer.xy.XYDotRenderer" name="org.jfree.chart.LegendItem getLegendItem(int, int)" map="m"/>
  <method class="org.jfree.chart.renderer.xy.XYDotRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.XYDotRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <class name="org.jfree.chart.renderer.xy.HighLowRenderer" map="H"/>
  <method class="org.jfree.chart.renderer.xy.HighLowRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.HighLowRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.HighLowRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.xy.XYDataset)" map="B"/>
  <class name="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer$State" map="_A"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer$State" name="seriesPath" map="J"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer$State" name="lastPointGood" map="K"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer$State" name="void startSeriesPass(org.jfree.data.xy.XYDataset, int, int, int, int, int)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer$State" name="void setLastPointGood(boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer$State" name="boolean isLastPointGood()" map="I"/>
  <class name="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" map="I"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="seriesShapesVisible" map="&#x00f1;"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="linesVisible" map="&#x00f2;"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="drawSeriesLineAsPath" map="&#x00f3;"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="useOutlinePaint" map="&#x00f4;"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="seriesShapesFilled" map="&#x00f5;"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="seriesLinesVisible" map="&#x00f6;"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="useFillPaint" map="&#x00f8;"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="shapesFilled" map="&#x00f9;"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="shapesVisible" map="&#x00fa;"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="legendLine" map="&#x00fb;"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="baseShapesVisible" map="&#x00fc;"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="baseLinesVisible" map="&#x00fd;"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="drawOutlines" map="&#x00fe;"/>
  <field class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="baseShapesFilled" map="&#x00ff;"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="boolean getUseOutlinePaint()" map="h"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="java.lang.Boolean getSeriesShapesFilled(int)" map="i"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="org.jfree.chart.LegendItem getLegendItem(int, int)" map="m"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="boolean getItemShapeFilled(int, int)" map="p"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="void drawFirstPassShape(java.awt.Graphics2D, int, int, int, java.awt.Shape)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="boolean isItemPass(int)" map="j"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="void drawPrimaryLine(org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, org.jfree.data.xy.XYDataset, int, int, int, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="void drawPrimaryLineAsPath(org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, org.jfree.data.xy.XYDataset, int, int, int, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, java.awt.geom.Rectangle2D)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="void drawSecondaryPass(java.awt.Graphics2D, org.jfree.chart.plot.XYPlot, org.jfree.data.xy.XYDataset, int, int, int, org.jfree.chart.axis.ValueAxis, java.awt.geom.Rectangle2D, org.jfree.chart.axis.ValueAxis, org.jfree.chart.plot.CrosshairState, org.jfree.chart.entity.EntityCollection)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="java.lang.Boolean getSeriesLinesVisible(int)" map="k"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="int getPassCount()" map="a"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="boolean getItemShapeVisible(int, int)" map="q"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="org.jfree.chart.renderer.xy.XYItemRendererState initialise(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.XYPlot, org.jfree.data.xy.XYDataset, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="java.lang.Boolean getSeriesShapesVisible(int)" map="l"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="boolean isLinePass(int)" map="m"/>
  <method class="org.jfree.chart.renderer.xy.XYLineAndShapeRenderer" name="boolean getItemLineVisible(int, int)" map="r"/>
  <class name="org.jfree.chart.renderer.xy.XYAreaRenderer" map="J"/>
  <method class="org.jfree.chart.renderer.xy.XYAreaRenderer" name="org.jfree.chart.LegendItem getLegendItem(int, int)" map="m"/>
  <method class="org.jfree.chart.renderer.xy.XYAreaRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.XYAreaRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYAreaRenderer" name="org.jfree.chart.renderer.xy.XYItemRendererState initialise(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.XYPlot, org.jfree.data.xy.XYDataset, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <class name="org.jfree.chart.renderer.xy.GradientXYBarPainter" map="K"/>
  <field class="org.jfree.chart.renderer.xy.GradientXYBarPainter" name="g3" map="A"/>
  <field class="org.jfree.chart.renderer.xy.GradientXYBarPainter" name="g2" map="B"/>
  <field class="org.jfree.chart.renderer.xy.GradientXYBarPainter" name="g1" map="C"/>
  <method class="org.jfree.chart.renderer.xy.GradientXYBarPainter" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.renderer.xy.GradientXYBarPainter" name="int hashCode()" map="hashCode"/>
  <class name="org.jfree.chart.renderer.xy.CandlestickRenderer" map="L"/>
  <method class="org.jfree.chart.renderer.xy.CandlestickRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.CandlestickRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.CandlestickRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.xy.XYDataset)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.CandlestickRenderer" name="org.jfree.chart.renderer.xy.XYItemRendererState initialise(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.XYPlot, org.jfree.data.xy.XYDataset, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <class name="org.jfree.chart.renderer.xy.YIntervalRenderer" map="M"/>
  <method class="org.jfree.chart.renderer.xy.YIntervalRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.YIntervalRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.YIntervalRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.xy.XYDataset)" map="B"/>
  <class name="org.jfree.chart.renderer.xy.XYAreaRenderer2" map="N"/>
  <method class="org.jfree.chart.renderer.xy.XYAreaRenderer2" name="org.jfree.chart.LegendItem getLegendItem(int, int)" map="m"/>
  <method class="org.jfree.chart.renderer.xy.XYAreaRenderer2" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.XYAreaRenderer2" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <class name="org.jfree.chart.renderer.xy.XYStepAreaRenderer" map="O"/>
  <method class="org.jfree.chart.renderer.xy.XYStepAreaRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.XYStepAreaRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYStepAreaRenderer" name="org.jfree.chart.renderer.xy.XYItemRendererState initialise(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.XYPlot, org.jfree.data.xy.XYDataset, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <class name="org.jfree.chart.renderer.xy.SamplingXYLineRenderer" map="P"/>
  <method class="org.jfree.chart.renderer.xy.SamplingXYLineRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.SamplingXYLineRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.SamplingXYLineRenderer" name="org.jfree.chart.renderer.xy.XYItemRendererState initialise(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.XYPlot, org.jfree.data.xy.XYDataset, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.SamplingXYLineRenderer" name="int getPassCount()" map="a"/>
  <class name="org.jfree.chart.renderer.xy.XYBubbleRenderer" map="Q"/>
  <method class="org.jfree.chart.renderer.xy.XYBubbleRenderer" name="org.jfree.chart.LegendItem getLegendItem(int, int)" map="m"/>
  <method class="org.jfree.chart.renderer.xy.XYBubbleRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.XYBubbleRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <class name="org.jfree.chart.renderer.xy.XYShapeRenderer" map="R"/>
  <method class="org.jfree.chart.renderer.xy.XYShapeRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYShapeRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.xy.XYDataset)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.XYShapeRenderer" name="int getPassCount()" map="a"/>
  <method class="org.jfree.chart.renderer.xy.XYShapeRenderer" name="org.jfree.data.Range findDomainBounds(org.jfree.data.xy.XYDataset)" map="A"/>
  <class name="org.jfree.chart.renderer.xy.XYBarRenderer" map="S"/>
  <field class="org.jfree.chart.renderer.xy.XYBarRenderer" name="defaultBarPainter" map="&#x0100;"/>
  <field class="org.jfree.chart.renderer.xy.XYBarRenderer" name="defaultShadowsVisible" map="&#x0101;"/>
  <method class="org.jfree.chart.renderer.xy.XYBarRenderer" name="org.jfree.chart.LegendItem getLegendItem(int, int)" map="m"/>
  <method class="org.jfree.chart.renderer.xy.XYBarRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.XYBarRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYBarRenderer" name="void setShadowVisible(boolean)" map="F"/>
  <method class="org.jfree.chart.renderer.xy.XYBarRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.xy.XYDataset)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.XYBarRenderer" name="void setBarPainter(org.jfree.chart.renderer.xy.XYBarPainter)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYBarRenderer" name="org.jfree.chart.renderer.xy.XYItemRendererState initialise(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.XYPlot, org.jfree.data.xy.XYDataset, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYBarRenderer" name="org.jfree.data.Range findDomainBounds(org.jfree.data.xy.XYDataset)" map="A"/>
  <class name="org.jfree.chart.renderer.xy.XYDifferenceRenderer" map="T"/>
  <method class="org.jfree.chart.renderer.xy.XYDifferenceRenderer" name="org.jfree.chart.LegendItem getLegendItem(int, int)" map="m"/>
  <method class="org.jfree.chart.renderer.xy.XYDifferenceRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.XYDifferenceRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYDifferenceRenderer" name="org.jfree.chart.renderer.xy.XYItemRendererState initialise(java.awt.Graphics2D, java.awt.geom.Rectangle2D, org.jfree.chart.plot.XYPlot, org.jfree.data.xy.XYDataset, org.jfree.chart.plot.PlotRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYDifferenceRenderer" name="int getPassCount()" map="a"/>
  <class name="org.jfree.chart.renderer.xy.XYStepRenderer" map="U"/>
  <method class="org.jfree.chart.renderer.xy.XYStepRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.XYStepRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <class name="org.jfree.chart.renderer.xy.XYBoxAndWhiskerRenderer" map="V"/>
  <method class="org.jfree.chart.renderer.xy.XYBoxAndWhiskerRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.XYBoxAndWhiskerRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYBoxAndWhiskerRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.xy.XYDataset)" map="B"/>
  <class name="org.jfree.chart.renderer.xy.WindItemRenderer" map="W"/>
  <method class="org.jfree.chart.renderer.xy.WindItemRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.WindItemRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <class name="org.jfree.chart.renderer.xy.XYBlockRenderer" map="X"/>
  <method class="org.jfree.chart.renderer.xy.XYBlockRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.xy.XYBlockRenderer" name="void drawItem(java.awt.Graphics2D, org.jfree.chart.renderer.xy.XYItemRendererState, java.awt.geom.Rectangle2D, org.jfree.chart.plot.PlotRenderingInfo, org.jfree.chart.plot.XYPlot, org.jfree.chart.axis.ValueAxis, org.jfree.chart.axis.ValueAxis, org.jfree.data.xy.XYDataset, int, int, org.jfree.chart.plot.CrosshairState, int)" map="A"/>
  <method class="org.jfree.chart.renderer.xy.XYBlockRenderer" name="org.jfree.data.Range findRangeBounds(org.jfree.data.xy.XYDataset)" map="B"/>
  <method class="org.jfree.chart.renderer.xy.XYBlockRenderer" name="org.jfree.data.Range findDomainBounds(org.jfree.data.xy.XYDataset)" map="A"/>
  <class name="org.jfree.chart.renderer.xy.XYBarPainter" map="Y"/>
  <class name="org.jfree.chart.renderer.RendererUtilities" map="A"/>
  <method class="org.jfree.chart.renderer.RendererUtilities" name="int[] findLiveItems(org.jfree.data.xy.XYDataset, int, double, double)" map="A"/>
  <method class="org.jfree.chart.renderer.RendererUtilities" name="int findLiveItemsLowerBound(org.jfree.data.xy.XYDataset, int, double, double)" map="B"/>
  <method class="org.jfree.chart.renderer.RendererUtilities" name="int findLiveItemsUpperBound(org.jfree.data.xy.XYDataset, int, double, double)" map="C"/>
  <class name="org.jfree.chart.renderer.AbstractRenderer" map="B"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="seriesVisible" map="Z"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="baseSeriesVisible" map="_"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="autoPopulateSeriesOutlinePaint" map="a"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="DEFAULT_STROKE" map="b"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="createEntities" map="c"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="autoPopulateSeriesPaint" map="d"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="itemLabelPaintList" map="e"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="baseOutlinePaint" map="f"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="itemLabelsVisible" map="g"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="outlinePaint" map="h"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="positiveItemLabelPositionList" map="i"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="autoPopulateSeriesOutlineStroke" map="j"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="seriesVisibleInLegendList" map="k"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="DEFAULT_PAINT" map="l"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="createEntitiesList" map="m"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="itemLabelPaint" map="n"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="fillPaint" map="o"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="legendShapeList" map="p"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="autoPopulateSeriesStroke" map="q"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="outlineStrokeList" map="r"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="DEFAULT_OUTLINE_PAINT" map="s"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="ZERO" map="t"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="strokeList" map="u"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="itemLabelFont" map="v"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="shape" map="w"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="legendTextFont" map="x"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="outlinePaintList" map="y"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="basePaint" map="z"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="baseItemLabelFont" map="&#x00a2;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="dataBoundsIncludesVisibleSeriesOnly" map="&#x00a3;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="baseCreateEntities" map="&#x00a4;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="itemLabelAnchorOffset" map="&#x00a5;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="ADJ" map="&#x00aa;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="itemLabelsVisibleList" map="&#x00b5;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="baseSeriesVisibleInLegend" map="&#x00ba;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="outlineStroke" map="&#x00c0;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="stroke" map="&#x00c1;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="baseOutlineStroke" map="&#x00c2;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="autoPopulateSeriesShape" map="&#x00c3;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="negativeItemLabelPositionList" map="&#x00c4;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="legendTextPaint" map="&#x00c5;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="baseItemLabelPaint" map="&#x00c6;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="baseLegendShape" map="&#x00c7;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="DEFAULT_VALUE_LABEL_FONT" map="&#x00c8;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="baseLegendTextFont" map="&#x00c9;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="autoPopulateSeriesFillPaint" map="&#x00ca;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="class$org$jfree$chart$event$RendererChangeListener" map="class$F$B$G$B$J"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="listenerList" map="&#x00cb;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="baseItemLabelsVisible" map="&#x00cc;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="treatLegendShapeAsLine" map="&#x00cd;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="seriesVisibleInLegend" map="&#x00ce;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="basePositiveItemLabelPosition" map="&#x00cf;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="DEFAULT_VALUE_LABEL_PAINT" map="&#x00d0;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="DEFAULT_SHAPE" map="&#x00d1;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="baseLegendTextPaint" map="&#x00d2;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="baseNegativeItemLabelPosition" map="&#x00d3;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="shapeList" map="&#x00d4;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="baseFillPaint" map="&#x00d5;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="paint" map="&#x00d6;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="DEFAULT_OUTLINE_STROKE" map="&#x00d8;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="paintList" map="&#x00d9;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="OPP" map="&#x00da;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="defaultEntityRadius" map="&#x00db;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="baseShape" map="&#x00dc;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="fillPaintList" map="&#x00dd;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="itemLabelFontList" map="&#x00de;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="positiveItemLabelPosition" map="&#x00df;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="baseStroke" map="&#x00e0;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="seriesVisibleList" map="&#x00e1;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="event" map="&#x00e2;"/>
  <field class="org.jfree.chart.renderer.AbstractRenderer" name="negativeItemLabelPosition" map="&#x00e3;"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Font getItemLabelFont(int, int)" map="_"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void clearSeriesPaints(boolean)" map="C"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setBasePositiveItemLabelPosition(org.jfree.chart.labels.ItemLabelPosition)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setBaseNegativeItemLabelPosition(org.jfree.chart.labels.ItemLabelPosition)" map="B"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Paint getItemLabelPaint(int, int)" map="a"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Shape lookupLegendShape(int)" map="L"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setBaseItemLabelsVisible(java.lang.Boolean, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Paint getSeriesOutlinePaint(int)" map="M"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="org.jfree.chart.plot.DrawingSupplier getDrawingSupplier()" map="U"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="boolean getItemCreateEntity(int, int)" map="b"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setBaseItemLabelFont(java.awt.Font, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setSeriesOutlineStroke(int, java.awt.Stroke, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.geom.Point2D calculateLabelAnchorPoint(org.jfree.chart.labels.ItemLabelAnchor, double, double, org.jfree.chart.plot.PlotOrientation)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="boolean isSeriesVisibleInLegend(int)" map="J"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="boolean getItemVisible(int, int)" map="c"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void fireChangeEvent()" map="V"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setBaseItemLabelPaint(java.awt.Paint, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setBaseLegendShape(java.awt.Shape)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Stroke lookupSeriesOutlineStroke(int)" map="N"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Stroke getItemOutlineStroke(int, int)" map="d"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Paint lookupLegendTextPaint(int)" map="O"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Shape lookupSeriesShape(int)" map="P"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Paint getSeriesItemLabelPaint(int)" map="Q"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Shape getLegendShape(int)" map="R"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="boolean getAutoPopulateSeriesPaint()" map="W"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Font lookupLegendTextFont(int)" map="S"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="double getItemLabelAnchorOffset()" map="X"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setSeriesPaint(int, java.awt.Paint, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Paint getItemPaint(int, int)" map="e"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Paint getLegendTextPaint(int)" map="T"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setSeriesShape(int, java.awt.Shape, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setBaseItemLabelsVisible(boolean)" map="D"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Shape getSeriesShape(int)" map="U"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void removeChangeListener(org.jfree.chart.event.RendererChangeListener)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Stroke getSeriesStroke(int)" map="V"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="boolean getAutoPopulateSeriesStroke()" map="Y"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setSeriesPaint(int, java.awt.Paint)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void addChangeListener(org.jfree.chart.event.RendererChangeListener)" map="B"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Paint lookupSeriesOutlinePaint(int)" map="W"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Paint lookupSeriesPaint(int)" map="X"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Shape getItemShape(int, int)" map="f"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="boolean isSeriesItemLabelsVisible(int)" map="Y"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Paint getItemFillPaint(int, int)" map="g"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setSeriesOutlinePaint(int, java.awt.Paint, boolean)" map="B"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setBasePositiveItemLabelPosition(org.jfree.chart.labels.ItemLabelPosition, boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setBaseItemLabelFont(java.awt.Font)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Stroke getSeriesOutlineStroke(int)" map="Z"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Paint lookupSeriesFillPaint(int)" map="_"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Paint getItemOutlinePaint(int, int)" map="h"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setBaseNegativeItemLabelPosition(org.jfree.chart.labels.ItemLabelPosition, boolean)" map="B"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Paint getSeriesPaint(int)" map="a"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.lang.Boolean getSeriesCreateEntities(int)" map="b"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setSeriesFillPaint(int, java.awt.Paint, boolean)" map="C"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Paint getSeriesFillPaint(int)" map="c"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setBaseItemLabelsVisible(java.lang.Boolean)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="boolean isItemLabelVisible(int, int)" map="i"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="boolean getDataBoundsIncludesVisibleSeriesOnly()" map="Z"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="int getDefaultEntityRadius()" map="_"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="org.jfree.chart.labels.ItemLabelPosition getPositiveItemLabelPosition(int, int)" map="j"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Stroke getItemStroke(int, int)" map="k"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Font getLegendTextFont(int)" map="d"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void clearSeriesStrokes(boolean)" map="E"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setSeriesStroke(int, java.awt.Stroke, boolean)" map="B"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="org.jfree.chart.labels.ItemLabelPosition getNegativeItemLabelPosition(int, int)" map="l"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Stroke lookupSeriesStroke(int)" map="e"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="org.jfree.chart.labels.ItemLabelPosition getSeriesPositiveItemLabelPosition(int)" map="f"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="java.awt.Font getSeriesItemLabelFont(int)" map="g"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="org.jfree.chart.labels.ItemLabelPosition getSeriesNegativeItemLabelPosition(int)" map="h"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void setBaseItemLabelPaint(java.awt.Paint)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="void notifyListeners(org.jfree.chart.event.RendererChangeEvent)" map="A"/>
  <method class="org.jfree.chart.renderer.AbstractRenderer" name="boolean isSeriesVisible(int)" map="K"/>
  <class name="org.jfree.chart.renderer.RendererState" map="C"/>
  <field class="org.jfree.chart.renderer.RendererState" name="info" map="A"/>
  <method class="org.jfree.chart.renderer.RendererState" name="org.jfree.chart.entity.EntityCollection getEntityCollection()" map="A"/>
  <method class="org.jfree.chart.renderer.RendererState" name="org.jfree.chart.plot.PlotRenderingInfo getInfo()" map="B"/>
  <package name="org.jfree.chart.urls" map="N"/>
  <class name="org.jfree.chart.urls.StandardPieURLGenerator" map="A"/>
  <field class="org.jfree.chart.urls.StandardPieURLGenerator" name="categoryParameterName" map="A"/>
  <field class="org.jfree.chart.urls.StandardPieURLGenerator" name="prefix" map="B"/>
  <field class="org.jfree.chart.urls.StandardPieURLGenerator" name="indexParameterName" map="C"/>
  <method class="org.jfree.chart.urls.StandardPieURLGenerator" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.urls.StandardPieURLGenerator" name="java.lang.String generateURL(org.jfree.data.general.PieDataset, java.lang.Comparable, int)" map="A"/>
  <class name="org.jfree.chart.urls.XYZURLGenerator" map="B"/>
  <class name="org.jfree.chart.urls.URLUtilities" map="C"/>
  <field class="org.jfree.chart.urls.URLUtilities" name="class$java$lang$String" map="class$java$lang$String"/>
  <field class="org.jfree.chart.urls.URLUtilities" name="class$java$net$URLEncoder" map="class$java$net$URLEncoder"/>
  <field class="org.jfree.chart.urls.URLUtilities" name="STRING_ARGS_2" map="A"/>
  <method class="org.jfree.chart.urls.URLUtilities" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jfree.chart.urls.URLUtilities" name="java.lang.String encode(java.lang.String, java.lang.String)" map="A"/>
  <class name="org.jfree.chart.urls.XYURLGenerator" map="D"/>
  <method class="org.jfree.chart.urls.XYURLGenerator" name="java.lang.String generateURL(org.jfree.data.xy.XYDataset, int, int)" map="A"/>
  <class name="org.jfree.chart.urls.StandardCategoryURLGenerator" map="E"/>
  <field class="org.jfree.chart.urls.StandardCategoryURLGenerator" name="categoryParameterName" map="A"/>
  <field class="org.jfree.chart.urls.StandardCategoryURLGenerator" name="seriesParameterName" map="B"/>
  <field class="org.jfree.chart.urls.StandardCategoryURLGenerator" name="prefix" map="C"/>
  <method class="org.jfree.chart.urls.StandardCategoryURLGenerator" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.urls.StandardCategoryURLGenerator" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.urls.StandardCategoryURLGenerator" name="java.lang.String generateURL(org.jfree.data.category.CategoryDataset, int, int)" map="A"/>
  <method class="org.jfree.chart.urls.StandardCategoryURLGenerator" name="int hashCode()" map="hashCode"/>
  <class name="org.jfree.chart.urls.StandardXYZURLGenerator" map="F"/>
  <class name="org.jfree.chart.urls.PieURLGenerator" map="G"/>
  <method class="org.jfree.chart.urls.PieURLGenerator" name="java.lang.String generateURL(org.jfree.data.general.PieDataset, java.lang.Comparable, int)" map="A"/>
  <class name="org.jfree.chart.urls.CategoryURLGenerator" map="H"/>
  <method class="org.jfree.chart.urls.CategoryURLGenerator" name="java.lang.String generateURL(org.jfree.data.category.CategoryDataset, int, int)" map="A"/>
  <class name="org.jfree.chart.urls.StandardXYURLGenerator" map="I"/>
  <field class="org.jfree.chart.urls.StandardXYURLGenerator" name="seriesParameterName" map="A"/>
  <field class="org.jfree.chart.urls.StandardXYURLGenerator" name="prefix" map="B"/>
  <field class="org.jfree.chart.urls.StandardXYURLGenerator" name="itemParameterName" map="C"/>
  <method class="org.jfree.chart.urls.StandardXYURLGenerator" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.urls.StandardXYURLGenerator" name="java.lang.String generateURL(org.jfree.data.xy.XYDataset, int, int)" map="A"/>
  <package name="org.jfree.chart.title" map="O"/>
  <class name="org.jfree.chart.title.TextTitle" map="A"/>
  <field class="org.jfree.chart.title.TextTitle" name="DEFAULT_TEXT_PAINT" map="&#x0271;"/>
  <field class="org.jfree.chart.title.TextTitle" name="expandToFitSpace" map="&#x0272;"/>
  <field class="org.jfree.chart.title.TextTitle" name="urlText" map="&#x0273;"/>
  <field class="org.jfree.chart.title.TextTitle" name="font" map="&#x0274;"/>
  <field class="org.jfree.chart.title.TextTitle" name="toolTipText" map="&#x0275;"/>
  <field class="org.jfree.chart.title.TextTitle" name="maximumLinesToDisplay" map="&#x0276;"/>
  <field class="org.jfree.chart.title.TextTitle" name="paint" map="&#x0277;"/>
  <field class="org.jfree.chart.title.TextTitle" name="DEFAULT_FONT" map="&#x0278;"/>
  <field class="org.jfree.chart.title.TextTitle" name="content" map="&#x0279;"/>
  <field class="org.jfree.chart.title.TextTitle" name="textAlignment" map="&#x027a;"/>
  <field class="org.jfree.chart.title.TextTitle" name="text" map="&#x027b;"/>
  <field class="org.jfree.chart.title.TextTitle" name="backgroundPaint" map="&#x027c;"/>
  <method class="org.jfree.chart.title.TextTitle" name="java.lang.String getText()" map="&#x0157;"/>
  <method class="org.jfree.chart.title.TextTitle" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.title.TextTitle" name="void drawVertical(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="P"/>
  <method class="org.jfree.chart.title.TextTitle" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.title.TextTitle" name="org.jfree.ui.Size2D arrangeRN(java.awt.Graphics2D, org.jfree.data.Range)" map="A"/>
  <method class="org.jfree.chart.title.TextTitle" name="void setPaint(java.awt.Paint)" map="h"/>
  <method class="org.jfree.chart.title.TextTitle" name="void drawHorizontal(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="Q"/>
  <method class="org.jfree.chart.title.TextTitle" name="java.awt.Paint getPaint()" map="&#x0158;"/>
  <method class="org.jfree.chart.title.TextTitle" name="java.awt.Font getFont()" map="&#x0159;"/>
  <method class="org.jfree.chart.title.TextTitle" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.title.TextTitle" name="java.lang.Object draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.lang.Object)" map="A"/>
  <method class="org.jfree.chart.title.TextTitle" name="org.jfree.ui.Size2D arrangeRR(java.awt.Graphics2D, org.jfree.data.Range, org.jfree.data.Range)" map="A"/>
  <method class="org.jfree.chart.title.TextTitle" name="org.jfree.ui.Size2D arrangeNN(java.awt.Graphics2D)" map="B"/>
  <method class="org.jfree.chart.title.TextTitle" name="org.jfree.ui.Size2D arrangeFN(java.awt.Graphics2D, double)" map="A"/>
  <method class="org.jfree.chart.title.TextTitle" name="org.jfree.ui.Size2D arrange(java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="A"/>
  <method class="org.jfree.chart.title.TextTitle" name="void setText(java.lang.String)" map="C"/>
  <method class="org.jfree.chart.title.TextTitle" name="void setFont(java.awt.Font)" map="H"/>
  <class name="org.jfree.chart.title.LegendItemBlockContainer" map="B"/>
  <field class="org.jfree.chart.title.LegendItemBlockContainer" name="seriesKey" map="&#x0254;"/>
  <field class="org.jfree.chart.title.LegendItemBlockContainer" name="urlText" map="&#x0255;"/>
  <field class="org.jfree.chart.title.LegendItemBlockContainer" name="series" map="&#x0256;"/>
  <field class="org.jfree.chart.title.LegendItemBlockContainer" name="toolTipText" map="&#x0257;"/>
  <field class="org.jfree.chart.title.LegendItemBlockContainer" name="dataset" map="&#x0258;"/>
  <method class="org.jfree.chart.title.LegendItemBlockContainer" name="java.lang.String getURLText()" map="&#x0150;"/>
  <method class="org.jfree.chart.title.LegendItemBlockContainer" name="void setToolTipText(java.lang.String)" map="A"/>
  <method class="org.jfree.chart.title.LegendItemBlockContainer" name="void setURLText(java.lang.String)" map="B"/>
  <method class="org.jfree.chart.title.LegendItemBlockContainer" name="java.lang.String getToolTipText()" map="&#x0151;"/>
  <method class="org.jfree.chart.title.LegendItemBlockContainer" name="java.lang.Object draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.lang.Object)" map="A"/>
  <class name="org.jfree.chart.title.LegendGraphic" map="C"/>
  <field class="org.jfree.chart.title.LegendGraphic" name="shapeOutlineVisible" map="&#x0259;"/>
  <field class="org.jfree.chart.title.LegendGraphic" name="shapeLocation" map="&#x025a;"/>
  <field class="org.jfree.chart.title.LegendGraphic" name="outlinePaint" map="&#x025b;"/>
  <field class="org.jfree.chart.title.LegendGraphic" name="lineVisible" map="&#x025c;"/>
  <field class="org.jfree.chart.title.LegendGraphic" name="outlineStroke" map="&#x025d;"/>
  <field class="org.jfree.chart.title.LegendGraphic" name="fillPaintTransformer" map="&#x025e;"/>
  <field class="org.jfree.chart.title.LegendGraphic" name="fillPaint" map="&#x025f;"/>
  <field class="org.jfree.chart.title.LegendGraphic" name="shapeFilled" map="&#x0260;"/>
  <field class="org.jfree.chart.title.LegendGraphic" name="shapeVisible" map="&#x0261;"/>
  <field class="org.jfree.chart.title.LegendGraphic" name="shape" map="&#x0262;"/>
  <field class="org.jfree.chart.title.LegendGraphic" name="linePaint" map="&#x0263;"/>
  <field class="org.jfree.chart.title.LegendGraphic" name="lineStroke" map="&#x0264;"/>
  <field class="org.jfree.chart.title.LegendGraphic" name="shapeAnchor" map="&#x0265;"/>
  <field class="org.jfree.chart.title.LegendGraphic" name="line" map="&#x0266;"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="void setOutlineStroke(java.awt.Stroke)" map="B"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="java.awt.Shape getLine()" map="&#x0152;"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="void setLineVisible(boolean)" map="S"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="void setLineStroke(java.awt.Stroke)" map="C"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="void setShapeAnchor(org.jfree.ui.RectangleAnchor)" map="A"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="void setLine(java.awt.Shape)" map="B"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="void draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D)" map="O"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="void setShapeOutlineVisible(boolean)" map="T"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="void setShapeLocation(org.jfree.ui.RectangleAnchor)" map="B"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="void setShapeFilled(boolean)" map="U"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="void setFillPaintTransformer(org.jfree.ui.GradientPaintTransformer)" map="A"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="org.jfree.ui.Size2D arrangeNN(java.awt.Graphics2D)" map="A"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="void setLinePaint(java.awt.Paint)" map="f"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="void setOutlinePaint(java.awt.Paint)" map="g"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="java.lang.Object draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.lang.Object)" map="A"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="org.jfree.ui.Size2D arrange(java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="A"/>
  <method class="org.jfree.chart.title.LegendGraphic" name="void setShapeVisible(boolean)" map="V"/>
  <class name="org.jfree.chart.title.Title" map="D"/>
  <field class="org.jfree.chart.title.Title" name="listenerList" map="&#x0267;"/>
  <field class="org.jfree.chart.title.Title" name="DEFAULT_POSITION" map="&#x0268;"/>
  <field class="org.jfree.chart.title.Title" name="DEFAULT_PADDING" map="&#x0269;"/>
  <field class="org.jfree.chart.title.Title" name="visible" map="&#x026a;"/>
  <field class="org.jfree.chart.title.Title" name="position" map="&#x026b;"/>
  <field class="org.jfree.chart.title.Title" name="verticalAlignment" map="&#x026c;"/>
  <field class="org.jfree.chart.title.Title" name="class$org$jfree$chart$event$TitleChangeListener" map="class$F$B$G$B$G"/>
  <field class="org.jfree.chart.title.Title" name="DEFAULT_HORIZONTAL_ALIGNMENT" map="&#x026d;"/>
  <field class="org.jfree.chart.title.Title" name="DEFAULT_VERTICAL_ALIGNMENT" map="&#x026e;"/>
  <field class="org.jfree.chart.title.Title" name="notify" map="&#x026f;"/>
  <field class="org.jfree.chart.title.Title" name="horizontalAlignment" map="&#x0270;"/>
  <method class="org.jfree.chart.title.Title" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.chart.title.Title" name="void addChangeListener(org.jfree.chart.event.TitleChangeListener)" map="A"/>
  <method class="org.jfree.chart.title.Title" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jfree.chart.title.Title" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.title.Title" name="org.jfree.ui.VerticalAlignment getVerticalAlignment()" map="&#x0153;"/>
  <method class="org.jfree.chart.title.Title" name="void removeChangeListener(org.jfree.chart.event.TitleChangeListener)" map="B"/>
  <method class="org.jfree.chart.title.Title" name="org.jfree.ui.HorizontalAlignment getHorizontalAlignment()" map="&#x0154;"/>
  <method class="org.jfree.chart.title.Title" name="boolean isVisible()" map="&#x0155;"/>
  <method class="org.jfree.chart.title.Title" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.title.Title" name="org.jfree.ui.RectangleEdge getPosition()" map="&#x0156;"/>
  <method class="org.jfree.chart.title.Title" name="void notifyListeners(org.jfree.chart.event.TitleChangeEvent)" map="B"/>
  <method class="org.jfree.chart.title.Title" name="void setPosition(org.jfree.ui.RectangleEdge)" map="A"/>
  <class name="org.jfree.chart.title.LegendTitle" map="E"/>
  <field class="org.jfree.chart.title.LegendTitle" name="sources" map="&#x027d;"/>
  <field class="org.jfree.chart.title.LegendTitle" name="wrapper" map="&#x027e;"/>
  <field class="org.jfree.chart.title.LegendTitle" name="itemFont" map="&#x027f;"/>
  <field class="org.jfree.chart.title.LegendTitle" name="DEFAULT_ITEM_FONT" map="&#x0280;"/>
  <field class="org.jfree.chart.title.LegendTitle" name="sortOrder" map="&#x0281;"/>
  <field class="org.jfree.chart.title.LegendTitle" name="hLayout" map="&#x0282;"/>
  <field class="org.jfree.chart.title.LegendTitle" name="legendItemGraphicLocation" map="&#x0283;"/>
  <field class="org.jfree.chart.title.LegendTitle" name="vLayout" map="&#x0284;"/>
  <field class="org.jfree.chart.title.LegendTitle" name="DEFAULT_ITEM_PAINT" map="&#x0285;"/>
  <field class="org.jfree.chart.title.LegendTitle" name="legendItemGraphicEdge" map="&#x0286;"/>
  <field class="org.jfree.chart.title.LegendTitle" name="items" map="&#x0287;"/>
  <field class="org.jfree.chart.title.LegendTitle" name="itemLabelPadding" map="&#x0288;"/>
  <field class="org.jfree.chart.title.LegendTitle" name="legendItemGraphicAnchor" map="&#x0289;"/>
  <field class="org.jfree.chart.title.LegendTitle" name="itemPaint" map="&#x028a;"/>
  <field class="org.jfree.chart.title.LegendTitle" name="backgroundPaint" map="&#x028b;"/>
  <field class="org.jfree.chart.title.LegendTitle" name="legendItemGraphicPadding" map="&#x028c;"/>
  <method class="org.jfree.chart.title.LegendTitle" name="org.jfree.chart.block.BlockContainer getWrapper()" map="&#x015a;"/>
  <method class="org.jfree.chart.title.LegendTitle" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.title.LegendTitle" name="void addItemBlock(org.jfree.chart.LegendItem)" map="A"/>
  <method class="org.jfree.chart.title.LegendTitle" name="void setItemPaint(java.awt.Paint)" map="i"/>
  <method class="org.jfree.chart.title.LegendTitle" name="org.jfree.ui.RectangleAnchor getLegendItemGraphicLocation()" map="&#x015b;"/>
  <method class="org.jfree.chart.title.LegendTitle" name="java.awt.Paint getBackgroundPaint()" map="&#x015c;"/>
  <method class="org.jfree.chart.title.LegendTitle" name="void fetchLegendItems()" map="&#x015d;"/>
  <method class="org.jfree.chart.title.LegendTitle" name="java.lang.Object draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.lang.Object)" map="A"/>
  <method class="org.jfree.chart.title.LegendTitle" name="void setBackgroundPaint(java.awt.Paint)" map="j"/>
  <method class="org.jfree.chart.title.LegendTitle" name="org.jfree.chart.block.Block createLegendItemBlock(org.jfree.chart.LegendItem)" map="B"/>
  <method class="org.jfree.chart.title.LegendTitle" name="org.jfree.ui.Size2D arrange(java.awt.Graphics2D, org.jfree.chart.block.RectangleConstraint)" map="A"/>
  <method class="org.jfree.chart.title.LegendTitle" name="org.jfree.ui.RectangleAnchor getLegendItemGraphicAnchor()" map="&#x015e;"/>
  <method class="org.jfree.chart.title.LegendTitle" name="void setItemFont(java.awt.Font)" map="I"/>
  <class name="org.jfree.chart.title.CompositeTitle" map="F"/>
  <method class="org.jfree.chart.title.CompositeTitle" name="org.jfree.chart.block.BlockContainer getContainer()" map="&#x015f;"/>
  <class name="org.jfree.chart.title.PaintScaleLegend" map="G"/>
  <method class="org.jfree.chart.title.PaintScaleLegend" name="void axisChanged(org.jfree.chart.event.AxisChangeEvent)" map="A"/>
  <method class="org.jfree.chart.title.PaintScaleLegend" name="void setBackgroundPaint(java.awt.Paint)" map="k"/>
  <method class="org.jfree.chart.title.PaintScaleLegend" name="org.jfree.chart.axis.ValueAxis getAxis()" map="&#x0160;"/>
  <class name="org.jfree.chart.ChartPanel" map="A"/>
  <field class="org.jfree.chart.ChartPanel" name="useBuffer" map="A"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomInFactor" map="B"/>
  <field class="org.jfree.chart.ChartPanel" name="verticalAxisTrace" map="C"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomInDomainMenuItem" map="D"/>
  <field class="org.jfree.chart.ChartPanel" name="panH" map="E"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomFillPaint" map="F"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomOutBothMenuItem" map="G"/>
  <field class="org.jfree.chart.ChartPanel" name="anchor" map="H"/>
  <field class="org.jfree.chart.ChartPanel" name="originalToolTipDismissDelay" map="I"/>
  <field class="org.jfree.chart.ChartPanel" name="maximumDrawHeight" map="J"/>
  <field class="org.jfree.chart.ChartPanel" name="horizontalAxisTrace" map="K"/>
  <field class="org.jfree.chart.ChartPanel" name="originalToolTipInitialDelay" map="L"/>
  <field class="org.jfree.chart.ChartPanel" name="chartBufferWidth" map="M"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomTriggerDistance" map="N"/>
  <field class="org.jfree.chart.ChartPanel" name="chartBuffer" map="O"/>
  <field class="org.jfree.chart.ChartPanel" name="overlays" map="P"/>
  <field class="org.jfree.chart.ChartPanel" name="ownToolTipDismissDelay" map="Q"/>
  <field class="org.jfree.chart.ChartPanel" name="domainZoomable" map="R"/>
  <field class="org.jfree.chart.ChartPanel" name="panLast" map="S"/>
  <field class="org.jfree.chart.ChartPanel" name="fillZoomRectangle" map="T"/>
  <field class="org.jfree.chart.ChartPanel" name="orientation" map="U"/>
  <field class="org.jfree.chart.ChartPanel" name="class$org$jfree$chart$ChartMouseListener" map="class$F$B$G$C"/>
  <field class="org.jfree.chart.ChartPanel" name="ownToolTipInitialDelay" map="V"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomInBothMenuItem" map="W"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomResetBothMenuItem" map="X"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomOutlinePaint" map="Y"/>
  <field class="org.jfree.chart.ChartPanel" name="minimumDrawWidth" map="Z"/>
  <field class="org.jfree.chart.ChartPanel" name="rangeZoomable" map="_"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomPoint" map="a"/>
  <field class="org.jfree.chart.ChartPanel" name="popup" map="b"/>
  <field class="org.jfree.chart.ChartPanel" name="ownToolTipReshowDelay" map="c"/>
  <field class="org.jfree.chart.ChartPanel" name="verticalTraceLine" map="d"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomResetRangeMenuItem" map="e"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomAroundAnchor" map="f"/>
  <field class="org.jfree.chart.ChartPanel" name="scaleY" map="g"/>
  <field class="org.jfree.chart.ChartPanel" name="scaleX" map="h"/>
  <field class="org.jfree.chart.ChartPanel" name="defaultDirectoryForSaveAs" map="i"/>
  <field class="org.jfree.chart.ChartPanel" name="refreshBuffer" map="j"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomRectangle" map="k"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomOutRangeMenuItem" map="l"/>
  <field class="org.jfree.chart.ChartPanel" name="enforceFileExtensions" map="m"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomInRangeMenuItem" map="n"/>
  <field class="org.jfree.chart.ChartPanel" name="chartBufferHeight" map="o"/>
  <field class="org.jfree.chart.ChartPanel" name="minimumDrawHeight" map="p"/>
  <field class="org.jfree.chart.ChartPanel" name="localizationResources" map="q"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomOutDomainMenuItem" map="r"/>
  <field class="org.jfree.chart.ChartPanel" name="horizontalTraceLine" map="s"/>
  <field class="org.jfree.chart.ChartPanel" name="originalToolTipReshowDelay" map="t"/>
  <field class="org.jfree.chart.ChartPanel" name="ownToolTipDelaysActive" map="u"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomOutFactor" map="v"/>
  <field class="org.jfree.chart.ChartPanel" name="info" map="w"/>
  <field class="org.jfree.chart.ChartPanel" name="panW" map="z"/>
  <field class="org.jfree.chart.ChartPanel" name="chart" map="&#x00a2;"/>
  <field class="org.jfree.chart.ChartPanel" name="panMask" map="&#x00a3;"/>
  <field class="org.jfree.chart.ChartPanel" name="zoomResetDomainMenuItem" map="&#x00a4;"/>
  <field class="org.jfree.chart.ChartPanel" name="maximumDrawWidth" map="&#x00a5;"/>
  <field class="org.jfree.chart.ChartPanel" name="chartMouseListeners" map="&#x00aa;"/>
  <method class="org.jfree.chart.ChartPanel" name="void zoomOutDomain(double, double)" map="A"/>
  <method class="org.jfree.chart.ChartPanel" name="void mouseExited(java.awt.event.MouseEvent)" map="mouseExited"/>
  <method class="org.jfree.chart.ChartPanel" name="void drawHorizontalAxisTrace(java.awt.Graphics2D, int)" map="A"/>
  <method class="org.jfree.chart.ChartPanel" name="void zoomInRange(double, double)" map="B"/>
  <method class="org.jfree.chart.ChartPanel" name="java.awt.geom.Point2D translateScreenToJava2D(java.awt.Point)" map="A"/>
  <method class="org.jfree.chart.ChartPanel" name="javax.swing.JPopupMenu createPopupMenu(boolean, boolean, boolean, boolean, boolean)" map="A"/>
  <method class="org.jfree.chart.ChartPanel" name="void drawZoomRectangle(java.awt.Graphics2D, boolean)" map="A"/>
  <method class="org.jfree.chart.ChartPanel" name="void setChart(org.jfree.chart.JFreeChart)" map="A"/>
  <method class="org.jfree.chart.ChartPanel" name="void mousePressed(java.awt.event.MouseEvent)" map="mousePressed"/>
  <method class="org.jfree.chart.ChartPanel" name="void mouseMoved(java.awt.event.MouseEvent)" map="mouseMoved"/>
  <method class="org.jfree.chart.ChartPanel" name="void drawVerticalAxisTrace(java.awt.Graphics2D, int)" map="B"/>
  <method class="org.jfree.chart.ChartPanel" name="void mouseEntered(java.awt.event.MouseEvent)" map="mouseEntered"/>
  <method class="org.jfree.chart.ChartPanel" name="void zoom(java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.ChartPanel" name="java.awt.geom.Rectangle2D scale(java.awt.geom.Rectangle2D)" map="B"/>
  <method class="org.jfree.chart.ChartPanel" name="void readObject(java.io.ObjectInputStream)" map="A"/>
  <method class="org.jfree.chart.ChartPanel" name="int getMaximumDrawHeight()" map="A"/>
  <method class="org.jfree.chart.ChartPanel" name="int getMaximumDrawWidth()" map="B"/>
  <method class="org.jfree.chart.ChartPanel" name="void zoomInDomain(double, double)" map="C"/>
  <method class="org.jfree.chart.ChartPanel" name="void mouseDragged(java.awt.event.MouseEvent)" map="mouseDragged"/>
  <method class="org.jfree.chart.ChartPanel" name="void zoomInBoth(double, double)" map="D"/>
  <method class="org.jfree.chart.ChartPanel" name="java.awt.geom.Rectangle2D getScreenDataArea()" map="C"/>
  <method class="org.jfree.chart.ChartPanel" name="void zoomOutRange(double, double)" map="E"/>
  <method class="org.jfree.chart.ChartPanel" name="void restoreAutoRangeBounds()" map="D"/>
  <method class="org.jfree.chart.ChartPanel" name="java.awt.geom.Rectangle2D getScreenDataArea(int, int)" map="A"/>
  <method class="org.jfree.chart.ChartPanel" name="void chartChanged(org.jfree.chart.event.ChartChangeEvent)" map="A"/>
  <method class="org.jfree.chart.ChartPanel" name="int getMinimumDrawHeight()" map="E"/>
  <method class="org.jfree.chart.ChartPanel" name="void restoreAutoDomainBounds()" map="F"/>
  <method class="org.jfree.chart.ChartPanel" name="void mouseReleased(java.awt.event.MouseEvent)" map="mouseReleased"/>
  <method class="org.jfree.chart.ChartPanel" name="double getScaleX()" map="G"/>
  <method class="org.jfree.chart.ChartPanel" name="int print(java.awt.Graphics, java.awt.print.PageFormat, int)" map="print"/>
  <method class="org.jfree.chart.ChartPanel" name="void restoreAutoBounds()" map="H"/>
  <method class="org.jfree.chart.ChartPanel" name="void mouseClicked(java.awt.event.MouseEvent)" map="mouseClicked"/>
  <method class="org.jfree.chart.ChartPanel" name="void doSaveAs()" map="I"/>
  <method class="org.jfree.chart.ChartPanel" name="void displayPopupMenu(int, int)" map="B"/>
  <method class="org.jfree.chart.ChartPanel" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jfree.chart.ChartPanel" name="boolean isEnforceFileExtensions()" map="J"/>
  <method class="org.jfree.chart.ChartPanel" name="void writeObject(java.io.ObjectOutputStream)" map="A"/>
  <method class="org.jfree.chart.ChartPanel" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <method class="org.jfree.chart.ChartPanel" name="void paintComponent(java.awt.Graphics)" map="paintComponent"/>
  <method class="org.jfree.chart.ChartPanel" name="void updateUI()" map="updateUI"/>
  <method class="org.jfree.chart.ChartPanel" name="void createChartPrintJob()" map="K"/>
  <method class="org.jfree.chart.ChartPanel" name="void zoomOutBoth(double, double)" map="F"/>
  <method class="org.jfree.chart.ChartPanel" name="void doCopy()" map="L"/>
  <method class="org.jfree.chart.ChartPanel" name="java.awt.geom.Point2D getPointInRectangle(int, int, java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.ChartPanel" name="void chartProgress(org.jfree.chart.event.ChartProgressEvent)" map="A"/>
  <method class="org.jfree.chart.ChartPanel" name="java.util.EventListener[] getListeners(java.lang.Class)" map="getListeners"/>
  <method class="org.jfree.chart.ChartPanel" name="int getMinimumDrawWidth()" map="M"/>
  <method class="org.jfree.chart.ChartPanel" name="void doEditChartProperties()" map="N"/>
  <method class="org.jfree.chart.ChartPanel" name="java.lang.String getToolTipText(java.awt.event.MouseEvent)" map="getToolTipText"/>
  <method class="org.jfree.chart.ChartPanel" name="void setDisplayToolTips(boolean)" map="A"/>
  <method class="org.jfree.chart.ChartPanel" name="double getScaleY()" map="O"/>
  <method class="org.jfree.chart.ChartPanel" name="org.jfree.chart.JFreeChart getChart()" map="P"/>
  <class name="org.jfree.chart.ChartColor" map="B"/>
  <field class="org.jfree.chart.ChartColor" name="LIGHT_GREEN" map="A"/>
  <field class="org.jfree.chart.ChartColor" name="DARK_YELLOW" map="B"/>
  <field class="org.jfree.chart.ChartColor" name="VERY_LIGHT_GREEN" map="C"/>
  <field class="org.jfree.chart.ChartColor" name="VERY_DARK_MAGENTA" map="D"/>
  <field class="org.jfree.chart.ChartColor" name="VERY_DARK_YELLOW" map="E"/>
  <field class="org.jfree.chart.ChartColor" name="LIGHT_MAGENTA" map="F"/>
  <field class="org.jfree.chart.ChartColor" name="DARK_CYAN" map="G"/>
  <field class="org.jfree.chart.ChartColor" name="VERY_LIGHT_MAGENTA" map="H"/>
  <field class="org.jfree.chart.ChartColor" name="DARK_GREEN" map="I"/>
  <field class="org.jfree.chart.ChartColor" name="VERY_DARK_RED" map="J"/>
  <field class="org.jfree.chart.ChartColor" name="DARK_RED" map="K"/>
  <field class="org.jfree.chart.ChartColor" name="DARK_MAGENTA" map="L"/>
  <field class="org.jfree.chart.ChartColor" name="VERY_LIGHT_BLUE" map="M"/>
  <field class="org.jfree.chart.ChartColor" name="VERY_DARK_BLUE" map="N"/>
  <field class="org.jfree.chart.ChartColor" name="LIGHT_BLUE" map="O"/>
  <field class="org.jfree.chart.ChartColor" name="VERY_LIGHT_RED" map="P"/>
  <field class="org.jfree.chart.ChartColor" name="VERY_DARK_GREEN" map="Q"/>
  <field class="org.jfree.chart.ChartColor" name="LIGHT_YELLOW" map="R"/>
  <field class="org.jfree.chart.ChartColor" name="DARK_BLUE" map="S"/>
  <field class="org.jfree.chart.ChartColor" name="VERY_LIGHT_YELLOW" map="T"/>
  <field class="org.jfree.chart.ChartColor" name="VERY_DARK_CYAN" map="U"/>
  <field class="org.jfree.chart.ChartColor" name="VERY_LIGHT_CYAN" map="V"/>
  <field class="org.jfree.chart.ChartColor" name="LIGHT_CYAN" map="W"/>
  <field class="org.jfree.chart.ChartColor" name="LIGHT_RED" map="X"/>
  <method class="org.jfree.chart.ChartColor" name="java.awt.Paint[] createDefaultPaintArray()" map="A"/>
  <class name="org.jfree.chart.ChartMouseListener" map="C"/>
  <method class="org.jfree.chart.ChartMouseListener" name="void chartMouseClicked(org.jfree.chart.ChartMouseEvent)" map="A"/>
  <method class="org.jfree.chart.ChartMouseListener" name="void chartMouseMoved(org.jfree.chart.ChartMouseEvent)" map="B"/>
  <class name="org.jfree.chart.LegendItem" map="D"/>
  <field class="org.jfree.chart.LegendItem" name="shape" map="A"/>
  <field class="org.jfree.chart.LegendItem" name="fillPaint" map="B"/>
  <field class="org.jfree.chart.LegendItem" name="fillPaintTransformer" map="C"/>
  <field class="org.jfree.chart.LegendItem" name="shapeOutlineVisible" map="D"/>
  <field class="org.jfree.chart.LegendItem" name="labelFont" map="E"/>
  <field class="org.jfree.chart.LegendItem" name="label" map="F"/>
  <field class="org.jfree.chart.LegendItem" name="shapeFilled" map="G"/>
  <field class="org.jfree.chart.LegendItem" name="shapeVisible" map="H"/>
  <field class="org.jfree.chart.LegendItem" name="series" map="I"/>
  <field class="org.jfree.chart.LegendItem" name="dataset" map="J"/>
  <field class="org.jfree.chart.LegendItem" name="UNUSED_SHAPE" map="K"/>
  <field class="org.jfree.chart.LegendItem" name="line" map="L"/>
  <field class="org.jfree.chart.LegendItem" name="UNUSED_STROKE" map="M"/>
  <field class="org.jfree.chart.LegendItem" name="toolTipText" map="N"/>
  <field class="org.jfree.chart.LegendItem" name="description" map="O"/>
  <field class="org.jfree.chart.LegendItem" name="lineVisible" map="P"/>
  <field class="org.jfree.chart.LegendItem" name="datasetIndex" map="Q"/>
  <field class="org.jfree.chart.LegendItem" name="outlineStroke" map="R"/>
  <field class="org.jfree.chart.LegendItem" name="labelPaint" map="S"/>
  <field class="org.jfree.chart.LegendItem" name="attributedLabel" map="T"/>
  <field class="org.jfree.chart.LegendItem" name="outlinePaint" map="U"/>
  <field class="org.jfree.chart.LegendItem" name="urlText" map="V"/>
  <field class="org.jfree.chart.LegendItem" name="lineStroke" map="W"/>
  <field class="org.jfree.chart.LegendItem" name="linePaint" map="X"/>
  <field class="org.jfree.chart.LegendItem" name="seriesKey" map="Y"/>
  <method class="org.jfree.chart.LegendItem" name="boolean isShapeVisible()" map="A"/>
  <method class="org.jfree.chart.LegendItem" name="java.awt.Shape getLine()" map="B"/>
  <method class="org.jfree.chart.LegendItem" name="void setSeriesKey(java.lang.Comparable)" map="A"/>
  <method class="org.jfree.chart.LegendItem" name="boolean isLineVisible()" map="C"/>
  <method class="org.jfree.chart.LegendItem" name="java.lang.Comparable getSeriesKey()" map="D"/>
  <method class="org.jfree.chart.LegendItem" name="java.lang.String getToolTipText()" map="E"/>
  <method class="org.jfree.chart.LegendItem" name="java.awt.Paint getLinePaint()" map="F"/>
  <method class="org.jfree.chart.LegendItem" name="java.awt.Paint getFillPaint()" map="G"/>
  <method class="org.jfree.chart.LegendItem" name="boolean isShapeFilled()" map="H"/>
  <method class="org.jfree.chart.LegendItem" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.LegendItem" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.LegendItem" name="org.jfree.ui.GradientPaintTransformer getFillPaintTransformer()" map="I"/>
  <method class="org.jfree.chart.LegendItem" name="java.awt.Font getLabelFont()" map="J"/>
  <method class="org.jfree.chart.LegendItem" name="org.jfree.data.general.Dataset getDataset()" map="K"/>
  <method class="org.jfree.chart.LegendItem" name="java.lang.String getLabel()" map="L"/>
  <method class="org.jfree.chart.LegendItem" name="void setLabelPaint(java.awt.Paint)" map="A"/>
  <method class="org.jfree.chart.LegendItem" name="java.lang.String getURLText()" map="M"/>
  <method class="org.jfree.chart.LegendItem" name="java.awt.Paint getOutlinePaint()" map="N"/>
  <method class="org.jfree.chart.LegendItem" name="java.awt.Shape getShape()" map="O"/>
  <method class="org.jfree.chart.LegendItem" name="void setFillPaintTransformer(org.jfree.ui.GradientPaintTransformer)" map="A"/>
  <method class="org.jfree.chart.LegendItem" name="java.awt.Stroke getLineStroke()" map="P"/>
  <method class="org.jfree.chart.LegendItem" name="java.awt.Paint getLabelPaint()" map="Q"/>
  <method class="org.jfree.chart.LegendItem" name="void setLabelFont(java.awt.Font)" map="A"/>
  <method class="org.jfree.chart.LegendItem" name="void setSeriesIndex(int)" map="A"/>
  <method class="org.jfree.chart.LegendItem" name="java.awt.Stroke getOutlineStroke()" map="R"/>
  <method class="org.jfree.chart.LegendItem" name="boolean isShapeOutlineVisible()" map="S"/>
  <method class="org.jfree.chart.LegendItem" name="void setDatasetIndex(int)" map="B"/>
  <method class="org.jfree.chart.LegendItem" name="void setDataset(org.jfree.data.general.Dataset)" map="A"/>
  <class name="org.jfree.chart.StrokeMap" map="E"/>
  <field class="org.jfree.chart.StrokeMap" name="store" map="A"/>
  <method class="org.jfree.chart.StrokeMap" name="void clear()" map="A"/>
  <method class="org.jfree.chart.StrokeMap" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.StrokeMap" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.StrokeMap" name="void put(java.lang.Comparable, java.awt.Stroke)" map="A"/>
  <method class="org.jfree.chart.StrokeMap" name="java.awt.Stroke getStroke(java.lang.Comparable)" map="A"/>
  <class name="org.jfree.chart.LegendItemSource" map="F"/>
  <method class="org.jfree.chart.LegendItemSource" name="org.jfree.chart.LegendItemCollection getLegendItems()" map="S"/>
  <class name="org.jfree.chart.PaintMap" map="G"/>
  <field class="org.jfree.chart.PaintMap" name="store" map="A"/>
  <method class="org.jfree.chart.PaintMap" name="java.awt.Paint getPaint(java.lang.Comparable)" map="A"/>
  <method class="org.jfree.chart.PaintMap" name="void clear()" map="A"/>
  <method class="org.jfree.chart.PaintMap" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.PaintMap" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.PaintMap" name="void put(java.lang.Comparable, java.awt.Paint)" map="A"/>
  <class name="org.jfree.chart.ChartTheme" map="H"/>
  <method class="org.jfree.chart.ChartTheme" name="void apply(org.jfree.chart.JFreeChart)" map="A"/>
  <class name="org.jfree.chart.ChartUtilities" map="I"/>
  <method class="org.jfree.chart.ChartUtilities" name="void saveChartAsPNG(java.io.File, org.jfree.chart.JFreeChart, int, int)" map="A"/>
  <method class="org.jfree.chart.ChartUtilities" name="void saveChartAsPNG(java.io.File, org.jfree.chart.JFreeChart, int, int, org.jfree.chart.ChartRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.ChartUtilities" name="void writeChartAsPNG(java.io.OutputStream, org.jfree.chart.JFreeChart, int, int, org.jfree.chart.ChartRenderingInfo)" map="A"/>
  <class name="org.jfree.chart.ChartFactory" map="J"/>
  <field class="org.jfree.chart.ChartFactory" name="currentTheme" map="A"/>
  <method class="org.jfree.chart.ChartFactory" name="org.jfree.chart.JFreeChart createStackedBarChart(java.lang.String, java.lang.String, java.lang.String, org.jfree.data.category.CategoryDataset, org.jfree.chart.plot.PlotOrientation, boolean, boolean, boolean)" map="A"/>
  <method class="org.jfree.chart.ChartFactory" name="org.jfree.chart.JFreeChart createBarChart(java.lang.String, java.lang.String, java.lang.String, org.jfree.data.category.CategoryDataset, org.jfree.chart.plot.PlotOrientation, boolean, boolean, boolean)" map="B"/>
  <method class="org.jfree.chart.ChartFactory" name="org.jfree.chart.JFreeChart createPieChart(java.lang.String, org.jfree.data.general.PieDataset, boolean, boolean, boolean)" map="A"/>
  <method class="org.jfree.chart.ChartFactory" name="org.jfree.chart.JFreeChart createXYLineChart(java.lang.String, java.lang.String, java.lang.String, org.jfree.data.xy.XYDataset, org.jfree.chart.plot.PlotOrientation, boolean, boolean, boolean)" map="A"/>
  <class name="org.jfree.chart.JFreeChart" map="K"/>
  <field class="org.jfree.chart.JFreeChart" name="progressListeners" map="&#x0207;"/>
  <field class="org.jfree.chart.JFreeChart" name="backgroundImage" map="&#x0208;"/>
  <field class="org.jfree.chart.JFreeChart" name="backgroundPaint" map="&#x0209;"/>
  <field class="org.jfree.chart.JFreeChart" name="backgroundImageAlignment" map="&#x020a;"/>
  <field class="org.jfree.chart.JFreeChart" name="INFO" map="&#x020b;"/>
  <field class="org.jfree.chart.JFreeChart" name="DEFAULT_BACKGROUND_IMAGE" map="&#x020c;"/>
  <field class="org.jfree.chart.JFreeChart" name="DEFAULT_BACKGROUND_PAINT" map="&#x020d;"/>
  <field class="org.jfree.chart.JFreeChart" name="borderStroke" map="&#x020e;"/>
  <field class="org.jfree.chart.JFreeChart" name="renderingHints" map="&#x020f;"/>
  <field class="org.jfree.chart.JFreeChart" name="class$org$jfree$chart$event$ChartProgressListener" map="class$F$B$G$B$L"/>
  <field class="org.jfree.chart.JFreeChart" name="borderVisible" map="&#x0210;"/>
  <field class="org.jfree.chart.JFreeChart" name="notify" map="&#x0211;"/>
  <field class="org.jfree.chart.JFreeChart" name="padding" map="&#x0212;"/>
  <field class="org.jfree.chart.JFreeChart" name="plot" map="&#x0213;"/>
  <field class="org.jfree.chart.JFreeChart" name="DEFAULT_TITLE_FONT" map="&#x0214;"/>
  <field class="org.jfree.chart.JFreeChart" name="subtitles" map="&#x0215;"/>
  <field class="org.jfree.chart.JFreeChart" name="class$org$jfree$chart$event$ChartChangeListener" map="class$F$B$G$B$K"/>
  <field class="org.jfree.chart.JFreeChart" name="borderPaint" map="&#x0216;"/>
  <field class="org.jfree.chart.JFreeChart" name="backgroundImageAlpha" map="&#x0217;"/>
  <field class="org.jfree.chart.JFreeChart" name="changeListeners" map="&#x0250;"/>
  <field class="org.jfree.chart.JFreeChart" name="title" map="&#x0251;"/>
  <method class="org.jfree.chart.JFreeChart" name="void fireChartChanged()" map="&#x0142;"/>
  <method class="org.jfree.chart.JFreeChart" name="java.awt.image.BufferedImage createBufferedImage(int, int, org.jfree.chart.ChartRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.JFreeChart" name="java.awt.geom.Rectangle2D createAlignedRectangle2D(org.jfree.ui.Size2D, java.awt.geom.Rectangle2D, org.jfree.ui.HorizontalAlignment, org.jfree.ui.VerticalAlignment)" map="A"/>
  <method class="org.jfree.chart.JFreeChart" name="void notifyListeners(org.jfree.chart.event.ChartChangeEvent)" map="A"/>
  <method class="org.jfree.chart.JFreeChart" name="void removeChangeListener(org.jfree.chart.event.ChartChangeListener)" map="A"/>
  <method class="org.jfree.chart.JFreeChart" name="boolean isBorderVisible()" map="&#x0143;"/>
  <method class="org.jfree.chart.JFreeChart" name="void setTitle(org.jfree.chart.title.TextTitle)" map="A"/>
  <method class="org.jfree.chart.JFreeChart" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.JFreeChart" name="int getSubtitleCount()" map="&#x0144;"/>
  <method class="org.jfree.chart.JFreeChart" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.JFreeChart" name="void removeProgressListener(org.jfree.chart.event.ChartProgressListener)" map="A"/>
  <method class="org.jfree.chart.JFreeChart" name="void addChangeListener(org.jfree.chart.event.ChartChangeListener)" map="B"/>
  <method class="org.jfree.chart.JFreeChart" name="org.jfree.chart.plot.CategoryPlot getCategoryPlot()" map="&#x0145;"/>
  <method class="org.jfree.chart.JFreeChart" name="org.jfree.chart.title.TextTitle getTitle()" map="&#x0146;"/>
  <method class="org.jfree.chart.JFreeChart" name="void draw(java.awt.Graphics2D, java.awt.geom.Rectangle2D, java.awt.geom.Point2D, org.jfree.chart.ChartRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.JFreeChart" name="org.jfree.chart.plot.Plot getPlot()" map="&#x0147;"/>
  <method class="org.jfree.chart.JFreeChart" name="void plotChanged(org.jfree.chart.event.PlotChangeEvent)" map="A"/>
  <method class="org.jfree.chart.JFreeChart" name="void setNotify(boolean)" map="Q"/>
  <method class="org.jfree.chart.JFreeChart" name="void titleChanged(org.jfree.chart.event.TitleChangeEvent)" map="A"/>
  <method class="org.jfree.chart.JFreeChart" name="void notifyListeners(org.jfree.chart.event.ChartProgressEvent)" map="A"/>
  <method class="org.jfree.chart.JFreeChart" name="java.awt.image.BufferedImage createBufferedImage(int, int, int, org.jfree.chart.ChartRenderingInfo)" map="A"/>
  <method class="org.jfree.chart.JFreeChart" name="org.jfree.chart.plot.XYPlot getXYPlot()" map="&#x0148;"/>
  <method class="org.jfree.chart.JFreeChart" name="void setAntiAlias(boolean)" map="R"/>
  <method class="org.jfree.chart.JFreeChart" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jfree.chart.JFreeChart" name="org.jfree.chart.entity.EntityCollection drawTitle(org.jfree.chart.title.Title, java.awt.Graphics2D, java.awt.geom.Rectangle2D, boolean)" map="A"/>
  <method class="org.jfree.chart.JFreeChart" name="java.awt.Paint getBackgroundPaint()" map="&#x0149;"/>
  <method class="org.jfree.chart.JFreeChart" name="org.jfree.chart.title.Title getSubtitle(int)" map="&#x00c7;"/>
  <method class="org.jfree.chart.JFreeChart" name="java.awt.Stroke getBorderStroke()" map="&#x014a;"/>
  <method class="org.jfree.chart.JFreeChart" name="void addProgressListener(org.jfree.chart.event.ChartProgressListener)" map="B"/>
  <method class="org.jfree.chart.JFreeChart" name="void setBackgroundPaint(java.awt.Paint)" map="e"/>
  <method class="org.jfree.chart.JFreeChart" name="boolean getAntiAlias()" map="&#x014b;"/>
  <method class="org.jfree.chart.JFreeChart" name="java.awt.Paint getBorderPaint()" map="&#x014c;"/>
  <class name="org.jfree.chart.StandardChartTheme" map="L"/>
  <field class="org.jfree.chart.StandardChartTheme" name="crosshairPaint" map="&#x03f3;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="axisOffset" map="&#x0401;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="smallFont" map="&#x0402;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="regularFont" map="&#x0403;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="plotBackgroundPaint" map="&#x0404;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="errorIndicatorPaint" map="&#x0405;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="legendBackgroundPaint" map="&#x0406;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="drawingSupplier" map="&#x0407;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="wallPaint" map="&#x0408;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="plotOutlinePaint" map="&#x0409;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="shadowGenerator" map="&#x040a;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="thermometerPaint" map="&#x040b;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="shadowPaint" map="&#x040c;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="gridBandAlternatePaint" map="&#x040e;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="domainGridlinePaint" map="&#x040f;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="gridBandPaint" map="&#x0410;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="titlePaint" map="&#x0411;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="barPainter" map="&#x0412;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="xyBarPainter" map="&#x0413;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="tickLabelPaint" map="&#x0414;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="largeFont" map="&#x0415;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="extraLargeFont" map="&#x0416;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="axisLabelPaint" map="&#x0417;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="rangeGridlinePaint" map="&#x0418;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="labelLinkPaint" map="&#x0419;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="itemLabelPaint" map="&#x041a;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="chartBackgroundPaint" map="&#x041b;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="baselinePaint" map="&#x041c;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="legendItemPaint" map="&#x041d;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="shadowVisible" map="&#x041e;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="subtitlePaint" map="&#x041f;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="labelLinkStyle" map="&#x0420;"/>
  <field class="org.jfree.chart.StandardChartTheme" name="name" map="&#x0421;"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToTitle(org.jfree.chart.title.Title)" map="A"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToAbstractRenderer(org.jfree.chart.renderer.AbstractRenderer)" map="A"/>
  <method class="org.jfree.chart.StandardChartTheme" name="org.jfree.chart.plot.DrawingSupplier getDrawingSupplier()" map="&#x01a8;"/>
  <method class="org.jfree.chart.StandardChartTheme" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToPolarPlot(org.jfree.chart.plot.PolarPlot)" map="A"/>
  <method class="org.jfree.chart.StandardChartTheme" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToSymbolAxis(org.jfree.chart.axis.SymbolAxis)" map="A"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToPiePlot(org.jfree.chart.plot.PiePlot)" map="A"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToMultiplePiePlot(org.jfree.chart.plot.MultiplePiePlot)" map="A"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToMeterPlot(org.jfree.chart.plot.MeterPlot)" map="A"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToBlock(org.jfree.chart.block.Block)" map="B"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToXYItemRenderer(org.jfree.chart.renderer.xy.XYItemRenderer)" map="C"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToSpiderWebPlot(org.jfree.chart.plot.SpiderWebPlot)" map="A"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToCategoryAxis(org.jfree.chart.axis.CategoryAxis)" map="B"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToCategoryItemRenderer(org.jfree.chart.renderer.category.CategoryItemRenderer)" map="C"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToCategoryPlot(org.jfree.chart.plot.CategoryPlot)" map="B"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToPlot(org.jfree.chart.plot.Plot)" map="B"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToXYAnnotation(org.jfree.chart.annotations.XYAnnotation)" map="A"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToXYPlot(org.jfree.chart.plot.XYPlot)" map="B"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToThermometerPlot(org.jfree.chart.plot.ThermometerPlot)" map="A"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToFastScatterPlot(org.jfree.chart.plot.FastScatterPlot)" map="A"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToValueAxis(org.jfree.chart.axis.ValueAxis)" map="D"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToPeriodAxis(org.jfree.chart.axis.PeriodAxis)" map="A"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void apply(org.jfree.chart.JFreeChart)" map="A"/>
  <method class="org.jfree.chart.StandardChartTheme" name="void applyToBlockContainer(org.jfree.chart.block.BlockContainer)" map="A"/>
  <class name="org.jfree.chart.LegendItemCollection" map="M"/>
  <field class="org.jfree.chart.LegendItemCollection" name="items" map="A"/>
  <method class="org.jfree.chart.LegendItemCollection" name="void add(org.jfree.chart.LegendItem)" map="A"/>
  <method class="org.jfree.chart.LegendItemCollection" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.LegendItemCollection" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.LegendItemCollection" name="int getItemCount()" map="A"/>
  <method class="org.jfree.chart.LegendItemCollection" name="org.jfree.chart.LegendItem get(int)" map="A"/>
  <method class="org.jfree.chart.LegendItemCollection" name="void addAll(org.jfree.chart.LegendItemCollection)" map="A"/>
  <class name="org.jfree.chart.ChartRenderingInfo" map="N"/>
  <field class="org.jfree.chart.ChartRenderingInfo" name="chartArea" map="A"/>
  <field class="org.jfree.chart.ChartRenderingInfo" name="entities" map="B"/>
  <field class="org.jfree.chart.ChartRenderingInfo" name="plotInfo" map="C"/>
  <method class="org.jfree.chart.ChartRenderingInfo" name="org.jfree.chart.plot.PlotRenderingInfo getPlotInfo()" map="A"/>
  <method class="org.jfree.chart.ChartRenderingInfo" name="void setChartArea(java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.chart.ChartRenderingInfo" name="void clear()" map="B"/>
  <method class="org.jfree.chart.ChartRenderingInfo" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.chart.ChartRenderingInfo" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.chart.ChartRenderingInfo" name="org.jfree.chart.entity.EntityCollection getEntityCollection()" map="C"/>
  <class name="org.jfree.chart.ChartMouseEvent" map="O"/>
  <field class="org.jfree.chart.ChartMouseEvent" name="entity" map="A"/>
  <field class="org.jfree.chart.ChartMouseEvent" name="trigger" map="B"/>
  <field class="org.jfree.chart.ChartMouseEvent" name="chart" map="C"/>
  <class name="org.jfree.chart.HashUtilities" map="P"/>
  <method class="org.jfree.chart.HashUtilities" name="int hashCodeForPaint(java.awt.Paint)" map="A"/>
  <method class="org.jfree.chart.HashUtilities" name="int hashCode(int, java.lang.Comparable)" map="A"/>
  <method class="org.jfree.chart.HashUtilities" name="int hashCode(int, org.jfree.util.BooleanList)" map="A"/>
  <method class="org.jfree.chart.HashUtilities" name="int hashCode(int, java.lang.String)" map="A"/>
  <method class="org.jfree.chart.HashUtilities" name="int hashCode(int, boolean)" map="A"/>
  <method class="org.jfree.chart.HashUtilities" name="int hashCode(int, org.jfree.util.StrokeList)" map="A"/>
  <method class="org.jfree.chart.HashUtilities" name="int hashCode(int, java.awt.Paint)" map="A"/>
  <method class="org.jfree.chart.HashUtilities" name="int hashCode(int, double)" map="A"/>
  <method class="org.jfree.chart.HashUtilities" name="int hashCode(int, int)" map="A"/>
  <method class="org.jfree.chart.HashUtilities" name="int hashCode(int, java.lang.Object)" map="A"/>
  <method class="org.jfree.chart.HashUtilities" name="int hashCode(int, java.awt.Stroke)" map="A"/>
  <method class="org.jfree.chart.HashUtilities" name="int hashCode(int, org.jfree.util.PaintList)" map="A"/>
  <class name="org.jfree.chart.JFreeChartInfo" map="Q"/>
  <class name="org.jfree.chart.Effect3D" map="R"/>
  <class name="org.jfree.chart.ChartTransferable" map="S"/>
  <field class="org.jfree.chart.ChartTransferable" name="height" map="A"/>
  <field class="org.jfree.chart.ChartTransferable" name="imageFlavor" map="B"/>
  <field class="org.jfree.chart.ChartTransferable" name="maxDrawWidth" map="C"/>
  <field class="org.jfree.chart.ChartTransferable" name="maxDrawHeight" map="D"/>
  <field class="org.jfree.chart.ChartTransferable" name="minDrawHeight" map="E"/>
  <field class="org.jfree.chart.ChartTransferable" name="width" map="F"/>
  <field class="org.jfree.chart.ChartTransferable" name="chart" map="G"/>
  <field class="org.jfree.chart.ChartTransferable" name="minDrawWidth" map="H"/>
  <method class="org.jfree.chart.ChartTransferable" name="java.awt.datatransfer.DataFlavor[] getTransferDataFlavors()" map="getTransferDataFlavors"/>
  <method class="org.jfree.chart.ChartTransferable" name="boolean isDataFlavorSupported(java.awt.datatransfer.DataFlavor)" map="isDataFlavorSupported"/>
  <method class="org.jfree.chart.ChartTransferable" name="java.awt.image.BufferedImage createBufferedImage(org.jfree.chart.JFreeChart, int, int, int, int, int, int)" map="A"/>
  <method class="org.jfree.chart.ChartTransferable" name="java.lang.Object getTransferData(java.awt.datatransfer.DataFlavor)" map="getTransferData"/>
  <package name="org.jfree.ui" map="H"/>
  <package name="org.jfree.ui.tabbedui" map="A"/>
  <class name="org.jfree.ui.tabbedui.VerticalLayout" map="A"/>
  <field class="org.jfree.ui.tabbedui.VerticalLayout" name="useSizeFromParent" map="A"/>
  <method class="org.jfree.ui.tabbedui.VerticalLayout" name="java.awt.Dimension minimumLayoutSize(java.awt.Container)" map="minimumLayoutSize"/>
  <method class="org.jfree.ui.tabbedui.VerticalLayout" name="void removeLayoutComponent(java.awt.Component)" map="removeLayoutComponent"/>
  <method class="org.jfree.ui.tabbedui.VerticalLayout" name="void layoutContainer(java.awt.Container)" map="layoutContainer"/>
  <method class="org.jfree.ui.tabbedui.VerticalLayout" name="boolean isUseSizeFromParent()" map="A"/>
  <method class="org.jfree.ui.tabbedui.VerticalLayout" name="java.awt.Dimension preferredLayoutSize(java.awt.Container)" map="preferredLayoutSize"/>
  <method class="org.jfree.ui.tabbedui.VerticalLayout" name="void addLayoutComponent(java.lang.String, java.awt.Component)" map="addLayoutComponent"/>
  <package name="org.jfree.ui.about" map="B"/>
  <class name="org.jfree.ui.about.ProjectInfo" map="A"/>
  <field class="org.jfree.ui.about.ProjectInfo" name="logo" map="J"/>
  <field class="org.jfree.ui.about.ProjectInfo" name="contributors" map="K"/>
  <field class="org.jfree.ui.about.ProjectInfo" name="licenceText" map="L"/>
  <method class="org.jfree.ui.about.ProjectInfo" name="void setLicenceText(java.lang.String)" map="G"/>
  <method class="org.jfree.ui.about.ProjectInfo" name="void setContributors(java.util.List)" map="A"/>
  <method class="org.jfree.ui.about.ProjectInfo" name="java.lang.String getLicenceText()" map="F"/>
  <method class="org.jfree.ui.about.ProjectInfo" name="void setLogo(java.awt.Image)" map="A"/>
  <method class="org.jfree.ui.about.ProjectInfo" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.ui.about.Licences" map="B"/>
  <field class="org.jfree.ui.about.Licences" name="singleton" map="A"/>
  <method class="org.jfree.ui.about.Licences" name="java.lang.String getLGPL()" map="A"/>
  <method class="org.jfree.ui.about.Licences" name="org.jfree.ui.about.Licences getInstance()" map="B"/>
  <class name="org.jfree.ui.about.Contributor" map="C"/>
  <field class="org.jfree.ui.about.Contributor" name="email" map="A"/>
  <field class="org.jfree.ui.about.Contributor" name="name" map="B"/>
  <method class="org.jfree.ui.about.Contributor" name="java.lang.String getEmail()" map="A"/>
  <method class="org.jfree.ui.about.Contributor" name="java.lang.String getName()" map="B"/>
  <class name="org.jfree.ui.LengthAdjustmentType" map="A"/>
  <field class="org.jfree.ui.LengthAdjustmentType" name="EXPAND" map="A"/>
  <field class="org.jfree.ui.LengthAdjustmentType" name="name" map="B"/>
  <field class="org.jfree.ui.LengthAdjustmentType" name="CONTRACT" map="C"/>
  <field class="org.jfree.ui.LengthAdjustmentType" name="NO_CHANGE" map="D"/>
  <method class="org.jfree.ui.LengthAdjustmentType" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.ui.LengthAdjustmentType" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.ui.LengthAdjustmentType" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.ui.GradientPaintTransformer" map="B"/>
  <method class="org.jfree.ui.GradientPaintTransformer" name="java.awt.GradientPaint transform(java.awt.GradientPaint, java.awt.Shape)" map="A"/>
  <class name="org.jfree.ui.VerticalAlignment" map="C"/>
  <field class="org.jfree.ui.VerticalAlignment" name="name" map="A"/>
  <field class="org.jfree.ui.VerticalAlignment" name="TOP" map="B"/>
  <field class="org.jfree.ui.VerticalAlignment" name="CENTER" map="C"/>
  <field class="org.jfree.ui.VerticalAlignment" name="BOTTOM" map="D"/>
  <method class="org.jfree.ui.VerticalAlignment" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.ui.VerticalAlignment" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.ui.VerticalAlignment" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.ui.Drawable" map="D"/>
  <class name="org.jfree.ui.TextAnchor" map="E"/>
  <field class="org.jfree.ui.TextAnchor" name="name" map="A"/>
  <field class="org.jfree.ui.TextAnchor" name="TOP_LEFT" map="B"/>
  <field class="org.jfree.ui.TextAnchor" name="TOP_RIGHT" map="C"/>
  <field class="org.jfree.ui.TextAnchor" name="BASELINE_CENTER" map="D"/>
  <field class="org.jfree.ui.TextAnchor" name="BOTTOM_CENTER" map="E"/>
  <field class="org.jfree.ui.TextAnchor" name="HALF_ASCENT_RIGHT" map="F"/>
  <field class="org.jfree.ui.TextAnchor" name="CENTER_RIGHT" map="G"/>
  <field class="org.jfree.ui.TextAnchor" name="BASELINE_LEFT" map="H"/>
  <field class="org.jfree.ui.TextAnchor" name="HALF_ASCENT_CENTER" map="I"/>
  <field class="org.jfree.ui.TextAnchor" name="TOP_CENTER" map="J"/>
  <field class="org.jfree.ui.TextAnchor" name="HALF_ASCENT_LEFT" map="K"/>
  <field class="org.jfree.ui.TextAnchor" name="BASELINE_RIGHT" map="L"/>
  <field class="org.jfree.ui.TextAnchor" name="BOTTOM_LEFT" map="M"/>
  <field class="org.jfree.ui.TextAnchor" name="CENTER" map="N"/>
  <field class="org.jfree.ui.TextAnchor" name="BOTTOM_RIGHT" map="O"/>
  <field class="org.jfree.ui.TextAnchor" name="CENTER_LEFT" map="P"/>
  <method class="org.jfree.ui.TextAnchor" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.ui.TextAnchor" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.ui.TextAnchor" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.ui.StandardGradientPaintTransformer" map="F"/>
  <field class="org.jfree.ui.StandardGradientPaintTransformer" name="type" map="&#x0422;"/>
  <method class="org.jfree.ui.StandardGradientPaintTransformer" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.ui.StandardGradientPaintTransformer" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.ui.StandardGradientPaintTransformer" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.ui.StandardGradientPaintTransformer" name="java.awt.GradientPaint transform(java.awt.GradientPaint, java.awt.Shape)" map="A"/>
  <class name="org.jfree.ui.FontChooserPanel" map="G"/>
  <field class="org.jfree.ui.FontChooserPanel" name="localizationResources" map="A"/>
  <field class="org.jfree.ui.FontChooserPanel" name="italic" map="B"/>
  <field class="org.jfree.ui.FontChooserPanel" name="fontlist" map="C"/>
  <field class="org.jfree.ui.FontChooserPanel" name="bold" map="D"/>
  <field class="org.jfree.ui.FontChooserPanel" name="SIZES" map="E"/>
  <field class="org.jfree.ui.FontChooserPanel" name="sizelist" map="F"/>
  <method class="org.jfree.ui.FontChooserPanel" name="void setSelectedFont(java.awt.Font)" map="A"/>
  <method class="org.jfree.ui.FontChooserPanel" name="int getSelectedStyle()" map="A"/>
  <method class="org.jfree.ui.FontChooserPanel" name="java.awt.Font getSelectedFont()" map="B"/>
  <method class="org.jfree.ui.FontChooserPanel" name="int getSelectedSize()" map="C"/>
  <method class="org.jfree.ui.FontChooserPanel" name="java.lang.String getSelectedName()" map="D"/>
  <class name="org.jfree.ui.Layer" map="H"/>
  <field class="org.jfree.ui.Layer" name="FOREGROUND" map="A"/>
  <field class="org.jfree.ui.Layer" name="name" map="B"/>
  <field class="org.jfree.ui.Layer" name="BACKGROUND" map="C"/>
  <method class="org.jfree.ui.Layer" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.ui.Layer" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.ui.Layer" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.ui.ExtensionFileFilter" map="I"/>
  <field class="org.jfree.ui.ExtensionFileFilter" name="description" map="A"/>
  <field class="org.jfree.ui.ExtensionFileFilter" name="extension" map="B"/>
  <method class="org.jfree.ui.ExtensionFileFilter" name="boolean accept(java.io.File)" map="accept"/>
  <method class="org.jfree.ui.ExtensionFileFilter" name="java.lang.String getDescription()" map="getDescription"/>
  <class name="org.jfree.ui.RectangleAnchor" map="J"/>
  <field class="org.jfree.ui.RectangleAnchor" name="name" map="A"/>
  <field class="org.jfree.ui.RectangleAnchor" name="TOP_LEFT" map="B"/>
  <field class="org.jfree.ui.RectangleAnchor" name="TOP_RIGHT" map="C"/>
  <field class="org.jfree.ui.RectangleAnchor" name="LEFT" map="D"/>
  <field class="org.jfree.ui.RectangleAnchor" name="TOP" map="E"/>
  <field class="org.jfree.ui.RectangleAnchor" name="RIGHT" map="F"/>
  <field class="org.jfree.ui.RectangleAnchor" name="BOTTOM" map="G"/>
  <field class="org.jfree.ui.RectangleAnchor" name="CENTER" map="H"/>
  <field class="org.jfree.ui.RectangleAnchor" name="BOTTOM_LEFT" map="I"/>
  <field class="org.jfree.ui.RectangleAnchor" name="BOTTOM_RIGHT" map="J"/>
  <method class="org.jfree.ui.RectangleAnchor" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.ui.RectangleAnchor" name="java.awt.geom.Rectangle2D createRectangle(org.jfree.ui.Size2D, double, double, org.jfree.ui.RectangleAnchor)" map="A"/>
  <method class="org.jfree.ui.RectangleAnchor" name="java.awt.geom.Point2D coordinates(java.awt.geom.Rectangle2D, org.jfree.ui.RectangleAnchor)" map="A"/>
  <method class="org.jfree.ui.RectangleAnchor" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.ui.RectangleAnchor" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.ui.Size2D" map="K"/>
  <field class="org.jfree.ui.Size2D" name="height" map="&#x0423;"/>
  <field class="org.jfree.ui.Size2D" name="width" map="&#x0424;"/>
  <method class="org.jfree.ui.Size2D" name="double getWidth()" map="&#x01a9;"/>
  <method class="org.jfree.ui.Size2D" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jfree.ui.Size2D" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.ui.Size2D" name="double getHeight()" map="&#x01aa;"/>
  <method class="org.jfree.ui.Size2D" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.ui.StrokeChooserPanel$1" map="1"/>
  <field class="org.jfree.ui.StrokeChooserPanel$1" name="this$0" map="this$0"/>
  <method class="org.jfree.ui.StrokeChooserPanel$1" name="void actionPerformed(java.awt.event.ActionEvent)" map="actionPerformed"/>
  <class name="org.jfree.ui.StrokeChooserPanel" map="L"/>
  <field class="org.jfree.ui.StrokeChooserPanel" name="selector" map="A"/>
  <method class="org.jfree.ui.StrokeChooserPanel" name="java.awt.Stroke getSelectedStroke()" map="A"/>
  <method class="org.jfree.ui.StrokeChooserPanel" name="javax.swing.JComboBox getSelector()" map="B"/>
  <class name="org.jfree.ui.GradientPaintTransformType" map="M"/>
  <field class="org.jfree.ui.GradientPaintTransformType" name="CENTER_HORIZONTAL" map="A"/>
  <field class="org.jfree.ui.GradientPaintTransformType" name="CENTER_VERTICAL" map="B"/>
  <field class="org.jfree.ui.GradientPaintTransformType" name="name" map="C"/>
  <field class="org.jfree.ui.GradientPaintTransformType" name="HORIZONTAL" map="D"/>
  <field class="org.jfree.ui.GradientPaintTransformType" name="VERTICAL" map="E"/>
  <method class="org.jfree.ui.GradientPaintTransformType" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.ui.GradientPaintTransformType" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.ui.GradientPaintTransformType" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.ui.StrokeSample" map="N"/>
  <field class="org.jfree.ui.StrokeSample" name="preferredSize" map="A"/>
  <field class="org.jfree.ui.StrokeSample" name="stroke" map="B"/>
  <method class="org.jfree.ui.StrokeSample" name="void paintComponent(java.awt.Graphics)" map="paintComponent"/>
  <method class="org.jfree.ui.StrokeSample" name="java.awt.Stroke getStroke()" map="A"/>
  <method class="org.jfree.ui.StrokeSample" name="java.awt.Dimension getPreferredSize()" map="getPreferredSize"/>
  <method class="org.jfree.ui.StrokeSample" name="void setStroke(java.awt.Stroke)" map="A"/>
  <method class="org.jfree.ui.StrokeSample" name="java.awt.Component getListCellRendererComponent(javax.swing.JList, java.lang.Object, int, boolean, boolean)" map="getListCellRendererComponent"/>
  <class name="org.jfree.ui.HorizontalAlignment" map="O"/>
  <field class="org.jfree.ui.HorizontalAlignment" name="LEFT" map="A"/>
  <field class="org.jfree.ui.HorizontalAlignment" name="name" map="B"/>
  <field class="org.jfree.ui.HorizontalAlignment" name="RIGHT" map="C"/>
  <field class="org.jfree.ui.HorizontalAlignment" name="CENTER" map="D"/>
  <method class="org.jfree.ui.HorizontalAlignment" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.ui.HorizontalAlignment" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.ui.HorizontalAlignment" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.ui.RectangleInsets" map="P"/>
  <field class="org.jfree.ui.RectangleInsets" name="bottom" map="A"/>
  <field class="org.jfree.ui.RectangleInsets" name="unitType" map="B"/>
  <field class="org.jfree.ui.RectangleInsets" name="right" map="C"/>
  <field class="org.jfree.ui.RectangleInsets" name="left" map="D"/>
  <field class="org.jfree.ui.RectangleInsets" name="top" map="E"/>
  <field class="org.jfree.ui.RectangleInsets" name="ZERO_INSETS" map="F"/>
  <method class="org.jfree.ui.RectangleInsets" name="java.awt.geom.Rectangle2D createInsetRectangle(java.awt.geom.Rectangle2D, boolean, boolean)" map="A"/>
  <method class="org.jfree.ui.RectangleInsets" name="double calculateBottomOutset(double)" map="A"/>
  <method class="org.jfree.ui.RectangleInsets" name="void trim(java.awt.geom.Rectangle2D)" map="A"/>
  <method class="org.jfree.ui.RectangleInsets" name="double calculateLeftOutset(double)" map="B"/>
  <method class="org.jfree.ui.RectangleInsets" name="java.awt.geom.Rectangle2D createInsetRectangle(java.awt.geom.Rectangle2D)" map="B"/>
  <method class="org.jfree.ui.RectangleInsets" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.ui.RectangleInsets" name="double calculateRightOutset(double)" map="C"/>
  <method class="org.jfree.ui.RectangleInsets" name="java.lang.String toString()" map="toString"/>
  <method class="org.jfree.ui.RectangleInsets" name="java.awt.geom.Rectangle2D createOutsetRectangle(java.awt.geom.Rectangle2D)" map="C"/>
  <method class="org.jfree.ui.RectangleInsets" name="java.awt.geom.Rectangle2D createOutsetRectangle(java.awt.geom.Rectangle2D, boolean, boolean)" map="B"/>
  <method class="org.jfree.ui.RectangleInsets" name="double extendHeight(double)" map="D"/>
  <method class="org.jfree.ui.RectangleInsets" name="double calculateRightInset(double)" map="E"/>
  <method class="org.jfree.ui.RectangleInsets" name="double getBottom()" map="A"/>
  <method class="org.jfree.ui.RectangleInsets" name="double calculateLeftInset(double)" map="F"/>
  <method class="org.jfree.ui.RectangleInsets" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.ui.RectangleInsets" name="double trimHeight(double)" map="G"/>
  <method class="org.jfree.ui.RectangleInsets" name="double calculateTopInset(double)" map="H"/>
  <method class="org.jfree.ui.RectangleInsets" name="double trimWidth(double)" map="I"/>
  <method class="org.jfree.ui.RectangleInsets" name="double getRight()" map="B"/>
  <method class="org.jfree.ui.RectangleInsets" name="java.awt.geom.Rectangle2D createAdjustedRectangle(java.awt.geom.Rectangle2D, org.jfree.ui.LengthAdjustmentType, org.jfree.ui.LengthAdjustmentType)" map="A"/>
  <method class="org.jfree.ui.RectangleInsets" name="double calculateTopOutset(double)" map="J"/>
  <method class="org.jfree.ui.RectangleInsets" name="double extendWidth(double)" map="K"/>
  <method class="org.jfree.ui.RectangleInsets" name="double calculateBottomInset(double)" map="L"/>
  <method class="org.jfree.ui.RectangleInsets" name="double getLeft()" map="C"/>
  <method class="org.jfree.ui.RectangleInsets" name="double getTop()" map="D"/>
  <class name="org.jfree.ui.FontDisplayField" map="Q"/>
  <field class="org.jfree.ui.FontDisplayField" name="displayFont" map="A"/>
  <field class="org.jfree.ui.FontDisplayField" name="localizationResources" map="B"/>
  <method class="org.jfree.ui.FontDisplayField" name="void setDisplayFont(java.awt.Font)" map="A"/>
  <method class="org.jfree.ui.FontDisplayField" name="java.lang.String fontToString(java.awt.Font)" map="B"/>
  <class name="org.jfree.ui.PaintSample" map="R"/>
  <field class="org.jfree.ui.PaintSample" name="preferredSize" map="A"/>
  <field class="org.jfree.ui.PaintSample" name="paint" map="B"/>
  <method class="org.jfree.ui.PaintSample" name="void paintComponent(java.awt.Graphics)" map="paintComponent"/>
  <method class="org.jfree.ui.PaintSample" name="void setPaint(java.awt.Paint)" map="A"/>
  <method class="org.jfree.ui.PaintSample" name="java.awt.Dimension getPreferredSize()" map="getPreferredSize"/>
  <method class="org.jfree.ui.PaintSample" name="java.awt.Paint getPaint()" map="A"/>
  <class name="org.jfree.ui.RectangleEdge" map="S"/>
  <field class="org.jfree.ui.RectangleEdge" name="LEFT" map="A"/>
  <field class="org.jfree.ui.RectangleEdge" name="name" map="B"/>
  <field class="org.jfree.ui.RectangleEdge" name="RIGHT" map="C"/>
  <field class="org.jfree.ui.RectangleEdge" name="TOP" map="D"/>
  <field class="org.jfree.ui.RectangleEdge" name="BOTTOM" map="E"/>
  <method class="org.jfree.ui.RectangleEdge" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.ui.RectangleEdge" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.ui.RectangleEdge" name="boolean isTopOrBottom(org.jfree.ui.RectangleEdge)" map="A"/>
  <method class="org.jfree.ui.RectangleEdge" name="org.jfree.ui.RectangleEdge opposite(org.jfree.ui.RectangleEdge)" map="B"/>
  <method class="org.jfree.ui.RectangleEdge" name="boolean isLeftOrRight(org.jfree.ui.RectangleEdge)" map="C"/>
  <method class="org.jfree.ui.RectangleEdge" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.ui.Align" map="T"/>
  <method class="org.jfree.ui.Align" name="void align(java.awt.geom.Rectangle2D, java.awt.geom.Rectangle2D, int)" map="A"/>
  <package name="org.jfree.text" map="I"/>
  <class name="org.jfree.text.TextFragment" map="A"/>
  <field class="org.jfree.text.TextFragment" name="baselineOffset" map="A"/>
  <field class="org.jfree.text.TextFragment" name="DEFAULT_FONT" map="B"/>
  <field class="org.jfree.text.TextFragment" name="font" map="C"/>
  <field class="org.jfree.text.TextFragment" name="logger" map="D"/>
  <field class="org.jfree.text.TextFragment" name="DEFAULT_PAINT" map="E"/>
  <field class="org.jfree.text.TextFragment" name="class$org$jfree$text$TextFragment" map="class$F$B$I$A"/>
  <field class="org.jfree.text.TextFragment" name="paint" map="F"/>
  <field class="org.jfree.text.TextFragment" name="text" map="G"/>
  <method class="org.jfree.text.TextFragment" name="java.lang.String getText()" map="A"/>
  <method class="org.jfree.text.TextFragment" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.text.TextFragment" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jfree.text.TextFragment" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.text.TextFragment" name="java.awt.Paint getPaint()" map="B"/>
  <method class="org.jfree.text.TextFragment" name="void draw(java.awt.Graphics2D, float, float, org.jfree.ui.TextAnchor, float, float, double)" map="A"/>
  <method class="org.jfree.text.TextFragment" name="java.awt.Font getFont()" map="C"/>
  <method class="org.jfree.text.TextFragment" name="float calculateBaselineOffset(java.awt.Graphics2D, org.jfree.ui.TextAnchor)" map="A"/>
  <method class="org.jfree.text.TextFragment" name="org.jfree.ui.Size2D calculateDimensions(java.awt.Graphics2D)" map="A"/>
  <class name="org.jfree.text.G2TextMeasurer" map="B"/>
  <field class="org.jfree.text.G2TextMeasurer" name="g2" map="A"/>
  <method class="org.jfree.text.G2TextMeasurer" name="float getStringWidth(java.lang.String, int, int)" map="A"/>
  <class name="org.jfree.text.TextBlock" map="C"/>
  <field class="org.jfree.text.TextBlock" name="lines" map="A"/>
  <field class="org.jfree.text.TextBlock" name="lineAlignment" map="B"/>
  <method class="org.jfree.text.TextBlock" name="float[] calculateOffsets(org.jfree.text.TextBlockAnchor, double, double)" map="A"/>
  <method class="org.jfree.text.TextBlock" name="void draw(java.awt.Graphics2D, float, float, org.jfree.text.TextBlockAnchor, float, float, double)" map="A"/>
  <method class="org.jfree.text.TextBlock" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.text.TextBlock" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.text.TextBlock" name="void addLine(org.jfree.text.TextLine)" map="A"/>
  <method class="org.jfree.text.TextBlock" name="void addLine(java.lang.String, java.awt.Font, java.awt.Paint)" map="A"/>
  <method class="org.jfree.text.TextBlock" name="org.jfree.text.TextLine getLastLine()" map="A"/>
  <method class="org.jfree.text.TextBlock" name="org.jfree.ui.Size2D calculateDimensions(java.awt.Graphics2D)" map="A"/>
  <method class="org.jfree.text.TextBlock" name="void draw(java.awt.Graphics2D, float, float, org.jfree.text.TextBlockAnchor)" map="A"/>
  <method class="org.jfree.text.TextBlock" name="void setLineAlignment(org.jfree.ui.HorizontalAlignment)" map="A"/>
  <method class="org.jfree.text.TextBlock" name="java.awt.Shape calculateBounds(java.awt.Graphics2D, float, float, org.jfree.text.TextBlockAnchor, float, float, double)" map="B"/>
  <class name="org.jfree.text.TextBlockAnchor" map="D"/>
  <field class="org.jfree.text.TextBlockAnchor" name="name" map="A"/>
  <field class="org.jfree.text.TextBlockAnchor" name="TOP_LEFT" map="B"/>
  <field class="org.jfree.text.TextBlockAnchor" name="TOP_RIGHT" map="C"/>
  <field class="org.jfree.text.TextBlockAnchor" name="BOTTOM_CENTER" map="D"/>
  <field class="org.jfree.text.TextBlockAnchor" name="CENTER_RIGHT" map="E"/>
  <field class="org.jfree.text.TextBlockAnchor" name="TOP_CENTER" map="F"/>
  <field class="org.jfree.text.TextBlockAnchor" name="CENTER" map="G"/>
  <field class="org.jfree.text.TextBlockAnchor" name="BOTTOM_LEFT" map="H"/>
  <field class="org.jfree.text.TextBlockAnchor" name="BOTTOM_RIGHT" map="I"/>
  <field class="org.jfree.text.TextBlockAnchor" name="CENTER_LEFT" map="J"/>
  <method class="org.jfree.text.TextBlockAnchor" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.text.TextBlockAnchor" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.text.TextBlockAnchor" name="java.lang.String toString()" map="toString"/>
  <class name="org.jfree.text.TextLine" map="E"/>
  <field class="org.jfree.text.TextLine" name="fragments" map="A"/>
  <method class="org.jfree.text.TextLine" name="org.jfree.text.TextFragment getLastTextFragment()" map="A"/>
  <method class="org.jfree.text.TextLine" name="float calculateBaselineOffset(java.awt.Graphics2D, org.jfree.ui.TextAnchor)" map="A"/>
  <method class="org.jfree.text.TextLine" name="void removeFragment(org.jfree.text.TextFragment)" map="A"/>
  <method class="org.jfree.text.TextLine" name="void addFragment(org.jfree.text.TextFragment)" map="B"/>
  <method class="org.jfree.text.TextLine" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.text.TextLine" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.text.TextLine" name="void draw(java.awt.Graphics2D, float, float, org.jfree.ui.TextAnchor, float, float, double)" map="A"/>
  <method class="org.jfree.text.TextLine" name="org.jfree.ui.Size2D calculateDimensions(java.awt.Graphics2D)" map="A"/>
  <class name="org.jfree.text.TextUtilities" map="F"/>
  <field class="org.jfree.text.TextUtilities" name="logger" map="A"/>
  <field class="org.jfree.text.TextUtilities" name="class$org$jfree$text$TextUtilities" map="class$F$B$I$F"/>
  <field class="org.jfree.text.TextUtilities" name="useDrawRotatedStringWorkaround" map="B"/>
  <field class="org.jfree.text.TextUtilities" name="useFontMetricsGetStringBounds" map="C"/>
  <method class="org.jfree.text.TextUtilities" name="java.awt.geom.Rectangle2D drawAlignedString(java.lang.String, java.awt.Graphics2D, float, float, org.jfree.ui.TextAnchor)" map="A"/>
  <method class="org.jfree.text.TextUtilities" name="void drawRotatedString(java.lang.String, java.awt.Graphics2D, float, float, org.jfree.ui.TextAnchor, double, org.jfree.ui.TextAnchor)" map="A"/>
  <method class="org.jfree.text.TextUtilities" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jfree.text.TextUtilities" name="org.jfree.text.TextBlock createTextBlock(java.lang.String, java.awt.Font, java.awt.Paint, float, org.jfree.text.TextMeasurer)" map="A"/>
  <method class="org.jfree.text.TextUtilities" name="void drawRotatedString(java.lang.String, java.awt.Graphics2D, float, float, org.jfree.ui.TextAnchor, double, float, float)" map="A"/>
  <method class="org.jfree.text.TextUtilities" name="java.awt.geom.Rectangle2D getTextBounds(java.lang.String, java.awt.Graphics2D, java.awt.FontMetrics)" map="A"/>
  <method class="org.jfree.text.TextUtilities" name="float[] deriveTextBoundsAnchorOffsets(java.awt.Graphics2D, java.lang.String, org.jfree.ui.TextAnchor)" map="A"/>
  <method class="org.jfree.text.TextUtilities" name="void drawRotatedString(java.lang.String, java.awt.Graphics2D, float, float, double, float, float)" map="A"/>
  <method class="org.jfree.text.TextUtilities" name="org.jfree.text.TextBlock createTextBlock(java.lang.String, java.awt.Font, java.awt.Paint)" map="A"/>
  <method class="org.jfree.text.TextUtilities" name="float[] deriveRotationAnchorOffsets(java.awt.Graphics2D, java.lang.String, org.jfree.ui.TextAnchor)" map="B"/>
  <method class="org.jfree.text.TextUtilities" name="int nextLineBreak(java.lang.String, int, float, java.text.BreakIterator, org.jfree.text.TextMeasurer)" map="A"/>
  <method class="org.jfree.text.TextUtilities" name="java.awt.Shape calculateRotatedStringBounds(java.lang.String, java.awt.Graphics2D, float, float, org.jfree.ui.TextAnchor, double, org.jfree.ui.TextAnchor)" map="B"/>
  <method class="org.jfree.text.TextUtilities" name="org.jfree.text.TextBlock createTextBlock(java.lang.String, java.awt.Font, java.awt.Paint, float, int, org.jfree.text.TextMeasurer)" map="A"/>
  <method class="org.jfree.text.TextUtilities" name="java.awt.Shape calculateRotatedStringBounds(java.lang.String, java.awt.Graphics2D, float, float, double, float, float)" map="B"/>
  <method class="org.jfree.text.TextUtilities" name="float[] deriveTextBoundsAnchorOffsets(java.awt.Graphics2D, java.lang.String, org.jfree.ui.TextAnchor, java.awt.geom.Rectangle2D)" map="A"/>
  <class name="org.jfree.text.TextMeasurer" map="G"/>
  <method class="org.jfree.text.TextMeasurer" name="float getStringWidth(java.lang.String, int, int)" map="A"/>
  <class name="org.jfree.text.TextBox" map="H"/>
  <field class="org.jfree.text.TextBox" name="outlineStroke" map="A"/>
  <field class="org.jfree.text.TextBox" name="interiorGap" map="B"/>
  <field class="org.jfree.text.TextBox" name="textBlock" map="C"/>
  <field class="org.jfree.text.TextBox" name="shadowXOffset" map="D"/>
  <field class="org.jfree.text.TextBox" name="shadowPaint" map="E"/>
  <field class="org.jfree.text.TextBox" name="shadowYOffset" map="F"/>
  <field class="org.jfree.text.TextBox" name="backgroundPaint" map="G"/>
  <field class="org.jfree.text.TextBox" name="outlinePaint" map="H"/>
  <method class="org.jfree.text.TextBox" name="void setInteriorGap(org.jfree.ui.RectangleInsets)" map="A"/>
  <method class="org.jfree.text.TextBox" name="int hashCode()" map="hashCode"/>
  <method class="org.jfree.text.TextBox" name="void setOutlinePaint(java.awt.Paint)" map="A"/>
  <method class="org.jfree.text.TextBox" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jfree.text.TextBox" name="void setShadowPaint(java.awt.Paint)" map="B"/>
  <method class="org.jfree.text.TextBox" name="void draw(java.awt.Graphics2D, float, float, org.jfree.ui.RectangleAnchor)" map="A"/>
  <method class="org.jfree.text.TextBox" name="void setOutlineStroke(java.awt.Stroke)" map="A"/>
  <method class="org.jfree.text.TextBox" name="void setBackgroundPaint(java.awt.Paint)" map="C"/>
  <method class="org.jfree.text.TextBox" name="double getHeight(java.awt.Graphics2D)" map="A"/>
  <class name="org.jfree.JCommonInfo" map="A"/>
  <field class="org.jfree.JCommonInfo" name="class$org$jfree$base$BaseBoot" map="class$F$B$A$A"/>
  <field class="org.jfree.JCommonInfo" name="singleton" map="M"/>
  <method class="org.jfree.JCommonInfo" name="org.jfree.JCommonInfo getInstance()" map="G"/>
  <method class="org.jfree.JCommonInfo" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <class name="org.jfree.JCommon" map="B"/>
  <field class="org.jfree.JCommon" name="INFO" map="A"/>
  <package name="org.apache" map="C"/>
  <package name="org.apache.xerces" map="A"/>
  <package name="org.apache.xerces.xs" map="A"/>
  <package name="org.apache.xerces.xs.datatypes" map="A"/>
  <class name="org.apache.xerces.xs.datatypes.ByteList" map="A"/>
  <class name="org.apache.xerces.xs.datatypes.XSDateTime" map="B"/>
  <class name="org.apache.xerces.xs.datatypes.XSQName" map="C"/>
  <class name="org.apache.xerces.xs.datatypes.XSFloat" map="D"/>
  <class name="org.apache.xerces.xs.datatypes.XSDouble" map="E"/>
  <class name="org.apache.xerces.xs.datatypes.XSDecimal" map="F"/>
  <class name="org.apache.xerces.xs.datatypes.ObjectList" map="G"/>
  <method class="org.apache.xerces.xs.datatypes.ObjectList" name="java.lang.Object item(int)" map="A"/>
  <method class="org.apache.xerces.xs.datatypes.ObjectList" name="int getLength()" map="A"/>
  <class name="org.apache.xerces.xs.XSSimpleTypeDefinition" map="A"/>
  <method class="org.apache.xerces.xs.XSSimpleTypeDefinition" name="org.apache.xerces.xs.XSSimpleTypeDefinition getPrimitiveType()" map="&#x00e0;"/>
  <method class="org.apache.xerces.xs.XSSimpleTypeDefinition" name="boolean getFinite()" map="&#x00e1;"/>
  <method class="org.apache.xerces.xs.XSSimpleTypeDefinition" name="short getBuiltInKind()" map="&#x00e2;"/>
  <method class="org.apache.xerces.xs.XSSimpleTypeDefinition" name="short getDefinedFacets()" map="&#x00e3;"/>
  <method class="org.apache.xerces.xs.XSSimpleTypeDefinition" name="boolean getNumeric()" map="&#x00e4;"/>
  <method class="org.apache.xerces.xs.XSSimpleTypeDefinition" name="org.apache.xerces.xs.XSObjectList getMemberTypes()" map="&#x00e5;"/>
  <method class="org.apache.xerces.xs.XSSimpleTypeDefinition" name="short getVariety()" map="&#x00e6;"/>
  <method class="org.apache.xerces.xs.XSSimpleTypeDefinition" name="org.apache.xerces.xs.XSSimpleTypeDefinition getItemType()" map="&#x00e7;"/>
  <class name="org.apache.xerces.xs.XSObject" map="B"/>
  <method class="org.apache.xerces.xs.XSObject" name="short getType()" map="A"/>
  <method class="org.apache.xerces.xs.XSObject" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.xerces.xs.XSObject" name="org.apache.xerces.xs.XSNamespaceItem getNamespaceItem()" map="C"/>
  <method class="org.apache.xerces.xs.XSObject" name="java.lang.String getNamespace()" map="D"/>
  <class name="org.apache.xerces.xs.XSException" map="C"/>
  <field class="org.apache.xerces.xs.XSException" name="code" map="A"/>
  <class name="org.apache.xerces.xs.XSAnnotation" map="D"/>
  <class name="org.apache.xerces.xs.XSAttributeDeclaration" map="E"/>
  <method class="org.apache.xerces.xs.XSAttributeDeclaration" name="org.apache.xerces.xs.XSSimpleTypeDefinition getTypeDefinition()" map="E"/>
  <method class="org.apache.xerces.xs.XSAttributeDeclaration" name="short getScope()" map="F"/>
  <class name="org.apache.xerces.xs.XSModelGroup" map="F"/>
  <method class="org.apache.xerces.xs.XSModelGroup" name="org.apache.xerces.xs.XSObjectList getParticles()" map="W"/>
  <class name="org.apache.xerces.xs.XSNamespaceItem" map="G"/>
  <class name="org.apache.xerces.xs.XSTypeDefinition" map="H"/>
  <method class="org.apache.xerces.xs.XSTypeDefinition" name="boolean getAnonymous()" map="r"/>
  <method class="org.apache.xerces.xs.XSTypeDefinition" name="org.apache.xerces.xs.XSTypeDefinition getBaseType()" map="s"/>
  <method class="org.apache.xerces.xs.XSTypeDefinition" name="short getFinal()" map="t"/>
  <method class="org.apache.xerces.xs.XSTypeDefinition" name="short getTypeCategory()" map="u"/>
  <class name="org.apache.xerces.xs.ItemPSVI" map="I"/>
  <method class="org.apache.xerces.xs.ItemPSVI" name="short getActualNormalizedValueType()" map="A"/>
  <method class="org.apache.xerces.xs.ItemPSVI" name="java.lang.Object getActualNormalizedValue()" map="B"/>
  <method class="org.apache.xerces.xs.ItemPSVI" name="org.apache.xerces.xs.ShortList getItemValueTypes()" map="C"/>
  <class name="org.apache.xerces.xs.XSParticle" map="J"/>
  <method class="org.apache.xerces.xs.XSParticle" name="org.apache.xerces.xs.XSTerm getTerm()" map="J"/>
  <class name="org.apache.xerces.xs.AttributePSVI" map="K"/>
  <class name="org.apache.xerces.xs.XSValue" map="L"/>
  <method class="org.apache.xerces.xs.XSValue" name="java.lang.String getNormalizedValue()" map="A"/>
  <method class="org.apache.xerces.xs.XSValue" name="org.apache.xerces.xs.ShortList getListValueTypes()" map="B"/>
  <method class="org.apache.xerces.xs.XSValue" name="org.apache.xerces.xs.XSSimpleTypeDefinition getTypeDefinition()" map="C"/>
  <method class="org.apache.xerces.xs.XSValue" name="org.apache.xerces.xs.XSObjectList getMemberTypeDefinitions()" map="D"/>
  <method class="org.apache.xerces.xs.XSValue" name="short getActualValueType()" map="E"/>
  <method class="org.apache.xerces.xs.XSValue" name="org.apache.xerces.xs.XSSimpleTypeDefinition getMemberTypeDefinition()" map="F"/>
  <method class="org.apache.xerces.xs.XSValue" name="java.lang.Object getActualValue()" map="G"/>
  <class name="org.apache.xerces.xs.ElementPSVI" map="M"/>
  <class name="org.apache.xerces.xs.XSNamedMap" map="N"/>
  <method class="org.apache.xerces.xs.XSNamedMap" name="org.apache.xerces.xs.XSObject item(int)" map="A"/>
  <method class="org.apache.xerces.xs.XSNamedMap" name="int getLength()" map="A"/>
  <class name="org.apache.xerces.xs.XSLoader" map="O"/>
  <class name="org.apache.xerces.xs.StringList" map="P"/>
  <method class="org.apache.xerces.xs.StringList" name="boolean contains(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xs.StringList" name="java.lang.String item(int)" map="A"/>
  <class name="org.apache.xerces.xs.XSIDCDefinition" map="Q"/>
  <class name="org.apache.xerces.xs.XSModelGroupDefinition" map="R"/>
  <method class="org.apache.xerces.xs.XSModelGroupDefinition" name="org.apache.xerces.xs.XSModelGroup getModelGroup()" map="V"/>
  <class name="org.apache.xerces.xs.XSNotationDeclaration" map="S"/>
  <class name="org.apache.xerces.xs.XSWildcard" map="T"/>
  <class name="org.apache.xerces.xs.XSComplexTypeDefinition" map="U"/>
  <method class="org.apache.xerces.xs.XSComplexTypeDefinition" name="short getContentType()" map="v"/>
  <class name="org.apache.xerces.xs.XSTerm" map="V"/>
  <class name="org.apache.xerces.xs.PSVIProvider" map="W"/>
  <class name="org.apache.xerces.xs.XSModel" map="X"/>
  <class name="org.apache.xerces.xs.XSAttributeUse" map="Y"/>
  <method class="org.apache.xerces.xs.XSAttributeUse" name="org.apache.xerces.xs.XSAttributeDeclaration getAttrDeclaration()" map="n"/>
  <class name="org.apache.xerces.xs.ShortList" map="Z"/>
  <method class="org.apache.xerces.xs.ShortList" name="short item(int)" map="A"/>
  <method class="org.apache.xerces.xs.ShortList" name="int getLength()" map="A"/>
  <class name="org.apache.xerces.xs.XSAttributeGroupDefinition" map="_"/>
  <method class="org.apache.xerces.xs.XSAttributeGroupDefinition" name="org.apache.xerces.xs.XSObjectList getAttributeUses()" map="p"/>
  <class name="org.apache.xerces.xs.XSObjectList" map="a"/>
  <method class="org.apache.xerces.xs.XSObjectList" name="org.apache.xerces.xs.XSObject item(int)" map="A"/>
  <method class="org.apache.xerces.xs.XSObjectList" name="int getLength()" map="A"/>
  <class name="org.apache.xerces.xs.XSElementDeclaration" map="b"/>
  <method class="org.apache.xerces.xs.XSElementDeclaration" name="org.apache.xerces.xs.XSTypeDefinition getTypeDefinition()" map="e"/>
  <method class="org.apache.xerces.xs.XSElementDeclaration" name="org.apache.xerces.xs.XSElementDeclaration getSubstitutionGroupAffiliation()" map="f"/>
  <method class="org.apache.xerces.xs.XSElementDeclaration" name="short getScope()" map="g"/>
  <package name="org.apache.xerces.xni" map="B"/>
  <package name="org.apache.xerces.xni.grammars" map="A"/>
  <class name="org.apache.xerces.xni.grammars.XMLGrammarLoader" map="A"/>
  <class name="org.apache.xerces.xni.grammars.XSGrammar" map="B"/>
  <class name="org.apache.xerces.xni.grammars.XMLGrammarPool" map="C"/>
  <method class="org.apache.xerces.xni.grammars.XMLGrammarPool" name="void cacheGrammars(java.lang.String, org.apache.xerces.xni.grammars.Grammar[])" map="A"/>
  <method class="org.apache.xerces.xni.grammars.XMLGrammarPool" name="org.apache.xerces.xni.grammars.Grammar[] retrieveInitialGrammarSet(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xni.grammars.XMLGrammarPool" name="org.apache.xerces.xni.grammars.Grammar retrieveGrammar(org.apache.xerces.xni.grammars.XMLGrammarDescription)" map="A"/>
  <class name="org.apache.xerces.xni.grammars.XMLDTDDescription" map="D"/>
  <method class="org.apache.xerces.xni.grammars.XMLDTDDescription" name="java.lang.String getRootName()" map="I"/>
  <class name="org.apache.xerces.xni.grammars.Grammar" map="E"/>
  <class name="org.apache.xerces.xni.grammars.XMLGrammarDescription" map="F"/>
  <method class="org.apache.xerces.xni.grammars.XMLGrammarDescription" name="java.lang.String getGrammarType()" map="H"/>
  <class name="org.apache.xerces.xni.grammars.XMLSchemaDescription" map="G"/>
  <method class="org.apache.xerces.xni.grammars.XMLSchemaDescription" name="java.lang.String getTargetNamespace()" map="J"/>
  <package name="org.apache.xerces.xni.parser" map="B"/>
  <class name="org.apache.xerces.xni.parser.XMLDocumentSource" map="A"/>
  <method class="org.apache.xerces.xni.parser.XMLDocumentSource" name="org.apache.xerces.xni.XMLDocumentHandler getDocumentHandler()" map="D"/>
  <method class="org.apache.xerces.xni.parser.XMLDocumentSource" name="void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler)" map="A"/>
  <class name="org.apache.xerces.xni.parser.XMLDocumentFilter" map="B"/>
  <class name="org.apache.xerces.xni.parser.XMLParserConfiguration" map="C"/>
  <method class="org.apache.xerces.xni.parser.XMLParserConfiguration" name="void addRecognizedFeatures(java.lang.String[])" map="A"/>
  <method class="org.apache.xerces.xni.parser.XMLParserConfiguration" name="void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler)" map="B"/>
  <method class="org.apache.xerces.xni.parser.XMLParserConfiguration" name="java.lang.Object getProperty(java.lang.String)" map="i"/>
  <method class="org.apache.xerces.xni.parser.XMLParserConfiguration" name="java.util.Locale getLocale()" map="&#x00d6;"/>
  <method class="org.apache.xerces.xni.parser.XMLParserConfiguration" name="boolean getFeature(java.lang.String)" map="h"/>
  <method class="org.apache.xerces.xni.parser.XMLParserConfiguration" name="void setProperty(java.lang.String, java.lang.Object)" map="D"/>
  <method class="org.apache.xerces.xni.parser.XMLParserConfiguration" name="void setEntityResolver(org.apache.xerces.xni.parser.XMLEntityResolver)" map="B"/>
  <method class="org.apache.xerces.xni.parser.XMLParserConfiguration" name="void parse(org.apache.xerces.xni.parser.XMLInputSource)" map="D"/>
  <method class="org.apache.xerces.xni.parser.XMLParserConfiguration" name="void setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler)" map="B"/>
  <method class="org.apache.xerces.xni.parser.XMLParserConfiguration" name="void addRecognizedProperties(java.lang.String[])" map="B"/>
  <method class="org.apache.xerces.xni.parser.XMLParserConfiguration" name="void setFeature(java.lang.String, boolean)" map="E"/>
  <method class="org.apache.xerces.xni.parser.XMLParserConfiguration" name="void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler)" map="B"/>
  <class name="org.apache.xerces.xni.parser.XMLDTDContentModelFilter" map="D"/>
  <class name="org.apache.xerces.xni.parser.XMLDTDScanner" map="E"/>
  <method class="org.apache.xerces.xni.parser.XMLDTDScanner" name="boolean scanDTDExternalSubset(boolean)" map="C"/>
  <method class="org.apache.xerces.xni.parser.XMLDTDScanner" name="void setInputSource(org.apache.xerces.xni.parser.XMLInputSource)" map="B"/>
  <method class="org.apache.xerces.xni.parser.XMLDTDScanner" name="boolean scanDTDInternalSubset(boolean, boolean, boolean)" map="A"/>
  <class name="org.apache.xerces.xni.parser.XMLDTDFilter" map="F"/>
  <class name="org.apache.xerces.xni.parser.XMLInputSource" map="G"/>
  <field class="org.apache.xerces.xni.parser.XMLInputSource" name="fEncoding" map="A"/>
  <field class="org.apache.xerces.xni.parser.XMLInputSource" name="fPublicId" map="B"/>
  <field class="org.apache.xerces.xni.parser.XMLInputSource" name="fByteStream" map="C"/>
  <field class="org.apache.xerces.xni.parser.XMLInputSource" name="fCharStream" map="D"/>
  <field class="org.apache.xerces.xni.parser.XMLInputSource" name="fBaseSystemId" map="E"/>
  <field class="org.apache.xerces.xni.parser.XMLInputSource" name="fSystemId" map="F"/>
  <method class="org.apache.xerces.xni.parser.XMLInputSource" name="java.io.Reader getCharacterStream()" map="A"/>
  <method class="org.apache.xerces.xni.parser.XMLInputSource" name="java.lang.String getEncoding()" map="B"/>
  <method class="org.apache.xerces.xni.parser.XMLInputSource" name="java.lang.String getBaseSystemId()" map="C"/>
  <method class="org.apache.xerces.xni.parser.XMLInputSource" name="void setCharacterStream(java.io.Reader)" map="A"/>
  <method class="org.apache.xerces.xni.parser.XMLInputSource" name="java.lang.String getPublicId()" map="D"/>
  <method class="org.apache.xerces.xni.parser.XMLInputSource" name="java.lang.String getSystemId()" map="E"/>
  <method class="org.apache.xerces.xni.parser.XMLInputSource" name="void setSystemId(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xni.parser.XMLInputSource" name="java.io.InputStream getByteStream()" map="F"/>
  <method class="org.apache.xerces.xni.parser.XMLInputSource" name="void setByteStream(java.io.InputStream)" map="A"/>
  <method class="org.apache.xerces.xni.parser.XMLInputSource" name="void setEncoding(java.lang.String)" map="B"/>
  <class name="org.apache.xerces.xni.parser.XMLDTDContentModelSource" map="H"/>
  <method class="org.apache.xerces.xni.parser.XMLDTDContentModelSource" name="void setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler)" map="A"/>
  <class name="org.apache.xerces.xni.parser.XMLParseException" map="I"/>
  <field class="org.apache.xerces.xni.parser.XMLParseException" name="fCharacterOffset" map="D"/>
  <field class="org.apache.xerces.xni.parser.XMLParseException" name="fLineNumber" map="E"/>
  <field class="org.apache.xerces.xni.parser.XMLParseException" name="fPublicId" map="F"/>
  <field class="org.apache.xerces.xni.parser.XMLParseException" name="fColumnNumber" map="G"/>
  <field class="org.apache.xerces.xni.parser.XMLParseException" name="fExpandedSystemId" map="H"/>
  <field class="org.apache.xerces.xni.parser.XMLParseException" name="fBaseSystemId" map="I"/>
  <field class="org.apache.xerces.xni.parser.XMLParseException" name="fLiteralSystemId" map="J"/>
  <method class="org.apache.xerces.xni.parser.XMLParseException" name="java.lang.String getPublicId()" map="D"/>
  <method class="org.apache.xerces.xni.parser.XMLParseException" name="int getColumnNumber()" map="E"/>
  <method class="org.apache.xerces.xni.parser.XMLParseException" name="int getLineNumber()" map="F"/>
  <method class="org.apache.xerces.xni.parser.XMLParseException" name="java.lang.String getExpandedSystemId()" map="G"/>
  <method class="org.apache.xerces.xni.parser.XMLParseException" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.xni.parser.XMLDTDSource" map="J"/>
  <method class="org.apache.xerces.xni.parser.XMLDTDSource" name="void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler)" map="A"/>
  <class name="org.apache.xerces.xni.parser.XMLComponentManager" map="K"/>
  <method class="org.apache.xerces.xni.parser.XMLComponentManager" name="boolean getFeature(java.lang.String)" map="h"/>
  <method class="org.apache.xerces.xni.parser.XMLComponentManager" name="java.lang.Object getProperty(java.lang.String)" map="i"/>
  <class name="org.apache.xerces.xni.parser.XMLPullParserConfiguration" map="L"/>
  <class name="org.apache.xerces.xni.parser.XMLErrorHandler" map="M"/>
  <method class="org.apache.xerces.xni.parser.XMLErrorHandler" name="void warning(java.lang.String, java.lang.String, org.apache.xerces.xni.parser.XMLParseException)" map="A"/>
  <method class="org.apache.xerces.xni.parser.XMLErrorHandler" name="void error(java.lang.String, java.lang.String, org.apache.xerces.xni.parser.XMLParseException)" map="B"/>
  <method class="org.apache.xerces.xni.parser.XMLErrorHandler" name="void fatalError(java.lang.String, java.lang.String, org.apache.xerces.xni.parser.XMLParseException)" map="C"/>
  <class name="org.apache.xerces.xni.parser.XMLEntityResolver" map="N"/>
  <method class="org.apache.xerces.xni.parser.XMLEntityResolver" name="org.apache.xerces.xni.parser.XMLInputSource resolveEntity(org.apache.xerces.xni.XMLResourceIdentifier)" map="A"/>
  <class name="org.apache.xerces.xni.parser.XMLConfigurationException" map="O"/>
  <field class="org.apache.xerces.xni.parser.XMLConfigurationException" name="fIdentifier" map="B"/>
  <field class="org.apache.xerces.xni.parser.XMLConfigurationException" name="fType" map="C"/>
  <method class="org.apache.xerces.xni.parser.XMLConfigurationException" name="short getType()" map="B"/>
  <method class="org.apache.xerces.xni.parser.XMLConfigurationException" name="java.lang.String getIdentifier()" map="C"/>
  <class name="org.apache.xerces.xni.parser.XMLDocumentScanner" map="P"/>
  <method class="org.apache.xerces.xni.parser.XMLDocumentScanner" name="boolean scanDocument(boolean)" map="A"/>
  <class name="org.apache.xerces.xni.parser.XMLComponent" map="Q"/>
  <method class="org.apache.xerces.xni.parser.XMLComponent" name="void setProperty(java.lang.String, java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.xni.parser.XMLComponent" name="void setFeature(java.lang.String, boolean)" map="B"/>
  <method class="org.apache.xerces.xni.parser.XMLComponent" name="java.lang.String[] getRecognizedFeatures()" map="E"/>
  <method class="org.apache.xerces.xni.parser.XMLComponent" name="java.lang.Boolean getFeatureDefault(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.xni.parser.XMLComponent" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.xni.parser.XMLComponent" name="java.lang.Object getPropertyDefault(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.xni.parser.XMLComponent" name="java.lang.String[] getRecognizedProperties()" map="F"/>
  <class name="org.apache.xerces.xni.XMLString" map="A"/>
  <field class="org.apache.xerces.xni.XMLString" name="ch" map="A"/>
  <field class="org.apache.xerces.xni.XMLString" name="length" map="B"/>
  <field class="org.apache.xerces.xni.XMLString" name="offset" map="C"/>
  <method class="org.apache.xerces.xni.XMLString" name="void setValues(org.apache.xerces.xni.XMLString)" map="A"/>
  <method class="org.apache.xerces.xni.XMLString" name="void clear()" map="A"/>
  <method class="org.apache.xerces.xni.XMLString" name="boolean equals(char[], int, int)" map="A"/>
  <method class="org.apache.xerces.xni.XMLString" name="void setValues(char[], int, int)" map="B"/>
  <method class="org.apache.xerces.xni.XMLString" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.xni.XMLString" name="boolean equals(java.lang.String)" map="A"/>
  <class name="org.apache.xerces.xni.XMLDTDContentModelHandler" map="B"/>
  <method class="org.apache.xerces.xni.XMLDTDContentModelHandler" name="void endGroup(org.apache.xerces.xni.Augmentations)" map="H"/>
  <method class="org.apache.xerces.xni.XMLDTDContentModelHandler" name="void startGroup(org.apache.xerces.xni.Augmentations)" map="I"/>
  <method class="org.apache.xerces.xni.XMLDTDContentModelHandler" name="void setDTDContentModelSource(org.apache.xerces.xni.parser.XMLDTDContentModelSource)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDTDContentModelHandler" name="void separator(short, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xni.XMLDTDContentModelHandler" name="void pcdata(org.apache.xerces.xni.Augmentations)" map="J"/>
  <method class="org.apache.xerces.xni.XMLDTDContentModelHandler" name="void empty(org.apache.xerces.xni.Augmentations)" map="K"/>
  <method class="org.apache.xerces.xni.XMLDTDContentModelHandler" name="void any(org.apache.xerces.xni.Augmentations)" map="L"/>
  <method class="org.apache.xerces.xni.XMLDTDContentModelHandler" name="void element(java.lang.String, org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.xni.XMLDTDContentModelHandler" name="void startContentModel(java.lang.String, org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.xni.XMLDTDContentModelHandler" name="void endContentModel(org.apache.xerces.xni.Augmentations)" map="M"/>
  <method class="org.apache.xerces.xni.XMLDTDContentModelHandler" name="void occurrence(short, org.apache.xerces.xni.Augmentations)" map="C"/>
  <class name="org.apache.xerces.xni.NamespaceContext" map="C"/>
  <field class="org.apache.xerces.xni.NamespaceContext" name="XMLNS_URI" map="A"/>
  <field class="org.apache.xerces.xni.NamespaceContext" name="XML_URI" map="B"/>
  <method class="org.apache.xerces.xni.NamespaceContext" name="java.lang.String getURI(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xni.NamespaceContext" name="void reset()" map="A"/>
  <method class="org.apache.xerces.xni.NamespaceContext" name="void popContext()" map="B"/>
  <method class="org.apache.xerces.xni.NamespaceContext" name="boolean declarePrefix(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xni.NamespaceContext" name="int getDeclaredPrefixCount()" map="C"/>
  <method class="org.apache.xerces.xni.NamespaceContext" name="java.lang.String getPrefix(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.xni.NamespaceContext" name="void pushContext()" map="D"/>
  <method class="org.apache.xerces.xni.NamespaceContext" name="java.util.Enumeration getAllPrefixes()" map="E"/>
  <method class="org.apache.xerces.xni.NamespaceContext" name="java.lang.String getDeclaredPrefixAt(int)" map="A"/>
  <class name="org.apache.xerces.xni.XMLResourceIdentifier" map="D"/>
  <method class="org.apache.xerces.xni.XMLResourceIdentifier" name="java.lang.String getPublicId()" map="A"/>
  <method class="org.apache.xerces.xni.XMLResourceIdentifier" name="void setBaseSystemId(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xni.XMLResourceIdentifier" name="void setLiteralSystemId(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.xni.XMLResourceIdentifier" name="void setExpandedSystemId(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.xni.XMLResourceIdentifier" name="java.lang.String getExpandedSystemId()" map="B"/>
  <method class="org.apache.xerces.xni.XMLResourceIdentifier" name="java.lang.String getLiteralSystemId()" map="C"/>
  <method class="org.apache.xerces.xni.XMLResourceIdentifier" name="java.lang.String getBaseSystemId()" map="D"/>
  <class name="org.apache.xerces.xni.Augmentations" map="E"/>
  <method class="org.apache.xerces.xni.Augmentations" name="java.lang.Object getItem(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xni.Augmentations" name="void removeAllItems()" map="A"/>
  <method class="org.apache.xerces.xni.Augmentations" name="java.lang.Object putItem(java.lang.String, java.lang.Object)" map="A"/>
  <class name="org.apache.xerces.xni.XMLDocumentHandler" map="F"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="org.apache.xerces.xni.parser.XMLDocumentSource getDocumentSource()" map="C"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void endElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void endGeneralEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void comment(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void characters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void startElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void startGeneralEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void startCDATA(org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void emptyElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void ignorableWhitespace(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void xmlDecl(java.lang.String, java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void processingInstruction(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void endDocument(org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void endCDATA(org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void textDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void startDocument(org.apache.xerces.xni.XMLLocator, java.lang.String, org.apache.xerces.xni.NamespaceContext, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDocumentHandler" name="void doctypeDecl(java.lang.String, java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <class name="org.apache.xerces.xni.QName" map="G"/>
  <field class="org.apache.xerces.xni.QName" name="localpart" map="A"/>
  <field class="org.apache.xerces.xni.QName" name="uri" map="B"/>
  <field class="org.apache.xerces.xni.QName" name="prefix" map="C"/>
  <field class="org.apache.xerces.xni.QName" name="rawname" map="D"/>
  <method class="org.apache.xerces.xni.QName" name="void clear()" map="A"/>
  <method class="org.apache.xerces.xni.QName" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.xni.QName" name="java.lang.Object clone()" map="clone"/>
  <method class="org.apache.xerces.xni.QName" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.xerces.xni.QName" name="void setValues(java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xni.QName" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.xni.QName" name="void setValues(org.apache.xerces.xni.QName)" map="A"/>
  <class name="org.apache.xerces.xni.XMLAttributes" map="H"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="void removeAllAttributes()" map="A"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="java.lang.String getQName(int)" map="A"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="void setSpecified(int, boolean)" map="A"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="int getLength()" map="B"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="java.lang.String getURI(int)" map="B"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="void setNonNormalizedValue(int, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="java.lang.String getType(int)" map="C"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="java.lang.String getNonNormalizedValue(int)" map="D"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="void removeAttributeAt(int)" map="E"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="java.lang.String getLocalName(int)" map="F"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="java.lang.String getValue(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="java.lang.String getValue(int)" map="G"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="int addAttribute(org.apache.xerces.xni.QName, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="void setValue(int, java.lang.String)" map="B"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="java.lang.String getPrefix(int)" map="H"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="boolean isSpecified(int)" map="I"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="void setType(int, java.lang.String)" map="C"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="void getName(int, org.apache.xerces.xni.QName)" map="A"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="java.lang.String getValue(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="org.apache.xerces.xni.Augmentations getAugmentations(int)" map="J"/>
  <method class="org.apache.xerces.xni.XMLAttributes" name="void setName(int, org.apache.xerces.xni.QName)" map="B"/>
  <class name="org.apache.xerces.xni.XNIException" map="I"/>
  <field class="org.apache.xerces.xni.XNIException" name="fException" map="A"/>
  <method class="org.apache.xerces.xni.XNIException" name="java.lang.Throwable getCause()" map="getCause"/>
  <method class="org.apache.xerces.xni.XNIException" name="java.lang.Exception getException()" map="A"/>
  <method class="org.apache.xerces.xni.XNIException" name="java.lang.Throwable initCause(java.lang.Throwable)" map="initCause"/>
  <class name="org.apache.xerces.xni.XMLLocator" map="J"/>
  <method class="org.apache.xerces.xni.XMLLocator" name="java.lang.String getPublicId()" map="A"/>
  <method class="org.apache.xerces.xni.XMLLocator" name="int getCharacterOffset()" map="B"/>
  <method class="org.apache.xerces.xni.XMLLocator" name="int getColumnNumber()" map="C"/>
  <method class="org.apache.xerces.xni.XMLLocator" name="int getLineNumber()" map="D"/>
  <method class="org.apache.xerces.xni.XMLLocator" name="java.lang.String getExpandedSystemId()" map="E"/>
  <method class="org.apache.xerces.xni.XMLLocator" name="java.lang.String getLiteralSystemId()" map="F"/>
  <method class="org.apache.xerces.xni.XMLLocator" name="java.lang.String getBaseSystemId()" map="G"/>
  <class name="org.apache.xerces.xni.XMLDTDHandler" map="K"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void externalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void startExternalSubset(org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void startConditional(short, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void attributeDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String[], java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void endDTD(org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void startParameterEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void comment(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void notationDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void startAttlist(java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void endExternalSubset(org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void elementDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void endConditional(org.apache.xerces.xni.Augmentations)" map="F"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void startDTD(org.apache.xerces.xni.XMLLocator, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void internalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void endParameterEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void unparsedEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void endAttlist(org.apache.xerces.xni.Augmentations)" map="G"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void processingInstruction(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void ignoredCharacters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.xni.XMLDTDHandler" name="void textDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <package name="org.apache.xerces.stax" map="C"/>
  <package name="org.apache.xerces.stax.events" map="A"/>
  <class name="org.apache.xerces.stax.events.CommentImpl" map="A"/>
  <class name="org.apache.xerces.stax.events.StartElementImpl$1" map="1"/>
  <method class="org.apache.xerces.stax.events.StartElementImpl$1" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="org.apache.xerces.stax.events.StartElementImpl" map="B"/>
  <field class="org.apache.xerces.stax.events.StartElementImpl" name="QNAME_COMPARATOR" map="A"/>
  <method class="org.apache.xerces.stax.events.StartElementImpl" name="javax.xml.namespace.NamespaceContext getNamespaceContext()" map="e"/>
  <method class="org.apache.xerces.stax.events.StartElementImpl" name="java.util.Iterator getAttributes()" map="f"/>
  <class name="org.apache.xerces.stax.events.NamespaceImpl" map="C"/>
  <method class="org.apache.xerces.stax.events.NamespaceImpl" name="java.lang.String getPrefix()" map="b"/>
  <class name="org.apache.xerces.stax.events.StartDocumentImpl" map="D"/>
  <class name="org.apache.xerces.stax.events.ProcessingInstructionImpl" map="E"/>
  <method class="org.apache.xerces.stax.events.ProcessingInstructionImpl" name="java.lang.String getData()" map="W"/>
  <method class="org.apache.xerces.stax.events.ProcessingInstructionImpl" name="java.lang.String getTarget()" map="V"/>
  <class name="org.apache.xerces.stax.events.EndDocumentImpl" map="F"/>
  <class name="org.apache.xerces.stax.events.EntityDeclarationImpl" map="G"/>
  <class name="org.apache.xerces.stax.events.EndElementImpl" map="H"/>
  <class name="org.apache.xerces.stax.events.DTDImpl" map="I"/>
  <class name="org.apache.xerces.stax.events.NotationDeclarationImpl" map="J"/>
  <class name="org.apache.xerces.stax.events.EntityReferenceImpl" map="K"/>
  <class name="org.apache.xerces.stax.events.CharactersImpl" map="L"/>
  <method class="org.apache.xerces.stax.events.CharactersImpl" name="java.lang.String getData()" map="X"/>
  <class name="org.apache.xerces.stax.events.XMLEventImpl" map="M"/>
  <method class="org.apache.xerces.stax.events.XMLEventImpl" name="javax.xml.stream.events.EndElement asEndElement()" map="P"/>
  <method class="org.apache.xerces.stax.events.XMLEventImpl" name="javax.xml.stream.events.Characters asCharacters()" map="R"/>
  <method class="org.apache.xerces.stax.events.XMLEventImpl" name="javax.xml.stream.events.StartElement asStartElement()" map="Q"/>
  <method class="org.apache.xerces.stax.events.XMLEventImpl" name="boolean isStartDocument()" map="S"/>
  <method class="org.apache.xerces.stax.events.XMLEventImpl" name="int getEventType()" map="T"/>
  <method class="org.apache.xerces.stax.events.XMLEventImpl" name="javax.xml.stream.Location getLocation()" map="U"/>
  <class name="org.apache.xerces.stax.events.AttributeImpl" map="N"/>
  <method class="org.apache.xerces.stax.events.AttributeImpl" name="java.lang.String getValue()" map="Y"/>
  <method class="org.apache.xerces.stax.events.AttributeImpl" name="javax.xml.namespace.QName getName()" map="Z"/>
  <method class="org.apache.xerces.stax.events.AttributeImpl" name="boolean isSpecified()" map="_"/>
  <method class="org.apache.xerces.stax.events.AttributeImpl" name="java.lang.String getDTDType()" map="a"/>
  <class name="org.apache.xerces.stax.events.ElementImpl" map="O"/>
  <method class="org.apache.xerces.stax.events.ElementImpl" name="javax.xml.namespace.QName getName()" map="c"/>
  <method class="org.apache.xerces.stax.events.ElementImpl" name="java.util.Iterator getNamespaces()" map="d"/>
  <package name="org.apache.xerces.dom" map="D"/>
  <class name="org.apache.xerces.dom.ProcessingInstructionImpl" map="A"/>
  <method class="org.apache.xerces.dom.ProcessingInstructionImpl" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.dom.ProcessingInstructionImpl" name="short getNodeType()" map="&#x00c3;"/>
  <method class="org.apache.xerces.dom.ProcessingInstructionImpl" name="java.lang.String getTarget()" map="&#x00df;"/>
  <class name="org.apache.xerces.dom.NodeImpl" map="B"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="org.w3c.dom.Node getParentNode()" map="w"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="org.w3c.dom.Node removeChild(org.w3c.dom.Node)" map="A"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="org.w3c.dom.Node getNextSibling()" map="x"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="org.w3c.dom.NodeList getChildNodes()" map="y"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="void setNodeValue(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="org.w3c.dom.Node getFirstChild()" map="z"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="org.w3c.dom.Document getOwnerDocument()" map="&#x00a2;"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="boolean hasAttributes()" map="&#x00a3;"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="int getLength()" map="&#x00c5;"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="java.lang.String getPrefix()" map="&#x00a4;"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="org.w3c.dom.Node replaceChild(org.w3c.dom.Node, org.w3c.dom.Node)" map="B"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="org.w3c.dom.NamedNodeMap getAttributes()" map="&#x00a5;"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="java.lang.String getTextContent()" map="&#x00aa;"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="org.w3c.dom.Node item(int)" map="B"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="void setTextContent(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="boolean hasChildNodes()" map="&#x00ba;"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="java.lang.String getNodeValue()" map="&#x00c0;"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="java.lang.String getNamespaceURI()" map="&#x00c1;"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="org.w3c.dom.Node getPreviousSibling()" map="&#x00c2;"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="short getNodeType()" map="&#x00c3;"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="java.lang.String getLocalName()" map="&#x00c4;"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="void setPrefix(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.dom.NodeImpl" name="org.w3c.dom.Node appendChild(org.w3c.dom.Node)" map="C"/>
  <class name="org.apache.xerces.dom.DeferredDocumentImpl" map="C"/>
  <field class="org.apache.xerces.dom.DeferredDocumentImpl" name="INIT_ARRAY" map="&#x00ed;"/>
  <class name="org.apache.xerces.dom.DeepNodeListImpl" map="D"/>
  <method class="org.apache.xerces.dom.DeepNodeListImpl" name="org.w3c.dom.Node item(int)" map="B"/>
  <method class="org.apache.xerces.dom.DeepNodeListImpl" name="int getLength()" map="&#x00c5;"/>
  <class name="org.apache.xerces.dom.ElementImpl" map="E"/>
  <method class="org.apache.xerces.dom.ElementImpl" name="boolean hasAttribute(java.lang.String)" map="F"/>
  <method class="org.apache.xerces.dom.ElementImpl" name="boolean hasAttributes()" map="&#x00a3;"/>
  <method class="org.apache.xerces.dom.ElementImpl" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.dom.ElementImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <method class="org.apache.xerces.dom.ElementImpl" name="org.w3c.dom.NamedNodeMap getAttributes()" map="&#x00a5;"/>
  <method class="org.apache.xerces.dom.ElementImpl" name="short getNodeType()" map="&#x00c3;"/>
  <method class="org.apache.xerces.dom.ElementImpl" name="void setIdAttribute(java.lang.String, boolean)" map="A"/>
  <method class="org.apache.xerces.dom.ElementImpl" name="org.w3c.dom.Attr getAttributeNode(java.lang.String)" map="G"/>
  <method class="org.apache.xerces.dom.ElementImpl" name="org.w3c.dom.NodeList getElementsByTagName(java.lang.String)" map="H"/>
  <method class="org.apache.xerces.dom.ElementImpl" name="void setAttribute(java.lang.String, java.lang.String)" map="C"/>
  <method class="org.apache.xerces.dom.ElementImpl" name="void setAttributeNS(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.dom.ElementImpl" name="java.lang.String getAttributeNS(java.lang.String, java.lang.String)" map="D"/>
  <method class="org.apache.xerces.dom.ElementImpl" name="org.w3c.dom.Attr getAttributeNodeNS(java.lang.String, java.lang.String)" map="E"/>
  <method class="org.apache.xerces.dom.ElementImpl" name="java.lang.String getAttribute(java.lang.String)" map="I"/>
  <class name="org.apache.xerces.dom.NotationImpl" map="F"/>
  <method class="org.apache.xerces.dom.NotationImpl" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.dom.NotationImpl" name="short getNodeType()" map="&#x00c3;"/>
  <class name="org.apache.xerces.dom.DocumentFragmentImpl" map="G"/>
  <method class="org.apache.xerces.dom.DocumentFragmentImpl" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.dom.DocumentFragmentImpl" name="short getNodeType()" map="&#x00c3;"/>
  <class name="org.apache.xerces.dom.DeferredNotationImpl" map="H"/>
  <class name="org.apache.xerces.dom.CoreDocumentImpl" map="I"/>
  <field class="org.apache.xerces.dom.CoreDocumentImpl" name="kidOK" map="&#x00ec;"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="org.w3c.dom.Attr createAttributeNS(java.lang.String, java.lang.String)" map="H"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="org.w3c.dom.Element createElementNS(java.lang.String, java.lang.String)" map="I"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="org.w3c.dom.Node removeChild(org.w3c.dom.Node)" map="A"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="org.w3c.dom.NodeList getElementsByTagNameNS(java.lang.String, java.lang.String)" map="G"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="void normalizeDocument()" map="&#x00d2;"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="org.w3c.dom.Document getOwnerDocument()" map="&#x00a2;"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="org.w3c.dom.Node replaceChild(org.w3c.dom.Node, org.w3c.dom.Node)" map="B"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="java.lang.String getTextContent()" map="&#x00aa;"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="org.w3c.dom.Element getDocumentElement()" map="&#x00d3;"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="org.w3c.dom.NodeList getElementsByTagName(java.lang.String)" map="L"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="void setTextContent(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="org.w3c.dom.DocumentType getDoctype()" map="&#x00d4;"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="short getNodeType()" map="&#x00c3;"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="org.w3c.dom.Text createTextNode(java.lang.String)" map="J"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="org.w3c.dom.Element createElement(java.lang.String)" map="K"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="org.w3c.dom.Node importNode(org.w3c.dom.Node, boolean)" map="A"/>
  <method class="org.apache.xerces.dom.CoreDocumentImpl" name="java.lang.String getDocumentURI()" map="&#x00d1;"/>
  <class name="org.apache.xerces.dom.CommentImpl" map="J"/>
  <method class="org.apache.xerces.dom.CommentImpl" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.dom.CommentImpl" name="short getNodeType()" map="&#x00c3;"/>
  <class name="org.apache.xerces.dom.ElementDefinitionImpl" map="K"/>
  <method class="org.apache.xerces.dom.ElementDefinitionImpl" name="org.w3c.dom.NamedNodeMap getAttributes()" map="&#x00a5;"/>
  <method class="org.apache.xerces.dom.ElementDefinitionImpl" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.dom.ElementDefinitionImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <method class="org.apache.xerces.dom.ElementDefinitionImpl" name="short getNodeType()" map="&#x00c3;"/>
  <class name="org.apache.xerces.dom.DocumentTypeImpl" map="L"/>
  <method class="org.apache.xerces.dom.DocumentTypeImpl" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.dom.DocumentTypeImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <method class="org.apache.xerces.dom.DocumentTypeImpl" name="void setTextContent(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.dom.DocumentTypeImpl" name="short getNodeType()" map="&#x00c3;"/>
  <method class="org.apache.xerces.dom.DocumentTypeImpl" name="java.lang.String getTextContent()" map="&#x00aa;"/>
  <method class="org.apache.xerces.dom.DocumentTypeImpl" name="java.lang.String getPublicId()" map="&#x00db;"/>
  <method class="org.apache.xerces.dom.DocumentTypeImpl" name="java.lang.String getSystemId()" map="&#x00dd;"/>
  <method class="org.apache.xerces.dom.DocumentTypeImpl" name="java.lang.String getName()" map="&#x00de;"/>
  <method class="org.apache.xerces.dom.DocumentTypeImpl" name="java.lang.String getInternalSubset()" map="&#x00dc;"/>
  <class name="org.apache.xerces.dom.DeferredEntityImpl" map="M"/>
  <class name="org.apache.xerces.dom.DOMConfigurationImpl" map="N"/>
  <method class="org.apache.xerces.dom.DOMConfigurationImpl" name="void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler)" map="B"/>
  <method class="org.apache.xerces.dom.DOMConfigurationImpl" name="java.util.Locale getLocale()" map="&#x00d6;"/>
  <method class="org.apache.xerces.dom.DOMConfigurationImpl" name="boolean getFeature(java.lang.String)" map="h"/>
  <method class="org.apache.xerces.dom.DOMConfigurationImpl" name="void setProperty(java.lang.String, java.lang.Object)" map="D"/>
  <method class="org.apache.xerces.dom.DOMConfigurationImpl" name="void setEntityResolver(org.apache.xerces.xni.parser.XMLEntityResolver)" map="B"/>
  <method class="org.apache.xerces.dom.DOMConfigurationImpl" name="void parse(org.apache.xerces.xni.parser.XMLInputSource)" map="D"/>
  <method class="org.apache.xerces.dom.DOMConfigurationImpl" name="void setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler)" map="B"/>
  <method class="org.apache.xerces.dom.DOMConfigurationImpl" name="void setFeature(java.lang.String, boolean)" map="E"/>
  <method class="org.apache.xerces.dom.DOMConfigurationImpl" name="void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler)" map="B"/>
  <class name="org.apache.xerces.dom.CharacterDataImpl$1" map="1"/>
  <method class="org.apache.xerces.dom.CharacterDataImpl$1" name="org.w3c.dom.Node item(int)" map="B"/>
  <method class="org.apache.xerces.dom.CharacterDataImpl$1" name="int getLength()" map="&#x00c5;"/>
  <class name="org.apache.xerces.dom.CharacterDataImpl" map="O"/>
  <field class="org.apache.xerces.dom.CharacterDataImpl" name="singletonNodeList" map="&#x00f1;"/>
  <method class="org.apache.xerces.dom.CharacterDataImpl" name="java.lang.String getNodeValue()" map="&#x00c0;"/>
  <method class="org.apache.xerces.dom.CharacterDataImpl" name="void setNodeValue(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.dom.CharacterDataImpl" name="org.w3c.dom.NodeList getChildNodes()" map="y"/>
  <method class="org.apache.xerces.dom.CharacterDataImpl" name="java.lang.String getData()" map="&#x00cb;"/>
  <class name="org.apache.xerces.dom.DeferredNode" map="P"/>
  <class name="org.apache.xerces.dom.ElementNSImpl" map="Q"/>
  <method class="org.apache.xerces.dom.ElementNSImpl" name="java.lang.String getLocalName()" map="&#x00c4;"/>
  <method class="org.apache.xerces.dom.ElementNSImpl" name="void setPrefix(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.dom.ElementNSImpl" name="java.lang.String getNamespaceURI()" map="&#x00c1;"/>
  <method class="org.apache.xerces.dom.ElementNSImpl" name="java.lang.String getPrefix()" map="&#x00a4;"/>
  <class name="org.apache.xerces.dom.DeferredCDATASectionImpl" map="R"/>
  <class name="org.apache.xerces.dom.AttrNSImpl" map="S"/>
  <method class="org.apache.xerces.dom.AttrNSImpl" name="java.lang.String getLocalName()" map="&#x00c4;"/>
  <method class="org.apache.xerces.dom.AttrNSImpl" name="void setPrefix(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.dom.AttrNSImpl" name="java.lang.String getNamespaceURI()" map="&#x00c1;"/>
  <method class="org.apache.xerces.dom.AttrNSImpl" name="java.lang.String getPrefix()" map="&#x00a4;"/>
  <class name="org.apache.xerces.dom.DeferredElementDefinitionImpl" map="T"/>
  <class name="org.apache.xerces.dom.DeferredEntityReferenceImpl" map="U"/>
  <class name="org.apache.xerces.dom.DeferredElementImpl" map="V"/>
  <class name="org.apache.xerces.dom.ParentNode" map="W"/>
  <method class="org.apache.xerces.dom.ParentNode" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <method class="org.apache.xerces.dom.ParentNode" name="void setTextContent(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.dom.ParentNode" name="org.w3c.dom.Node getFirstChild()" map="z"/>
  <method class="org.apache.xerces.dom.ParentNode" name="boolean hasChildNodes()" map="&#x00ba;"/>
  <method class="org.apache.xerces.dom.ParentNode" name="org.w3c.dom.Node replaceChild(org.w3c.dom.Node, org.w3c.dom.Node)" map="B"/>
  <method class="org.apache.xerces.dom.ParentNode" name="java.lang.String getTextContent()" map="&#x00aa;"/>
  <method class="org.apache.xerces.dom.ParentNode" name="org.w3c.dom.Node removeChild(org.w3c.dom.Node)" map="A"/>
  <method class="org.apache.xerces.dom.ParentNode" name="boolean isEqualNode(org.w3c.dom.Node)" map="B"/>
  <method class="org.apache.xerces.dom.ParentNode" name="org.w3c.dom.NodeList getChildNodes()" map="y"/>
  <method class="org.apache.xerces.dom.ParentNode" name="org.w3c.dom.Document getOwnerDocument()" map="&#x00a2;"/>
  <method class="org.apache.xerces.dom.ParentNode" name="org.w3c.dom.Node insertBefore(org.w3c.dom.Node, org.w3c.dom.Node)" map="A"/>
  <class name="org.apache.xerces.dom.TextImpl" map="X"/>
  <method class="org.apache.xerces.dom.TextImpl" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.dom.TextImpl" name="short getNodeType()" map="&#x00c3;"/>
  <class name="org.apache.xerces.dom.DeferredCommentImpl" map="Y"/>
  <class name="org.apache.xerces.dom.AttrImpl" map="Z"/>
  <method class="org.apache.xerces.dom.AttrImpl" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.dom.AttrImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <method class="org.apache.xerces.dom.AttrImpl" name="org.w3c.dom.Node getFirstChild()" map="z"/>
  <method class="org.apache.xerces.dom.AttrImpl" name="boolean hasChildNodes()" map="&#x00ba;"/>
  <method class="org.apache.xerces.dom.AttrImpl" name="org.w3c.dom.Node replaceChild(org.w3c.dom.Node, org.w3c.dom.Node)" map="B"/>
  <method class="org.apache.xerces.dom.AttrImpl" name="short getNodeType()" map="&#x00c3;"/>
  <method class="org.apache.xerces.dom.AttrImpl" name="void setNodeValue(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.dom.AttrImpl" name="java.lang.String getNodeValue()" map="&#x00c0;"/>
  <method class="org.apache.xerces.dom.AttrImpl" name="org.w3c.dom.Node removeChild(org.w3c.dom.Node)" map="A"/>
  <method class="org.apache.xerces.dom.AttrImpl" name="java.lang.String getName()" map="&#x00c9;"/>
  <method class="org.apache.xerces.dom.AttrImpl" name="org.w3c.dom.NodeList getChildNodes()" map="y"/>
  <method class="org.apache.xerces.dom.AttrImpl" name="org.w3c.dom.Element getOwnerElement()" map="&#x00c6;"/>
  <method class="org.apache.xerces.dom.AttrImpl" name="java.lang.String getValue()" map="&#x00c7;"/>
  <method class="org.apache.xerces.dom.AttrImpl" name="boolean getSpecified()" map="&#x00c8;"/>
  <method class="org.apache.xerces.dom.AttrImpl" name="void setValue(java.lang.String)" map="E"/>
  <class name="org.apache.xerces.dom.DeferredTextImpl" map="_"/>
  <class name="org.apache.xerces.dom.ChildNode" map="a"/>
  <method class="org.apache.xerces.dom.ChildNode" name="org.w3c.dom.Node getPreviousSibling()" map="&#x00c2;"/>
  <method class="org.apache.xerces.dom.ChildNode" name="org.w3c.dom.Node getParentNode()" map="w"/>
  <method class="org.apache.xerces.dom.ChildNode" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <method class="org.apache.xerces.dom.ChildNode" name="org.w3c.dom.Node getNextSibling()" map="x"/>
  <class name="org.apache.xerces.dom.DeferredDocumentTypeImpl" map="b"/>
  <class name="org.apache.xerces.dom.EntityReferenceImpl" map="c"/>
  <method class="org.apache.xerces.dom.EntityReferenceImpl" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.dom.EntityReferenceImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <method class="org.apache.xerces.dom.EntityReferenceImpl" name="short getNodeType()" map="&#x00c3;"/>
  <class name="org.apache.xerces.dom.DeferredAttrImpl" map="d"/>
  <class name="org.apache.xerces.dom.DeferredAttrNSImpl" map="e"/>
  <class name="org.apache.xerces.dom.DeferredProcessingInstructionImpl" map="f"/>
  <class name="org.apache.xerces.dom.DeferredElementNSImpl" map="g"/>
  <class name="org.apache.xerces.dom.CDATASectionImpl" map="h"/>
  <method class="org.apache.xerces.dom.CDATASectionImpl" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.dom.CDATASectionImpl" name="short getNodeType()" map="&#x00c3;"/>
  <class name="org.apache.xerces.dom.EntityImpl" map="i"/>
  <method class="org.apache.xerces.dom.EntityImpl" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.dom.EntityImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <method class="org.apache.xerces.dom.EntityImpl" name="short getNodeType()" map="&#x00c3;"/>
  <class name="org.apache.xerces.dom.DocumentImpl" map="j"/>
  <method class="org.apache.xerces.dom.DocumentImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <package name="org.apache.xerces.util" map="E"/>
  <class name="org.apache.xerces.util.EncodingMap" map="A"/>
  <field class="org.apache.xerces.util.EncodingMap" name="fIANA2JavaMap" map="A"/>
  <field class="org.apache.xerces.util.EncodingMap" name="fJava2IANAMap" map="B"/>
  <method class="org.apache.xerces.util.EncodingMap" name="java.lang.String getIANA2JavaMapping(java.lang.String)" map="A"/>
  <class name="org.apache.xerces.util.XMLResourceIdentifierImpl" map="B"/>
  <field class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="fNamespace" map="A"/>
  <field class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="fPublicId" map="B"/>
  <field class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="fExpandedSystemId" map="C"/>
  <field class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="fBaseSystemId" map="D"/>
  <field class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="fLiteralSystemId" map="E"/>
  <method class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="void setLiteralSystemId(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="void setBaseSystemId(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="java.lang.String getBaseSystemId()" map="D"/>
  <method class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="void clear()" map="E"/>
  <method class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="java.lang.String getExpandedSystemId()" map="B"/>
  <method class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="void setNamespace(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="java.lang.String getPublicId()" map="A"/>
  <method class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="void setValues(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="java.lang.String getNamespace()" map="F"/>
  <method class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="java.lang.String getLiteralSystemId()" map="C"/>
  <method class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="void setExpandedSystemId(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.util.XMLResourceIdentifierImpl" name="void setValues(java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <class name="org.apache.xerces.util.XMLSymbols" map="C"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="fREQUIREDSymbol" map="A"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="fFIXEDSymbol" map="B"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="EMPTY_STRING" map="C"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="fENTITIESSymbol" map="D"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="fIDSymbol" map="E"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="fENTITYSymbol" map="F"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="fNMTOKENSymbol" map="G"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="fCDATASymbol" map="H"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="fIDREFSSymbol" map="I"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="fIDREFSymbol" map="J"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="fNMTOKENSSymbol" map="K"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="fENUMERATIONSymbol" map="L"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="fNOTATIONSymbol" map="M"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="PREFIX_XMLNS" map="N"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="fIMPLIEDSymbol" map="O"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="fANYSymbol" map="P"/>
  <field class="org.apache.xerces.util.XMLSymbols" name="PREFIX_XML" map="Q"/>
  <class name="org.apache.xerces.util.EntityResolver2Wrapper" map="D"/>
  <field class="org.apache.xerces.util.EntityResolver2Wrapper" name="fEntityResolver" map="&#x0417;"/>
  <method class="org.apache.xerces.util.EntityResolver2Wrapper" name="org.apache.xerces.xni.parser.XMLInputSource getExternalSubset(org.apache.xerces.xni.grammars.XMLDTDDescription)" map="A"/>
  <method class="org.apache.xerces.util.EntityResolver2Wrapper" name="void setEntityResolver(org.xml.sax.ext.EntityResolver2)" map="A"/>
  <method class="org.apache.xerces.util.EntityResolver2Wrapper" name="org.xml.sax.ext.EntityResolver2 getEntityResolver()" map="&#x00ee;"/>
  <method class="org.apache.xerces.util.EntityResolver2Wrapper" name="org.apache.xerces.xni.parser.XMLInputSource createXMLInputSource(org.xml.sax.InputSource, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.EntityResolver2Wrapper" name="org.apache.xerces.xni.parser.XMLInputSource resolveEntity(org.apache.xerces.xni.XMLResourceIdentifier)" map="A"/>
  <class name="org.apache.xerces.util.IntStack" map="E"/>
  <field class="org.apache.xerces.util.IntStack" name="fData" map="A"/>
  <field class="org.apache.xerces.util.IntStack" name="fDepth" map="B"/>
  <method class="org.apache.xerces.util.IntStack" name="void clear()" map="A"/>
  <method class="org.apache.xerces.util.IntStack" name="int pop()" map="B"/>
  <method class="org.apache.xerces.util.IntStack" name="int size()" map="C"/>
  <method class="org.apache.xerces.util.IntStack" name="int elementAt(int)" map="A"/>
  <method class="org.apache.xerces.util.IntStack" name="void ensureCapacity(int)" map="B"/>
  <method class="org.apache.xerces.util.IntStack" name="void push(int)" map="C"/>
  <method class="org.apache.xerces.util.IntStack" name="int peek()" map="D"/>
  <class name="org.apache.xerces.util.MessageFormatter" map="F"/>
  <method class="org.apache.xerces.util.MessageFormatter" name="java.lang.String formatMessage(java.util.Locale, java.lang.String, java.lang.Object[])" map="A"/>
  <class name="org.apache.xerces.util.SAXMessageFormatter" map="G"/>
  <method class="org.apache.xerces.util.SAXMessageFormatter" name="java.lang.String formatMessage(java.util.Locale, java.lang.String, java.lang.Object[])" map="A"/>
  <class name="org.apache.xerces.util.EntityResolverWrapper" map="H"/>
  <field class="org.apache.xerces.util.EntityResolverWrapper" name="fEntityResolver" map="&#x0416;"/>
  <method class="org.apache.xerces.util.EntityResolverWrapper" name="void setEntityResolver(org.xml.sax.EntityResolver)" map="B"/>
  <method class="org.apache.xerces.util.EntityResolverWrapper" name="org.apache.xerces.xni.parser.XMLInputSource resolveEntity(org.apache.xerces.xni.XMLResourceIdentifier)" map="A"/>
  <method class="org.apache.xerces.util.EntityResolverWrapper" name="org.xml.sax.EntityResolver getEntityResolver()" map="&#x00ed;"/>
  <class name="org.apache.xerces.util.DOMInputSource" map="I"/>
  <method class="org.apache.xerces.util.DOMInputSource" name="org.w3c.dom.Node getNode()" map="G"/>
  <class name="org.apache.xerces.util.SecurityManager" map="J"/>
  <method class="org.apache.xerces.util.SecurityManager" name="int getMaxOccurNodeLimit()" map="A"/>
  <method class="org.apache.xerces.util.SecurityManager" name="int getEntityExpansionLimit()" map="B"/>
  <class name="org.apache.xerces.util.URI$MalformedURIException" map="_A"/>
  <class name="org.apache.xerces.util.URI" map="K"/>
  <field class="org.apache.xerces.util.URI" name="m_host" map="A"/>
  <field class="org.apache.xerces.util.URI" name="m_regAuthority" map="B"/>
  <field class="org.apache.xerces.util.URI" name="m_path" map="C"/>
  <field class="org.apache.xerces.util.URI" name="m_scheme" map="D"/>
  <field class="org.apache.xerces.util.URI" name="fgLookupTable" map="E"/>
  <field class="org.apache.xerces.util.URI" name="m_port" map="F"/>
  <field class="org.apache.xerces.util.URI" name="m_userinfo" map="G"/>
  <field class="org.apache.xerces.util.URI" name="m_fragment" map="H"/>
  <field class="org.apache.xerces.util.URI" name="m_queryString" map="I"/>
  <field class="org.apache.xerces.util.URI" name="DEBUG" map="J"/>
  <method class="org.apache.xerces.util.URI" name="void initializePath(java.lang.String, int)" map="A"/>
  <method class="org.apache.xerces.util.URI" name="void initialize(org.apache.xerces.util.URI)" map="A"/>
  <method class="org.apache.xerces.util.URI" name="java.lang.String getFragment()" map="A"/>
  <method class="org.apache.xerces.util.URI" name="void initialize(org.apache.xerces.util.URI, java.lang.String, boolean)" map="A"/>
  <method class="org.apache.xerces.util.URI" name="void absolutize(org.apache.xerces.util.URI)" map="B"/>
  <method class="org.apache.xerces.util.URI" name="boolean isSchemeCharacter(char)" map="A"/>
  <method class="org.apache.xerces.util.URI" name="boolean isConformantSchemeName(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.URI" name="boolean isURIString(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.util.URI" name="java.lang.String getPath()" map="B"/>
  <method class="org.apache.xerces.util.URI" name="boolean isValidRegistryBasedAuthority(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.util.URI" name="java.lang.String getAuthority()" map="C"/>
  <method class="org.apache.xerces.util.URI" name="boolean isURICharacter(char)" map="B"/>
  <method class="org.apache.xerces.util.URI" name="void setPath(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.util.URI" name="void initializeScheme(java.lang.String)" map="E"/>
  <method class="org.apache.xerces.util.URI" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.util.URI" name="void setQueryString(java.lang.String)" map="F"/>
  <method class="org.apache.xerces.util.URI" name="boolean isHex(char)" map="C"/>
  <method class="org.apache.xerces.util.URI" name="void setScheme(java.lang.String)" map="G"/>
  <method class="org.apache.xerces.util.URI" name="java.lang.String getScheme()" map="D"/>
  <method class="org.apache.xerces.util.URI" name="boolean isValidServerBasedAuthority(java.lang.String, int, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.URI" name="void setFragment(java.lang.String)" map="H"/>
  <method class="org.apache.xerces.util.URI" name="boolean isWellFormedIPv6Reference(java.lang.String)" map="I"/>
  <method class="org.apache.xerces.util.URI" name="boolean isAlpha(char)" map="D"/>
  <method class="org.apache.xerces.util.URI" name="java.lang.String getQueryString()" map="E"/>
  <method class="org.apache.xerces.util.URI" name="void setUserinfo(java.lang.String)" map="J"/>
  <method class="org.apache.xerces.util.URI" name="int getPort()" map="F"/>
  <method class="org.apache.xerces.util.URI" name="int scanHexSequence(java.lang.String, int, int, int[])" map="A"/>
  <method class="org.apache.xerces.util.URI" name="boolean isWellFormedAddress(java.lang.String)" map="K"/>
  <method class="org.apache.xerces.util.URI" name="java.lang.String getSchemeSpecificPart()" map="G"/>
  <method class="org.apache.xerces.util.URI" name="boolean isPathCharacter(char)" map="E"/>
  <method class="org.apache.xerces.util.URI" name="void initialize(org.apache.xerces.util.URI, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.URI" name="boolean isAlphanum(char)" map="F"/>
  <method class="org.apache.xerces.util.URI" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.util.URI" name="boolean initializeAuthority(java.lang.String)" map="L"/>
  <method class="org.apache.xerces.util.URI" name="boolean isGenericURI()" map="H"/>
  <method class="org.apache.xerces.util.URI" name="boolean isAbsoluteURI()" map="I"/>
  <method class="org.apache.xerces.util.URI" name="void setHost(java.lang.String)" map="M"/>
  <method class="org.apache.xerces.util.URI" name="java.lang.String getUserinfo()" map="J"/>
  <method class="org.apache.xerces.util.URI" name="void setPort(int)" map="A"/>
  <method class="org.apache.xerces.util.URI" name="boolean isUserinfoCharacter(char)" map="G"/>
  <method class="org.apache.xerces.util.URI" name="boolean isDigit(char)" map="H"/>
  <method class="org.apache.xerces.util.URI" name="java.lang.String getRegBasedAuthority()" map="K"/>
  <method class="org.apache.xerces.util.URI" name="boolean isWellFormedIPv4Address(java.lang.String)" map="N"/>
  <method class="org.apache.xerces.util.URI" name="java.lang.String getHost()" map="L"/>
  <class name="org.apache.xerces.util.AugmentationsImpl$SmallContainer" map="_A"/>
  <field class="org.apache.xerces.util.AugmentationsImpl$SmallContainer" name="fAugmentations" map="B"/>
  <field class="org.apache.xerces.util.AugmentationsImpl$SmallContainer" name="fNumEntries" map="C"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$SmallContainer" name="java.lang.Object putItem(java.lang.Object, java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$SmallContainer" name="boolean isFull()" map="A"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$SmallContainer" name="void clear()" map="B"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$SmallContainer" name="org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer expand()" map="C"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$SmallContainer" name="java.lang.Object getItem(java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$SmallContainer" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.util.AugmentationsImpl$LargeContainer" map="_B"/>
  <field class="org.apache.xerces.util.AugmentationsImpl$LargeContainer" name="fAugmentations" map="A"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$LargeContainer" name="java.lang.Object putItem(java.lang.Object, java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$LargeContainer" name="boolean isFull()" map="A"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$LargeContainer" name="void clear()" map="B"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$LargeContainer" name="org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer expand()" map="C"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$LargeContainer" name="java.lang.Object getItem(java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$LargeContainer" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer" map="_C"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer" name="java.lang.Object putItem(java.lang.Object, java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer" name="boolean isFull()" map="A"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer" name="void clear()" map="B"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer" name="org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer expand()" map="C"/>
  <method class="org.apache.xerces.util.AugmentationsImpl$AugmentationsItemsContainer" name="java.lang.Object getItem(java.lang.Object)" map="A"/>
  <class name="org.apache.xerces.util.AugmentationsImpl" map="L"/>
  <field class="org.apache.xerces.util.AugmentationsImpl" name="fAugmentationsContainer" map="A"/>
  <method class="org.apache.xerces.util.AugmentationsImpl" name="java.lang.Object getItem(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.AugmentationsImpl" name="void removeAllItems()" map="A"/>
  <method class="org.apache.xerces.util.AugmentationsImpl" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.util.AugmentationsImpl" name="java.lang.Object putItem(java.lang.String, java.lang.Object)" map="A"/>
  <class name="org.apache.xerces.util.SAXLocatorWrapper" map="M"/>
  <field class="org.apache.xerces.util.SAXLocatorWrapper" name="fLocator" map="A"/>
  <field class="org.apache.xerces.util.SAXLocatorWrapper" name="fLocator2" map="B"/>
  <method class="org.apache.xerces.util.SAXLocatorWrapper" name="java.lang.String getPublicId()" map="A"/>
  <method class="org.apache.xerces.util.SAXLocatorWrapper" name="int getCharacterOffset()" map="B"/>
  <method class="org.apache.xerces.util.SAXLocatorWrapper" name="int getColumnNumber()" map="C"/>
  <method class="org.apache.xerces.util.SAXLocatorWrapper" name="int getLineNumber()" map="D"/>
  <method class="org.apache.xerces.util.SAXLocatorWrapper" name="java.lang.String getExpandedSystemId()" map="E"/>
  <method class="org.apache.xerces.util.SAXLocatorWrapper" name="void setLocator(org.xml.sax.Locator)" map="A"/>
  <method class="org.apache.xerces.util.SAXLocatorWrapper" name="java.lang.String getLiteralSystemId()" map="F"/>
  <method class="org.apache.xerces.util.SAXLocatorWrapper" name="java.lang.String getBaseSystemId()" map="G"/>
  <class name="org.apache.xerces.util.ErrorHandlerProxy" map="N"/>
  <method class="org.apache.xerces.util.ErrorHandlerProxy" name="org.apache.xerces.xni.parser.XMLErrorHandler getErrorHandler()" map="G"/>
  <method class="org.apache.xerces.util.ErrorHandlerProxy" name="void error(org.xml.sax.SAXParseException)" map="A"/>
  <method class="org.apache.xerces.util.ErrorHandlerProxy" name="void warning(org.xml.sax.SAXParseException)" map="B"/>
  <method class="org.apache.xerces.util.ErrorHandlerProxy" name="void fatalError(org.xml.sax.SAXParseException)" map="C"/>
  <class name="org.apache.xerces.util.ParserConfigurationSettings" map="O"/>
  <field class="org.apache.xerces.util.ParserConfigurationSettings" name="fParentSettings" map="&#x020d;"/>
  <field class="org.apache.xerces.util.ParserConfigurationSettings" name="fFeatures" map="&#x020e;"/>
  <field class="org.apache.xerces.util.ParserConfigurationSettings" name="fRecognizedFeatures" map="&#x020f;"/>
  <field class="org.apache.xerces.util.ParserConfigurationSettings" name="fRecognizedProperties" map="&#x0210;"/>
  <field class="org.apache.xerces.util.ParserConfigurationSettings" name="fProperties" map="&#x0211;"/>
  <method class="org.apache.xerces.util.ParserConfigurationSettings" name="void checkProperty(java.lang.String)" map="j"/>
  <method class="org.apache.xerces.util.ParserConfigurationSettings" name="void setProperty(java.lang.String, java.lang.Object)" map="D"/>
  <method class="org.apache.xerces.util.ParserConfigurationSettings" name="void setFeature(java.lang.String, boolean)" map="E"/>
  <method class="org.apache.xerces.util.ParserConfigurationSettings" name="void checkFeature(java.lang.String)" map="k"/>
  <method class="org.apache.xerces.util.ParserConfigurationSettings" name="boolean getFeature(java.lang.String)" map="h"/>
  <method class="org.apache.xerces.util.ParserConfigurationSettings" name="void addRecognizedFeatures(java.lang.String[])" map="A"/>
  <method class="org.apache.xerces.util.ParserConfigurationSettings" name="java.lang.Object getProperty(java.lang.String)" map="i"/>
  <method class="org.apache.xerces.util.ParserConfigurationSettings" name="void addRecognizedProperties(java.lang.String[])" map="B"/>
  <class name="org.apache.xerces.util.NamespaceSupport$Prefixes" map="_A"/>
  <field class="org.apache.xerces.util.NamespaceSupport$Prefixes" name="this$0" map="this$0"/>
  <field class="org.apache.xerces.util.NamespaceSupport$Prefixes" name="counter" map="A"/>
  <field class="org.apache.xerces.util.NamespaceSupport$Prefixes" name="size" map="B"/>
  <field class="org.apache.xerces.util.NamespaceSupport$Prefixes" name="prefixes" map="C"/>
  <method class="org.apache.xerces.util.NamespaceSupport$Prefixes" name="boolean hasMoreElements()" map="hasMoreElements"/>
  <method class="org.apache.xerces.util.NamespaceSupport$Prefixes" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.util.NamespaceSupport$Prefixes" name="java.lang.Object nextElement()" map="nextElement"/>
  <class name="org.apache.xerces.util.NamespaceSupport" map="P"/>
  <field class="org.apache.xerces.util.NamespaceSupport" name="fNamespace" map="C"/>
  <field class="org.apache.xerces.util.NamespaceSupport" name="fCurrentContext" map="D"/>
  <field class="org.apache.xerces.util.NamespaceSupport" name="fPrefixes" map="E"/>
  <field class="org.apache.xerces.util.NamespaceSupport" name="fNamespaceSize" map="F"/>
  <field class="org.apache.xerces.util.NamespaceSupport" name="fContext" map="G"/>
  <method class="org.apache.xerces.util.NamespaceSupport" name="java.lang.String getURI(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.NamespaceSupport" name="void popContext()" map="B"/>
  <method class="org.apache.xerces.util.NamespaceSupport" name="void reset()" map="A"/>
  <method class="org.apache.xerces.util.NamespaceSupport" name="boolean declarePrefix(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.NamespaceSupport" name="int getDeclaredPrefixCount()" map="C"/>
  <method class="org.apache.xerces.util.NamespaceSupport" name="java.lang.String getPrefix(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.util.NamespaceSupport" name="void pushContext()" map="D"/>
  <method class="org.apache.xerces.util.NamespaceSupport" name="boolean containsPrefix(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.util.NamespaceSupport" name="java.util.Enumeration getAllPrefixes()" map="E"/>
  <method class="org.apache.xerces.util.NamespaceSupport" name="java.lang.String getDeclaredPrefixAt(int)" map="A"/>
  <class name="org.apache.xerces.util.StAXInputSource" map="Q"/>
  <method class="org.apache.xerces.util.StAXInputSource" name="javax.xml.stream.XMLStreamReader getXMLStreamReader()" map="H"/>
  <method class="org.apache.xerces.util.StAXInputSource" name="boolean shouldConsumeRemainingContent()" map="I"/>
  <method class="org.apache.xerces.util.StAXInputSource" name="javax.xml.stream.XMLEventReader getXMLEventReader()" map="J"/>
  <class name="org.apache.xerces.util.XMLChar" map="R"/>
  <field class="org.apache.xerces.util.XMLChar" name="CHARS" map="A"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isName(int)" map="A"/>
  <method class="org.apache.xerces.util.XMLChar" name="char lowSurrogate(int)" map="B"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isSpace(int)" map="C"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isNameStart(int)" map="D"/>
  <method class="org.apache.xerces.util.XMLChar" name="java.lang.String trim(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.XMLChar" name="int supplemental(char, char)" map="A"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isLowSurrogate(int)" map="E"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isValidNCName(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isSupplemental(int)" map="F"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isNCName(int)" map="G"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isValid(int)" map="H"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isValidJavaEncoding(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isHighSurrogate(int)" map="I"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isValidName(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isMarkup(int)" map="J"/>
  <method class="org.apache.xerces.util.XMLChar" name="char highSurrogate(int)" map="K"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isContent(int)" map="L"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isPubid(int)" map="M"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isValidNmtoken(java.lang.String)" map="E"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isInvalid(int)" map="N"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isValidIANAEncoding(java.lang.String)" map="F"/>
  <method class="org.apache.xerces.util.XMLChar" name="boolean isNCNameStart(int)" map="O"/>
  <class name="org.apache.xerces.util.DOMEntityResolverWrapper" map="S"/>
  <method class="org.apache.xerces.util.DOMEntityResolverWrapper" name="org.apache.xerces.xni.parser.XMLInputSource resolveEntity(org.apache.xerces.xni.XMLResourceIdentifier)" map="A"/>
  <class name="org.apache.xerces.util.XMLLocatorWrapper" map="T"/>
  <field class="org.apache.xerces.util.XMLLocatorWrapper" name="fLocator" map="C"/>
  <method class="org.apache.xerces.util.XMLLocatorWrapper" name="java.lang.String getPublicId()" map="A"/>
  <method class="org.apache.xerces.util.XMLLocatorWrapper" name="int getCharacterOffset()" map="B"/>
  <method class="org.apache.xerces.util.XMLLocatorWrapper" name="int getColumnNumber()" map="C"/>
  <method class="org.apache.xerces.util.XMLLocatorWrapper" name="int getLineNumber()" map="D"/>
  <method class="org.apache.xerces.util.XMLLocatorWrapper" name="java.lang.String getExpandedSystemId()" map="E"/>
  <method class="org.apache.xerces.util.XMLLocatorWrapper" name="java.lang.String getLiteralSystemId()" map="F"/>
  <method class="org.apache.xerces.util.XMLLocatorWrapper" name="void setLocator(org.apache.xerces.xni.XMLLocator)" map="A"/>
  <method class="org.apache.xerces.util.XMLLocatorWrapper" name="java.lang.String getBaseSystemId()" map="G"/>
  <class name="org.apache.xerces.util.SAXInputSource" map="U"/>
  <method class="org.apache.xerces.util.SAXInputSource" name="org.xml.sax.InputSource getInputSource()" map="K"/>
  <method class="org.apache.xerces.util.SAXInputSource" name="org.xml.sax.XMLReader getXMLReader()" map="L"/>
  <class name="org.apache.xerces.util.DefaultErrorHandler" map="V"/>
  <field class="org.apache.xerces.util.DefaultErrorHandler" name="fOut" map="A"/>
  <method class="org.apache.xerces.util.DefaultErrorHandler" name="void printError(java.lang.String, org.apache.xerces.xni.parser.XMLParseException)" map="A"/>
  <method class="org.apache.xerces.util.DefaultErrorHandler" name="void warning(java.lang.String, java.lang.String, org.apache.xerces.xni.parser.XMLParseException)" map="A"/>
  <method class="org.apache.xerces.util.DefaultErrorHandler" name="void error(java.lang.String, java.lang.String, org.apache.xerces.xni.parser.XMLParseException)" map="B"/>
  <method class="org.apache.xerces.util.DefaultErrorHandler" name="void fatalError(java.lang.String, java.lang.String, org.apache.xerces.xni.parser.XMLParseException)" map="C"/>
  <class name="org.apache.xerces.util.XMLAttributesImpl$Attribute" map="_A"/>
  <field class="org.apache.xerces.util.XMLAttributesImpl$Attribute" name="augs" map="A"/>
  <field class="org.apache.xerces.util.XMLAttributesImpl$Attribute" name="name" map="B"/>
  <field class="org.apache.xerces.util.XMLAttributesImpl$Attribute" name="next" map="C"/>
  <field class="org.apache.xerces.util.XMLAttributesImpl$Attribute" name="type" map="D"/>
  <field class="org.apache.xerces.util.XMLAttributesImpl$Attribute" name="specified" map="E"/>
  <field class="org.apache.xerces.util.XMLAttributesImpl$Attribute" name="nonNormalizedValue" map="F"/>
  <field class="org.apache.xerces.util.XMLAttributesImpl$Attribute" name="value" map="G"/>
  <class name="org.apache.xerces.util.XMLAttributesImpl" map="W"/>
  <field class="org.apache.xerces.util.XMLAttributesImpl" name="fNamespaces" map="A"/>
  <field class="org.apache.xerces.util.XMLAttributesImpl" name="fLargeCount" map="B"/>
  <field class="org.apache.xerces.util.XMLAttributesImpl" name="fTableViewBuckets" map="C"/>
  <field class="org.apache.xerces.util.XMLAttributesImpl" name="fIsTableViewConsistent" map="D"/>
  <field class="org.apache.xerces.util.XMLAttributesImpl" name="fAttributeTableViewChainState" map="E"/>
  <field class="org.apache.xerces.util.XMLAttributesImpl" name="fAttributes" map="F"/>
  <field class="org.apache.xerces.util.XMLAttributesImpl" name="fLength" map="G"/>
  <field class="org.apache.xerces.util.XMLAttributesImpl" name="fAttributeTableView" map="H"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="void removeAllAttributes()" map="A"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="java.lang.String getReportableType(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="int getIndex(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="int getIndexFast(java.lang.String, java.lang.String)" map="B"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="java.lang.String getQName(int)" map="A"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="org.apache.xerces.xni.QName checkDuplicatesNS()" map="C"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="void setURI(int, java.lang.String)" map="D"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="int getTableViewBucket(java.lang.String, java.lang.String)" map="C"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="int getLength()" map="B"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="void setSpecified(int, boolean)" map="A"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="java.lang.String getURI(int)" map="B"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="int getIndexFast(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="void setNonNormalizedValue(int, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="java.lang.String getType(int)" map="C"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="void cleanTableView()" map="D"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="java.lang.String getNonNormalizedValue(int)" map="D"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="java.lang.String getLocalName(int)" map="F"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="void removeAttributeAt(int)" map="E"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="void prepareTableView()" map="E"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="java.lang.String getValue(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="java.lang.String getValue(int)" map="G"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="int addAttribute(org.apache.xerces.xni.QName, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="int getIndex(java.lang.String, java.lang.String)" map="D"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="int getTableViewBucket(java.lang.String)" map="E"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="void setValue(int, java.lang.String)" map="B"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="void prepareAndPopulateTableView()" map="F"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="java.lang.String getPrefix(int)" map="H"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="void setNamespaces(boolean)" map="A"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="void setType(int, java.lang.String)" map="C"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="void getName(int, org.apache.xerces.xni.QName)" map="A"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="boolean isSpecified(int)" map="I"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="java.lang.String getValue(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="org.apache.xerces.xni.Augmentations getAugmentations(int)" map="J"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="void setName(int, org.apache.xerces.xni.QName)" map="B"/>
  <method class="org.apache.xerces.util.XMLAttributesImpl" name="void addAttributeNS(org.apache.xerces.xni.QName, java.lang.String, java.lang.String)" map="B"/>
  <class name="org.apache.xerces.util.SymbolTable$Entry" map="_A"/>
  <field class="org.apache.xerces.util.SymbolTable$Entry" name="characters" map="A"/>
  <field class="org.apache.xerces.util.SymbolTable$Entry" name="next" map="B"/>
  <field class="org.apache.xerces.util.SymbolTable$Entry" name="symbol" map="C"/>
  <class name="org.apache.xerces.util.SymbolTable" map="X"/>
  <field class="org.apache.xerces.util.SymbolTable" name="fCount" map="A"/>
  <field class="org.apache.xerces.util.SymbolTable" name="fLoadFactor" map="B"/>
  <field class="org.apache.xerces.util.SymbolTable" name="fThreshold" map="C"/>
  <field class="org.apache.xerces.util.SymbolTable" name="fBuckets" map="D"/>
  <field class="org.apache.xerces.util.SymbolTable" name="fTableSize" map="E"/>
  <method class="org.apache.xerces.util.SymbolTable" name="java.lang.String addSymbol(char[], int, int)" map="A"/>
  <method class="org.apache.xerces.util.SymbolTable" name="java.lang.String addSymbol(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.SymbolTable" name="int hash(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.util.SymbolTable" name="void rehash()" map="A"/>
  <method class="org.apache.xerces.util.SymbolTable" name="int hash(char[], int, int)" map="B"/>
  <class name="org.apache.xerces.util.XMLEntityDescriptionImpl" map="Y"/>
  <field class="org.apache.xerces.util.XMLEntityDescriptionImpl" name="fEntityName" map="F"/>
  <method class="org.apache.xerces.util.XMLEntityDescriptionImpl" name="void clear()" map="E"/>
  <method class="org.apache.xerces.util.XMLEntityDescriptionImpl" name="void setDescription(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.XMLEntityDescriptionImpl" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.xerces.util.XMLEntityDescriptionImpl" name="java.lang.String getEntityName()" map="G"/>
  <method class="org.apache.xerces.util.XMLEntityDescriptionImpl" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.util.XMLEntityDescriptionImpl" name="void setDescription(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <class name="org.apache.xerces.util.SymbolHash$Entry" map="_A"/>
  <field class="org.apache.xerces.util.SymbolHash$Entry" name="key" map="A"/>
  <field class="org.apache.xerces.util.SymbolHash$Entry" name="next" map="B"/>
  <field class="org.apache.xerces.util.SymbolHash$Entry" name="value" map="C"/>
  <method class="org.apache.xerces.util.SymbolHash$Entry" name="org.apache.xerces.util.SymbolHash$Entry makeClone()" map="A"/>
  <class name="org.apache.xerces.util.SymbolHash" map="Z"/>
  <field class="org.apache.xerces.util.SymbolHash" name="fNum" map="A"/>
  <field class="org.apache.xerces.util.SymbolHash" name="fBuckets" map="B"/>
  <field class="org.apache.xerces.util.SymbolHash" name="fTableSize" map="C"/>
  <method class="org.apache.xerces.util.SymbolHash" name="org.apache.xerces.util.SymbolHash makeClone()" map="A"/>
  <method class="org.apache.xerces.util.SymbolHash" name="void clear()" map="B"/>
  <method class="org.apache.xerces.util.SymbolHash" name="org.apache.xerces.util.SymbolHash$Entry search(java.lang.Object, int)" map="A"/>
  <method class="org.apache.xerces.util.SymbolHash" name="java.lang.Object[] getEntries()" map="C"/>
  <method class="org.apache.xerces.util.SymbolHash" name="int getValues(java.lang.Object[], int)" map="A"/>
  <method class="org.apache.xerces.util.SymbolHash" name="int getLength()" map="D"/>
  <method class="org.apache.xerces.util.SymbolHash" name="java.lang.Object get(java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.util.SymbolHash" name="void put(java.lang.Object, java.lang.Object)" map="A"/>
  <class name="org.apache.xerces.util.JAXPNamespaceContextWrapper" map="_"/>
  <field class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="fSymbolTable" map="L"/>
  <field class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="fCurrentContext" map="M"/>
  <field class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="fPrefixes" map="N"/>
  <field class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="fNamespaceContext" map="O"/>
  <field class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="fContext" map="P"/>
  <field class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="fAllPrefixes" map="Q"/>
  <method class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="java.lang.String getURI(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="void reset()" map="A"/>
  <method class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="void popContext()" map="B"/>
  <method class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="void setNamespaceContext(javax.xml.namespace.NamespaceContext)" map="A"/>
  <method class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="boolean declarePrefix(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="int getDeclaredPrefixCount()" map="C"/>
  <method class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="java.lang.String getPrefix(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="void setDeclaredPrefixes(java.util.List)" map="A"/>
  <method class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="void pushContext()" map="D"/>
  <method class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="java.lang.String getDeclaredPrefixAt(int)" map="A"/>
  <method class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="java.util.Enumeration getAllPrefixes()" map="E"/>
  <method class="org.apache.xerces.util.JAXPNamespaceContextWrapper" name="void setSymbolTable(org.apache.xerces.util.SymbolTable)" map="A"/>
  <class name="org.apache.xerces.util.HTTPInputSource" map="a"/>
  <field class="org.apache.xerces.util.HTTPInputSource" name="fHTTPRequestProperties" map="G"/>
  <field class="org.apache.xerces.util.HTTPInputSource" name="fFollowRedirects" map="H"/>
  <method class="org.apache.xerces.util.HTTPInputSource" name="boolean getFollowHTTPRedirects()" map="M"/>
  <method class="org.apache.xerces.util.HTTPInputSource" name="java.util.Iterator getHTTPRequestProperties()" map="N"/>
  <method class="org.apache.xerces.util.HTTPInputSource" name="void setHTTPRequestProperty(java.lang.String, java.lang.String)" map="A"/>
  <class name="org.apache.xerces.util.XMLStringBuffer" map="b"/>
  <method class="org.apache.xerces.util.XMLStringBuffer" name="void append(char[], int, int)" map="C"/>
  <method class="org.apache.xerces.util.XMLStringBuffer" name="void clear()" map="A"/>
  <method class="org.apache.xerces.util.XMLStringBuffer" name="void append(char)" map="A"/>
  <method class="org.apache.xerces.util.XMLStringBuffer" name="void append(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.util.XMLStringBuffer" name="void append(org.apache.xerces.xni.XMLString)" map="B"/>
  <class name="org.apache.xerces.util.DOMUtil" map="c"/>
  <method class="org.apache.xerces.util.DOMUtil" name="void setHidden(org.w3c.dom.Node, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.util.DOMUtil" name="org.w3c.dom.Document getDocument(org.w3c.dom.Node)" map="A"/>
  <method class="org.apache.xerces.util.DOMUtil" name="java.lang.String getAttrValue(org.w3c.dom.Element, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.DOMUtil" name="org.w3c.dom.Element getFirstChildElement(org.w3c.dom.Node)" map="B"/>
  <method class="org.apache.xerces.util.DOMUtil" name="java.lang.String getAnnotation(org.w3c.dom.Node)" map="C"/>
  <method class="org.apache.xerces.util.DOMUtil" name="java.lang.String getSyntheticAnnotation(org.w3c.dom.Node)" map="D"/>
  <method class="org.apache.xerces.util.DOMUtil" name="java.lang.String getNamespaceURI(org.w3c.dom.Node)" map="E"/>
  <method class="org.apache.xerces.util.DOMUtil" name="org.w3c.dom.Element getNextSiblingElement(org.w3c.dom.Node)" map="F"/>
  <method class="org.apache.xerces.util.DOMUtil" name="org.w3c.dom.Element getRoot(org.w3c.dom.Document)" map="A"/>
  <method class="org.apache.xerces.util.DOMUtil" name="org.w3c.dom.Element getFirstVisibleChildElement(org.w3c.dom.Node, java.util.Hashtable)" map="B"/>
  <method class="org.apache.xerces.util.DOMUtil" name="boolean isHidden(org.w3c.dom.Node, java.util.Hashtable)" map="C"/>
  <method class="org.apache.xerces.util.DOMUtil" name="org.w3c.dom.Element getNextVisibleSiblingElement(org.w3c.dom.Node, java.util.Hashtable)" map="D"/>
  <method class="org.apache.xerces.util.DOMUtil" name="java.lang.String getPrefix(org.w3c.dom.Node)" map="G"/>
  <method class="org.apache.xerces.util.DOMUtil" name="void setVisible(org.w3c.dom.Node, java.util.Hashtable)" map="E"/>
  <method class="org.apache.xerces.util.DOMUtil" name="java.lang.String getName(org.w3c.dom.Node)" map="H"/>
  <method class="org.apache.xerces.util.DOMUtil" name="org.w3c.dom.Attr[] getAttrs(org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.util.DOMUtil" name="org.w3c.dom.Element getParent(org.w3c.dom.Element)" map="B"/>
  <method class="org.apache.xerces.util.DOMUtil" name="org.w3c.dom.Attr getAttr(org.w3c.dom.Element, java.lang.String)" map="B"/>
  <method class="org.apache.xerces.util.DOMUtil" name="java.lang.String getLocalName(org.w3c.dom.Node)" map="I"/>
  <method class="org.apache.xerces.util.DOMUtil" name="java.lang.String getValue(org.w3c.dom.Attr)" map="A"/>
  <class name="org.apache.xerces.util.DOMErrorHandlerWrapper" map="d"/>
  <method class="org.apache.xerces.util.DOMErrorHandlerWrapper" name="void warning(java.lang.String, java.lang.String, org.apache.xerces.xni.parser.XMLParseException)" map="A"/>
  <method class="org.apache.xerces.util.DOMErrorHandlerWrapper" name="void error(java.lang.String, java.lang.String, org.apache.xerces.xni.parser.XMLParseException)" map="B"/>
  <method class="org.apache.xerces.util.DOMErrorHandlerWrapper" name="void fatalError(java.lang.String, java.lang.String, org.apache.xerces.xni.parser.XMLParseException)" map="C"/>
  <class name="org.apache.xerces.util.XML11Char" map="e"/>
  <field class="org.apache.xerces.util.XML11Char" name="XML11CHARS" map="A"/>
  <method class="org.apache.xerces.util.XML11Char" name="boolean isXML11ValidName(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.util.XML11Char" name="boolean isXML11NameHighSurrogate(int)" map="A"/>
  <method class="org.apache.xerces.util.XML11Char" name="boolean isXML11ValidLiteral(int)" map="B"/>
  <method class="org.apache.xerces.util.XML11Char" name="boolean isXML11NameStart(int)" map="C"/>
  <method class="org.apache.xerces.util.XML11Char" name="boolean isXML11NCName(int)" map="D"/>
  <method class="org.apache.xerces.util.XML11Char" name="boolean isXML11Content(int)" map="E"/>
  <method class="org.apache.xerces.util.XML11Char" name="boolean isXML11ValidNmtoken(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.util.XML11Char" name="boolean isXML11InternalEntityContent(int)" map="F"/>
  <method class="org.apache.xerces.util.XML11Char" name="boolean isXML11Name(int)" map="G"/>
  <method class="org.apache.xerces.util.XML11Char" name="boolean isXML11NCNameStart(int)" map="H"/>
  <method class="org.apache.xerces.util.XML11Char" name="boolean isXML11Valid(int)" map="I"/>
  <method class="org.apache.xerces.util.XML11Char" name="boolean isXML11Space(int)" map="J"/>
  <method class="org.apache.xerces.util.XML11Char" name="boolean isXML11Invalid(int)" map="K"/>
  <class name="org.apache.xerces.util.StAXLocationWrapper" map="f"/>
  <field class="org.apache.xerces.util.StAXLocationWrapper" name="fLocation" map="D"/>
  <method class="org.apache.xerces.util.StAXLocationWrapper" name="java.lang.String getPublicId()" map="A"/>
  <method class="org.apache.xerces.util.StAXLocationWrapper" name="int getCharacterOffset()" map="B"/>
  <method class="org.apache.xerces.util.StAXLocationWrapper" name="int getColumnNumber()" map="C"/>
  <method class="org.apache.xerces.util.StAXLocationWrapper" name="int getLineNumber()" map="D"/>
  <method class="org.apache.xerces.util.StAXLocationWrapper" name="java.lang.String getExpandedSystemId()" map="E"/>
  <method class="org.apache.xerces.util.StAXLocationWrapper" name="java.lang.String getLiteralSystemId()" map="F"/>
  <method class="org.apache.xerces.util.StAXLocationWrapper" name="void setLocation(javax.xml.stream.Location)" map="A"/>
  <method class="org.apache.xerces.util.StAXLocationWrapper" name="java.lang.String getBaseSystemId()" map="G"/>
  <class name="org.apache.xerces.util.ErrorHandlerWrapper$1" map="1"/>
  <field class="org.apache.xerces.util.ErrorHandlerWrapper$1" name="val$fColumnNumber" map="val$fColumnNumber"/>
  <field class="org.apache.xerces.util.ErrorHandlerWrapper$1" name="val$fLineNumber" map="val$fLineNumber"/>
  <field class="org.apache.xerces.util.ErrorHandlerWrapper$1" name="val$fPublicId" map="val$fPublicId"/>
  <field class="org.apache.xerces.util.ErrorHandlerWrapper$1" name="val$fExpandedSystemId" map="val$fExpandedSystemId"/>
  <method class="org.apache.xerces.util.ErrorHandlerWrapper$1" name="java.lang.String getPublicId()" map="A"/>
  <method class="org.apache.xerces.util.ErrorHandlerWrapper$1" name="int getCharacterOffset()" map="B"/>
  <method class="org.apache.xerces.util.ErrorHandlerWrapper$1" name="int getLineNumber()" map="D"/>
  <method class="org.apache.xerces.util.ErrorHandlerWrapper$1" name="int getColumnNumber()" map="C"/>
  <method class="org.apache.xerces.util.ErrorHandlerWrapper$1" name="java.lang.String getExpandedSystemId()" map="E"/>
  <method class="org.apache.xerces.util.ErrorHandlerWrapper$1" name="java.lang.String getLiteralSystemId()" map="F"/>
  <method class="org.apache.xerces.util.ErrorHandlerWrapper$1" name="java.lang.String getBaseSystemId()" map="G"/>
  <class name="org.apache.xerces.util.ErrorHandlerWrapper" map="g"/>
  <field class="org.apache.xerces.util.ErrorHandlerWrapper" name="fErrorHandler" map="B"/>
  <method class="org.apache.xerces.util.ErrorHandlerWrapper" name="void warning(java.lang.String, java.lang.String, org.apache.xerces.xni.parser.XMLParseException)" map="A"/>
  <method class="org.apache.xerces.util.ErrorHandlerWrapper" name="org.apache.xerces.xni.XNIException createXNIException(org.xml.sax.SAXException)" map="A"/>
  <method class="org.apache.xerces.util.ErrorHandlerWrapper" name="void error(java.lang.String, java.lang.String, org.apache.xerces.xni.parser.XMLParseException)" map="B"/>
  <method class="org.apache.xerces.util.ErrorHandlerWrapper" name="org.apache.xerces.xni.parser.XMLParseException createXMLParseException(org.xml.sax.SAXParseException)" map="A"/>
  <method class="org.apache.xerces.util.ErrorHandlerWrapper" name="void setErrorHandler(org.xml.sax.ErrorHandler)" map="A"/>
  <method class="org.apache.xerces.util.ErrorHandlerWrapper" name="org.xml.sax.SAXParseException createSAXParseException(org.apache.xerces.xni.parser.XMLParseException)" map="A"/>
  <method class="org.apache.xerces.util.ErrorHandlerWrapper" name="void fatalError(java.lang.String, java.lang.String, org.apache.xerces.xni.parser.XMLParseException)" map="C"/>
  <package name="org.apache.xerces.xpointer" map="F"/>
  <class name="org.apache.xerces.xpointer.XPointerHandler" map="A"/>
  <method class="org.apache.xerces.xpointer.XPointerHandler" name="void setProperty(java.lang.String, java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.xpointer.XPointerHandler" name="boolean isXPointerResolved()" map="a"/>
  <method class="org.apache.xerces.xpointer.XPointerHandler" name="void parseXPointer(java.lang.String)" map="N"/>
  <method class="org.apache.xerces.xpointer.XPointerHandler" name="void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler)" map="A"/>
  <class name="org.apache.xerces.xpointer.XPointerProcessor" map="B"/>
  <method class="org.apache.xerces.xpointer.XPointerProcessor" name="boolean isXPointerResolved()" map="a"/>
  <method class="org.apache.xerces.xpointer.XPointerProcessor" name="void parseXPointer(java.lang.String)" map="N"/>
  <package name="org.apache.xerces.impl" map="G"/>
  <package name="org.apache.xerces.impl.xpath" map="A"/>
  <package name="org.apache.xerces.impl.xpath.regex" map="A"/>
  <class name="org.apache.xerces.impl.xpath.regex.REUtil" map="A"/>
  <field class="org.apache.xerces.impl.xpath.regex.REUtil" name="regexCache" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.REUtil" name="int parseOptions(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.REUtil" name="int composeFromSurrogates(int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.REUtil" name="java.lang.String decomposeToSurrogates(int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.REUtil" name="int getOptionValue(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.REUtil" name="java.lang.String quoteMeta(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.REUtil" name="java.lang.String stripExtendedComment(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.REUtil" name="boolean isHighSurrogate(int)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.REUtil" name="java.lang.String createOptionString(int)" map="D"/>
  <method class="org.apache.xerces.impl.xpath.regex.REUtil" name="boolean isLowSurrogate(int)" map="E"/>
  <class name="org.apache.xerces.impl.xpath.regex.Token$ConditionToken" map="_A"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$ConditionToken" name="refNumber" map="v"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$ConditionToken" name="no" map="w"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$ConditionToken" name="yes" map="x"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$ConditionToken" name="condition" map="y"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ConditionToken" name="java.lang.String toString(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ConditionToken" name="org.apache.xerces.impl.xpath.regex.Token getChild(int)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ConditionToken" name="int size()" map="L"/>
  <class name="org.apache.xerces.impl.xpath.regex.Token$ConcatToken" map="_B"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$ConcatToken" name="child2" map="b"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$ConcatToken" name="child" map="c"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ConcatToken" name="java.lang.String toString(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ConcatToken" name="org.apache.xerces.impl.xpath.regex.Token getChild(int)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ConcatToken" name="int size()" map="L"/>
  <class name="org.apache.xerces.impl.xpath.regex.Token$ClosureToken" map="_C"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$ClosureToken" name="max" map="d"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$ClosureToken" name="min" map="e"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$ClosureToken" name="child" map="f"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ClosureToken" name="java.lang.String toString(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ClosureToken" name="org.apache.xerces.impl.xpath.regex.Token getChild(int)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ClosureToken" name="int size()" map="L"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ClosureToken" name="int getMax()" map="M"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ClosureToken" name="int getMin()" map="G"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ClosureToken" name="void setMin(int)" map="G"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ClosureToken" name="void setMax(int)" map="A"/>
  <class name="org.apache.xerces.impl.xpath.regex.Token$FixedStringContainer" map="_D"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$FixedStringContainer" name="options" map="A"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$FixedStringContainer" name="token" map="B"/>
  <class name="org.apache.xerces.impl.xpath.regex.Token$ModifierToken" map="_E"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$ModifierToken" name="mask" map="g"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$ModifierToken" name="add" map="h"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$ModifierToken" name="child" map="i"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ModifierToken" name="java.lang.String toString(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ModifierToken" name="org.apache.xerces.impl.xpath.regex.Token getChild(int)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ModifierToken" name="int size()" map="L"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ModifierToken" name="int getOptions()" map="P"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ModifierToken" name="int getOptionsMask()" map="Q"/>
  <class name="org.apache.xerces.impl.xpath.regex.Token$UnionToken" map="_F"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$UnionToken" name="children" map="j"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$UnionToken" name="java.lang.String toString(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$UnionToken" name="org.apache.xerces.impl.xpath.regex.Token getChild(int)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$UnionToken" name="int size()" map="L"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$UnionToken" name="void addChild(org.apache.xerces.impl.xpath.regex.Token)" map="E"/>
  <class name="org.apache.xerces.impl.xpath.regex.Token$StringToken" map="_G"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$StringToken" name="refNumber" map="k"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$StringToken" name="string" map="l"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$StringToken" name="java.lang.String toString(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$StringToken" name="java.lang.String getString()" map="E"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$StringToken" name="int getReferenceNumber()" map="N"/>
  <class name="org.apache.xerces.impl.xpath.regex.Token$ParenToken" map="_H"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$ParenToken" name="parennumber" map="m"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$ParenToken" name="child" map="n"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ParenToken" name="java.lang.String toString(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ParenToken" name="int getParenNumber()" map="I"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ParenToken" name="org.apache.xerces.impl.xpath.regex.Token getChild(int)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$ParenToken" name="int size()" map="L"/>
  <class name="org.apache.xerces.impl.xpath.regex.Token$CharToken" map="_I"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token$CharToken" name="chardata" map="o"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$CharToken" name="java.lang.String toString(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token$CharToken" name="int getChar()" map="O"/>
  <class name="org.apache.xerces.impl.xpath.regex.Token" map="B"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_not_wordedge" map="A"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="categoryNames" map="B"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_spaces" map="C"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="type" map="D"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_linebeginning" map="E"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_0to9" map="F"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_linebeginning2" map="G"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_dot" map="H"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="categories2" map="I"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_empty" map="J"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_wordbeginning" map="K"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_stringbeginning" map="L"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="tokens" map="M"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="nonBMPBlockRanges" map="N"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="nonxs" map="O"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="categories" map="P"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_ccs" map="Q"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_wordedge" map="R"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_wordend" map="S"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_grapheme" map="T"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_stringend2" map="U"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_lineend" map="V"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_wordchars" map="W"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_not_0to9" map="X"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_not_wordchars" map="Y"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_not_spaces" map="Z"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="token_stringend" map="_"/>
  <field class="org.apache.xerces.impl.xpath.regex.Token" name="blockNames" map="a"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.RangeToken getRange(java.lang.String, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="int analyzeFirstCharacter(org.apache.xerces.impl.xpath.regex.RangeToken, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token$UnionToken createUnion()" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="int getMinLength()" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="void setMax(int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token getCombiningCharacterSequence()" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="boolean isShorterThan(org.apache.xerces.impl.xpath.regex.Token)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="java.lang.String toString(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="void addRange(int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.RangeToken createNRange()" map="D"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="java.lang.String getString()" map="E"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="void registerNonXS(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token$ConditionToken createCondition(int, org.apache.xerces.impl.xpath.regex.Token, org.apache.xerces.impl.xpath.regex.Token, org.apache.xerces.impl.xpath.regex.Token)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="void mergeRanges(org.apache.xerces.impl.xpath.regex.Token)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token createEmpty()" map="F"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="void setAlias(java.lang.String, java.lang.String, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="int getMin()" map="G"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.RangeToken createRange()" map="H"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token getChild(int)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="int getParenNumber()" map="I"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.RangeToken getRange(java.lang.String, boolean, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token$UnionToken createConcat()" map="J"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token$StringToken createString(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token getGraphemePattern()" map="K"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="boolean isSet(int, int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token$CharToken createChar(int)" map="D"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token$ClosureToken createClosure(org.apache.xerces.impl.xpath.regex.Token)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="boolean isRegisterNonXS(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token$CharToken createAnchor(int)" map="E"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="int size()" map="L"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="int getMax()" map="M"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token$ParenToken createLook(int, org.apache.xerces.impl.xpath.regex.Token)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="int getReferenceNumber()" map="N"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token$ClosureToken createNGClosure(org.apache.xerces.impl.xpath.regex.Token)" map="D"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="int getChar()" map="O"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="void addChild(org.apache.xerces.impl.xpath.regex.Token)" map="E"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="void findFixedString(org.apache.xerces.impl.xpath.regex.Token$FixedStringContainer, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token$ModifierToken createModifierGroup(org.apache.xerces.impl.xpath.regex.Token, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token$ConcatToken createConcat(org.apache.xerces.impl.xpath.regex.Token, org.apache.xerces.impl.xpath.regex.Token)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token complementRanges(org.apache.xerces.impl.xpath.regex.Token)" map="F"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token$StringToken createBackReference(int)" map="F"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="org.apache.xerces.impl.xpath.regex.Token$ParenToken createParen(org.apache.xerces.impl.xpath.regex.Token, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="void setMin(int)" map="G"/>
  <method class="org.apache.xerces.impl.xpath.regex.Token" name="void subtractRanges(org.apache.xerces.impl.xpath.regex.Token)" map="G"/>
  <class name="org.apache.xerces.impl.xpath.regex.BMPattern" map="C"/>
  <field class="org.apache.xerces.impl.xpath.regex.BMPattern" name="ignoreCase" map="A"/>
  <field class="org.apache.xerces.impl.xpath.regex.BMPattern" name="shiftTable" map="B"/>
  <field class="org.apache.xerces.impl.xpath.regex.BMPattern" name="pattern" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.BMPattern" name="int matchesIgnoreCase(java.lang.String, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.BMPattern" name="int matches(java.lang.String, int, int)" map="B"/>
  <class name="org.apache.xerces.impl.xpath.regex.Match" map="D"/>
  <field class="org.apache.xerces.impl.xpath.regex.Match" name="ciSource" map="A"/>
  <field class="org.apache.xerces.impl.xpath.regex.Match" name="charSource" map="B"/>
  <field class="org.apache.xerces.impl.xpath.regex.Match" name="beginpos" map="C"/>
  <field class="org.apache.xerces.impl.xpath.regex.Match" name="strSource" map="D"/>
  <field class="org.apache.xerces.impl.xpath.regex.Match" name="nofgroups" map="E"/>
  <field class="org.apache.xerces.impl.xpath.regex.Match" name="endpos" map="F"/>
  <method class="org.apache.xerces.impl.xpath.regex.Match" name="int getEnd(int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Match" name="int getBeginning(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Match" name="void setSource(java.text.CharacterIterator)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Match" name="java.lang.Object clone()" map="clone"/>
  <method class="org.apache.xerces.impl.xpath.regex.Match" name="void setBeginning(int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Match" name="void setNumberOfGroups(int)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.Match" name="void setEnd(int, int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Match" name="void setSource(java.lang.String)" map="A"/>
  <class name="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" map="E"/>
  <field class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="UPPER_CASE_MATCH" map="A"/>
  <field class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="CHUNK_MASK" map="B"/>
  <field class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="LOWER_CASE_MATCH" map="C"/>
  <field class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="INITIAL_CHUNK_COUNT" map="D"/>
  <field class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="CHUNK_SIZE" map="E"/>
  <field class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="CHUNK_SHIFT" map="F"/>
  <field class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="caseInsensitiveMap" map="G"/>
  <method class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="int[] getMapping(int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="int[] expandAndAdd(int[], int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="int[] get(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="int[] updateMap(int, int[], int, int[], int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="int[] expandMap(int[], int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="boolean contains(int[], int, int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="void buildCaseInsensitiveMap()" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="void set(int, int[])" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.CaseInsensitiveMap" name="boolean contains(int[], int)" map="B"/>
  <class name="org.apache.xerces.impl.xpath.regex.ParseException" map="F"/>
  <field class="org.apache.xerces.impl.xpath.regex.ParseException" name="location" map="A"/>
  <class name="org.apache.xerces.impl.xpath.regex.RegularExpression$ExpressionTarget" map="_A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression$ExpressionTarget" name="boolean regionMatches(boolean, int, int, java.lang.String, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression$ExpressionTarget" name="char charAt(int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression$ExpressionTarget" name="boolean regionMatches(boolean, int, int, int, int)" map="A"/>
  <class name="org.apache.xerces.impl.xpath.regex.RegularExpression$Context" map="_B"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression$Context" name="limit" map="A"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression$Context" name="match" map="B"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression$Context" name="inuse" map="C"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression$Context" name="stringTarget" map="D"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression$Context" name="length" map="E"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression$Context" name="closureContexts" map="F"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression$Context" name="target" map="G"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression$Context" name="start" map="H"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression$Context" name="void resetCommon(int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression$Context" name="void setInUse(boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression$Context" name="void reset(java.lang.String, int, int, int)" map="A"/>
  <class name="org.apache.xerces.impl.xpath.regex.RegularExpression$StringTarget" map="_C"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression$StringTarget" name="target" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression$StringTarget" name="boolean regionMatches(boolean, int, int, java.lang.String, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression$StringTarget" name="char charAt(int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression$StringTarget" name="boolean regionMatches(boolean, int, int, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression$StringTarget" name="void resetTarget(java.lang.String)" map="A"/>
  <class name="org.apache.xerces.impl.xpath.regex.RegularExpression$ClosureContext" map="_D"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression$ClosureContext" name="currentIndex" map="A"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression$ClosureContext" name="offsets" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression$ClosureContext" name="boolean contains(int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression$ClosureContext" name="void reset()" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression$ClosureContext" name="int[] expandOffsets()" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression$ClosureContext" name="void addOffset(int)" map="B"/>
  <class name="org.apache.xerces.impl.xpath.regex.RegularExpression" map="G"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="operations" map="A"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="context" map="B"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="fixedString" map="C"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="minlength" map="D"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="hasBackReferences" map="E"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="numberOfClosures" map="F"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="nofparen" map="G"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="fixedStringOnly" map="H"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="fixedStringTable" map="I"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="regex" map="J"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="tokentree" map="K"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="fixedStringOptions" map="L"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="firstChar" map="M"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="options" map="N"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="void setPattern(java.lang.String, int, java.util.Locale)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="boolean matchChar(int, int, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="boolean isEOLChar(int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="java.lang.String getOptions()" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="boolean matches(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="boolean isWordChar(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="int getPreviousWordType(org.apache.xerces.impl.xpath.regex.RegularExpression$ExpressionTarget, int, int, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="org.apache.xerces.impl.xpath.regex.Op compile(org.apache.xerces.impl.xpath.regex.Token, org.apache.xerces.impl.xpath.regex.Op, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="int getWordType(org.apache.xerces.impl.xpath.regex.RegularExpression$ExpressionTarget, int, int, int, int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="void setPattern(java.lang.String, java.lang.String, java.util.Locale)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="int match(org.apache.xerces.impl.xpath.regex.RegularExpression$Context, org.apache.xerces.impl.xpath.regex.Op, int, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="boolean matchIgnoreCase(int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="void prepare()" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="int getWordType0(char, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="boolean isSet(int, int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="boolean matchAnchor(org.apache.xerces.impl.xpath.regex.RegularExpression$ExpressionTarget, org.apache.xerces.impl.xpath.regex.Op, org.apache.xerces.impl.xpath.regex.RegularExpression$Context, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="void compile(org.apache.xerces.impl.xpath.regex.Token)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegularExpression" name="boolean matches(java.lang.String, int, int, org.apache.xerces.impl.xpath.regex.Match)" map="A"/>
  <class name="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" map="H"/>
  <field class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="ranges2" map="M"/>
  <field class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="ranges" map="N"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processCondition()" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.RangeToken getRange(java.lang.String, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processStar(org.apache.xerces.impl.xpath.regex.Token)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_gt()" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.RangeToken parseSetOperations()" map="D"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_X()" map="E"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_I()" map="F"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_C()" map="I"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_g()" map="H"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processIndependent()" map="J"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.RangeToken parseCharacterClass(boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processNegativelookahead()" map="L"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processDollar()" map="M"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processModifiers()" map="N"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_z()" map="P"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_b()" map="Q"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_A()" map="R"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processQuestion(org.apache.xerces.impl.xpath.regex.Token)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processParen2()" map="S"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processLookahead()" map="T"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processCaret()" map="V"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="int processCIinCharacterClass(org.apache.xerces.impl.xpath.regex.RangeToken, int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="int decodeEscaped()" map="W"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processParen()" map="X"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processLookbehind()" map="Y"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processBackreference()" map="Z"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_lt()" map="_"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processNegativelookbehind()" map="a"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="boolean checkQuestion(int)" map="D"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="void setupRange(org.apache.xerces.impl.xpath.regex.Token, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_i()" map="c"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processPlus(org.apache.xerces.impl.xpath.regex.Token)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_Z()" map="d"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_c()" map="e"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_B()" map="f"/>
  <method class="org.apache.xerces.impl.xpath.regex.ParserForXMLSchema" name="org.apache.xerces.impl.xpath.regex.Token getTokenForShorthand(int)" map="F"/>
  <class name="org.apache.xerces.impl.xpath.regex.Op$ConditionOp" map="_A"/>
  <field class="org.apache.xerces.impl.xpath.regex.Op$ConditionOp" name="refNumber" map="K"/>
  <field class="org.apache.xerces.impl.xpath.regex.Op$ConditionOp" name="no" map="L"/>
  <field class="org.apache.xerces.impl.xpath.regex.Op$ConditionOp" name="yes" map="M"/>
  <field class="org.apache.xerces.impl.xpath.regex.Op$ConditionOp" name="condition" map="N"/>
  <class name="org.apache.xerces.impl.xpath.regex.Op$UnionOp" map="_B"/>
  <field class="org.apache.xerces.impl.xpath.regex.Op$UnionOp" name="branches" map="D"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op$UnionOp" name="void addElement(org.apache.xerces.impl.xpath.regex.Op)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op$UnionOp" name="int size()" map="G"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op$UnionOp" name="org.apache.xerces.impl.xpath.regex.Op elementAt(int)" map="D"/>
  <class name="org.apache.xerces.impl.xpath.regex.Op$ChildOp" map="_C"/>
  <field class="org.apache.xerces.impl.xpath.regex.Op$ChildOp" name="child" map="E"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op$ChildOp" name="void setChild(org.apache.xerces.impl.xpath.regex.Op)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op$ChildOp" name="org.apache.xerces.impl.xpath.regex.Op getChild()" map="F"/>
  <class name="org.apache.xerces.impl.xpath.regex.Op$ModifierOp" map="_D"/>
  <field class="org.apache.xerces.impl.xpath.regex.Op$ModifierOp" name="v2" map="F"/>
  <field class="org.apache.xerces.impl.xpath.regex.Op$ModifierOp" name="v1" map="G"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op$ModifierOp" name="int getData2()" map="E"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op$ModifierOp" name="int getData()" map="C"/>
  <class name="org.apache.xerces.impl.xpath.regex.Op$StringOp" map="_E"/>
  <field class="org.apache.xerces.impl.xpath.regex.Op$StringOp" name="string" map="H"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op$StringOp" name="java.lang.String getString()" map="H"/>
  <class name="org.apache.xerces.impl.xpath.regex.Op$RangeOp" map="_F"/>
  <field class="org.apache.xerces.impl.xpath.regex.Op$RangeOp" name="tok" map="I"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op$RangeOp" name="org.apache.xerces.impl.xpath.regex.RangeToken getToken()" map="A"/>
  <class name="org.apache.xerces.impl.xpath.regex.Op$CharOp" map="_G"/>
  <field class="org.apache.xerces.impl.xpath.regex.Op$CharOp" name="charData" map="J"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op$CharOp" name="int getData()" map="C"/>
  <class name="org.apache.xerces.impl.xpath.regex.Op" map="I"/>
  <field class="org.apache.xerces.impl.xpath.regex.Op" name="nofinstances" map="A"/>
  <field class="org.apache.xerces.impl.xpath.regex.Op" name="next" map="B"/>
  <field class="org.apache.xerces.impl.xpath.regex.Op" name="type" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.RangeToken getToken()" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op$ChildOp createNonGreedyClosure()" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="int getData()" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op$ChildOp createClosure(int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op$ChildOp createLook(int, org.apache.xerces.impl.xpath.regex.Op, org.apache.xerces.impl.xpath.regex.Op)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op$ConditionOp createCondition(org.apache.xerces.impl.xpath.regex.Op, int, org.apache.xerces.impl.xpath.regex.Op, org.apache.xerces.impl.xpath.regex.Op, org.apache.xerces.impl.xpath.regex.Op)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op createDot()" map="D"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="int getData2()" map="E"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op$RangeOp createRange(org.apache.xerces.impl.xpath.regex.Token)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op$CharOp createAnchor(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op$UnionOp createUnion(int)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op$StringOp createString(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op elementAt(int)" map="D"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op$ChildOp createQuestion(boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op$CharOp createChar(int)" map="E"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op$ChildOp createIndependent(org.apache.xerces.impl.xpath.regex.Op, org.apache.xerces.impl.xpath.regex.Op)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op getChild()" map="F"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="int size()" map="G"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op$ModifierOp createModifier(org.apache.xerces.impl.xpath.regex.Op, org.apache.xerces.impl.xpath.regex.Op, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op$CharOp createCapture(int, org.apache.xerces.impl.xpath.regex.Op)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="java.lang.String getString()" map="H"/>
  <method class="org.apache.xerces.impl.xpath.regex.Op" name="org.apache.xerces.impl.xpath.regex.Op$CharOp createBackReference(int)" map="F"/>
  <class name="org.apache.xerces.impl.xpath.regex.RegexParser$ReferencePosition" map="_A"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegexParser$ReferencePosition" name="position" map="A"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegexParser$ReferencePosition" name="refNumber" map="B"/>
  <class name="org.apache.xerces.impl.xpath.regex.RegexParser" map="J"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegexParser" name="context" map="A"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegexParser" name="hasBackReferences" map="B"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegexParser" name="resources" map="C"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegexParser" name="regexlen" map="D"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegexParser" name="offset" map="E"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegexParser" name="nexttoken" map="F"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegexParser" name="parennumber" map="G"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegexParser" name="regex" map="H"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegexParser" name="parenOpened" map="I"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegexParser" name="references" map="J"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegexParser" name="chardata" map="K"/>
  <field class="org.apache.xerces.impl.xpath.regex.RegexParser" name="options" map="L"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processCondition()" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processStar(org.apache.xerces.impl.xpath.regex.Token)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.RangeToken processBacksolidus_pP(int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_gt()" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="int read()" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.RangeToken parseSetOperations()" map="D"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_X()" map="E"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_I()" map="F"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token parseFactor()" map="G"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_g()" map="H"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_C()" map="I"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processIndependent()" map="J"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="void next()" map="K"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token parse(java.lang.String, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.RangeToken parseCharacterClass(boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processNegativelookahead()" map="L"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processDollar()" map="M"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="void addCaseInsensitiveChar(org.apache.xerces.impl.xpath.regex.RangeToken, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processModifiers()" map="N"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token parseAtom()" map="O"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="void setContext(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_z()" map="P"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_b()" map="Q"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_A()" map="R"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processQuestion(org.apache.xerces.impl.xpath.regex.Token)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processParen2()" map="S"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processLookahead()" map="T"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token parseTerm()" map="U"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processCaret()" map="V"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="int decodeEscaped()" map="W"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="int processCIinCharacterClass(org.apache.xerces.impl.xpath.regex.RangeToken, int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processParen()" map="X"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processLookbehind()" map="Y"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="int hexChar(int)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processBackreference()" map="Z"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_lt()" map="_"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processNegativelookbehind()" map="a"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.ParseException ex(java.lang.String, int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token parseRegex()" map="b"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="boolean checkQuestion(int)" map="D"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_i()" map="c"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processPlus(org.apache.xerces.impl.xpath.regex.Token)" map="C"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_Z()" map="d"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_c()" map="e"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token processBacksolidus_B()" map="f"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="void addCaseInsensitiveCharRange(org.apache.xerces.impl.xpath.regex.RangeToken, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="void setLocale(java.util.Locale)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="boolean isSet(int)" map="E"/>
  <method class="org.apache.xerces.impl.xpath.regex.RegexParser" name="org.apache.xerces.impl.xpath.regex.Token getTokenForShorthand(int)" map="F"/>
  <class name="org.apache.xerces.impl.xpath.regex.RangeToken" map="K"/>
  <field class="org.apache.xerces.impl.xpath.regex.RangeToken" name="compacted" map="p"/>
  <field class="org.apache.xerces.impl.xpath.regex.RangeToken" name="ranges" map="q"/>
  <field class="org.apache.xerces.impl.xpath.regex.RangeToken" name="sorted" map="r"/>
  <field class="org.apache.xerces.impl.xpath.regex.RangeToken" name="icaseCache" map="s"/>
  <field class="org.apache.xerces.impl.xpath.regex.RangeToken" name="map" map="t"/>
  <field class="org.apache.xerces.impl.xpath.regex.RangeToken" name="nonMapIndex" map="u"/>
  <method class="org.apache.xerces.impl.xpath.regex.RangeToken" name="void setSorted(boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RangeToken" name="java.lang.String toString(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.RangeToken" name="void sortRanges()" map="R"/>
  <method class="org.apache.xerces.impl.xpath.regex.RangeToken" name="void mergeRanges(org.apache.xerces.impl.xpath.regex.Token)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.regex.RangeToken" name="boolean match(int)" map="H"/>
  <method class="org.apache.xerces.impl.xpath.regex.RangeToken" name="void subtractRanges(org.apache.xerces.impl.xpath.regex.Token)" map="G"/>
  <method class="org.apache.xerces.impl.xpath.regex.RangeToken" name="void addRange(int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.regex.RangeToken" name="void compactRanges()" map="S"/>
  <method class="org.apache.xerces.impl.xpath.regex.RangeToken" name="void setCompacted()" map="T"/>
  <method class="org.apache.xerces.impl.xpath.regex.RangeToken" name="void intersectRanges(org.apache.xerces.impl.xpath.regex.Token)" map="H"/>
  <method class="org.apache.xerces.impl.xpath.regex.RangeToken" name="boolean isCompacted()" map="U"/>
  <method class="org.apache.xerces.impl.xpath.regex.RangeToken" name="java.lang.String escapeCharInCharClass(int)" map="I"/>
  <method class="org.apache.xerces.impl.xpath.regex.RangeToken" name="org.apache.xerces.impl.xpath.regex.Token complementRanges(org.apache.xerces.impl.xpath.regex.Token)" map="F"/>
  <method class="org.apache.xerces.impl.xpath.regex.RangeToken" name="void createMap()" map="V"/>
  <method class="org.apache.xerces.impl.xpath.regex.RangeToken" name="boolean isSorted()" map="W"/>
  <class name="org.apache.xerces.impl.xpath.XPath$LocationPath" map="_A"/>
  <field class="org.apache.xerces.impl.xpath.XPath$LocationPath" name="steps" map="A"/>
  <method class="org.apache.xerces.impl.xpath.XPath$LocationPath" name="java.lang.Object clone()" map="clone"/>
  <method class="org.apache.xerces.impl.xpath.XPath$LocationPath" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.xpath.XPath$Axis" map="_B"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Axis" name="type" map="A"/>
  <method class="org.apache.xerces.impl.xpath.XPath$Axis" name="java.lang.Object clone()" map="clone"/>
  <method class="org.apache.xerces.impl.xpath.XPath$Axis" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.xpath.XPath$Scanner" map="_C"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fParentSymbol" map="A"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fDescendantOrSelfSymbol" map="B"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fASCIICharMap" map="C"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fFollowingSymbol" map="D"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fAncestorOrSelfSymbol" map="E"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fAncestorSymbol" map="F"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fDescendantSymbol" map="G"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fPrecedingSymbol" map="H"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fPrecedingSiblingSymbol" map="I"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fPISymbol" map="J"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fAndSymbol" map="K"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fSelfSymbol" map="L"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fTextSymbol" map="M"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fNamespaceSymbol" map="N"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fFollowingSiblingSymbol" map="O"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fSymbolTable" map="P"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fOrSymbol" map="Q"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fCommentSymbol" map="R"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fModSymbol" map="S"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fDivSymbol" map="T"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fAttributeSymbol" map="U"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fChildSymbol" map="V"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Scanner" name="fNodeSymbol" map="W"/>
  <method class="org.apache.xerces.impl.xpath.XPath$Scanner" name="void addToken(org.apache.xerces.impl.xpath.XPath$Tokens, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.XPath$Scanner" name="int scanNumber(org.apache.xerces.impl.xpath.XPath$Tokens, java.lang.String, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.XPath$Scanner" name="boolean scanExpr(org.apache.xerces.util.SymbolTable, org.apache.xerces.impl.xpath.XPath$Tokens, java.lang.String, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.XPath$Scanner" name="int scanNCName(java.lang.String, int, int)" map="A"/>
  <class name="org.apache.xerces.impl.xpath.XPath$Step" map="_D"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Step" name="axis" map="A"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Step" name="nodeTest" map="B"/>
  <method class="org.apache.xerces.impl.xpath.XPath$Step" name="java.lang.Object clone()" map="clone"/>
  <method class="org.apache.xerces.impl.xpath.XPath$Step" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.xpath.XPath$1" map="1"/>
  <field class="org.apache.xerces.impl.xpath.XPath$1" name="this$0" map="this$0"/>
  <method class="org.apache.xerces.impl.xpath.XPath$1" name="void addToken(org.apache.xerces.impl.xpath.XPath$Tokens, int)" map="A"/>
  <class name="org.apache.xerces.impl.xpath.XPath$NodeTest" map="_E"/>
  <field class="org.apache.xerces.impl.xpath.XPath$NodeTest" name="name" map="A"/>
  <field class="org.apache.xerces.impl.xpath.XPath$NodeTest" name="type" map="B"/>
  <method class="org.apache.xerces.impl.xpath.XPath$NodeTest" name="java.lang.Object clone()" map="clone"/>
  <method class="org.apache.xerces.impl.xpath.XPath$NodeTest" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.xpath.XPath$Tokens" map="_F"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Tokens" name="fCurrentTokenIndex" map="A"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Tokens" name="fSymbolTable" map="B"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Tokens" name="fgTokenNames" map="C"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Tokens" name="fSymbolMapping" map="D"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Tokens" name="fTokenCount" map="E"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Tokens" name="fTokens" map="F"/>
  <field class="org.apache.xerces.impl.xpath.XPath$Tokens" name="fTokenNames" map="G"/>
  <method class="org.apache.xerces.impl.xpath.XPath$Tokens" name="void addToken(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.XPath$Tokens" name="java.lang.String getTokenString(int)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.XPath$Tokens" name="void addToken(int)" map="B"/>
  <method class="org.apache.xerces.impl.xpath.XPath$Tokens" name="int peekToken()" map="A"/>
  <method class="org.apache.xerces.impl.xpath.XPath$Tokens" name="java.lang.String nextTokenAsString()" map="B"/>
  <method class="org.apache.xerces.impl.xpath.XPath$Tokens" name="int nextToken()" map="C"/>
  <method class="org.apache.xerces.impl.xpath.XPath$Tokens" name="boolean hasMore()" map="D"/>
  <class name="org.apache.xerces.impl.xpath.XPath" map="A"/>
  <field class="org.apache.xerces.impl.xpath.XPath" name="fLocationPaths" map="A"/>
  <field class="org.apache.xerces.impl.xpath.XPath" name="fSymbolTable" map="B"/>
  <field class="org.apache.xerces.impl.xpath.XPath" name="fExpression" map="C"/>
  <method class="org.apache.xerces.impl.xpath.XPath" name="org.apache.xerces.impl.xpath.XPath$LocationPath buildLocationPath(java.util.Vector)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.XPath" name="org.apache.xerces.impl.xpath.XPath$NodeTest parseNodeTest(int, org.apache.xerces.impl.xpath.XPath$Tokens, org.apache.xerces.xni.NamespaceContext)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.XPath" name="org.apache.xerces.impl.xpath.XPath$LocationPath[] getLocationPaths()" map="A"/>
  <method class="org.apache.xerces.impl.xpath.XPath" name="void check(boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xpath.XPath" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.xpath.XPath" name="org.apache.xerces.impl.xpath.XPath$LocationPath[] parseExpression(org.apache.xerces.xni.NamespaceContext)" map="A"/>
  <class name="org.apache.xerces.impl.xpath.XPathException" map="B"/>
  <field class="org.apache.xerces.impl.xpath.XPathException" name="fKey" map="A"/>
  <method class="org.apache.xerces.impl.xpath.XPathException" name="java.lang.String getKey()" map="A"/>
  <package name="org.apache.xerces.impl.validation" map="B"/>
  <class name="org.apache.xerces.impl.validation.ValidationManager" map="A"/>
  <field class="org.apache.xerces.impl.validation.ValidationManager" name="fGrammarFound" map="A"/>
  <field class="org.apache.xerces.impl.validation.ValidationManager" name="fCachedDTD" map="B"/>
  <field class="org.apache.xerces.impl.validation.ValidationManager" name="fVSs" map="C"/>
  <method class="org.apache.xerces.impl.validation.ValidationManager" name="void reset()" map="A"/>
  <method class="org.apache.xerces.impl.validation.ValidationManager" name="boolean isGrammarFound()" map="B"/>
  <method class="org.apache.xerces.impl.validation.ValidationManager" name="boolean isCachedDTD()" map="C"/>
  <method class="org.apache.xerces.impl.validation.ValidationManager" name="void setEntityState(org.apache.xerces.impl.validation.EntityState)" map="A"/>
  <method class="org.apache.xerces.impl.validation.ValidationManager" name="void addValidationState(org.apache.xerces.impl.validation.ValidationState)" map="A"/>
  <method class="org.apache.xerces.impl.validation.ValidationManager" name="void setGrammarFound(boolean)" map="A"/>
  <method class="org.apache.xerces.impl.validation.ValidationManager" name="void setCachedDTD(boolean)" map="B"/>
  <class name="org.apache.xerces.impl.validation.EntityState" map="B"/>
  <method class="org.apache.xerces.impl.validation.EntityState" name="boolean isEntityUnparsed(java.lang.String)" map="R"/>
  <class name="org.apache.xerces.impl.validation.ValidationState" map="C"/>
  <field class="org.apache.xerces.impl.validation.ValidationState" name="fNullValue" map="C"/>
  <field class="org.apache.xerces.impl.validation.ValidationState" name="fNamespaces" map="D"/>
  <field class="org.apache.xerces.impl.validation.ValidationState" name="fFacetChecking" map="E"/>
  <field class="org.apache.xerces.impl.validation.ValidationState" name="fNormalize" map="F"/>
  <field class="org.apache.xerces.impl.validation.ValidationState" name="fLocale" map="G"/>
  <field class="org.apache.xerces.impl.validation.ValidationState" name="fNamespaceContext" map="H"/>
  <field class="org.apache.xerces.impl.validation.ValidationState" name="fIdRefTable" map="I"/>
  <field class="org.apache.xerces.impl.validation.ValidationState" name="fEntityState" map="J"/>
  <field class="org.apache.xerces.impl.validation.ValidationState" name="fIdTable" map="K"/>
  <field class="org.apache.xerces.impl.validation.ValidationState" name="fExtraChecking" map="L"/>
  <field class="org.apache.xerces.impl.validation.ValidationState" name="fSymbolTable" map="M"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="void setUsingNamespaces(boolean)" map="A"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="void setNormalizationRequired(boolean)" map="B"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="void setNamespaceSupport(org.apache.xerces.xni.NamespaceContext)" map="B"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="void setFacetChecking(boolean)" map="C"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="boolean useNamespaces()" map="C"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="java.util.Locale getLocale()" map="B"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="boolean needToNormalize()" map="E"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="void setExtraChecking(boolean)" map="D"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="boolean needExtraChecking()" map="A"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="java.lang.String getSymbol(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="java.lang.String checkIDRefID()" map="F"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="void addIdRef(java.lang.String)" map="E"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="void addId(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="boolean needFacetChecking()" map="D"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="void setSymbolTable(org.apache.xerces.util.SymbolTable)" map="A"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="boolean isIdDeclared(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="java.lang.String getURI(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="void setLocale(java.util.Locale)" map="A"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="boolean isEntityUnparsed(java.lang.String)" map="F"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="void setEntityState(org.apache.xerces.impl.validation.EntityState)" map="A"/>
  <method class="org.apache.xerces.impl.validation.ValidationState" name="void resetIDTables()" map="G"/>
  <class name="org.apache.xerces.impl.validation.ConfigurableValidationState" map="D"/>
  <field class="org.apache.xerces.impl.validation.ConfigurableValidationState" name="fIdIdrefChecking" map="N"/>
  <field class="org.apache.xerces.impl.validation.ConfigurableValidationState" name="fUnparsedEntityChecking" map="O"/>
  <method class="org.apache.xerces.impl.validation.ConfigurableValidationState" name="void addIdRef(java.lang.String)" map="E"/>
  <method class="org.apache.xerces.impl.validation.ConfigurableValidationState" name="void addId(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.impl.validation.ConfigurableValidationState" name="boolean isIdDeclared(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.validation.ConfigurableValidationState" name="void setUnparsedEntityChecking(boolean)" map="E"/>
  <method class="org.apache.xerces.impl.validation.ConfigurableValidationState" name="boolean isEntityUnparsed(java.lang.String)" map="F"/>
  <method class="org.apache.xerces.impl.validation.ConfigurableValidationState" name="java.lang.String checkIDRefID()" map="F"/>
  <method class="org.apache.xerces.impl.validation.ConfigurableValidationState" name="void setIdIdrefChecking(boolean)" map="F"/>
  <package name="org.apache.xerces.impl.xs" map="C"/>
  <package name="org.apache.xerces.impl.xs.util" map="A"/>
  <class name="org.apache.xerces.impl.xs.util.ObjectListImpl" map="A"/>
  <field class="org.apache.xerces.impl.xs.util.ObjectListImpl" name="EMPTY_LIST" map="A"/>
  <field class="org.apache.xerces.impl.xs.util.ObjectListImpl" name="fArray" map="B"/>
  <field class="org.apache.xerces.impl.xs.util.ObjectListImpl" name="fLength" map="C"/>
  <method class="org.apache.xerces.impl.xs.util.ObjectListImpl" name="java.lang.Object[] toArray(java.lang.Object[])" map="toArray"/>
  <method class="org.apache.xerces.impl.xs.util.ObjectListImpl" name="int size()" map="size"/>
  <method class="org.apache.xerces.impl.xs.util.ObjectListImpl" name="java.lang.Object[] toArray()" map="toArray"/>
  <method class="org.apache.xerces.impl.xs.util.ObjectListImpl" name="java.lang.Object item(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.ObjectListImpl" name="void toArray0(java.lang.Object[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.ObjectListImpl" name="int getLength()" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.ObjectListImpl" name="java.lang.Object get(int)" map="get"/>
  <method class="org.apache.xerces.impl.xs.util.ObjectListImpl" name="boolean contains(java.lang.Object)" map="contains"/>
  <class name="org.apache.xerces.impl.xs.util.XSNamedMapImpl$XSNamedMapEntry" map="_A"/>
  <field class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$XSNamedMapEntry" name="key" map="A"/>
  <field class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$XSNamedMapEntry" name="value" map="B"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$XSNamedMapEntry" name="java.lang.Object getKey()" map="getKey"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$XSNamedMapEntry" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$XSNamedMapEntry" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$XSNamedMapEntry" name="java.lang.Object setValue(java.lang.Object)" map="setValue"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$XSNamedMapEntry" name="java.lang.Object getValue()" map="getValue"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$XSNamedMapEntry" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.xs.util.XSNamedMapImpl$2" map="2"/>
  <field class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$2" name="index" map="A"/>
  <field class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$2" name="this$1" map="this$1"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$2" name="boolean hasNext()" map="hasNext"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$2" name="void remove()" map="remove"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$2" name="java.lang.Object next()" map="next"/>
  <class name="org.apache.xerces.impl.xs.util.XSNamedMapImpl$1" map="1"/>
  <field class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$1" name="this$0" map="this$0"/>
  <field class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$1" name="val$entries" map="val$entries"/>
  <field class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$1" name="val$length" map="val$length"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$1" name="int access$000(org.apache.xerces.impl.xs.util.XSNamedMapImpl$1)" map="access$000"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$1" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$1" name="int size()" map="size"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl$1" name="org.apache.xerces.impl.xs.util.XSNamedMapImpl$XSNamedMapEntry[] access$100(org.apache.xerces.impl.xs.util.XSNamedMapImpl$1)" map="access$100"/>
  <class name="org.apache.xerces.impl.xs.util.XSNamedMapImpl" map="B"/>
  <field class="org.apache.xerces.impl.xs.util.XSNamedMapImpl" name="fEntrySet" map="A"/>
  <field class="org.apache.xerces.impl.xs.util.XSNamedMapImpl" name="fNamespaces" map="B"/>
  <field class="org.apache.xerces.impl.xs.util.XSNamedMapImpl" name="fMaps" map="C"/>
  <field class="org.apache.xerces.impl.xs.util.XSNamedMapImpl" name="EMPTY_MAP" map="D"/>
  <field class="org.apache.xerces.impl.xs.util.XSNamedMapImpl" name="fArray" map="E"/>
  <field class="org.apache.xerces.impl.xs.util.XSNamedMapImpl" name="fLength" map="F"/>
  <field class="org.apache.xerces.impl.xs.util.XSNamedMapImpl" name="fNSNum" map="G"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl" name="boolean containsKey(java.lang.Object)" map="containsKey"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl" name="org.apache.xerces.xs.XSObject itemByName(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl" name="int size()" map="size"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl" name="java.util.Set entrySet()" map="entrySet"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl" name="org.apache.xerces.xs.XSObject item(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl" name="boolean isEqual(java.lang.String, java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl" name="int getLength()" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMapImpl" name="java.lang.Object get(java.lang.Object)" map="get"/>
  <class name="org.apache.xerces.impl.xs.util.XSInputSource" map="C"/>
  <method class="org.apache.xerces.impl.xs.util.XSInputSource" name="org.apache.xerces.xs.XSObject[] getComponents()" map="O"/>
  <method class="org.apache.xerces.impl.xs.util.XSInputSource" name="org.apache.xerces.impl.xs.SchemaGrammar[] getGrammars()" map="P"/>
  <class name="org.apache.xerces.impl.xs.util.ShortListImpl" map="D"/>
  <field class="org.apache.xerces.impl.xs.util.ShortListImpl" name="EMPTY_LIST" map="A"/>
  <field class="org.apache.xerces.impl.xs.util.ShortListImpl" name="fArray" map="B"/>
  <field class="org.apache.xerces.impl.xs.util.ShortListImpl" name="fLength" map="C"/>
  <method class="org.apache.xerces.impl.xs.util.ShortListImpl" name="short item(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.ShortListImpl" name="int size()" map="size"/>
  <method class="org.apache.xerces.impl.xs.util.ShortListImpl" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.xs.util.ShortListImpl" name="int getLength()" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.ShortListImpl" name="java.lang.Object get(int)" map="get"/>
  <class name="org.apache.xerces.impl.xs.util.XIntPool" map="E"/>
  <field class="org.apache.xerces.impl.xs.util.XIntPool" name="fXIntPool" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.XIntPool" name="org.apache.xerces.impl.xs.util.XInt getXInt(int)" map="A"/>
  <class name="org.apache.xerces.impl.xs.util.XInt" map="F"/>
  <field class="org.apache.xerces.impl.xs.util.XInt" name="fValue" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.XInt" name="int intValue()" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.XInt" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.xs.util.XInt" name="short shortValue()" map="B"/>
  <class name="org.apache.xerces.impl.xs.util.SimpleLocator" map="G"/>
  <field class="org.apache.xerces.impl.xs.util.SimpleLocator" name="line" map="E"/>
  <field class="org.apache.xerces.impl.xs.util.SimpleLocator" name="column" map="F"/>
  <field class="org.apache.xerces.impl.xs.util.SimpleLocator" name="charOffset" map="G"/>
  <field class="org.apache.xerces.impl.xs.util.SimpleLocator" name="esid" map="H"/>
  <field class="org.apache.xerces.impl.xs.util.SimpleLocator" name="lsid" map="I"/>
  <method class="org.apache.xerces.impl.xs.util.SimpleLocator" name="java.lang.String getPublicId()" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.SimpleLocator" name="int getCharacterOffset()" map="B"/>
  <method class="org.apache.xerces.impl.xs.util.SimpleLocator" name="int getColumnNumber()" map="C"/>
  <method class="org.apache.xerces.impl.xs.util.SimpleLocator" name="int getLineNumber()" map="D"/>
  <method class="org.apache.xerces.impl.xs.util.SimpleLocator" name="void setValues(java.lang.String, java.lang.String, int, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.SimpleLocator" name="java.lang.String getExpandedSystemId()" map="E"/>
  <method class="org.apache.xerces.impl.xs.util.SimpleLocator" name="java.lang.String getLiteralSystemId()" map="F"/>
  <method class="org.apache.xerces.impl.xs.util.SimpleLocator" name="java.lang.String getBaseSystemId()" map="G"/>
  <class name="org.apache.xerces.impl.xs.util.XSObjectListImpl$XSObjectListIterator" map="_A"/>
  <field class="org.apache.xerces.impl.xs.util.XSObjectListImpl$XSObjectListIterator" name="this$0" map="this$0"/>
  <field class="org.apache.xerces.impl.xs.util.XSObjectListImpl$XSObjectListIterator" name="index" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$XSObjectListIterator" name="boolean hasNext()" map="hasNext"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$XSObjectListIterator" name="void remove()" map="remove"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$XSObjectListIterator" name="boolean hasPrevious()" map="hasPrevious"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$XSObjectListIterator" name="int previousIndex()" map="previousIndex"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$XSObjectListIterator" name="void set(java.lang.Object)" map="set"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$XSObjectListIterator" name="void add(java.lang.Object)" map="add"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$XSObjectListIterator" name="java.lang.Object next()" map="next"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$XSObjectListIterator" name="int nextIndex()" map="nextIndex"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$XSObjectListIterator" name="java.lang.Object previous()" map="previous"/>
  <class name="org.apache.xerces.impl.xs.util.XSObjectListImpl$1" map="1"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$1" name="boolean hasNext()" map="hasNext"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$1" name="void remove()" map="remove"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$1" name="boolean hasPrevious()" map="hasPrevious"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$1" name="int previousIndex()" map="previousIndex"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$1" name="void set(java.lang.Object)" map="set"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$1" name="void add(java.lang.Object)" map="add"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$1" name="java.lang.Object next()" map="next"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$1" name="int nextIndex()" map="nextIndex"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl$1" name="java.lang.Object previous()" map="previous"/>
  <class name="org.apache.xerces.impl.xs.util.XSObjectListImpl" map="H"/>
  <field class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="EMPTY_LIST" map="A"/>
  <field class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="fArray" map="B"/>
  <field class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="EMPTY_ITERATOR" map="C"/>
  <field class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="fLength" map="D"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="boolean containsNull()" map="B"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="java.lang.Object[] toArray()" map="toArray"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="java.util.ListIterator listIterator(int)" map="listIterator"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="void addXSObject(org.apache.xerces.xs.XSObject)" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="int getLength()" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="void addXSObject(int, org.apache.xerces.xs.XSObject)" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="boolean containsObject(java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="java.util.ListIterator listIterator()" map="listIterator"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="org.apache.xerces.xs.XSObject[] access$100(org.apache.xerces.impl.xs.util.XSObjectListImpl)" map="access$100"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="java.lang.Object[] toArray(java.lang.Object[])" map="toArray"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="java.lang.Object get(int)" map="get"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="boolean contains(java.lang.Object)" map="contains"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="int size()" map="size"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="java.util.ListIterator listIterator0(int)" map="B"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="int access$000(org.apache.xerces.impl.xs.util.XSObjectListImpl)" map="access$000"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="void toArray0(java.lang.Object[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.XSObjectListImpl" name="org.apache.xerces.xs.XSObject item(int)" map="A"/>
  <class name="org.apache.xerces.impl.xs.util.XSNamedMap4Types" map="I"/>
  <field class="org.apache.xerces.impl.xs.util.XSNamedMap4Types" name="fType" map="H"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMap4Types" name="org.apache.xerces.xs.XSObject itemByName(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMap4Types" name="org.apache.xerces.xs.XSObject item(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.XSNamedMap4Types" name="int getLength()" map="A"/>
  <class name="org.apache.xerces.impl.xs.util.StringListImpl" map="J"/>
  <field class="org.apache.xerces.impl.xs.util.StringListImpl" name="EMPTY_LIST" map="A"/>
  <field class="org.apache.xerces.impl.xs.util.StringListImpl" name="fVector" map="B"/>
  <field class="org.apache.xerces.impl.xs.util.StringListImpl" name="fArray" map="C"/>
  <field class="org.apache.xerces.impl.xs.util.StringListImpl" name="fLength" map="D"/>
  <method class="org.apache.xerces.impl.xs.util.StringListImpl" name="java.lang.Object[] toArray(java.lang.Object[])" map="toArray"/>
  <method class="org.apache.xerces.impl.xs.util.StringListImpl" name="int size()" map="size"/>
  <method class="org.apache.xerces.impl.xs.util.StringListImpl" name="boolean contains(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.StringListImpl" name="java.lang.Object[] toArray()" map="toArray"/>
  <method class="org.apache.xerces.impl.xs.util.StringListImpl" name="void toArray0(java.lang.Object[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.StringListImpl" name="int getLength()" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.StringListImpl" name="java.lang.String item(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.util.StringListImpl" name="java.lang.Object get(int)" map="get"/>
  <package name="org.apache.xerces.impl.xs.identity" map="B"/>
  <class name="org.apache.xerces.impl.xs.identity.XPathMatcher" map="A"/>
  <field class="org.apache.xerces.impl.xs.identity.XPathMatcher" name="fQName" map="A"/>
  <field class="org.apache.xerces.impl.xs.identity.XPathMatcher" name="fLocationPaths" map="B"/>
  <field class="org.apache.xerces.impl.xs.identity.XPathMatcher" name="fMatched" map="C"/>
  <field class="org.apache.xerces.impl.xs.identity.XPathMatcher" name="fNoMatchDepth" map="D"/>
  <field class="org.apache.xerces.impl.xs.identity.XPathMatcher" name="fMatchedString" map="E"/>
  <field class="org.apache.xerces.impl.xs.identity.XPathMatcher" name="fCurrentStep" map="F"/>
  <field class="org.apache.xerces.impl.xs.identity.XPathMatcher" name="fStepIndexes" map="G"/>
  <method class="org.apache.xerces.impl.xs.identity.XPathMatcher" name="void startElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.XPathMatcher" name="void handleContent(org.apache.xerces.xs.XSTypeDefinition, boolean, java.lang.Object, short, org.apache.xerces.xs.ShortList)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.XPathMatcher" name="void startDocumentFragment()" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.XPathMatcher" name="void endElement(org.apache.xerces.xni.QName, org.apache.xerces.xs.XSTypeDefinition, boolean, java.lang.Object, short, org.apache.xerces.xs.ShortList)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.XPathMatcher" name="boolean isMatched()" map="B"/>
  <method class="org.apache.xerces.impl.xs.identity.XPathMatcher" name="boolean matches(org.apache.xerces.impl.xpath.XPath$NodeTest, org.apache.xerces.xni.QName)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.XPathMatcher" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.xs.identity.XPathMatcher" name="void matched(java.lang.Object, short, org.apache.xerces.xs.ShortList, boolean)" map="A"/>
  <class name="org.apache.xerces.impl.xs.identity.Selector$XPath" map="_A"/>
  <method class="org.apache.xerces.impl.xs.identity.Selector$XPath" name="java.lang.String normalize(java.lang.String)" map="A"/>
  <class name="org.apache.xerces.impl.xs.identity.Selector$Matcher" map="_B"/>
  <field class="org.apache.xerces.impl.xs.identity.Selector$Matcher" name="this$0" map="this$0"/>
  <field class="org.apache.xerces.impl.xs.identity.Selector$Matcher" name="fFieldActivator" map="H"/>
  <field class="org.apache.xerces.impl.xs.identity.Selector$Matcher" name="fElementDepth" map="I"/>
  <field class="org.apache.xerces.impl.xs.identity.Selector$Matcher" name="fInitialDepth" map="J"/>
  <field class="org.apache.xerces.impl.xs.identity.Selector$Matcher" name="fMatchedDepth" map="K"/>
  <method class="org.apache.xerces.impl.xs.identity.Selector$Matcher" name="void startElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.Selector$Matcher" name="void startDocumentFragment()" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.Selector$Matcher" name="void endElement(org.apache.xerces.xni.QName, org.apache.xerces.xs.XSTypeDefinition, boolean, java.lang.Object, short, org.apache.xerces.xs.ShortList)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.Selector$Matcher" name="org.apache.xerces.impl.xs.identity.IdentityConstraint getIdentityConstraint()" map="C"/>
  <method class="org.apache.xerces.impl.xs.identity.Selector$Matcher" name="int getInitialDepth()" map="D"/>
  <class name="org.apache.xerces.impl.xs.identity.Selector" map="B"/>
  <field class="org.apache.xerces.impl.xs.identity.Selector" name="fXPath" map="A"/>
  <field class="org.apache.xerces.impl.xs.identity.Selector" name="fIdentityConstraint" map="B"/>
  <method class="org.apache.xerces.impl.xs.identity.Selector" name="org.apache.xerces.impl.xs.identity.XPathMatcher createMatcher(org.apache.xerces.impl.xs.identity.FieldActivator, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.Selector" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.xs.identity.Field$XPath" map="_A"/>
  <method class="org.apache.xerces.impl.xs.identity.Field$XPath" name="java.lang.String fixupXPath(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.xs.identity.Field$XPath" name="java.lang.String fixupXPath2(java.lang.String, int, int)" map="A"/>
  <class name="org.apache.xerces.impl.xs.identity.Field$Matcher" map="_B"/>
  <field class="org.apache.xerces.impl.xs.identity.Field$Matcher" name="this$0" map="this$0"/>
  <field class="org.apache.xerces.impl.xs.identity.Field$Matcher" name="fMayMatch" map="L"/>
  <field class="org.apache.xerces.impl.xs.identity.Field$Matcher" name="fStore" map="M"/>
  <method class="org.apache.xerces.impl.xs.identity.Field$Matcher" name="void handleContent(org.apache.xerces.xs.XSTypeDefinition, boolean, java.lang.Object, short, org.apache.xerces.xs.ShortList)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.Field$Matcher" name="org.apache.xerces.xs.ShortList convertToPrimitiveKind(org.apache.xerces.xs.ShortList)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.Field$Matcher" name="short convertToPrimitiveKind(short)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.Field$Matcher" name="void matched(java.lang.Object, short, org.apache.xerces.xs.ShortList, boolean)" map="A"/>
  <class name="org.apache.xerces.impl.xs.identity.Field" map="C"/>
  <field class="org.apache.xerces.impl.xs.identity.Field" name="fXPath" map="A"/>
  <field class="org.apache.xerces.impl.xs.identity.Field" name="fIdentityConstraint" map="B"/>
  <method class="org.apache.xerces.impl.xs.identity.Field" name="org.apache.xerces.impl.xs.identity.XPathMatcher createMatcher(org.apache.xerces.impl.xs.identity.ValueStore)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.Field" name="org.apache.xerces.impl.xs.identity.IdentityConstraint getIdentityConstraint()" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.Field" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.xs.identity.ValueStore" map="D"/>
  <method class="org.apache.xerces.impl.xs.identity.ValueStore" name="void reportError(java.lang.String, java.lang.Object[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.ValueStore" name="void addValue(org.apache.xerces.impl.xs.identity.Field, boolean, java.lang.Object, short, org.apache.xerces.xs.ShortList)" map="A"/>
  <class name="org.apache.xerces.impl.xs.identity.UniqueOrKey" map="E"/>
  <class name="org.apache.xerces.impl.xs.identity.IdentityConstraint" map="F"/>
  <field class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="fFields" map="S"/>
  <field class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="fSelector" map="T"/>
  <field class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="fAnnotations" map="U"/>
  <field class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="fNamespace" map="V"/>
  <field class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="fIdentityConstraintName" map="W"/>
  <field class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="fElementName" map="X"/>
  <field class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="type" map="Y"/>
  <field class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="fFieldCount" map="Z"/>
  <field class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="fNumAnnotations" map="_"/>
  <method class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="org.apache.xerces.impl.xs.identity.Selector getSelector()" map="P"/>
  <method class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="void addAnnotation(org.apache.xerces.impl.xs.XSAnnotationImpl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="short getCategory()" map="Q"/>
  <method class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="org.apache.xerces.impl.xs.identity.Field[] resize(org.apache.xerces.impl.xs.identity.Field[], int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="void addField(org.apache.xerces.impl.xs.identity.Field)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="java.lang.String getElementName()" map="R"/>
  <method class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="int getFieldCount()" map="S"/>
  <method class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="org.apache.xerces.impl.xs.identity.Field getFieldAt(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="java.lang.String getIdentityConstraintName()" map="T"/>
  <method class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="java.lang.String getNamespace()" map="D"/>
  <method class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="short getType()" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.xs.identity.IdentityConstraint" name="void setSelector(org.apache.xerces.impl.xs.identity.Selector)" map="A"/>
  <class name="org.apache.xerces.impl.xs.identity.FieldActivator" map="G"/>
  <method class="org.apache.xerces.impl.xs.identity.FieldActivator" name="void endValueScopeFor(org.apache.xerces.impl.xs.identity.IdentityConstraint, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.FieldActivator" name="org.apache.xerces.impl.xs.identity.XPathMatcher activateField(org.apache.xerces.impl.xs.identity.Field, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.identity.FieldActivator" name="void startValueScopeFor(org.apache.xerces.impl.xs.identity.IdentityConstraint, int)" map="B"/>
  <class name="org.apache.xerces.impl.xs.identity.KeyRef" map="H"/>
  <field class="org.apache.xerces.impl.xs.identity.KeyRef" name="fKey" map="a"/>
  <method class="org.apache.xerces.impl.xs.identity.KeyRef" name="org.apache.xerces.impl.xs.identity.UniqueOrKey getKey()" map="U"/>
  <package name="org.apache.xerces.impl.xs.opti" map="C"/>
  <class name="org.apache.xerces.impl.xs.opti.SchemaDOMParser$BooleanStack" map="_A"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOMParser$BooleanStack" name="fData" map="A"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOMParser$BooleanStack" name="fDepth" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser$BooleanStack" name="void clear()" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser$BooleanStack" name="int size()" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser$BooleanStack" name="void push(boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser$BooleanStack" name="void ensureCapacity(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser$BooleanStack" name="boolean pop()" map="C"/>
  <class name="org.apache.xerces.impl.xs.opti.SchemaDOMParser" map="A"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="fSawAnnotation" map="&#x0200;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="fErrorReporter" map="&#x0201;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="config" map="&#x0202;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="fNamespaceContext" map="&#x0203;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="schemaDOM" map="&#x0204;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="fDepth" map="&#x0205;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="fHasNonSchemaAttributes" map="&#x0206;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="fAnnotationDepth" map="&#x0207;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="fLocator" map="&#x0208;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="fGenerateSyntheticAnnotation" map="&#x0209;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="fEmptyAttr" map="&#x020a;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="fInnerAnnotationDepth" map="&#x020b;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="fCurrentAnnotationElement" map="&#x020c;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void endElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void setProperty(java.lang.String, java.lang.Object)" map="C"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void resetNodePool()" map="&#x00d4;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void setEntityResolver(org.apache.xerces.xni.parser.XMLEntityResolver)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void comment(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void characters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void startElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void parse(org.apache.xerces.xni.parser.XMLInputSource)" map="C"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="java.lang.Object getProperty(java.lang.String)" map="g"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="boolean hasNonSchemaAttributes(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void startCDATA(org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void emptyElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void ignorableWhitespace(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void processingInstruction(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void endDocument(org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void endCDATA(org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void setFeature(java.lang.String, boolean)" map="D"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="void startDocument(org.apache.xerces.xni.XMLLocator, java.lang.String, org.apache.xerces.xni.NamespaceContext, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOMParser" name="org.w3c.dom.Document getDocument()" map="&#x00d5;"/>
  <class name="org.apache.xerces.impl.xs.opti.NodeImpl" map="B"/>
  <field class="org.apache.xerces.impl.xs.opti.NodeImpl" name="nodeType" map="&#x00d4;"/>
  <field class="org.apache.xerces.impl.xs.opti.NodeImpl" name="localpart" map="&#x00d5;"/>
  <field class="org.apache.xerces.impl.xs.opti.NodeImpl" name="uri" map="&#x00d6;"/>
  <field class="org.apache.xerces.impl.xs.opti.NodeImpl" name="hidden" map="&#x00d8;"/>
  <field class="org.apache.xerces.impl.xs.opti.NodeImpl" name="prefix" map="&#x00d9;"/>
  <field class="org.apache.xerces.impl.xs.opti.NodeImpl" name="rawname" map="&#x00da;"/>
  <method class="org.apache.xerces.impl.xs.opti.NodeImpl" name="java.lang.String getLocalName()" map="&#x00c4;"/>
  <method class="org.apache.xerces.impl.xs.opti.NodeImpl" name="java.lang.String getNamespaceURI()" map="&#x00c1;"/>
  <method class="org.apache.xerces.impl.xs.opti.NodeImpl" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.impl.xs.opti.NodeImpl" name="short getNodeType()" map="&#x00c3;"/>
  <method class="org.apache.xerces.impl.xs.opti.NodeImpl" name="boolean getReadOnly()" map="&#x00ca;"/>
  <method class="org.apache.xerces.impl.xs.opti.NodeImpl" name="void setReadOnly(boolean, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.NodeImpl" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.xs.opti.NodeImpl" name="java.lang.String getPrefix()" map="&#x00a4;"/>
  <class name="org.apache.xerces.impl.xs.opti.DefaultText" map="C"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultText" name="java.lang.String getData()" map="&#x00cb;"/>
  <class name="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" map="D"/>
  <field class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="fDTDSource" map="&#x01fd;"/>
  <field class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="fDocumentSource" map="&#x01fe;"/>
  <field class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="fCMSource" map="&#x01ff;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void startElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void element(java.lang.String, org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void startContentModel(java.lang.String, org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void notationDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void unparsedEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void startCDATA(org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void startGeneralEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void processingInstruction(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void endConditional(org.apache.xerces.xni.Augmentations)" map="F"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void endElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void characters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void endExternalSubset(org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void xmlDecl(java.lang.String, java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void elementDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void endGeneralEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void ignorableWhitespace(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void empty(org.apache.xerces.xni.Augmentations)" map="K"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void startParameterEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void endGroup(org.apache.xerces.xni.Augmentations)" map="H"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void doctypeDecl(java.lang.String, java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void comment(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void startAttlist(java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void startExternalSubset(org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void occurrence(short, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void endContentModel(org.apache.xerces.xni.Augmentations)" map="M"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void startDocument(org.apache.xerces.xni.XMLLocator, java.lang.String, org.apache.xerces.xni.NamespaceContext, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void endDocument(org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void endParameterEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void externalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void startDTD(org.apache.xerces.xni.XMLLocator, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void startConditional(short, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void any(org.apache.xerces.xni.Augmentations)" map="L"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void startGroup(org.apache.xerces.xni.Augmentations)" map="I"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void ignoredCharacters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void separator(short, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void internalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void attributeDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String[], java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void emptyElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void pcdata(org.apache.xerces.xni.Augmentations)" map="J"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void endAttlist(org.apache.xerces.xni.Augmentations)" map="G"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void setDTDContentModelSource(org.apache.xerces.xni.parser.XMLDTDContentModelSource)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void endCDATA(org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void endDTD(org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultXMLDocumentHandler" name="void textDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <class name="org.apache.xerces.impl.xs.opti.DefaultDocument" map="E"/>
  <field class="org.apache.xerces.impl.xs.opti.DefaultDocument" name="fDocumentURI" map="&#x00e5;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultDocument" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultDocument" name="org.w3c.dom.NodeList getElementsByTagNameNS(java.lang.String, java.lang.String)" map="G"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultDocument" name="org.w3c.dom.Node importNode(org.w3c.dom.Node, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultDocument" name="org.w3c.dom.Text createTextNode(java.lang.String)" map="J"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultDocument" name="org.w3c.dom.Element createElement(java.lang.String)" map="K"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultDocument" name="org.w3c.dom.NodeList getElementsByTagName(java.lang.String)" map="L"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultDocument" name="java.lang.String getDocumentURI()" map="&#x00d1;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultDocument" name="void setDocumentURI(java.lang.String)" map="M"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultDocument" name="org.w3c.dom.Attr createAttributeNS(java.lang.String, java.lang.String)" map="H"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultDocument" name="void normalizeDocument()" map="&#x00d2;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultDocument" name="org.w3c.dom.Element createElementNS(java.lang.String, java.lang.String)" map="I"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultDocument" name="org.w3c.dom.Element getDocumentElement()" map="&#x00d3;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultDocument" name="org.w3c.dom.DocumentType getDoctype()" map="&#x00d4;"/>
  <class name="org.apache.xerces.impl.xs.opti.DefaultNode" map="F"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="org.w3c.dom.Node getParentNode()" map="w"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="org.w3c.dom.Node removeChild(org.w3c.dom.Node)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="org.w3c.dom.Node getNextSibling()" map="x"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="org.w3c.dom.NodeList getChildNodes()" map="y"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="void setNodeValue(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="org.w3c.dom.Node insertBefore(org.w3c.dom.Node, org.w3c.dom.Node)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="org.w3c.dom.Node getFirstChild()" map="z"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="org.w3c.dom.Document getOwnerDocument()" map="&#x00a2;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="boolean hasAttributes()" map="&#x00a3;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="org.w3c.dom.Node replaceChild(org.w3c.dom.Node, org.w3c.dom.Node)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="java.lang.String getPrefix()" map="&#x00a4;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="org.w3c.dom.NamedNodeMap getAttributes()" map="&#x00a5;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="java.lang.String getTextContent()" map="&#x00aa;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="void setTextContent(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="boolean hasChildNodes()" map="&#x00ba;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="java.lang.String getNodeValue()" map="&#x00c0;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="java.lang.String getNamespaceURI()" map="&#x00c1;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="org.w3c.dom.Node getPreviousSibling()" map="&#x00c2;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="short getNodeType()" map="&#x00c3;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="boolean isEqualNode(org.w3c.dom.Node)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="java.lang.String getLocalName()" map="&#x00c4;"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="void setPrefix(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultNode" name="org.w3c.dom.Node appendChild(org.w3c.dom.Node)" map="C"/>
  <class name="org.apache.xerces.impl.xs.opti.DefaultElement" map="G"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultElement" name="boolean hasAttribute(java.lang.String)" map="F"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultElement" name="void setIdAttribute(java.lang.String, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultElement" name="org.w3c.dom.Attr getAttributeNode(java.lang.String)" map="G"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultElement" name="org.w3c.dom.NodeList getElementsByTagName(java.lang.String)" map="H"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultElement" name="void setAttribute(java.lang.String, java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultElement" name="void setAttributeNS(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultElement" name="java.lang.String getAttributeNS(java.lang.String, java.lang.String)" map="D"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultElement" name="org.w3c.dom.Attr getAttributeNodeNS(java.lang.String, java.lang.String)" map="E"/>
  <method class="org.apache.xerces.impl.xs.opti.DefaultElement" name="java.lang.String getAttribute(java.lang.String)" map="I"/>
  <class name="org.apache.xerces.impl.xs.opti.SchemaDOM" map="H"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="nextFreeLoc" map="&#x00e6;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="relations" map="&#x00e7;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="parent" map="&#x00e8;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="currLoc" map="&#x00e9;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="fAnnotationBuffer" map="&#x00ea;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="inCDATA" map="&#x00eb;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="org.apache.xerces.impl.xs.opti.ElementImpl emptyElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, int, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void startAnnotation(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.NamespaceContext)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void startAnnotationElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void resizeRelations(int)" map="C"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="org.apache.xerces.impl.xs.opti.ElementImpl startElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, int, int, int)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void startAnnotation(java.lang.String, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.NamespaceContext)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void endAnnotationElement(java.lang.String)" map="N"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="org.w3c.dom.Element getDocumentElement()" map="&#x00d3;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void charactersRaw(java.lang.String)" map="O"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void reset()" map="&#x00d5;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void endAnnotation(org.apache.xerces.xni.QName, org.apache.xerces.impl.xs.opti.ElementImpl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void endSyntheticAnnotationElement(java.lang.String, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void startAnnotationCDATA()" map="&#x00d6;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void endAnnotationCDATA()" map="&#x00d8;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void processElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.impl.xs.opti.ElementImpl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void endAnnotationElement(org.apache.xerces.xni.QName)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void comment(org.apache.xerces.xni.XMLString)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void startAnnotationElement(java.lang.String, org.apache.xerces.xni.XMLAttributes)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="java.lang.String escapeAttValue(java.lang.String, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void resizeRelations()" map="&#x00d9;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="java.lang.String processAttValue(java.lang.String)" map="P"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void processingInstruction(java.lang.String, org.apache.xerces.xni.XMLString)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void endElement()" map="&#x00da;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaDOM" name="void characters(org.apache.xerces.xni.XMLString)" map="B"/>
  <class name="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" map="I"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fXML11DTDScanner" map="&#x027a;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fDTDScanner" map="&#x027b;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fVersionDetector" map="&#x027c;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fCurrentScanner" map="&#x027d;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fGrammarPool" map="&#x027e;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fCurrentDTDScanner" map="&#x027f;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fInputSource" map="&#x0280;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fEntityManager" map="&#x0281;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fCurrentDVFactory" map="&#x0282;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fErrorReporter" map="&#x0283;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fXML11DatatypeFactory" map="&#x0284;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fValidationManager" map="&#x0285;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fNamespaceScanner" map="&#x0286;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fConfigUpdated" map="&#x0287;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fDatatypeValidatorFactory" map="&#x0288;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="f11Initialized" map="&#x0289;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fXML11NSDocScanner" map="&#x028a;"/>
  <field class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="fParseInProgress" map="&#x028b;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void checkProperty(java.lang.String)" map="j"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void setInputSource(org.apache.xerces.xni.parser.XMLInputSource)" map="F"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void checkFeature(java.lang.String)" map="k"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void configurePipeline()" map="&#x00e0;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void setProperty(java.lang.String, java.lang.Object)" map="D"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void resetNodePool()" map="&#x00e1;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void configureXML11Pipeline()" map="&#x00e2;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void reset()" map="&#x00df;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void resetXML10()" map="&#x00e3;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void parse(org.apache.xerces.xni.parser.XMLInputSource)" map="D"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="boolean parse(boolean)" map="I"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void addRecognizedParamsAndSetDefaults(org.apache.xerces.xni.parser.XMLComponent)" map="F"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="java.lang.Object getProperty(java.lang.String)" map="i"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void resetXML11()" map="&#x00e4;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void initXML11Components()" map="&#x00e5;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void cleanup()" map="&#x00e6;"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="boolean getFeature(java.lang.String)" map="h"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void setLocale(java.util.Locale)" map="C"/>
  <method class="org.apache.xerces.impl.xs.opti.SchemaParsingConfig" name="void setFeature(java.lang.String, boolean)" map="E"/>
  <class name="org.apache.xerces.impl.xs.opti.NamedNodeMapImpl" map="J"/>
  <field class="org.apache.xerces.impl.xs.opti.NamedNodeMapImpl" name="attrs" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.NamedNodeMapImpl" name="org.w3c.dom.Node item(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.NamedNodeMapImpl" name="org.w3c.dom.Node removeNamedItem(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.NamedNodeMapImpl" name="org.w3c.dom.Node getNamedItem(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.xs.opti.NamedNodeMapImpl" name="int getLength()" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.NamedNodeMapImpl" name="org.w3c.dom.Node removeNamedItemNS(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.NamedNodeMapImpl" name="org.w3c.dom.Node setNamedItemNS(org.w3c.dom.Node)" map="A"/>
  <method class="org.apache.xerces.impl.xs.opti.NamedNodeMapImpl" name="org.w3c.dom.Node getNamedItemNS(java.lang.String, java.lang.String)" map="B"/>
  <class name="org.apache.xerces.impl.xs.opti.AttrImpl" map="K"/>
  <field class="org.apache.xerces.impl.xs.opti.AttrImpl" name="element" map="&#x00f2;"/>
  <field class="org.apache.xerces.impl.xs.opti.AttrImpl" name="value" map="&#x00f3;"/>
  <method class="org.apache.xerces.impl.xs.opti.AttrImpl" name="org.w3c.dom.Element getOwnerElement()" map="&#x00c6;"/>
  <method class="org.apache.xerces.impl.xs.opti.AttrImpl" name="java.lang.String getValue()" map="&#x00c7;"/>
  <method class="org.apache.xerces.impl.xs.opti.AttrImpl" name="boolean getSpecified()" map="&#x00c8;"/>
  <method class="org.apache.xerces.impl.xs.opti.AttrImpl" name="org.w3c.dom.Document getOwnerDocument()" map="&#x00a2;"/>
  <method class="org.apache.xerces.impl.xs.opti.AttrImpl" name="java.lang.String getNodeValue()" map="&#x00c0;"/>
  <method class="org.apache.xerces.impl.xs.opti.AttrImpl" name="void setValue(java.lang.String)" map="E"/>
  <method class="org.apache.xerces.impl.xs.opti.AttrImpl" name="java.lang.String getName()" map="&#x00c9;"/>
  <method class="org.apache.xerces.impl.xs.opti.AttrImpl" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.xs.opti.ElementImpl" map="L"/>
  <field class="org.apache.xerces.impl.xs.opti.ElementImpl" name="col" map="&#x00db;"/>
  <field class="org.apache.xerces.impl.xs.opti.ElementImpl" name="fAnnotation" map="&#x00dc;"/>
  <field class="org.apache.xerces.impl.xs.opti.ElementImpl" name="column" map="&#x00dd;"/>
  <field class="org.apache.xerces.impl.xs.opti.ElementImpl" name="schemaDOM" map="&#x00de;"/>
  <field class="org.apache.xerces.impl.xs.opti.ElementImpl" name="charOffset" map="&#x00df;"/>
  <field class="org.apache.xerces.impl.xs.opti.ElementImpl" name="attrs" map="&#x00e0;"/>
  <field class="org.apache.xerces.impl.xs.opti.ElementImpl" name="fSyntheticAnnotation" map="&#x00e1;"/>
  <field class="org.apache.xerces.impl.xs.opti.ElementImpl" name="parentRow" map="&#x00e2;"/>
  <field class="org.apache.xerces.impl.xs.opti.ElementImpl" name="row" map="&#x00e3;"/>
  <field class="org.apache.xerces.impl.xs.opti.ElementImpl" name="line" map="&#x00e4;"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="org.w3c.dom.Node getParentNode()" map="w"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="boolean hasAttribute(java.lang.String)" map="F"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="org.w3c.dom.Attr getAttributeNodeNS(java.lang.String, java.lang.String)" map="E"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="org.w3c.dom.Node getNextSibling()" map="x"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="org.w3c.dom.Node getFirstChild()" map="z"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="org.w3c.dom.Document getOwnerDocument()" map="&#x00a2;"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="boolean hasAttributes()" map="&#x00a3;"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="int getLineNumber()" map="&#x00cc;"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="org.w3c.dom.NamedNodeMap getAttributes()" map="&#x00a5;"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="java.lang.String getAttribute(java.lang.String)" map="I"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="java.lang.String getSyntheticAnnotation()" map="&#x00cd;"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="java.lang.String getAttributeNS(java.lang.String, java.lang.String)" map="D"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="int getCharacterOffset()" map="&#x00ce;"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="boolean hasChildNodes()" map="&#x00ba;"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="boolean nsEquals(java.lang.String, java.lang.String)" map="F"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="org.w3c.dom.Node getPreviousSibling()" map="&#x00c2;"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="java.lang.String getAnnotation()" map="&#x00cf;"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="int getColumnNumber()" map="&#x00d0;"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="void setAttribute(java.lang.String, java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.xs.opti.ElementImpl" name="org.w3c.dom.Attr getAttributeNode(java.lang.String)" map="G"/>
  <package name="org.apache.xerces.impl.xs.traversers" map="D"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDNotationTraverser" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDNotationTraverser" name="org.apache.xerces.impl.xs.XSNotationDecl traverse(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="N"/>
  <class name="org.apache.xerces.impl.xs.traversers.OneAttr" map="B"/>
  <field class="org.apache.xerces.impl.xs.traversers.OneAttr" name="name" map="A"/>
  <field class="org.apache.xerces.impl.xs.traversers.OneAttr" name="dfltValue" map="B"/>
  <field class="org.apache.xerces.impl.xs.traversers.OneAttr" name="valueIndex" map="C"/>
  <field class="org.apache.xerces.impl.xs.traversers.OneAttr" name="dvIndex" map="D"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDSimpleTypeTraverser" map="C"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDSimpleTypeTraverser" name="fIsBuiltIn" map="I"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDSimpleTypeTraverser" name="org.apache.xerces.impl.dv.XSSimpleType errorType(java.lang.String, java.lang.String, short)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDSimpleTypeTraverser" name="boolean isListDatatype(org.apache.xerces.impl.dv.XSSimpleType)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDSimpleTypeTraverser" name="org.apache.xerces.impl.dv.XSSimpleType traverseSimpleTypeDecl(org.w3c.dom.Element, java.lang.Object[], org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDSimpleTypeTraverser" name="java.lang.String genAnonTypeName(org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDSimpleTypeTraverser" name="org.apache.xerces.impl.dv.XSSimpleType getSimpleType(java.lang.String, org.w3c.dom.Element, java.lang.Object[], org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDSimpleTypeTraverser" name="boolean checkBuiltIn(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDSimpleTypeTraverser" name="org.apache.xerces.impl.dv.XSSimpleType traverseLocal(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDSimpleTypeTraverser" name="org.apache.xerces.impl.dv.XSSimpleType findDTValidator(org.w3c.dom.Element, java.lang.String, org.apache.xerces.xni.QName, short, org.apache.xerces.impl.xs.traversers.XSDocumentInfo)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDSimpleTypeTraverser" name="org.apache.xerces.impl.dv.XSSimpleType traverseGlobal(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="B"/>
  <class name="org.apache.xerces.impl.xs.traversers.LargeContainer" map="D"/>
  <field class="org.apache.xerces.impl.xs.traversers.LargeContainer" name="items" map="D"/>
  <method class="org.apache.xerces.impl.xs.traversers.LargeContainer" name="org.apache.xerces.impl.xs.traversers.OneAttr get(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.LargeContainer" name="void put(java.lang.String, org.apache.xerces.impl.xs.traversers.OneAttr)" map="A"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDElementTraverser" map="E"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDElementTraverser" name="fTempElementDecl" map="J"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDElementTraverser" name="fDeferTraversingLocalElements" map="K"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDElementTraverser" name="org.apache.xerces.impl.xs.XSElementDecl traverseNamedElement(org.w3c.dom.Element, java.lang.Object[], org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar, boolean, org.apache.xerces.xs.XSObject)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDElementTraverser" name="void traverseLocal(org.apache.xerces.impl.xs.XSParticleDecl, org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar, int, org.apache.xerces.xs.XSObject, java.lang.String[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDElementTraverser" name="void reset(org.apache.xerces.util.SymbolTable, boolean, java.util.Locale)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDElementTraverser" name="org.apache.xerces.impl.xs.XSElementDecl traverseGlobal(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDElementTraverser" name="org.apache.xerces.impl.xs.XSParticleDecl traverseLocal(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar, int, org.apache.xerces.xs.XSObject)" map="A"/>
  <class name="org.apache.xerces.impl.xs.traversers.SmallContainer" map="F"/>
  <field class="org.apache.xerces.impl.xs.traversers.SmallContainer" name="keys" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.SmallContainer" name="org.apache.xerces.impl.xs.traversers.OneAttr get(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.SmallContainer" name="void put(java.lang.String, org.apache.xerces.impl.xs.traversers.OneAttr)" map="A"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDAbstractIDConstraintTraverser" map="G"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractIDConstraintTraverser" name="boolean traverseIdentityConstraint(org.apache.xerces.impl.xs.identity.IdentityConstraint, org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, java.lang.Object[])" map="A"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSAnnotationInfo" map="H"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAnnotationInfo" name="fAnnotation" map="A"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAnnotationInfo" name="next" map="B"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAnnotationInfo" name="fLine" map="C"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAnnotationInfo" name="fColumn" map="D"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAnnotationInfo" name="fCharOffset" map="E"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDAttributeTraverser" map="I"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAttributeTraverser" name="org.apache.xerces.impl.xs.XSAttributeDecl traverseNamedAttr(org.w3c.dom.Element, java.lang.Object[], org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar, boolean, org.apache.xerces.impl.xs.XSComplexTypeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAttributeTraverser" name="void checkDefaultValid(org.apache.xerces.impl.xs.XSAttributeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAttributeTraverser" name="org.apache.xerces.impl.xs.XSAttributeDecl traverseGlobal(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="D"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAttributeTraverser" name="org.apache.xerces.impl.xs.XSAttributeUseImpl traverseLocal(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar, org.apache.xerces.impl.xs.XSComplexTypeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAttributeTraverser" name="void checkDefaultValid(org.apache.xerces.impl.xs.XSAttributeUseImpl)" map="A"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDAbstractParticleTraverser$ParticleArray" map="_A"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractParticleTraverser$ParticleArray" name="fParticles" map="A"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractParticleTraverser$ParticleArray" name="fContextCount" map="B"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractParticleTraverser$ParticleArray" name="fPos" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractParticleTraverser$ParticleArray" name="void pushContext()" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractParticleTraverser$ParticleArray" name="int getParticleCount()" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractParticleTraverser$ParticleArray" name="void addParticle(org.apache.xerces.impl.xs.XSParticleDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractParticleTraverser$ParticleArray" name="org.apache.xerces.impl.xs.XSParticleDecl[] popContext()" map="C"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDAbstractParticleTraverser" map="J"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractParticleTraverser" name="fPArray" map="L"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractParticleTraverser" name="boolean hasAllContent(org.apache.xerces.impl.xs.XSParticleDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractParticleTraverser" name="org.apache.xerces.impl.xs.XSParticleDecl traverseSequence(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar, int, org.apache.xerces.xs.XSObject)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractParticleTraverser" name="org.apache.xerces.impl.xs.XSParticleDecl traverseAll(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar, int, org.apache.xerces.xs.XSObject)" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractParticleTraverser" name="org.apache.xerces.impl.xs.XSParticleDecl traverseSeqChoice(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar, int, boolean, org.apache.xerces.xs.XSObject)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractParticleTraverser" name="org.apache.xerces.impl.xs.XSParticleDecl traverseChoice(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar, int, org.apache.xerces.xs.XSObject)" map="D"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDGroupTraverser" map="K"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDGroupTraverser" name="org.apache.xerces.impl.xs.XSParticleDecl traverseLocal(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="E"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDGroupTraverser" name="org.apache.xerces.impl.xs.XSGroupDecl traverseGlobal(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="F"/>
  <class name="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" map="L"/>
  <field class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="fStringBuffer" map="A"/>
  <field class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="fElementQName" map="B"/>
  <field class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="fNeedPushNSContext" map="C"/>
  <field class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="fSchemaDOMParser" map="D"/>
  <field class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="fTempString" map="E"/>
  <field class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="fSAXLocatorWrapper" map="F"/>
  <field class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="fNamespacePrefixes" map="G"/>
  <field class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="fAttributes" map="H"/>
  <field class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="fAttributeQName" map="I"/>
  <field class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="fNamespaceContext" map="J"/>
  <field class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="fStringsInternalized" map="K"/>
  <field class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="fSymbolTable" map="L"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void endPrefixMapping(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void convertToSAXParseException(org.apache.xerces.xni.parser.XMLParseException)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void setDocumentLocator(org.xml.sax.Locator)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void reset(org.apache.xerces.impl.xs.opti.SchemaDOMParser, org.apache.xerces.util.SymbolTable, boolean, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void fillQName(org.apache.xerces.xni.QName, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void startDocument()" map="E"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void convertToSAXException(org.apache.xerces.xni.XNIException)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void characters(char[], int, int)" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void skippedEntity(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void processingInstruction(java.lang.String, java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void ignorableWhitespace(char[], int, int)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void startPrefixMapping(java.lang.String, java.lang.String)" map="D"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void endElement(java.lang.String, java.lang.String, java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void fillXMLAttributes(org.xml.sax.Attributes)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void addNamespaceDeclarations(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="org.w3c.dom.Document getDocument()" map="F"/>
  <method class="org.apache.xerces.impl.xs.traversers.SchemaContentHandler" name="void endDocument()" map="D"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDHandler$SAX2XNIUtil" map="_A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler$SAX2XNIUtil" name="org.apache.xerces.xni.parser.XMLParseException createXMLParseException0(org.xml.sax.SAXParseException)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler$SAX2XNIUtil" name="org.apache.xerces.xni.XNIException createXNIException0(org.xml.sax.SAXException)" map="B"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDHandler$1" map="1"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDHandler$XSAnnotationGrammarPool" map="_B"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler$XSAnnotationGrammarPool" name="fInitialGrammarSet" map="A"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler$XSAnnotationGrammarPool" name="fGrammarBucket" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler$XSAnnotationGrammarPool" name="void refreshGrammars(org.apache.xerces.impl.xs.XSGrammarBucket)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler$XSAnnotationGrammarPool" name="void cacheGrammars(java.lang.String, org.apache.xerces.xni.grammars.Grammar[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler$XSAnnotationGrammarPool" name="org.apache.xerces.xni.grammars.Grammar[] retrieveInitialGrammarSet(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler$XSAnnotationGrammarPool" name="org.apache.xerces.xni.grammars.Grammar retrieveGrammar(org.apache.xerces.xni.grammars.XMLGrammarDescription)" map="A"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDHandler$XSDKey" map="_C"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler$XSDKey" name="referType" map="A"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler$XSDKey" name="systemId" map="B"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler$XSDKey" name="referNS" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler$XSDKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler$XSDKey" name="int hashCode()" map="hashCode"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDHandler" map="M"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUnparsedRegistriesExt" map="A"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fErrorReporter" map="B"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fEntityResolver" map="C"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fNotationTraverser" map="D"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fGlobalTypeDecls" map="E"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fDoc2SystemId" map="F"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fLocationPairs" map="G"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUnparsedAttributeGroupRegistrySub" map="H"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fAllContext" map="I"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fHiddenNodes" map="J"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fGlobalGroupDecls" map="K"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUnparsedAttributeRegistry" map="L"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fReportedTNS" map="M"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fSchemaGrammarDescription" map="N"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fAllTNSs" map="O"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fLocalElemStackPos" map="P"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="CIRCULAR_CODES" map="Q"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUnparsedTypeRegistry" map="R"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fImportMap" map="S"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="COMP_TYPE" map="T"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fRedefine2XSDMap" map="U"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fGlobalNotationDecls" map="V"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fGlobalAttrDecls" map="W"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fGlobalElemDecls" map="X"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fGlobalIDConstraintDecls" map="Y"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fGrammarPool" map="Z"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUniqueOrKeyTraverser" map="_"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUnparsedIdentityConstraintRegistrySub" map="a"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fXSDocumentInfoRegistry" map="b"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fRedefine2NSSupport" map="c"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fLocalElementDecl" map="d"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fLocalElementDecl_schema" map="e"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fKeyrefsMapXSDocumentInfo" map="f"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fKeyrefNamespaceContext" map="g"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fParent" map="h"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fLastSchemaWasDuplicate" map="i"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fGrammarBucketAdapter" map="j"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fDVFactory" map="k"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fParticle" map="l"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fHonourAllSchemaLocations" map="m"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fRedefinedRestrictedGroupRegistry" map="n"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUnparsedGroupRegistrySub" map="o"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUnparsedElementRegistry" map="p"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUnparsedNotationRegistrySub" map="q"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fAttributeTraverser" map="r"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fNotationRegistry" map="s"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUnparsedGroupRegistry" map="t"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUnparsedTypeRegistrySub" map="u"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fSchemaParser" map="v"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fSimpleTypeTraverser" map="w"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fComplexTypeTraverser" map="x"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fSymbolTable" map="y"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fKeyrefTraverser" map="z"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fDeclPool" map="&#x00a2;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fKeyrefElems" map="&#x00a3;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fLocalElemNamespaceContext" map="&#x00a4;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fGroupTraverser" map="&#x00a5;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fNamespaceGrowth" map="&#x00aa;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fGlobalAttrGrpDecls" map="&#x00b5;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="EMPTY_TABLE" map="&#x00ba;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fAnnotationValidator" map="&#x00c0;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUnparsedAttributeRegistrySub" map="&#x00c1;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUnparsedElementRegistrySub" map="&#x00c2;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fAttributeChecker" map="&#x00c3;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fTolerateDuplicates" map="&#x00c4;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUnparsedIdentityConstraintRegistry" map="&#x00c5;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fAttributeGroupTraverser" map="&#x00c6;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fKeyrefs" map="&#x00c7;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fRedefinedRestrictedAttributeGroupRegistry" map="&#x00c8;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fWildCardTraverser" map="&#x00c9;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUnparsedNotationRegistry" map="&#x00ca;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fRoot" map="&#x00cb;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="ELE_ERROR_CODES" map="&#x00cc;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fStAXSchemaParser" map="&#x00cd;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fXSContentHandler" map="&#x00ce;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fUnparsedAttributeGroupRegistry" map="&#x00cf;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fDoc2XSDocumentMap" map="&#x00d0;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fValidateAnnotations" map="&#x00d1;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fElementTraverser" map="&#x00d2;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fKeyrefStackPos" map="&#x00d3;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="xl" map="&#x00d4;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="NS_ERROR_CODES" map="&#x00d5;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fGrammarBucket" map="&#x00d6;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fDependencyMap" map="&#x00d8;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="fTraversed" map="&#x00d9;"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGlobalTypeDecl(org.apache.xerces.xs.XSTypeDefinition)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void setSchemasVisible(org.apache.xerces.impl.xs.traversers.XSDocumentInfo)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="java.lang.Object getGlobalDeclFromGrammar(org.apache.xerces.impl.xs.SchemaGrammar, int, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void buildGlobalNameRegistries()" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void reportSchemaWarning(java.lang.String, java.lang.Object[], org.w3c.dom.Element, java.lang.Exception)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGlobalGroupDecls(org.apache.xerces.impl.xs.SchemaGrammar, org.apache.xerces.impl.xs.SchemaGrammar)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="boolean nonAnnotationContent(org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGlobalComponents(java.util.Vector, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.w3c.dom.Element getSchemaDocument1(boolean, boolean, org.apache.xerces.xni.parser.XMLInputSource, org.w3c.dom.Element, java.io.IOException)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void expandRelatedComponents(org.apache.xerces.xs.XSObject, java.util.Vector, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.impl.xs.SchemaGrammar parseSchema(org.apache.xerces.xni.parser.XMLInputSource, org.apache.xerces.impl.xs.XSDDescription, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.xni.parser.XMLInputSource resolveSchemaSource(org.apache.xerces.impl.xs.XSDDescription, boolean, org.w3c.dom.Element, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="java.lang.Object getGlobalDecl(java.lang.String, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void updateImportDependencies(java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.w3c.dom.Element getSchemaDocument0(org.apache.xerces.impl.xs.traversers.XSDHandler$XSDKey, java.lang.String, org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.impl.xs.XSAttributeGroupDecl getGlobalAttributeGroupDecl(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.impl.xs.util.SimpleLocator element2Locator(org.w3c.dom.Element)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="java.util.Vector expandGrammars(org.apache.xerces.impl.xs.SchemaGrammar[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGlobalElementDecls(org.apache.xerces.impl.xs.SchemaGrammar, org.apache.xerces.impl.xs.SchemaGrammar)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGlobalAttributeGroupDecl(org.apache.xerces.impl.xs.XSAttributeGroupDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="java.lang.String null2EmptyString(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.impl.xs.XSNotationDecl getGlobalNotationDecl(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.impl.xs.SchemaGrammar createGrammarFrom(org.apache.xerces.impl.xs.SchemaGrammar)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="java.lang.String emptyString2Null(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="boolean existingGrammars(java.util.Vector)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void traverseLocalElements()" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGlobalAttributeGroupDecls(org.apache.xerces.impl.xs.SchemaGrammar, org.apache.xerces.impl.xs.SchemaGrammar)" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void expandRelatedAttributeComponents(org.apache.xerces.xs.XSAttributeDeclaration, java.util.Vector, java.lang.String, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void expandRelatedElementComponents(org.apache.xerces.xs.XSElementDeclaration, java.util.Vector, java.lang.String, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addRelatedType(org.apache.xerces.xs.XSTypeDefinition, java.util.Vector, java.lang.String, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGlobalGroupDecl(org.apache.xerces.impl.xs.XSGroupDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addNewGrammarLocations(org.apache.xerces.impl.xs.SchemaGrammar, org.apache.xerces.impl.xs.SchemaGrammar)" map="D"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void resolveKeyRefs()" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="boolean needReportTNSError(java.lang.String)" map="E"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void fillInLocalElemInfo(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, int, org.apache.xerces.xs.XSObject, org.apache.xerces.impl.xs.XSParticleDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void expandRelatedAttributeUsesComponents(org.apache.xerces.xs.XSObjectList, java.util.Vector, java.lang.String, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.impl.xs.SchemaGrammar findGrammar(org.apache.xerces.impl.xs.XSDDescription, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="java.util.Hashtable getIDRegistry()" map="D"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.w3c.dom.Element getSchemaDocument(java.lang.String, org.apache.xerces.util.SAXInputSource, boolean, short, org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.impl.xs.identity.IdentityConstraint getIDConstraintDecl(java.lang.String)" map="F"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="java.lang.String schemaDocument2SystemId(org.apache.xerces.impl.xs.traversers.XSDocumentInfo)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void checkForDuplicateNames(java.lang.String, int, java.util.Hashtable, java.util.Hashtable, org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void checkForDuplicateNames(java.lang.String, int, org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.w3c.dom.Element getSchemaDocument(java.lang.String, org.apache.xerces.util.DOMInputSource, boolean, short, org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.impl.xs.traversers.XSDocumentInfo constructTrees(org.w3c.dom.Element, java.lang.String, org.apache.xerces.impl.xs.XSDDescription, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void updateImportList(java.util.Vector, java.util.Vector)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="java.lang.Object traverseGlobalDecl(int, org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void reportSchemaWarning(java.lang.String, java.lang.Object[], org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="java.util.Vector expandComponents(org.apache.xerces.xs.XSObject[], java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void expandRelatedAttributeUseComponents(org.apache.xerces.xs.XSAttributeUse, java.util.Vector, java.lang.String, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="boolean canAddComponent(org.apache.xerces.xs.XSObject, org.apache.xerces.impl.xs.XSDDescription)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void reportSchemaError(java.lang.String, java.lang.Object[], org.w3c.dom.Element, java.lang.Exception)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.w3c.dom.Element resolveSchema(org.apache.xerces.xni.parser.XMLInputSource, org.apache.xerces.impl.xs.XSDDescription, boolean, org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void createAnnotationValidator()" map="E"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void reportSharingError(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addNamespaceDependency(java.lang.String, java.lang.String, java.util.Vector)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addRelatedElement(org.apache.xerces.xs.XSElementDeclaration, java.util.Vector, java.lang.String, java.util.Hashtable)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addNewImportedGrammars(org.apache.xerces.impl.xs.SchemaGrammar, org.apache.xerces.impl.xs.SchemaGrammar)" map="E"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void reportSchemaError(java.lang.String, java.lang.Object[], org.w3c.dom.Element)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="java.lang.String findQName(java.lang.String, org.apache.xerces.impl.xs.traversers.XSDocumentInfo)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.xs.XSTypeDefinition getGlobalTypeDecl(java.lang.String)" map="G"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addIDConstraintDecl(org.apache.xerces.impl.xs.identity.IdentityConstraint)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.impl.xs.traversers.XSDocumentInfo findXSDocumentForDecl(org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addImportList(org.apache.xerces.impl.xs.SchemaGrammar, java.util.Vector, java.util.Vector)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void updateImportListWith(org.apache.xerces.impl.xs.SchemaGrammar)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void updateImportListFor(org.apache.xerces.impl.xs.SchemaGrammar)" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void expandRelatedAttributeGroupComponents(org.apache.xerces.xs.XSAttributeGroupDefinition, java.util.Vector, java.lang.String, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void storeKeyRef(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.XSElementDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="java.util.Hashtable getIDRegistry_sub()" map="F"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void prepareForTraverse()" map="G"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="java.lang.Object getGrpOrAttrGrpRedefinedByRestriction(int, org.apache.xerces.xni.QName, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="java.lang.Object getGlobalDecl(org.apache.xerces.impl.xs.traversers.XSDocumentInfo, int, org.apache.xerces.xni.QName, org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void validateAnnotations(java.util.ArrayList)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.impl.xs.XSGroupDecl getGlobalGroupDecl(java.lang.String)" map="H"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void expandRelatedParticleComponents(org.apache.xerces.xs.XSParticle, java.util.Vector, java.lang.String, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="boolean removeParticle(org.apache.xerces.impl.xs.XSModelGroupImpl, org.apache.xerces.impl.xs.XSParticleDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void expandRelatedModelGroupDefinitionComponents(org.apache.xerces.xs.XSModelGroupDefinition, java.util.Vector, java.lang.String, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void expandImportList(java.lang.String, java.util.Vector)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="int changeRedefineGroup(java.lang.String, java.lang.String, java.lang.String, org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void setGenerateSyntheticAnnotations(boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGlobalAttributeDecls(org.apache.xerces.impl.xs.SchemaGrammar, org.apache.xerces.impl.xs.SchemaGrammar)" map="F"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="boolean containedImportedGrammar(java.util.Vector, org.apache.xerces.impl.xs.SchemaGrammar)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.impl.xs.XSAttributeDecl getGlobalAttributeDecl(java.lang.String)" map="I"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="java.lang.String doc2SystemId(org.w3c.dom.Element)" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void expandRelatedTypeComponents(org.apache.xerces.xs.XSTypeDefinition, java.util.Vector, java.lang.String, java.util.Hashtable)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addNewGrammarComponents(org.apache.xerces.impl.xs.SchemaGrammar, org.apache.xerces.impl.xs.SchemaGrammar)" map="G"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void updateImportList(org.apache.xerces.impl.xs.SchemaGrammar, java.util.Vector, java.util.Vector)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void expandRelatedSimpleTypeComponents(org.apache.xerces.xs.XSSimpleTypeDefinition, java.util.Vector, java.lang.String, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGlobalAttributeDecl(org.apache.xerces.impl.xs.XSAttributeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.impl.xs.XSElementDecl getGlobalElementDecl(java.lang.String)" map="J"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.w3c.dom.Element getSchemaDocument(java.lang.String, org.apache.xerces.xni.parser.XMLInputSource, boolean, short, org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void setDVFactory(org.apache.xerces.impl.dv.SchemaDVFactory)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGlobalElementDecl(org.apache.xerces.impl.xs.XSElementDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.w3c.dom.Element resolveSchema(org.apache.xerces.impl.xs.XSDDescription, boolean, org.w3c.dom.Element, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.w3c.dom.Element getSchemaDocument(org.apache.xerces.impl.xs.util.XSInputSource, org.apache.xerces.impl.xs.XSDDescription)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void expandRelatedModelGroupComponents(org.apache.xerces.xs.XSModelGroup, java.util.Vector, java.lang.String, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="boolean element2Locator(org.w3c.dom.Element, org.apache.xerces.impl.xs.util.SimpleLocator)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.impl.xs.SchemaGrammar getGrammar(java.lang.String)" map="K"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void expandRelatedComplexTypeComponents(org.apache.xerces.impl.xs.XSComplexTypeDecl, java.util.Vector, java.lang.String, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void setDeclPool(org.apache.xerces.impl.xs.XSDeclarationPool)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGrammars(java.util.Vector)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void renameRedefiningComponents(org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.w3c.dom.Element, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.apache.xerces.impl.xs.SchemaGrammar getSchemaGrammar(org.apache.xerces.impl.xs.XSDDescription)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="org.w3c.dom.Element getSchemaDocument(java.lang.String, org.apache.xerces.util.StAXInputSource, boolean, short, org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGrammarComponents(org.apache.xerces.impl.xs.SchemaGrammar, org.apache.xerces.impl.xs.SchemaGrammar)" map="H"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void createTraversers()" map="H"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGlobalComponent(org.apache.xerces.xs.XSObject, org.apache.xerces.impl.xs.XSDDescription)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGlobalNotationDecl(org.apache.xerces.impl.xs.XSNotationDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="java.util.Vector findDependentNamespaces(java.lang.String, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="boolean isExistingGrammar(org.apache.xerces.impl.xs.XSDDescription, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addRelatedAttribute(org.apache.xerces.xs.XSAttributeDeclaration, java.util.Vector, java.lang.String, java.util.Hashtable)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="boolean canAddComponents(java.util.Vector)" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGlobalTypeDecls(org.apache.xerces.impl.xs.SchemaGrammar, org.apache.xerces.impl.xs.SchemaGrammar)" map="I"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void prepareForParse()" map="I"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void addGlobalNotationDecls(org.apache.xerces.impl.xs.SchemaGrammar, org.apache.xerces.impl.xs.SchemaGrammar)" map="J"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDHandler" name="void traverseSchemas(java.util.ArrayList)" map="B"/>
  <class name="org.apache.xerces.impl.xs.traversers.Container" map="N"/>
  <field class="org.apache.xerces.impl.xs.traversers.Container" name="values" map="A"/>
  <field class="org.apache.xerces.impl.xs.traversers.Container" name="pos" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.Container" name="org.apache.xerces.impl.xs.traversers.Container getContainer(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.Container" name="org.apache.xerces.impl.xs.traversers.OneAttr get(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.Container" name="void put(java.lang.String, org.apache.xerces.impl.xs.traversers.OneAttr)" map="A"/>
  <class name="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" map="O"/>
  <field class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="fStringBuffer" map="A"/>
  <field class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="fElementQName" map="B"/>
  <field class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="fSchemaDOMParser" map="C"/>
  <field class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="fDeclaredPrefixes" map="D"/>
  <field class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="fTempString" map="E"/>
  <field class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="fAttributes" map="F"/>
  <field class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="fNamespaceContext" map="G"/>
  <field class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="fAttributeQName" map="H"/>
  <field class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="fDepth" map="I"/>
  <field class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="fLocationWrapper" map="J"/>
  <field class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="fCharBuffer" map="K"/>
  <field class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="fSymbolTable" map="L"/>
  <method class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="void fillDeclaredPrefixes(javax.xml.stream.events.StartElement)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="void parse(javax.xml.stream.XMLStreamReader)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="void fillQName(org.apache.xerces.xni.QName, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="void fillQName(org.apache.xerces.xni.QName, javax.xml.namespace.QName)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="void addNamespaceDeclarations()" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="org.w3c.dom.Document getDocument()" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="void fillXMLAttributes(javax.xml.stream.XMLStreamReader)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="void fillXMLAttributes(javax.xml.stream.events.StartElement)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="void sendCharactersToSchemaParser(java.lang.String, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="void parse(javax.xml.stream.XMLEventReader)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="void fillDeclaredPrefixes(java.util.Iterator)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="void reset(org.apache.xerces.impl.xs.opti.SchemaDOMParser, org.apache.xerces.util.SymbolTable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="void fillProcessingInstruction(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="void fillDeclaredPrefixes(javax.xml.stream.XMLStreamReader)" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.StAXSchemaParser" name="void fillDeclaredPrefixes(javax.xml.stream.events.EndElement)" map="A"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDKeyrefTraverser" map="P"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDKeyrefTraverser" name="void traverse(org.w3c.dom.Element, org.apache.xerces.impl.xs.XSElementDecl, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="A"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDUniqueOrKeyTraverser" map="Q"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDUniqueOrKeyTraverser" name="void traverse(org.w3c.dom.Element, org.apache.xerces.impl.xs.XSElementDecl, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="B"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDAttributeGroupTraverser" map="R"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAttributeGroupTraverser" name="org.apache.xerces.impl.xs.XSAttributeGroupDecl traverseGlobal(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="J"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAttributeGroupTraverser" name="org.apache.xerces.impl.xs.XSAttributeGroupDecl traverseLocal(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="K"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" map="S"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fBlockDefault" map="A"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fImportedNS" map="B"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fNamespaceSupport" map="C"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fTargetNamespace" map="D"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fAnnotations" map="E"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fAreLocalElementsQualified" map="F"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="SchemaNamespaceSupportStack" map="G"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fIsChameleonSchema" map="H"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fNamespaceSupportRoot" map="I"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fAreLocalAttributesQualified" map="J"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fAttrChecker" map="K"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fValidationContext" map="L"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fSchemaAttrs" map="M"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fFinalDefault" map="N"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fReportedTNS" map="O"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fSymbolTable" map="P"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="fSchemaElement" map="Q"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="java.lang.Object[] getSchemaAttrs()" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="void returnSchemaAttrs()" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="void addAnnotation(org.apache.xerces.impl.xs.traversers.XSAnnotationInfo)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="void restoreNSSupport()" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="org.apache.xerces.impl.xs.traversers.XSAnnotationInfo getAnnotations()" map="D"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="boolean isAllowedNS(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="void addAllowedNS(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="boolean needReportTNSError(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDocumentInfo" name="void backupNSSupport(org.apache.xerces.impl.xs.SchemaNamespaceSupport)" map="A"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser$ComplexTypeRecoverableError" map="_A"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser$ComplexTypeRecoverableError" name="errorElem" map="A"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser$ComplexTypeRecoverableError" name="errorSubstText" map="B"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" map="T"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fDerivedBy" map="M"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fGlobalStorePos" map="N"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fTargetNamespace" map="O"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fErrorWildcard" map="P"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fAnnotations" map="Q"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fFinal" map="R"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fParticle" map="S"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fBlock" map="T"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fBaseType" map="U"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fXSSimpleType" map="V"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fName" map="W"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fContentType" map="X"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fComplexTypeDecl" map="Y"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fAttrGrp" map="Z"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fIsAbstract" map="_"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fGlobalStore" map="a"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="fErrorContent" map="b"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="org.apache.xerces.impl.xs.XSWildcardDecl getErrorWildcard()" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="org.apache.xerces.impl.xs.XSComplexTypeDecl traverseGlobal(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="G"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="void mergeAttributes(org.apache.xerces.impl.xs.XSAttributeGroupDecl, org.apache.xerces.impl.xs.XSAttributeGroupDecl, java.lang.String, boolean, org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="void addAnnotation(org.apache.xerces.impl.xs.XSAnnotationImpl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="java.lang.String genAnonTypeName(org.w3c.dom.Element)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="void processComplexContent(org.w3c.dom.Element, boolean, boolean, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="void traverseComplexContent(org.w3c.dom.Element, boolean, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="void contentRestore()" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="org.apache.xerces.impl.xs.XSComplexTypeDecl traverseLocal(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="H"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="void traverseSimpleContent(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="I"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="void contentBackup()" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="org.apache.xerces.impl.xs.XSParticleDecl getErrorContent()" map="D"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="boolean isAttrOrAttrGroup(org.w3c.dom.Element)" map="C"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="void handleComplexTypeError(java.lang.String, java.lang.Object[], org.w3c.dom.Element)" map="B"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDComplexTypeTraverser" name="org.apache.xerces.impl.xs.XSComplexTypeDecl traverseComplexTypeDecl(org.w3c.dom.Element, java.lang.String, java.lang.Object[], org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="A"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" map="U"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_ID" map="A"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_BLOCK" map="B"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_ABSTRACT" map="C"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="fXIntPool" map="D"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_NAMESPACE_LIST" map="E"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_NAMESPACE" map="F"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_EMPTY_SET" map="G"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_FIXED" map="H"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_QUALIFIED" map="I"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_REFER" map="J"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_ANY_SKIP" map="K"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_SYSTEM" map="L"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_MINOCCURS" map="M"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_FINALDEFAULT" map="N"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_TYPE" map="O"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="fSeenTemp" map="P"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="fEleAttrsMapL" map="Q"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_DEFAULT" map="R"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_ANY_LIST" map="S"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_REF" map="T"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_MIXED" map="U"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="fEleAttrsMapG" map="V"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_PROCESSCONTENTS" map="W"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="fSeen" map="X"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_BLOCKDEFAULT" map="Y"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_USE" map="Z"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_ENUMNSDECLS" map="_"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_ANY_LAX" map="a"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_ANY_ANY" map="b"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_XML_LANG" map="c"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_ITEMTYPE" map="d"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_UNBOUNDED" map="e"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="fExtraDVs" map="f"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_WS_REPLACE" map="g"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_UNQUALIFIED" map="h"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_PUBLIC" map="i"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_NAME" map="j"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_FROMDEFAULT" map="k"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_FINAL" map="l"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_SUBSGROUP" map="m"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="fSymbolTable" map="n"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_SCHEMALOCATION" map="o"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_MAXOCCURS" map="p"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="fArrayPool" map="q"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_USE_PROHIBITED" map="r"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="fNamespaceList" map="s"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_BASE" map="t"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="fNonSchemaAttrs" map="u"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_ANY_NOT" map="v"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_WS_PRESERVE" map="w"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_USE_OPTIONAL" map="x"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_VALUE" map="y"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_ISRETURNED" map="z"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="fPoolPos" map="&#x00a2;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_COUNT" map="&#x00a3;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_AFORMDEFAULT" map="&#x00a4;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_WS_COLLAPSE" map="&#x00a5;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_SOURCE" map="&#x00aa;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="fTempArray" map="&#x00b5;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_MEMBERTYPES" map="&#x00ba;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="fSchemaHandler" map="&#x00c0;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_VERSION" map="&#x00c1;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_XPATH" map="&#x00c2;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_ANY_STRICT" map="&#x00c3;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_TARGETNAMESPACE" map="&#x00c4;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_EFORMDEFAULT" map="&#x00c5;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_NILLABLE" map="&#x00c6;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_FORM" map="&#x00c7;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="INT_USE_REQUIRED" map="&#x00c8;"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="ATTIDX_NONSCHEMA" map="&#x00c9;"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="java.lang.Object[] checkAttributes(org.w3c.dom.Element, boolean, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="void returnAttrArray(java.lang.Object[], org.apache.xerces.impl.xs.traversers.XSDocumentInfo)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="java.lang.Object[] checkAttributes(org.w3c.dom.Element, boolean, org.apache.xerces.impl.xs.traversers.XSDocumentInfo)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="void reset(org.apache.xerces.util.SymbolTable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="java.lang.Object validate(java.lang.Object[], java.lang.String, java.lang.String, int, org.apache.xerces.impl.xs.traversers.XSDocumentInfo)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="void resolveNamespace(org.w3c.dom.Element, org.w3c.dom.Attr[], org.apache.xerces.impl.xs.SchemaNamespaceSupport)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="void reportSchemaError(java.lang.String, java.lang.Object[], org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSAttributeChecker" name="java.lang.Object[] getAvailableArray()" map="A"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser$FacetInfo" map="_A"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser$FacetInfo" name="fFixedFacets" map="A"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser$FacetInfo" name="fPresentFacets" map="B"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser$FacetInfo" name="nodeAfterFacets" map="C"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser$FacetInfo" name="facetdata" map="D"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" map="V"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="fPattern" map="A"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="fValidationState" map="B"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="fSymbolTable" map="C"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="fQNameDV" map="D"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="fValidateAnnotations" map="E"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="fAttrChecker" map="F"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="fSchemaHandler" map="G"/>
  <field class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="xsFacets" map="H"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="org.apache.xerces.impl.xs.XSParticleDecl checkOccurrences(org.apache.xerces.impl.xs.XSParticleDecl, java.lang.String, org.w3c.dom.Element, int, long)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser$FacetInfo traverseFacets(org.w3c.dom.Element, org.apache.xerces.impl.dv.XSSimpleType, org.apache.xerces.impl.xs.traversers.XSDocumentInfo)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="java.lang.String escapeAttValue(java.lang.String, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="java.lang.String processAttValue(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="void checkNotationType(java.lang.String, org.apache.xerces.xs.XSTypeDefinition, org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="void reportSchemaError(java.lang.String, java.lang.Object[], org.w3c.dom.Element)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="void reset(org.apache.xerces.util.SymbolTable, boolean, java.util.Locale)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="org.apache.xerces.impl.xs.XSAnnotationImpl traverseAnnotationDecl(org.w3c.dom.Element, java.lang.Object[], boolean, org.apache.xerces.impl.xs.traversers.XSDocumentInfo)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="org.w3c.dom.Element traverseAttrsAndAttrGrps(org.w3c.dom.Element, org.apache.xerces.impl.xs.XSAttributeGroupDecl, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar, org.apache.xerces.impl.xs.XSComplexTypeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="boolean containsQName(org.apache.xerces.impl.dv.XSSimpleType)" map="A"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDAbstractTraverser" name="org.apache.xerces.impl.xs.XSAnnotationImpl traverseSyntheticAnnotation(org.w3c.dom.Element, java.lang.String, java.lang.Object[], boolean, org.apache.xerces.impl.xs.traversers.XSDocumentInfo)" map="A"/>
  <class name="org.apache.xerces.impl.xs.traversers.XSDWildcardTraverser" map="W"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDWildcardTraverser" name="org.apache.xerces.impl.xs.XSWildcardDecl traverseAnyAttribute(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="L"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDWildcardTraverser" name="org.apache.xerces.impl.xs.XSParticleDecl traverseAny(org.w3c.dom.Element, org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="M"/>
  <method class="org.apache.xerces.impl.xs.traversers.XSDWildcardTraverser" name="org.apache.xerces.impl.xs.XSWildcardDecl traverseWildcardDecl(org.w3c.dom.Element, java.lang.Object[], org.apache.xerces.impl.xs.traversers.XSDocumentInfo, org.apache.xerces.impl.xs.SchemaGrammar)" map="B"/>
  <package name="org.apache.xerces.impl.xs.models" map="E"/>
  <class name="org.apache.xerces.impl.xs.models.CMBuilder" map="A"/>
  <field class="org.apache.xerces.impl.xs.models.CMBuilder" name="fEmptyCM" map="A"/>
  <field class="org.apache.xerces.impl.xs.models.CMBuilder" name="fNodeFactory" map="B"/>
  <field class="org.apache.xerces.impl.xs.models.CMBuilder" name="fLeafCount" map="C"/>
  <field class="org.apache.xerces.impl.xs.models.CMBuilder" name="fDeclPool" map="D"/>
  <field class="org.apache.xerces.impl.xs.models.CMBuilder" name="fParticleCount" map="E"/>
  <method class="org.apache.xerces.impl.xs.models.CMBuilder" name="boolean useRepeatingLeafNodes(org.apache.xerces.impl.xs.XSParticleDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.CMBuilder" name="org.apache.xerces.impl.dtd.models.CMNode copyNode(org.apache.xerces.impl.dtd.models.CMNode)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.CMBuilder" name="org.apache.xerces.impl.dtd.models.CMNode buildSyntaxTree(org.apache.xerces.impl.xs.XSParticleDecl, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.CMBuilder" name="void setDeclPool(org.apache.xerces.impl.xs.XSDeclarationPool)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.CMBuilder" name="org.apache.xerces.impl.xs.models.XSCMValidator createDFACM(org.apache.xerces.impl.xs.XSParticleDecl, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.CMBuilder" name="org.apache.xerces.impl.xs.models.XSCMValidator createAllCM(org.apache.xerces.impl.xs.XSParticleDecl)" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.CMBuilder" name="org.apache.xerces.impl.dtd.models.CMNode buildCompactSyntaxTree2(org.apache.xerces.impl.xs.XSParticleDecl, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.CMBuilder" name="org.apache.xerces.impl.xs.models.XSCMValidator getContentModel(org.apache.xerces.impl.xs.XSComplexTypeDecl, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.CMBuilder" name="org.apache.xerces.impl.dtd.models.CMNode expandContentModel(org.apache.xerces.impl.dtd.models.CMNode, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.CMBuilder" name="org.apache.xerces.impl.dtd.models.CMNode buildCompactSyntaxTree(org.apache.xerces.impl.xs.XSParticleDecl)" map="C"/>
  <method class="org.apache.xerces.impl.xs.models.CMBuilder" name="org.apache.xerces.impl.dtd.models.CMNode multiNodes(org.apache.xerces.impl.dtd.models.CMNode, int, boolean)" map="A"/>
  <class name="org.apache.xerces.impl.xs.models.XSAllCM" map="B"/>
  <field class="org.apache.xerces.impl.xs.models.XSAllCM" name="fHasOptionalContent" map="Q"/>
  <field class="org.apache.xerces.impl.xs.models.XSAllCM" name="fNumElements" map="R"/>
  <field class="org.apache.xerces.impl.xs.models.XSAllCM" name="fIsOptionalElement" map="S"/>
  <field class="org.apache.xerces.impl.xs.models.XSAllCM" name="fAllElements" map="T"/>
  <method class="org.apache.xerces.impl.xs.models.XSAllCM" name="java.lang.String getTermName(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSAllCM" name="boolean endContentModel(int[])" map="C"/>
  <method class="org.apache.xerces.impl.xs.models.XSAllCM" name="int[] startContentModel()" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.XSAllCM" name="java.util.Vector whatCanGoHere(int[])" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.XSAllCM" name="boolean checkUniqueParticleAttribution(org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSAllCM" name="int[] occurenceInfo(int[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSAllCM" name="java.lang.Object findMatchingDecl(org.apache.xerces.xni.QName, org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.XSAllCM" name="java.lang.Object oneTransition(org.apache.xerces.xni.QName, int[], org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSAllCM" name="boolean isCompactedForUPA()" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSAllCM" name="void addElement(org.apache.xerces.impl.xs.XSElementDecl, boolean)" map="A"/>
  <class name="org.apache.xerces.impl.xs.models.CMNodeFactory" map="C"/>
  <field class="org.apache.xerces.impl.xs.models.CMNodeFactory" name="nodeCount" map="A"/>
  <field class="org.apache.xerces.impl.xs.models.CMNodeFactory" name="fSecurityManager" map="B"/>
  <field class="org.apache.xerces.impl.xs.models.CMNodeFactory" name="fErrorReporter" map="C"/>
  <field class="org.apache.xerces.impl.xs.models.CMNodeFactory" name="maxNodeLimit" map="D"/>
  <method class="org.apache.xerces.impl.xs.models.CMNodeFactory" name="org.apache.xerces.impl.dtd.models.CMNode getCMBinOpNode(int, org.apache.xerces.impl.dtd.models.CMNode, org.apache.xerces.impl.dtd.models.CMNode)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.CMNodeFactory" name="void reset()" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.CMNodeFactory" name="void resetNodeCount()" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.CMNodeFactory" name="org.apache.xerces.impl.dtd.models.CMNode getCMLeafNode(int, java.lang.Object, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.CMNodeFactory" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.CMNodeFactory" name="org.apache.xerces.impl.dtd.models.CMNode getCMUniOpNode(int, org.apache.xerces.impl.dtd.models.CMNode)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.CMNodeFactory" name="org.apache.xerces.impl.dtd.models.CMNode getCMRepeatingLeafNode(int, java.lang.Object, int, int, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.CMNodeFactory" name="void nodeCountCheck()" map="C"/>
  <class name="org.apache.xerces.impl.xs.models.XSCMRepeatingLeaf" map="D"/>
  <field class="org.apache.xerces.impl.xs.models.XSCMRepeatingLeaf" name="fMinOccurs" map="U"/>
  <field class="org.apache.xerces.impl.xs.models.XSCMRepeatingLeaf" name="fMaxOccurs" map="V"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMRepeatingLeaf" name="int getMinOccurs()" map="R"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMRepeatingLeaf" name="int getMaxOccurs()" map="S"/>
  <class name="org.apache.xerces.impl.xs.models.XSDFACM$Occurence" map="_A"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM$Occurence" name="elemIndex" map="A"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM$Occurence" name="maxOccurs" map="B"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM$Occurence" name="minOccurs" map="C"/>
  <method class="org.apache.xerces.impl.xs.models.XSDFACM$Occurence" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.xs.models.XSDFACM" map="E"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM" name="fElemMap" map="A"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM" name="fElemMapId" map="B"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM" name="time" map="C"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM" name="fTransTable" map="D"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM" name="fTransTableSize" map="E"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM" name="fHeadNode" map="F"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM" name="fLeafListType" map="G"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM" name="fElemMapType" map="H"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM" name="fFinalStateFlags" map="I"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM" name="fIsCompactedForUPA" map="J"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM" name="fFollowList" map="K"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM" name="fCountingStates" map="L"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM" name="fElemMapSize" map="M"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM" name="fLeafList" map="N"/>
  <field class="org.apache.xerces.impl.xs.models.XSDFACM" name="fLeafCount" map="O"/>
  <method class="org.apache.xerces.impl.xs.models.XSDFACM" name="java.lang.String getTermName(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSDFACM" name="void calcFollowList(org.apache.xerces.impl.dtd.models.CMNode)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSDFACM" name="boolean endContentModel(int[])" map="C"/>
  <method class="org.apache.xerces.impl.xs.models.XSDFACM" name="void buildDFA(org.apache.xerces.impl.dtd.models.CMNode)" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.XSDFACM" name="int[] startContentModel()" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.XSDFACM" name="void postTreeBuildInit(org.apache.xerces.impl.dtd.models.CMNode)" map="C"/>
  <method class="org.apache.xerces.impl.xs.models.XSDFACM" name="java.util.Vector whatCanGoHere(int[])" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.XSDFACM" name="boolean checkUniqueParticleAttribution(org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSDFACM" name="java.lang.Object findMatchingDecl(org.apache.xerces.xni.QName, int[], org.apache.xerces.impl.xs.SubstitutionGroupHandler, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSDFACM" name="int[] makeDefStateList()" map="C"/>
  <method class="org.apache.xerces.impl.xs.models.XSDFACM" name="int[] occurenceInfo(int[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSDFACM" name="java.lang.Object findMatchingDecl(org.apache.xerces.xni.QName, org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSDFACM" name="java.lang.Object oneTransition(org.apache.xerces.xni.QName, int[], org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSDFACM" name="boolean isCompactedForUPA()" map="A"/>
  <class name="org.apache.xerces.impl.xs.models.XSCMUniOp" map="F"/>
  <field class="org.apache.xerces.impl.xs.models.XSCMUniOp" name="fChild" map="G"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMUniOp" name="boolean isNullable()" map="D"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMUniOp" name="org.apache.xerces.impl.dtd.models.CMNode getChild()" map="F"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMUniOp" name="void calcFirstPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMUniOp" name="void calcLastPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="A"/>
  <class name="org.apache.xerces.impl.xs.models.XSCMBinOp" map="G"/>
  <field class="org.apache.xerces.impl.xs.models.XSCMBinOp" name="fRightChild" map="H"/>
  <field class="org.apache.xerces.impl.xs.models.XSCMBinOp" name="fLeftChild" map="I"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMBinOp" name="boolean isNullable()" map="D"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMBinOp" name="org.apache.xerces.impl.dtd.models.CMNode getLeft()" map="G"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMBinOp" name="void calcFirstPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMBinOp" name="org.apache.xerces.impl.dtd.models.CMNode getRight()" map="H"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMBinOp" name="void calcLastPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="A"/>
  <class name="org.apache.xerces.impl.xs.models.XSEmptyCM" map="H"/>
  <field class="org.apache.xerces.impl.xs.models.XSEmptyCM" name="EMPTY" map="P"/>
  <method class="org.apache.xerces.impl.xs.models.XSEmptyCM" name="boolean isCompactedForUPA()" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSEmptyCM" name="java.lang.String getTermName(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSEmptyCM" name="java.lang.Object oneTransition(org.apache.xerces.xni.QName, int[], org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSEmptyCM" name="int[] startContentModel()" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.XSEmptyCM" name="int[] occurenceInfo(int[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSEmptyCM" name="boolean checkUniqueParticleAttribution(org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSEmptyCM" name="java.util.Vector whatCanGoHere(int[])" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.XSEmptyCM" name="boolean endContentModel(int[])" map="C"/>
  <class name="org.apache.xerces.impl.xs.models.XSCMValidator" map="I"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMValidator" name="boolean isCompactedForUPA()" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMValidator" name="java.lang.String getTermName(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMValidator" name="java.lang.Object oneTransition(org.apache.xerces.xni.QName, int[], org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMValidator" name="int[] startContentModel()" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMValidator" name="int[] occurenceInfo(int[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMValidator" name="boolean checkUniqueParticleAttribution(org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMValidator" name="java.util.Vector whatCanGoHere(int[])" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMValidator" name="boolean endContentModel(int[])" map="C"/>
  <class name="org.apache.xerces.impl.xs.models.XSCMLeaf" map="J"/>
  <field class="org.apache.xerces.impl.xs.models.XSCMLeaf" name="fParticleId" map="R"/>
  <field class="org.apache.xerces.impl.xs.models.XSCMLeaf" name="fLeaf" map="S"/>
  <field class="org.apache.xerces.impl.xs.models.XSCMLeaf" name="fPosition" map="T"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMLeaf" name="int getParticleId()" map="O"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMLeaf" name="boolean isNullable()" map="D"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMLeaf" name="void calcFirstPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="B"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMLeaf" name="java.lang.Object getLeaf()" map="P"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMLeaf" name="void calcLastPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="A"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMLeaf" name="int getPosition()" map="Q"/>
  <method class="org.apache.xerces.impl.xs.models.XSCMLeaf" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.xs.XSAttributeGroupDecl" map="A"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="fNamespaceItem" map="&#x00cb;"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="fTargetNamespace" map="&#x00cc;"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="fIDAttrName" map="&#x00cd;"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="fAnnotations" map="&#x00ce;"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="fAttributeUses" map="&#x00cf;"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="fAttrUseNum" map="&#x00d0;"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="fName" map="&#x00d1;"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="fAttrUses" map="&#x00d2;"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="fAttributeWC" map="&#x00d3;"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="void removeProhibitedAttrs()" map="q"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="java.lang.Object[] validRestrictionOf(java.lang.String, org.apache.xerces.impl.xs.XSAttributeGroupDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="void setNamespaceItem(org.apache.xerces.xs.XSNamespaceItem)" map="E"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="org.apache.xerces.xs.XSObjectList getAttributeUses()" map="p"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="void replaceAttributeUse(org.apache.xerces.xs.XSAttributeUse, org.apache.xerces.impl.xs.XSAttributeUseImpl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="java.lang.String addAttributeUse(org.apache.xerces.impl.xs.XSAttributeUseImpl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="java.lang.String getNamespace()" map="D"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="short getType()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="org.apache.xerces.xs.XSAttributeUse getAttributeUseNoProhibited(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="org.apache.xerces.xs.XSNamespaceItem getNamespaceItem()" map="C"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="org.apache.xerces.impl.xs.XSAttributeUseImpl[] resize(org.apache.xerces.impl.xs.XSAttributeUseImpl[], int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeGroupDecl" name="org.apache.xerces.xs.XSAttributeUse getAttributeUse(java.lang.String, java.lang.String)" map="B"/>
  <class name="org.apache.xerces.impl.xs.XSDeclarationPool" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSDeclarationPool" name="org.apache.xerces.impl.xs.XSAttributeUseImpl getAttributeUse()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSDeclarationPool" name="void reset()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSDeclarationPool" name="org.apache.xerces.impl.xs.XSAttributeDecl getAttributeDecl()" map="C"/>
  <method class="org.apache.xerces.impl.xs.XSDeclarationPool" name="org.apache.xerces.impl.xs.XSElementDecl getElementDecl()" map="D"/>
  <method class="org.apache.xerces.impl.xs.XSDeclarationPool" name="org.apache.xerces.impl.xs.XSParticleDecl getParticleDecl()" map="E"/>
  <class name="org.apache.xerces.impl.xs.XSWildcardDecl" map="C"/>
  <field class="org.apache.xerces.impl.xs.XSWildcardDecl" name="fDescription" map="r"/>
  <field class="org.apache.xerces.impl.xs.XSWildcardDecl" name="fAnnotations" map="s"/>
  <field class="org.apache.xerces.impl.xs.XSWildcardDecl" name="fNamespaceList" map="t"/>
  <field class="org.apache.xerces.impl.xs.XSWildcardDecl" name="fProcessContents" map="u"/>
  <field class="org.apache.xerces.impl.xs.XSWildcardDecl" name="fType" map="v"/>
  <field class="org.apache.xerces.impl.xs.XSWildcardDecl" name="ABSENT" map="w"/>
  <method class="org.apache.xerces.impl.xs.XSWildcardDecl" name="boolean allowNamespace(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSWildcardDecl" name="java.lang.String[] intersect2sets(java.lang.String[], java.lang.String[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSWildcardDecl" name="org.apache.xerces.impl.xs.XSWildcardDecl performIntersectionWith(org.apache.xerces.impl.xs.XSWildcardDecl, short)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSWildcardDecl" name="org.apache.xerces.impl.xs.XSWildcardDecl performUnionWith(org.apache.xerces.impl.xs.XSWildcardDecl, short)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSWildcardDecl" name="boolean areSame(org.apache.xerces.impl.xs.XSWildcardDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSWildcardDecl" name="java.lang.String getNamespace()" map="D"/>
  <method class="org.apache.xerces.impl.xs.XSWildcardDecl" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSWildcardDecl" name="boolean weakerProcessContents(org.apache.xerces.impl.xs.XSWildcardDecl)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSWildcardDecl" name="short getType()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSWildcardDecl" name="boolean subset2sets(java.lang.String[], java.lang.String[])" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSWildcardDecl" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.xs.XSWildcardDecl" name="boolean elementInSet(java.lang.String, java.lang.String[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSWildcardDecl" name="boolean isSubsetOf(org.apache.xerces.impl.xs.XSWildcardDecl)" map="C"/>
  <method class="org.apache.xerces.impl.xs.XSWildcardDecl" name="java.lang.String[] union2sets(java.lang.String[], java.lang.String[])" map="C"/>
  <method class="org.apache.xerces.impl.xs.XSWildcardDecl" name="java.lang.String getProcessContentsAsString()" map="d"/>
  <class name="org.apache.xerces.impl.xs.XSElementDecl" map="D"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fScope" map="x"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fEnclosingCT" map="y"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fNamespaceItem" map="z"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fIDCPos" map="&#x00a2;"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fType" map="&#x00a3;"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fTargetNamespace" map="&#x00a4;"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fAnnotations" map="&#x00a5;"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fDefault" map="&#x00aa;"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fFinal" map="&#x00b5;"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fBlock" map="&#x00ba;"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fSubGroup" map="&#x00c0;"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fUnresolvedTypeName" map="&#x00c1;"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fDescription" map="&#x00c2;"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fName" map="&#x00c3;"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fIDConstraints" map="&#x00c4;"/>
  <field class="org.apache.xerces.impl.xs.XSElementDecl" name="fMiscFlags" map="&#x00c5;"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="org.apache.xerces.xs.XSTypeDefinition getTypeDefinition()" map="e"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="boolean getNillable()" map="h"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="void addIDConstraint(org.apache.xerces.impl.xs.identity.IdentityConstraint)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="void setConstraintType(short)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="boolean getAbstract()" map="i"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="void setNamespaceItem(org.apache.xerces.xs.XSNamespaceItem)" map="D"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="short getConstraintType()" map="j"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="org.apache.xerces.impl.xs.identity.IdentityConstraint[] resize(org.apache.xerces.impl.xs.identity.IdentityConstraint[], int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="void setIsGlobal()" map="k"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="org.apache.xerces.xs.XSElementDeclaration getSubstitutionGroupAffiliation()" map="f"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="short getType()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="short getScope()" map="g"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="void setIsLocal(org.apache.xerces.impl.xs.XSComplexTypeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="void setIsNillable()" map="l"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="org.apache.xerces.xs.XSNamespaceItem getNamespaceItem()" map="C"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="void setIsAbstract()" map="m"/>
  <method class="org.apache.xerces.impl.xs.XSElementDecl" name="java.lang.String getNamespace()" map="D"/>
  <class name="org.apache.xerces.impl.xs.XSAttributeUseImpl" map="E"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeUseImpl" name="fAnnotations" map="&#x00c6;"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeUseImpl" name="fConstraintType" map="&#x00c7;"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeUseImpl" name="fDefault" map="&#x00c8;"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeUseImpl" name="fUse" map="&#x00c9;"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeUseImpl" name="fAttrDecl" map="&#x00ca;"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeUseImpl" name="short getType()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeUseImpl" name="boolean getRequired()" map="o"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeUseImpl" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeUseImpl" name="org.apache.xerces.xs.XSAttributeDeclaration getAttrDeclaration()" map="n"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeUseImpl" name="java.lang.String getNamespace()" map="D"/>
  <class name="org.apache.xerces.impl.xs.XSAnnotationImpl" map="F"/>
  <field class="org.apache.xerces.impl.xs.XSAnnotationImpl" name="fData" map="A"/>
  <field class="org.apache.xerces.impl.xs.XSAnnotationImpl" name="fGrammar" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSAnnotationImpl" name="short getType()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSAnnotationImpl" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSAnnotationImpl" name="java.lang.String getNamespace()" map="D"/>
  <class name="org.apache.xerces.impl.xs.XSGroupDecl" map="G"/>
  <field class="org.apache.xerces.impl.xs.XSGroupDecl" name="fAnnotations" map="b"/>
  <field class="org.apache.xerces.impl.xs.XSGroupDecl" name="fTargetNamespace" map="c"/>
  <field class="org.apache.xerces.impl.xs.XSGroupDecl" name="fNamespaceItem" map="d"/>
  <field class="org.apache.xerces.impl.xs.XSGroupDecl" name="fName" map="e"/>
  <field class="org.apache.xerces.impl.xs.XSGroupDecl" name="fModelGroup" map="f"/>
  <method class="org.apache.xerces.impl.xs.XSGroupDecl" name="org.apache.xerces.xs.XSModelGroup getModelGroup()" map="V"/>
  <method class="org.apache.xerces.impl.xs.XSGroupDecl" name="short getType()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSGroupDecl" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSGroupDecl" name="org.apache.xerces.xs.XSNamespaceItem getNamespaceItem()" map="C"/>
  <method class="org.apache.xerces.impl.xs.XSGroupDecl" name="java.lang.String getNamespace()" map="D"/>
  <method class="org.apache.xerces.impl.xs.XSGroupDecl" name="void setNamespaceItem(org.apache.xerces.xs.XSNamespaceItem)" map="B"/>
  <class name="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" map="_A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalComplexTypeDecl(org.apache.xerces.impl.xs.XSComplexTypeDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalAttributeDecl(org.apache.xerces.impl.xs.XSAttributeDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalComplexTypeDecl(org.apache.xerces.impl.xs.XSComplexTypeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalGroupDecl(org.apache.xerces.impl.xs.XSGroupDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalAttributeDecl(org.apache.xerces.impl.xs.XSAttributeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addDocument(java.lang.Object, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalTypeDecl(org.apache.xerces.xs.XSTypeDefinition)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalElementDeclAll(org.apache.xerces.impl.xs.XSElementDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalTypeDecl(org.apache.xerces.xs.XSTypeDefinition, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalAttributeGroupDecl(org.apache.xerces.impl.xs.XSAttributeGroupDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalElementDecl(org.apache.xerces.impl.xs.XSElementDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addRedefinedGroupDecl(org.apache.xerces.impl.xs.XSGroupDecl, org.apache.xerces.impl.xs.XSGroupDecl, org.apache.xerces.impl.xs.util.SimpleLocator)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void setImportedGrammars(java.util.Vector)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalNotationDecl(org.apache.xerces.impl.xs.XSNotationDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalNotationDecl(org.apache.xerces.impl.xs.XSNotationDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalSimpleTypeDecl(org.apache.xerces.impl.dv.XSSimpleType)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalGroupDecl(org.apache.xerces.impl.xs.XSGroupDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addComplexTypeDecl(org.apache.xerces.impl.xs.XSComplexTypeDecl, org.apache.xerces.impl.xs.util.SimpleLocator)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalElementDecl(org.apache.xerces.impl.xs.XSElementDecl)" map="B"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalAttributeGroupDecl(org.apache.xerces.impl.xs.XSAttributeGroupDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinSchemaGrammar" name="void addGlobalSimpleTypeDecl(org.apache.xerces.impl.dv.XSSimpleType, java.lang.String)" map="A"/>
  <class name="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinAttrDecl" map="_B"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$BuiltinAttrDecl" name="org.apache.xerces.xs.XSNamespaceItem getNamespaceItem()" map="C"/>
  <class name="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" map="_C"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="INSTANCE" map="&#x0195;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalComplexTypeDecl(org.apache.xerces.impl.xs.XSComplexTypeDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalComplexTypeDecl(org.apache.xerces.impl.xs.XSComplexTypeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="org.apache.xerces.impl.xs.XSParticleDecl createUnboundedAnyWildcardSequenceParticle()" map="&#x00c4;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalGroupDecl(org.apache.xerces.impl.xs.XSGroupDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalAttributeDecl(org.apache.xerces.impl.xs.XSAttributeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="org.apache.xerces.impl.xs.XSParticleDecl createAnyLaxWildcardParticle()" map="&#x00c5;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="org.apache.xerces.impl.xs.XSParticleDecl createChoiceElementParticle(org.apache.xerces.impl.xs.XSElementDecl)" map="C"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addDocument(java.lang.Object, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalTypeDecl(org.apache.xerces.xs.XSTypeDefinition)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalElementDeclAll(org.apache.xerces.impl.xs.XSElementDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="org.apache.xerces.impl.xs.XSParticleDecl createUnboundedModelGroupParticle()" map="&#x00c6;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalTypeDecl(org.apache.xerces.xs.XSTypeDefinition, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalAttributeGroupDecl(org.apache.xerces.impl.xs.XSAttributeGroupDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalElementDecl(org.apache.xerces.impl.xs.XSElementDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addRedefinedGroupDecl(org.apache.xerces.impl.xs.XSGroupDecl, org.apache.xerces.impl.xs.XSGroupDecl, org.apache.xerces.impl.xs.util.SimpleLocator)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void setImportedGrammars(java.util.Vector)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalNotationDecl(org.apache.xerces.impl.xs.XSNotationDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalNotationDecl(org.apache.xerces.impl.xs.XSNotationDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalSimpleTypeDecl(org.apache.xerces.impl.dv.XSSimpleType)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalGroupDecl(org.apache.xerces.impl.xs.XSGroupDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addComplexTypeDecl(org.apache.xerces.impl.xs.XSComplexTypeDecl, org.apache.xerces.impl.xs.util.SimpleLocator)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="org.apache.xerces.impl.xs.XSElementDecl createAnnotationElementDecl(java.lang.String)" map="b"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalElementDecl(org.apache.xerces.impl.xs.XSElementDecl)" map="B"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalAttributeGroupDecl(org.apache.xerces.impl.xs.XSAttributeGroupDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$Schema4Annotations" name="void addGlobalSimpleTypeDecl(org.apache.xerces.impl.dv.XSSimpleType, java.lang.String)" map="A"/>
  <class name="org.apache.xerces.impl.xs.SchemaGrammar$XSAnyType" map="_D"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$XSAnyType" name="org.apache.xerces.xs.XSObjectList getAttributeUses()" map="&#x00f4;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$XSAnyType" name="org.apache.xerces.impl.xs.XSAttributeGroupDecl getAttrGrp()" map="&#x00f6;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$XSAnyType" name="void setName(java.lang.String)" map="Q"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$XSAnyType" name="org.apache.xerces.xs.XSNamespaceItem getNamespaceItem()" map="C"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$XSAnyType" name="org.apache.xerces.xs.XSParticle getParticle()" map="&#x00f9;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar$XSAnyType" name="void setIsAnonymous()" map="&#x00f3;"/>
  <class name="org.apache.xerces.impl.xs.SchemaGrammar" map="H"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fComponentsExt" map="&#x016a;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fCTCount" map="&#x016b;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fGlobalAttrGrpDecls" map="&#x016c;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fSubGroupCount" map="&#x016d;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fAllGlobalElemDecls" map="&#x016e;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fImported" map="&#x016f;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fGlobalTypeDecls" map="&#x0170;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fRedefinedGroupDecls" map="&#x0171;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fDocuments" map="&#x0172;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fGlobalGroupDeclsExt" map="&#x0173;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fGlobalNotationDeclsExt" map="&#x0174;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fGlobalAttrGrpDeclsExt" map="&#x0175;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="SG_XSI" map="&#x0176;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fCTLocators" map="&#x0177;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="GLOBAL_COMP" map="&#x0178;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fRGCount" map="&#x0179;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fComponents" map="&#x017a;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="SG_SchemaNS" map="&#x017b;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fGlobalAttrDecls" map="&#x017c;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fIsImmutable" map="&#x017d;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fGlobalAttrDeclsExt" map="&#x017e;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fGlobalIDConstraintDecls" map="&#x017f;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fAnnotations" map="&#x0180;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fGlobalTypeDeclsExt" map="&#x0181;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fComplexTypeDecls" map="&#x0182;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fNumAnnotations" map="&#x0183;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fDOMParser" map="&#x0184;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fGlobalNotationDecls" map="&#x0185;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fSymbolTable" map="&#x0186;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fSubGroups" map="&#x0187;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fAnyType" map="&#x0188;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fFullChecked" map="&#x0189;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fAnySimpleType" map="&#x018a;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fGlobalGroupDecls" map="&#x018b;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fGlobalElemDeclsExt" map="&#x018c;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fTargetNamespace" map="&#x018d;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fGlobalElemDecls" map="&#x018e;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fSAXParser" map="&#x018f;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fGrammarDescription" map="&#x0190;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fRGLocators" map="&#x0191;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fLocations" map="&#x0192;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="SG_SchemaNSExtended" map="&#x0193;"/>
  <field class="org.apache.xerces.impl.xs.SchemaGrammar" name="fGlobalIDConstraintDeclsExt" map="&#x0194;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSAttributeDecl getGlobalAttributeDecl(java.lang.String, java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addRedefinedGroupDecl(org.apache.xerces.impl.xs.XSGroupDecl, org.apache.xerces.impl.xs.XSGroupDecl, org.apache.xerces.impl.xs.util.SimpleLocator)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSAttributeGroupDecl getGlobalAttributeGroupDecl(java.lang.String)" map="S"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.xs.XSNamedMap getComponents(short)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.util.SimpleLocator[] resize(org.apache.xerces.impl.xs.util.SimpleLocator[], int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.xs.XSTypeDefinition getTypeDefinition(java.lang.String)" map="T"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSComplexTypeDecl[] getUncheckedComplexTypeDecls()" map="&#x00a3;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSElementDecl[] resize(org.apache.xerces.impl.xs.XSElementDecl[], int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalSimpleTypeDecl(org.apache.xerces.impl.dv.XSSimpleType, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSNotationDecl getGlobalNotationDecl(java.lang.String, java.lang.String)" map="D"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalTypeDecl(org.apache.xerces.xs.XSTypeDefinition, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.identity.IdentityConstraint getIDConstraintDecl(java.lang.String, java.lang.String)" map="E"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.xs.XSTypeDefinition getGlobalTypeDecl(java.lang.String, java.lang.String)" map="F"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalNotationDecl(org.apache.xerces.impl.xs.XSNotationDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSAttributeGroupDecl getGlobalAttributeGroupDecl(java.lang.String, java.lang.String)" map="G"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalTypeDecl(org.apache.xerces.xs.XSTypeDefinition)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSElementDecl getGlobalElementDecl(java.lang.String)" map="U"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalElementDeclAll(org.apache.xerces.impl.xs.XSElementDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addDocument(java.lang.Object, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSGroupDecl getGlobalGroupDecl(java.lang.String)" map="V"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSElementDecl getGlobalElementDecl(java.lang.String, java.lang.String)" map="H"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalElementDecl(org.apache.xerces.impl.xs.XSElementDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="boolean isImmutable()" map="&#x00a4;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalAttributeGroupDecl(org.apache.xerces.impl.xs.XSAttributeGroupDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSComplexTypeDecl[] resize(org.apache.xerces.impl.xs.XSComplexTypeDecl[], int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalGroupDecl(org.apache.xerces.impl.xs.XSGroupDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSElementDecl[] getSubstitutionGroups()" map="&#x00a5;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.util.SimpleLocator[] getUncheckedCTLocators()" map="&#x00aa;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalSimpleTypeDecl(org.apache.xerces.impl.dv.XSSimpleType)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addIDConstraintDecl(org.apache.xerces.impl.xs.XSElementDecl, org.apache.xerces.impl.xs.identity.IdentityConstraint)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.xs.XSAttributeDeclaration getAttributeDeclaration(java.lang.String)" map="W"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalElementDecl(org.apache.xerces.impl.xs.XSElementDecl)" map="B"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSAttributeDecl getGlobalAttributeDecl(java.lang.String)" map="X"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalAttributeDecl(org.apache.xerces.impl.xs.XSAttributeDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void resetComponents()" map="&#x00b5;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalComplexTypeDecl(org.apache.xerces.impl.xs.XSComplexTypeDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSGroupDecl[] getRedefinedGroupDecls()" map="&#x00ba;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalAttributeGroupDecl(org.apache.xerces.impl.xs.XSAttributeGroupDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void setImportedGrammars(java.util.Vector)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalAttributeDecl(org.apache.xerces.impl.xs.XSAttributeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addIDConstraintDecl(org.apache.xerces.impl.xs.XSElementDecl, org.apache.xerces.impl.xs.identity.IdentityConstraint, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void setImmutable(boolean)" map="G"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.xs.XSElementDeclaration getElementDeclaration(java.lang.String)" map="Y"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.xs.datatypes.ObjectList getComponentsExt(short)" map="B"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="java.lang.String getTargetNamespace()" map="&#x00c0;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSNotationDecl getGlobalNotationDecl(java.lang.String)" map="Z"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.xs.XSTypeDefinition getGlobalTypeDecl(java.lang.String)" map="_"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addComplexTypeDecl(org.apache.xerces.impl.xs.XSComplexTypeDecl, org.apache.xerces.impl.xs.util.SimpleLocator)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="java.util.Vector getImportedGrammars()" map="&#x00c1;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.xs.StringList getDocumentLocations()" map="&#x00c2;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void setUncheckedTypeNum(int)" map="V"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalGroupDecl(org.apache.xerces.impl.xs.XSGroupDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.util.SimpleLocator[] getRGLocators()" map="&#x00c3;"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addAnnotation(org.apache.xerces.impl.xs.XSAnnotationImpl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSGroupDecl[] resize(org.apache.xerces.impl.xs.XSGroupDecl[], int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.XSGroupDecl getGlobalGroupDecl(java.lang.String, java.lang.String)" map="I"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="org.apache.xerces.impl.xs.identity.IdentityConstraint getIDConstraintDecl(java.lang.String)" map="a"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalNotationDecl(org.apache.xerces.impl.xs.XSNotationDecl, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaGrammar" name="void addGlobalComplexTypeDecl(org.apache.xerces.impl.xs.XSComplexTypeDecl)" map="A"/>
  <class name="org.apache.xerces.impl.xs.SchemaNamespaceSupport$SchemaRootContext" map="_A"/>
  <field class="org.apache.xerces.impl.xs.SchemaNamespaceSupport$SchemaRootContext" name="fSymbolTable" map="A"/>
  <field class="org.apache.xerces.impl.xs.SchemaNamespaceSupport$SchemaRootContext" name="fNamespace" map="B"/>
  <field class="org.apache.xerces.impl.xs.SchemaNamespaceSupport$SchemaRootContext" name="fSchemaRoot" map="C"/>
  <field class="org.apache.xerces.impl.xs.SchemaNamespaceSupport$SchemaRootContext" name="fDOMContextBuilt" map="D"/>
  <field class="org.apache.xerces.impl.xs.SchemaNamespaceSupport$SchemaRootContext" name="fAttributeQName" map="E"/>
  <field class="org.apache.xerces.impl.xs.SchemaNamespaceSupport$SchemaRootContext" name="fNamespaceSize" map="F"/>
  <method class="org.apache.xerces.impl.xs.SchemaNamespaceSupport$SchemaRootContext" name="void declarePrefix(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaNamespaceSupport$SchemaRootContext" name="void fillNamespaceContext()" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaNamespaceSupport$SchemaRootContext" name="void fillQName(org.apache.xerces.xni.QName, org.w3c.dom.Node)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaNamespaceSupport$SchemaRootContext" name="java.lang.String getURI(java.lang.String)" map="A"/>
  <class name="org.apache.xerces.impl.xs.SchemaNamespaceSupport" map="I"/>
  <field class="org.apache.xerces.impl.xs.SchemaNamespaceSupport" name="fSchemaRootContext" map="H"/>
  <method class="org.apache.xerces.impl.xs.SchemaNamespaceSupport" name="void makeGlobal()" map="F"/>
  <method class="org.apache.xerces.impl.xs.SchemaNamespaceSupport" name="void setEffectiveContext(java.lang.String[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.SchemaNamespaceSupport" name="java.lang.String[] getEffectiveLocalContext()" map="G"/>
  <method class="org.apache.xerces.impl.xs.SchemaNamespaceSupport" name="java.lang.String getURI(java.lang.String)" map="A"/>
  <class name="org.apache.xerces.impl.xs.XSParticleDecl" map="J"/>
  <field class="org.apache.xerces.impl.xs.XSParticleDecl" name="fMinOccurs" map="M"/>
  <field class="org.apache.xerces.impl.xs.XSParticleDecl" name="fDescription" map="N"/>
  <field class="org.apache.xerces.impl.xs.XSParticleDecl" name="fValue" map="O"/>
  <field class="org.apache.xerces.impl.xs.XSParticleDecl" name="fAnnotations" map="P"/>
  <field class="org.apache.xerces.impl.xs.XSParticleDecl" name="fType" map="Q"/>
  <field class="org.apache.xerces.impl.xs.XSParticleDecl" name="fMaxOccurs" map="R"/>
  <method class="org.apache.xerces.impl.xs.XSParticleDecl" name="int maxEffectiveTotalRange()" map="K"/>
  <method class="org.apache.xerces.impl.xs.XSParticleDecl" name="void appendParticle(java.lang.StringBuffer)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSParticleDecl" name="int minEffectiveTotalRange()" map="L"/>
  <method class="org.apache.xerces.impl.xs.XSParticleDecl" name="org.apache.xerces.xs.XSTerm getTerm()" map="J"/>
  <method class="org.apache.xerces.impl.xs.XSParticleDecl" name="boolean getMaxOccursUnbounded()" map="M"/>
  <method class="org.apache.xerces.impl.xs.XSParticleDecl" name="boolean emptiable()" map="N"/>
  <method class="org.apache.xerces.impl.xs.XSParticleDecl" name="java.lang.String getNamespace()" map="D"/>
  <method class="org.apache.xerces.impl.xs.XSParticleDecl" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSParticleDecl" name="short getType()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSParticleDecl" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.xs.XSParticleDecl" name="boolean isEmpty()" map="O"/>
  <class name="org.apache.xerces.impl.xs.AttributePSVImpl" map="K"/>
  <field class="org.apache.xerces.impl.xs.AttributePSVImpl" name="fErrors" map="A"/>
  <field class="org.apache.xerces.impl.xs.AttributePSVImpl" name="fValue" map="B"/>
  <field class="org.apache.xerces.impl.xs.AttributePSVImpl" name="fSpecified" map="C"/>
  <field class="org.apache.xerces.impl.xs.AttributePSVImpl" name="fValidationAttempted" map="D"/>
  <field class="org.apache.xerces.impl.xs.AttributePSVImpl" name="fDeclaration" map="E"/>
  <field class="org.apache.xerces.impl.xs.AttributePSVImpl" name="fValidationContext" map="F"/>
  <field class="org.apache.xerces.impl.xs.AttributePSVImpl" name="fTypeDecl" map="G"/>
  <field class="org.apache.xerces.impl.xs.AttributePSVImpl" name="fValidity" map="H"/>
  <method class="org.apache.xerces.impl.xs.AttributePSVImpl" name="void reset()" map="D"/>
  <method class="org.apache.xerces.impl.xs.AttributePSVImpl" name="short getActualNormalizedValueType()" map="A"/>
  <method class="org.apache.xerces.impl.xs.AttributePSVImpl" name="java.lang.Object getActualNormalizedValue()" map="B"/>
  <method class="org.apache.xerces.impl.xs.AttributePSVImpl" name="org.apache.xerces.xs.ShortList getItemValueTypes()" map="C"/>
  <class name="org.apache.xerces.impl.xs.XSComplexTypeDecl" map="L"/>
  <field class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="fDerivedBy" map="&#x012c;"/>
  <field class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="fNamespaceItem" map="&#x012d;"/>
  <field class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="fTargetNamespace" map="&#x012e;"/>
  <field class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="fAnnotations" map="&#x012f;"/>
  <field class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="fFinal" map="&#x0130;"/>
  <field class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="fParticle" map="&#x0131;"/>
  <field class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="fBlock" map="&#x0132;"/>
  <field class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="fBaseType" map="&#x0133;"/>
  <field class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="fXSSimpleType" map="&#x0134;"/>
  <field class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="fContentType" map="&#x0135;"/>
  <field class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="fName" map="&#x0136;"/>
  <field class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="fCMValidator" map="&#x0137;"/>
  <field class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="fAttrGrp" map="&#x0138;"/>
  <field class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="fUPACMValidator" map="&#x0139;"/>
  <field class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="fMiscFlags" map="&#x013a;"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="void setIsAnonymous()" map="&#x00f3;"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="org.apache.xerces.xs.XSObjectList getAttributeUses()" map="&#x00f4;"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="boolean getAbstract()" map="&#x00f5;"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="void setNamespaceItem(org.apache.xerces.xs.XSNamespaceItem)" map="G"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="void setValues(java.lang.String, java.lang.String, org.apache.xerces.xs.XSTypeDefinition, short, short, short, short, boolean, org.apache.xerces.impl.xs.XSAttributeGroupDecl, org.apache.xerces.impl.dv.XSSimpleType, org.apache.xerces.impl.xs.XSParticleDecl, org.apache.xerces.impl.xs.util.XSObjectListImpl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="org.apache.xerces.impl.xs.XSAttributeGroupDecl getAttrGrp()" map="&#x00f6;"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="java.lang.String getTypeName()" map="&#x00f8;"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="void setName(java.lang.String)" map="Q"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="short getType()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="boolean getAnonymous()" map="r"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="org.apache.xerces.xs.XSParticle getParticle()" map="&#x00f9;"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="short getContentType()" map="v"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="org.apache.xerces.impl.xs.models.XSCMValidator getContentModel(org.apache.xerces.impl.xs.models.CMBuilder, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="void appendTypeInfo(java.lang.StringBuffer)" map="C"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="org.apache.xerces.xs.XSSimpleTypeDefinition getSimpleType()" map="&#x00fa;"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="org.apache.xerces.xs.XSTypeDefinition getBaseType()" map="s"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="org.apache.xerces.xs.XSNamespaceItem getNamespaceItem()" map="C"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="boolean containsTypeID()" map="&#x00fb;"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="short getFinal()" map="t"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="short getTypeCategory()" map="u"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="org.apache.xerces.impl.xs.models.XSCMValidator getContentModel(org.apache.xerces.impl.xs.models.CMBuilder)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSComplexTypeDecl" name="java.lang.String getNamespace()" map="D"/>
  <class name="org.apache.xerces.impl.xs.SubstitutionGroupHandler$OneSubGroup" map="_A"/>
  <field class="org.apache.xerces.impl.xs.SubstitutionGroupHandler$OneSubGroup" name="dMethod" map="A"/>
  <field class="org.apache.xerces.impl.xs.SubstitutionGroupHandler$OneSubGroup" name="sub" map="B"/>
  <field class="org.apache.xerces.impl.xs.SubstitutionGroupHandler$OneSubGroup" name="bMethod" map="C"/>
  <class name="org.apache.xerces.impl.xs.SubstitutionGroupHandler" map="M"/>
  <field class="org.apache.xerces.impl.xs.SubstitutionGroupHandler" name="EMPTY_VECTOR" map="A"/>
  <field class="org.apache.xerces.impl.xs.SubstitutionGroupHandler" name="fSubGroupsB" map="B"/>
  <field class="org.apache.xerces.impl.xs.SubstitutionGroupHandler" name="fSubGroups" map="C"/>
  <field class="org.apache.xerces.impl.xs.SubstitutionGroupHandler" name="fXSElementDeclHelper" map="D"/>
  <field class="org.apache.xerces.impl.xs.SubstitutionGroupHandler" name="EMPTY_GROUP" map="E"/>
  <method class="org.apache.xerces.impl.xs.SubstitutionGroupHandler" name="org.apache.xerces.impl.xs.SubstitutionGroupHandler$OneSubGroup[] getSubGroupB(org.apache.xerces.impl.xs.XSElementDecl, org.apache.xerces.impl.xs.SubstitutionGroupHandler$OneSubGroup)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SubstitutionGroupHandler" name="void reset()" map="A"/>
  <method class="org.apache.xerces.impl.xs.SubstitutionGroupHandler" name="boolean substitutionGroupOK(org.apache.xerces.impl.xs.XSElementDecl, org.apache.xerces.impl.xs.XSElementDecl, short)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SubstitutionGroupHandler" name="org.apache.xerces.impl.xs.XSElementDecl[] getSubstitutionGroup(org.apache.xerces.impl.xs.XSElementDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SubstitutionGroupHandler" name="boolean typeDerivationOK(org.apache.xerces.xs.XSTypeDefinition, org.apache.xerces.xs.XSTypeDefinition, short)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SubstitutionGroupHandler" name="boolean getDBMethods(org.apache.xerces.xs.XSTypeDefinition, org.apache.xerces.xs.XSTypeDefinition, org.apache.xerces.impl.xs.SubstitutionGroupHandler$OneSubGroup)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SubstitutionGroupHandler" name="org.apache.xerces.impl.xs.XSElementDecl getMatchingElemDecl(org.apache.xerces.xni.QName, org.apache.xerces.impl.xs.XSElementDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.SubstitutionGroupHandler" name="void addSubstitutionGroup(org.apache.xerces.impl.xs.XSElementDecl[])" map="A"/>
  <class name="org.apache.xerces.impl.xs.FilePathToURI" map="N"/>
  <field class="org.apache.xerces.impl.xs.FilePathToURI" name="gNeedEscaping" map="A"/>
  <field class="org.apache.xerces.impl.xs.FilePathToURI" name="gHexChs" map="B"/>
  <field class="org.apache.xerces.impl.xs.FilePathToURI" name="gAfterEscaping2" map="C"/>
  <field class="org.apache.xerces.impl.xs.FilePathToURI" name="gAfterEscaping1" map="D"/>
  <method class="org.apache.xerces.impl.xs.FilePathToURI" name="java.lang.String filepath2URI(java.lang.String)" map="A"/>
  <class name="org.apache.xerces.impl.xs.XMLSchemaValidator$LocalIDKey" map="_A"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$LocalIDKey" name="fId" map="A"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$LocalIDKey" name="fDepth" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$LocalIDKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$LocalIDKey" name="int hashCode()" map="hashCode"/>
  <class name="org.apache.xerces.impl.xs.XMLSchemaValidator$KeyRefValueStore" map="_B"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$KeyRefValueStore" name="this$0" map="this$0"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$KeyRefValueStore" name="fKeyValueStore" map="R"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$KeyRefValueStore" name="void endDocument()" map="G"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$KeyRefValueStore" name="void endDocumentFragment()" map="D"/>
  <class name="org.apache.xerces.impl.xs.XMLSchemaValidator$XPathMatcherStack" map="_C"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$XPathMatcherStack" name="fContextStack" map="A"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$XPathMatcherStack" name="fMatchersCount" map="B"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$XPathMatcherStack" name="fMatchers" map="C"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$XPathMatcherStack" name="void addMatcher(org.apache.xerces.impl.xs.identity.XPathMatcher)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$XPathMatcherStack" name="void pushContext()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$XPathMatcherStack" name="void clear()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$XPathMatcherStack" name="int size()" map="C"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$XPathMatcherStack" name="void ensureMatcherCapacity()" map="D"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$XPathMatcherStack" name="int getMatcherCount()" map="E"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$XPathMatcherStack" name="org.apache.xerces.impl.xs.identity.XPathMatcher getMatcherAt(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$XPathMatcherStack" name="void popContext()" map="F"/>
  <class name="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" map="_D"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fFieldCount" map="A"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fLocalItemValueTypes" map="B"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fItemValueTypesLength" map="C"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fValueType" map="D"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fItemValueTypes" map="E"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fValues" map="F"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fUseValueTypeVector" map="G"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fTempBuffer" map="H"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fLocalValues" map="I"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fItemValueType" map="J"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fLocalValueTypes" map="K"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="this$0" map="this$0"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fUseItemValueTypeVector" map="L"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fValueTypesLength" map="M"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fValueTypes" map="N"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fIdentityConstraint" map="O"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fFields" map="P"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="fValuesCount" map="Q"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="void addValue(org.apache.xerces.impl.xs.identity.Field, boolean, java.lang.Object, short, org.apache.xerces.xs.ShortList)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="boolean contains()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="boolean valueTypeContains(short)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="void startValueScope()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="int contains(org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="org.apache.xerces.xs.ShortList getItemValueTypeAt(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="java.lang.String toString(java.util.Vector, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="void addValueType(short)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="void append(org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="void checkDuplicateValues()" map="C"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="void endDocumentFragment()" map="D"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="boolean itemValueTypeContains(org.apache.xerces.xs.ShortList)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="void addItemValueType(org.apache.xerces.xs.ShortList)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="void endValueScope()" map="E"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="java.lang.String toString(java.lang.Object[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="void reportError(java.lang.String, java.lang.Object[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="void clear()" map="F"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="short getValueTypeAt(int)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase" name="void endDocument()" map="G"/>
  <class name="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache" map="_E"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache" name="this$0" map="this$0"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache" name="fIdentityConstraint2ValueStoreMap" map="A"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache" name="fGlobalMapStack" map="B"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache" name="fLocalId" map="C"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache" name="fValueStores" map="D"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache" name="fGlobalIDConstraintMap" map="E"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache" name="void endDocument()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache" name="void initValueStoresFor(org.apache.xerces.impl.xs.XSElementDecl, org.apache.xerces.impl.xs.identity.FieldActivator)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache" name="void endElement()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache" name="void startDocument()" map="C"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache" name="void transplant(org.apache.xerces.impl.xs.identity.IdentityConstraint, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache" name="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreBase getValueStoreFor(org.apache.xerces.impl.xs.identity.IdentityConstraint, int)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ValueStoreCache" name="void startElement()" map="D"/>
  <class name="org.apache.xerces.impl.xs.XMLSchemaValidator$XSIErrorReporter" map="_F"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$XSIErrorReporter" name="this$0" map="this$0"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$XSIErrorReporter" name="fErrors" map="A"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$XSIErrorReporter" name="fContextCount" map="B"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$XSIErrorReporter" name="fErrorReporter" map="C"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$XSIErrorReporter" name="fContext" map="D"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$XSIErrorReporter" name="void pushContext()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$XSIErrorReporter" name="java.lang.String[] popContext()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$XSIErrorReporter" name="void reportError(java.lang.String, java.lang.String, java.lang.Object[], short)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$XSIErrorReporter" name="java.lang.String[] mergeContext()" map="C"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$XSIErrorReporter" name="void reset(org.apache.xerces.impl.XMLErrorReporter)" map="A"/>
  <class name="org.apache.xerces.impl.xs.XMLSchemaValidator$KeyValueStore" map="_G"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$KeyValueStore" name="this$0" map="this$0"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$KeyValueStore" name="void checkDuplicateValues()" map="C"/>
  <class name="org.apache.xerces.impl.xs.XMLSchemaValidator$ShortVector" map="_H"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ShortVector" name="fData" map="A"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$ShortVector" name="fLength" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ShortVector" name="short valueAt(int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ShortVector" name="void add(short)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ShortVector" name="void clear()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ShortVector" name="boolean contains(short)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$ShortVector" name="void ensureCapacity(int)" map="B"/>
  <class name="org.apache.xerces.impl.xs.XMLSchemaValidator$UniqueValueStore" map="_I"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator$UniqueValueStore" name="this$0" map="this$0"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator$UniqueValueStore" name="void checkDuplicateValues()" map="C"/>
  <class name="org.apache.xerces.impl.xs.XMLSchemaValidator" map="O"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fLocator" map="&#x02a5;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fNilStack" map="&#x02a6;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fValidationState" map="&#x02a7;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fSchemaElementDefault" map="&#x02a8;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fEntityResolver" map="&#x02b0;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fEntityRef" map="&#x02b1;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fLocationPairs" map="&#x02b2;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fRootTypeDefinition" map="&#x02b3;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fNNoneValidationDepth" map="&#x02b4;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fExternalSchemas" map="&#x02b5;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fJaxpSchemaSource" map="&#x02b6;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fNormalizedStr" map="&#x02b7;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fSawTextStack" map="&#x02b8;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fNFullValidationDepth" map="&#x02bb;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fAugmentations" map="&#x02bc;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fValueStoreCache" map="&#x02bd;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fState4ApplyDefault" map="&#x02be;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fTrailing" map="&#x02bf;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fQNameDV" map="&#x02c0;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fDynamicValidation" map="&#x02c1;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fNotationStack" map="&#x02d0;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fStringContent" map="&#x02d1;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fSubElementStack" map="&#x02e0;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fGrammarPool" map="&#x02e1;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fFirstChunk" map="&#x02e2;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fCurrentType" map="&#x02e3;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="XSI_NIL" map="&#x02e4;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fStrictAssessStack" map="&#x037a;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fTypeStack" map="&#x0386;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fDoValidation" map="&#x0388;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="RECOGNIZED_FEATURES" map="&#x0389;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fUnparsedLocations" map="&#x038a;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fCurrentCM" map="&#x038c;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fSchemaLoader" map="&#x038e;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fCMStack" map="&#x038f;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fNotation" map="&#x0390;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fSubElement" map="&#x0391;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fElementDepth" map="&#x0392;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fDocumentSource" map="&#x0393;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fSawText" map="&#x0394;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fCurrCMState" map="&#x0395;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fState4XsiType" map="&#x0396;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fIDCChecking" map="&#x0397;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fExternalNoNamespaceSchema" map="&#x0398;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fCurrentElemDecl" map="&#x0399;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fSchemaType" map="&#x039a;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="FEATURE_DEFAULTS" map="&#x039b;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="RECOGNIZED_PROPERTIES" map="&#x039c;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fBuffer" map="&#x039d;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fEmptyXMLStr" map="&#x039e;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fXSDDescription" map="&#x039f;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="nodeFactory" map="&#x03a0;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fValidationRoot" map="&#x03a1;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fValidatedInfo" map="&#x03a3;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fNil" map="&#x03a4;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fSymbolTable" map="&#x03a5;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fDefaultValue" map="&#x03a6;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fSchemaDynamicValidation" map="&#x03a7;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fUnionType" map="&#x03a8;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fMatcherStack" map="&#x03a9;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fIgnoreXSITypeDepth" map="&#x03aa;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fRootTypeQName" map="&#x03ab;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fNamespaceGrowth" map="&#x03ac;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="XSI_NONAMESPACESCHEMALOCATION" map="&#x03ad;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="EMPTY_TABLE" map="&#x03ae;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fCMBuilder" map="&#x03af;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fCurrentPSVI" map="&#x03b0;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fWhiteSpace" map="&#x03b1;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fAppendBuffer" map="&#x03b2;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fElemDeclStack" map="&#x03b3;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="XSI_SCHEMALOCATION" map="&#x03b4;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fFullChecking" map="&#x03b5;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fSawCharacters" map="&#x03b6;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fIdConstraint" map="&#x03b7;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fValidationManager" map="&#x03b8;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="PROPERTY_DEFAULTS" map="&#x03b9;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fSubGroupHandler" map="&#x03ba;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fUseGrammarPoolOnly" map="&#x03bb;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="XSI_TYPE" map="&#x03bc;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fExpandedLocationPairs" map="&#x03bd;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fSkipValidationDepth" map="&#x03be;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fRootElementDeclaration" map="&#x03bf;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fInCDATA" map="&#x03c0;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fStrictAssess" map="&#x03c1;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fRootElementDeclQName" map="&#x03c2;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fCMStateStack" map="&#x03c3;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fDocumentHandler" map="&#x03c4;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fXSIErrorReporter" map="&#x03c5;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fNormalizeData" map="&#x03c6;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fAugPSVI" map="&#x03c7;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fGrammarBucket" map="&#x03c8;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="fTempQName" map="&#x03c9;"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="java.lang.Object elementLocallyValidType(org.apache.xerces.xni.QName, java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void startElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void ensureStackCapacity()" map="&#x00e8;"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void processElementContent(org.apache.xerces.xni.QName)" map="F"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void setFeature(java.lang.String, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="java.lang.String[] getRecognizedFeatures()" map="E"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void setLocationHints(org.apache.xerces.impl.xs.XSDDescription, java.lang.String[], org.apache.xerces.xs.StringList)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="java.lang.String[] getRecognizedProperties()" map="F"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void startCDATA(org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void startGeneralEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void processingInstruction(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void setLocationHints(org.apache.xerces.impl.xs.XSDDescription, java.lang.String[], org.apache.xerces.impl.xs.SchemaGrammar)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="org.apache.xerces.xni.parser.XMLDocumentSource getDocumentSource()" map="C"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void endElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void characters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="java.lang.Object elementLocallyValidComplexType(org.apache.xerces.xni.QName, java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void xmlDecl(java.lang.String, java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void endGeneralEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="org.apache.xerces.impl.xs.SchemaGrammar findSchemaGrammar(short, java.lang.String, org.apache.xerces.xni.QName, org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void handleEndDocument()" map="&#x00e9;"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void ignorableWhitespace(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="org.apache.xerces.xni.Augmentations handleStartElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void doctypeDecl(java.lang.String, java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void comment(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void processRootElementDeclQName(javax.xml.namespace.QName, org.apache.xerces.xni.QName)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void processOneAttribute(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, int, org.apache.xerces.impl.xs.XSAttributeDecl, org.apache.xerces.impl.xs.XSAttributeUseImpl, org.apache.xerces.impl.xs.AttributePSVImpl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void startDocument(org.apache.xerces.xni.XMLLocator, java.lang.String, org.apache.xerces.xni.NamespaceContext, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="org.apache.xerces.xni.XMLString handleCharacters(org.apache.xerces.xni.XMLString)" map="F"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void access$100(org.apache.xerces.impl.xs.XMLSchemaValidator, org.apache.xerces.impl.xs.identity.IdentityConstraint)" map="access$100"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="boolean getXsiNil(org.apache.xerces.xni.QName, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void endDocument(org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void endValueScopeFor(org.apache.xerces.impl.xs.identity.IdentityConstraint, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void checkElementMatchesRootElementDecl(org.apache.xerces.impl.xs.XSElementDecl, org.apache.xerces.xni.QName)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="org.apache.xerces.impl.xs.XSElementDecl getGlobalElementDecl(org.apache.xerces.xni.QName)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void addDefaultAttributes(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.impl.xs.XSAttributeGroupDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void reportSchemaError(java.lang.String, java.lang.Object[])" map="D"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void normalizeWhitespace(org.apache.xerces.xni.XMLString, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void storeLocations(java.lang.String, java.lang.String)" map="J"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="org.apache.xerces.xni.Augmentations getEmptyAugs(org.apache.xerces.xni.Augmentations)" map="O"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="java.lang.Boolean getFeatureDefault(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="org.apache.xerces.xni.Augmentations handleEndElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="org.apache.xerces.impl.xs.identity.XPathMatcher activateField(org.apache.xerces.impl.xs.identity.Field, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="int access$000(org.apache.xerces.impl.xs.XMLSchemaValidator)" map="access$000"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void emptyElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void startValueScopeFor(org.apache.xerces.impl.xs.identity.IdentityConstraint, int)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void setProperty(java.lang.String, java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="org.apache.xerces.xni.Augmentations endElementPSVI(boolean, org.apache.xerces.impl.xs.SchemaGrammar[], org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="java.lang.String expectedStr(java.util.Vector)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="org.apache.xerces.xni.XMLDocumentHandler getDocumentHandler()" map="D"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void processAttributes(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.impl.xs.XSAttributeGroupDecl)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="boolean hasSchemaComponent(org.apache.xerces.impl.xs.SchemaGrammar, short, org.apache.xerces.xni.QName)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void processRootTypeQName(javax.xml.namespace.QName)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="java.lang.Object getPropertyDefault(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void endCDATA(org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="org.apache.xerces.xs.XSTypeDefinition getAndCheckXsiType(org.apache.xerces.xni.QName, java.lang.String, org.apache.xerces.xni.XMLAttributes)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void activateSelectorFor(org.apache.xerces.impl.xs.identity.IdentityConstraint)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void handleStartDocument(org.apache.xerces.xni.XMLLocator, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void handleIgnorableWhitespace(org.apache.xerces.xni.XMLString)" map="G"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaValidator" name="void textDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <class name="org.apache.xerces.impl.xs.SchemaSymbols" map="P"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_FINALDEFAULT" map="A"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_ATTRIBUTEGROUP" map="B"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_ANYATTRIBUTE" map="C"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_REFER" map="D"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_PROCESSCONTENTS" map="E"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_ANY" map="F"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_MINLENGTH" map="G"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_IMPORT" map="H"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_ABSTRACT" map="I"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_ITEMTYPE" map="J"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_UNIQUE" map="K"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_MINEXCLUSIVE" map="L"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_UNION" map="M"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_SYSTEM" map="N"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_MAXOCCURS" map="O"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_BLOCKDEFAULT" map="P"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_KEY" map="Q"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_FORM" map="R"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="URI_SCHEMAFORSCHEMA" map="S"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_KEYREF" map="T"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_EXTENSION" map="U"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_TARGETNAMESPACE" map="V"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_MAXEXCLUSIVE" map="W"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_NOTATION" map="X"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_ATTRIBUTEFORMDEFAULT" map="Y"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="XSI_NIL" map="Z"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_MININCLUSIVE" map="_"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_COMPLEXCONTENT" map="a"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_BLOCK" map="b"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_SCHEMALOCATION" map="c"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_ID" map="d"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_ELEMENT" map="e"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_BASE" map="f"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_ENUMERATION" map="g"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_NAMESPACE" map="h"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_MEMBERTYPES" map="i"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_ALL" map="j"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_VALUE" map="k"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_VERSION" map="l"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_DEFAULT" map="m"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_MAXINCLUSIVE" map="n"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_SIMPLETYPE" map="o"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_NILLABLE" map="p"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_MAXLENGTH" map="q"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_FIELD" map="r"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_SOURCE" map="s"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_PATTERN" map="t"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_SIMPLECONTENT" map="u"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_SCHEMA" map="v"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_MIXED" map="w"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_WHITESPACE" map="x"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_ANNOTATION" map="y"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_ELEMENTFORMDEFAULT" map="z"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_REDEFINE" map="&#x00a2;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_USE" map="&#x00a3;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_TYPE" map="&#x00a4;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_LIST" map="&#x00a5;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_INCLUDE" map="&#x00aa;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_SELECTOR" map="&#x00b5;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_PUBLIC" map="&#x00ba;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_COMPLEXTYPE" map="&#x00c0;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="XSI_NONAMESPACESCHEMALOCATION" map="&#x00c1;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_APPINFO" map="&#x00c2;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_SEQUENCE" map="&#x00c3;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_SUBSTITUTIONGROUP" map="&#x00c4;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_NAME" map="&#x00c5;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="URI_XSI" map="&#x00c6;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_MINOCCURS" map="&#x00c7;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_TOTALDIGITS" map="&#x00c8;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_GROUP" map="&#x00c9;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_FRACTIONDIGITS" map="&#x00ca;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_CHOICE" map="&#x00cb;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="XSI_SCHEMALOCATION" map="&#x00cc;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_FINAL" map="&#x00cd;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_XML_LANG" map="&#x00ce;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="XSI_TYPE" map="&#x00cf;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_FIXED" map="&#x00d0;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_ATTRIBUTE" map="&#x00d1;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_XPATH" map="&#x00d2;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_DOCUMENTATION" map="&#x00d3;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ATT_REF" map="&#x00d4;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_RESTRICTION" map="&#x00d5;"/>
  <field class="org.apache.xerces.impl.xs.SchemaSymbols" name="ELT_LENGTH" map="&#x00d6;"/>
  <class name="org.apache.xerces.impl.xs.XSDDescription" map="Q"/>
  <field class="org.apache.xerces.impl.xs.XSDDescription" name="fAttributes" map="I"/>
  <field class="org.apache.xerces.impl.xs.XSDDescription" name="fContextType" map="J"/>
  <field class="org.apache.xerces.impl.xs.XSDDescription" name="fEnclosedElementName" map="K"/>
  <field class="org.apache.xerces.impl.xs.XSDDescription" name="fTriggeringComponent" map="L"/>
  <field class="org.apache.xerces.impl.xs.XSDDescription" name="fLocationHints" map="M"/>
  <method class="org.apache.xerces.impl.xs.XSDDescription" name="boolean fromInstance()" map="K"/>
  <method class="org.apache.xerces.impl.xs.XSDDescription" name="void reset()" map="L"/>
  <method class="org.apache.xerces.impl.xs.XSDDescription" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.xerces.impl.xs.XSDDescription" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.xs.XSDDescription" name="short getContextType()" map="M"/>
  <method class="org.apache.xerces.impl.xs.XSDDescription" name="void setContextType(short)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSDDescription" name="java.lang.String getGrammarType()" map="H"/>
  <method class="org.apache.xerces.impl.xs.XSDDescription" name="java.lang.String getTargetNamespace()" map="J"/>
  <method class="org.apache.xerces.impl.xs.XSDDescription" name="org.apache.xerces.impl.xs.XSDDescription makeClone()" map="N"/>
  <method class="org.apache.xerces.impl.xs.XSDDescription" name="void setLocationHints(java.lang.String[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSDDescription" name="java.lang.String[] getLocationHints()" map="O"/>
  <method class="org.apache.xerces.impl.xs.XSDDescription" name="void setTargetNamespace(java.lang.String)" map="F"/>
  <class name="org.apache.xerces.impl.xs.XSElementDeclHelper" map="R"/>
  <method class="org.apache.xerces.impl.xs.XSElementDeclHelper" name="org.apache.xerces.impl.xs.XSElementDecl getGlobalElementDecl(org.apache.xerces.xni.QName)" map="A"/>
  <class name="org.apache.xerces.impl.xs.XMLSchemaException" map="S"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaException" name="args" map="A"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaException" name="key" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaException" name="java.lang.String getKey()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaException" name="java.lang.Object[] getArgs()" map="B"/>
  <class name="org.apache.xerces.impl.xs.XSGrammarBucket" map="T"/>
  <field class="org.apache.xerces.impl.xs.XSGrammarBucket" name="fNoNSGrammar" map="A"/>
  <field class="org.apache.xerces.impl.xs.XSGrammarBucket" name="fGrammarRegistry" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSGrammarBucket" name="boolean putGrammar(org.apache.xerces.impl.xs.SchemaGrammar, boolean, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSGrammarBucket" name="boolean putGrammar(org.apache.xerces.impl.xs.SchemaGrammar, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSGrammarBucket" name="void putGrammar(org.apache.xerces.impl.xs.SchemaGrammar)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSGrammarBucket" name="void reset()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSGrammarBucket" name="org.apache.xerces.impl.xs.SchemaGrammar getGrammar(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSGrammarBucket" name="org.apache.xerces.impl.xs.SchemaGrammar[] getGrammars()" map="B"/>
  <class name="org.apache.xerces.impl.xs.ElementPSVImpl" map="U"/>
  <field class="org.apache.xerces.impl.xs.ElementPSVImpl" name="fNil" map="I"/>
  <field class="org.apache.xerces.impl.xs.ElementPSVImpl" name="fTypeDecl" map="J"/>
  <field class="org.apache.xerces.impl.xs.ElementPSVImpl" name="fErrors" map="K"/>
  <field class="org.apache.xerces.impl.xs.ElementPSVImpl" name="fSpecified" map="L"/>
  <field class="org.apache.xerces.impl.xs.ElementPSVImpl" name="fValidity" map="M"/>
  <field class="org.apache.xerces.impl.xs.ElementPSVImpl" name="fValidationAttempted" map="N"/>
  <field class="org.apache.xerces.impl.xs.ElementPSVImpl" name="fGrammars" map="O"/>
  <field class="org.apache.xerces.impl.xs.ElementPSVImpl" name="fNotation" map="P"/>
  <field class="org.apache.xerces.impl.xs.ElementPSVImpl" name="fSchemaInformation" map="Q"/>
  <field class="org.apache.xerces.impl.xs.ElementPSVImpl" name="fValidationContext" map="R"/>
  <field class="org.apache.xerces.impl.xs.ElementPSVImpl" name="fDeclaration" map="S"/>
  <field class="org.apache.xerces.impl.xs.ElementPSVImpl" name="fValue" map="T"/>
  <method class="org.apache.xerces.impl.xs.ElementPSVImpl" name="void reset()" map="E"/>
  <class name="org.apache.xerces.impl.xs.XSModelGroupImpl" map="V"/>
  <field class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="fParticles" map="m"/>
  <field class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="fDescription" map="n"/>
  <field class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="fAnnotations" map="o"/>
  <field class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="fCompositor" map="p"/>
  <field class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="fParticleCount" map="q"/>
  <method class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="int maxEffectiveTotalRange()" map="X"/>
  <method class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="int minEffectiveTotalRangeAllSeq()" map="Y"/>
  <method class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="int minEffectiveTotalRange()" map="Z"/>
  <method class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="int maxEffectiveTotalRangeAllSeq()" map="_"/>
  <method class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="org.apache.xerces.xs.XSObjectList getParticles()" map="W"/>
  <method class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="java.lang.String getNamespace()" map="D"/>
  <method class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="short getType()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="int minEffectiveTotalRangeChoice()" map="a"/>
  <method class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="boolean isEmpty()" map="b"/>
  <method class="org.apache.xerces.impl.xs.XSModelGroupImpl" name="int maxEffectiveTotalRangeChoice()" map="c"/>
  <class name="org.apache.xerces.impl.xs.XSNotationDecl" map="W"/>
  <field class="org.apache.xerces.impl.xs.XSNotationDecl" name="fAnnotations" map="g"/>
  <field class="org.apache.xerces.impl.xs.XSNotationDecl" name="fPublicId" map="h"/>
  <field class="org.apache.xerces.impl.xs.XSNotationDecl" name="fTargetNamespace" map="i"/>
  <field class="org.apache.xerces.impl.xs.XSNotationDecl" name="fNamespaceItem" map="j"/>
  <field class="org.apache.xerces.impl.xs.XSNotationDecl" name="fName" map="k"/>
  <field class="org.apache.xerces.impl.xs.XSNotationDecl" name="fSystemId" map="l"/>
  <method class="org.apache.xerces.impl.xs.XSNotationDecl" name="short getType()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSNotationDecl" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSNotationDecl" name="org.apache.xerces.xs.XSNamespaceItem getNamespaceItem()" map="C"/>
  <method class="org.apache.xerces.impl.xs.XSNotationDecl" name="java.lang.String getNamespace()" map="D"/>
  <method class="org.apache.xerces.impl.xs.XSNotationDecl" name="void setNamespaceItem(org.apache.xerces.xs.XSNamespaceItem)" map="C"/>
  <class name="org.apache.xerces.impl.xs.XSConstraints$1" map="1"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints$1" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="org.apache.xerces.impl.xs.XSConstraints" map="X"/>
  <field class="org.apache.xerces.impl.xs.XSConstraints" name="ELEMENT_PARTICLE_COMPARATOR" map="A"/>
  <field class="org.apache.xerces.impl.xs.XSConstraints" name="STRING_TYPE" map="B"/>
  <field class="org.apache.xerces.impl.xs.XSConstraints" name="fEmptyParticle" map="C"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="boolean checkSimpleDerivationOk(org.apache.xerces.impl.dv.XSSimpleType, org.apache.xerces.xs.XSTypeDefinition, short)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="void addElementToParticleVector(java.util.Vector, org.apache.xerces.impl.xs.XSElementDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="boolean overlapUPA(org.apache.xerces.impl.xs.XSWildcardDecl, org.apache.xerces.impl.xs.XSWildcardDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="java.util.Vector removePointlessChildren(org.apache.xerces.impl.xs.XSParticleDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="boolean overlapUPA(org.apache.xerces.impl.xs.XSElementDecl, org.apache.xerces.impl.xs.XSElementDecl, org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="void checkRecurseLax(java.util.Vector, int, int, org.apache.xerces.impl.xs.SubstitutionGroupHandler, java.util.Vector, int, int, org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="void checkRecurse(java.util.Vector, int, int, org.apache.xerces.impl.xs.SubstitutionGroupHandler, java.util.Vector, int, int, org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="org.apache.xerces.impl.xs.XSParticleDecl getEmptySequence()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="void checkNameAndTypeOK(org.apache.xerces.impl.xs.XSElementDecl, int, int, org.apache.xerces.impl.xs.XSElementDecl, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="void checkMapAndSum(java.util.Vector, int, int, org.apache.xerces.impl.xs.SubstitutionGroupHandler, java.util.Vector, int, int, org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="C"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="void checkIDConstraintRestriction(org.apache.xerces.impl.xs.XSElementDecl, org.apache.xerces.impl.xs.XSElementDecl)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="void checkNSRecurseCheckCardinality(java.util.Vector, int, int, org.apache.xerces.impl.xs.SubstitutionGroupHandler, org.apache.xerces.impl.xs.XSParticleDecl, int, int, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="boolean overlapUPA(org.apache.xerces.impl.xs.XSElementDecl, org.apache.xerces.impl.xs.XSWildcardDecl, org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="void checkNSSubset(org.apache.xerces.impl.xs.XSWildcardDecl, int, int, org.apache.xerces.impl.xs.XSWildcardDecl, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="boolean checkSimpleDerivation(org.apache.xerces.impl.dv.XSSimpleType, org.apache.xerces.impl.dv.XSSimpleType, short)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="void findElemInTable(org.apache.xerces.impl.xs.XSComplexTypeDecl, org.apache.xerces.impl.xs.XSElementDecl, org.apache.xerces.util.SymbolHash)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="void gatherChildren(int, org.apache.xerces.impl.xs.XSParticleDecl, java.util.Vector)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="boolean checkComplexDerivation(org.apache.xerces.impl.xs.XSComplexTypeDecl, org.apache.xerces.xs.XSTypeDefinition, short)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="void checkNSCompat(org.apache.xerces.impl.xs.XSElementDecl, int, int, org.apache.xerces.impl.xs.XSWildcardDecl, int, int, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="org.apache.xerces.impl.xs.XSParticleDecl getNonUnaryGroup(org.apache.xerces.impl.xs.XSParticleDecl)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="void reportSchemaError(org.apache.xerces.impl.XMLErrorReporter, org.apache.xerces.impl.xs.util.SimpleLocator, java.lang.String, java.lang.Object[])" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="boolean checkTypeDerivationOk(org.apache.xerces.xs.XSTypeDefinition, org.apache.xerces.xs.XSTypeDefinition, short)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="boolean checkOccurrenceRange(int, int, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="void checkElementDeclsConsistent(org.apache.xerces.impl.xs.XSComplexTypeDecl, org.apache.xerces.impl.xs.XSParticleDecl, org.apache.xerces.util.SymbolHash, org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="boolean overlapUPA(java.lang.Object, java.lang.Object, org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="void checkRecurseUnordered(java.util.Vector, int, int, org.apache.xerces.impl.xs.SubstitutionGroupHandler, java.util.Vector, int, int, org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="D"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="void fullSchemaChecking(org.apache.xerces.impl.xs.XSGrammarBucket, org.apache.xerces.impl.xs.SubstitutionGroupHandler, org.apache.xerces.impl.xs.models.CMBuilder, org.apache.xerces.impl.XMLErrorReporter)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="java.lang.Object ElementDefaultValidImmediate(org.apache.xerces.xs.XSTypeDefinition, java.lang.String, org.apache.xerces.impl.dv.ValidationContext, org.apache.xerces.impl.dv.ValidatedInfo)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="boolean particleValidRestriction(org.apache.xerces.impl.xs.XSParticleDecl, org.apache.xerces.impl.xs.SubstitutionGroupHandler, org.apache.xerces.impl.xs.XSParticleDecl, org.apache.xerces.impl.xs.SubstitutionGroupHandler, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSConstraints" name="boolean particleValidRestriction(org.apache.xerces.impl.xs.XSParticleDecl, org.apache.xerces.impl.xs.SubstitutionGroupHandler, org.apache.xerces.impl.xs.XSParticleDecl, org.apache.xerces.impl.xs.SubstitutionGroupHandler)" map="A"/>
  <class name="org.apache.xerces.impl.xs.XMLSchemaLoader$LocationArray" map="_A"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader$LocationArray" name="locations" map="A"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader$LocationArray" name="length" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader$LocationArray" name="void resize(int, int)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader$LocationArray" name="java.lang.String[] getLocationArray()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader$LocationArray" name="java.lang.String getFirstLocation()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader$LocationArray" name="void addLocation(java.lang.String)" map="A"/>
  <class name="org.apache.xerces.impl.xs.XMLSchemaLoader" map="Y"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="class$java$lang$Object" map="class$java$lang$Object"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fErrorHandler" map="&#x028c;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fLocale" map="&#x028d;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fGrammarBucket" map="&#x028e;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="class$java$lang$String" map="class$java$lang$String"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fXSDDescription" map="&#x028f;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fExternalSchemas" map="&#x0290;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="RECOGNIZED_FEATURES" map="&#x0291;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fGrammarPool" map="&#x0292;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fSettingsChanged" map="&#x0293;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fEntityManager" map="&#x0294;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fDefaultSchemaDVFactory" map="&#x0295;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fLoaderConfig" map="&#x0296;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fErrorReporter" map="&#x0297;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="class$java$io$File" map="class$java$io$File"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fDeclPool" map="&#x0298;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="class$java$io$InputStream" map="class$java$io$InputStream"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fRecognizedParameters" map="&#x0299;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fJAXPSource" map="&#x029a;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fJAXPCache" map="&#x029b;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fSubGroupHandler" map="&#x029c;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fJAXPProcessed" map="&#x029d;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fCMBuilder" map="&#x029e;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fIsCheckedFully" map="&#x029f;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fSchemaHandler" map="&#x02a0;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="RECOGNIZED_PROPERTIES" map="&#x02a1;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="class$org$xml$sax$InputSource" map="class$F$A$A$M"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fExternalNoNSSchema" map="&#x02a2;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fUserEntityResolver" map="&#x02a3;"/>
  <field class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="fResourceResolver" map="&#x02a4;"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="void initGrammarBucket()" map="&#x00e7;"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="void processExternalHints(java.lang.String, java.lang.String, java.util.Hashtable, org.apache.xerces.impl.XMLErrorReporter)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="void setProperty(java.lang.String, java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="org.apache.xerces.xni.parser.XMLInputSource resolveDocument(org.apache.xerces.impl.xs.XSDDescription, java.util.Hashtable, org.apache.xerces.xni.parser.XMLEntityResolver)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="java.lang.String[] getRecognizedFeatures()" map="E"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="org.apache.xerces.impl.xs.SchemaGrammar loadSchema(org.apache.xerces.impl.xs.XSDDescription, org.apache.xerces.xni.parser.XMLInputSource, java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="java.lang.Boolean getFeatureDefault(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="void processJAXPSchemaSource(java.util.Hashtable)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="boolean parserSettingsUpdated(org.apache.xerces.xni.parser.XMLComponentManager)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="org.apache.xerces.xni.parser.XMLInputSource xsdToXMLInputSource(java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="java.lang.Object getPropertyDefault(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="org.apache.xerces.impl.xs.XSElementDecl getGlobalElementDecl(org.apache.xerces.xni.QName)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="org.apache.xerces.xni.parser.XMLInputSource saxToXMLInputSource(org.xml.sax.InputSource)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="void setLocale(java.util.Locale)" map="D"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="boolean tokenizeSchemaLocationStr(java.lang.String, java.util.Hashtable, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="void setFeature(java.lang.String, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.xs.XMLSchemaLoader" name="java.lang.String[] getRecognizedProperties()" map="F"/>
  <class name="org.apache.xerces.impl.xs.XSAttributeDecl" map="Z"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeDecl" name="fScope" map="C"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeDecl" name="fEnclosingCT" map="D"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeDecl" name="fNamespaceItem" map="E"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeDecl" name="fType" map="F"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeDecl" name="fTargetNamespace" map="G"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeDecl" name="fAnnotations" map="H"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeDecl" name="fDefault" map="I"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeDecl" name="fConstraintType" map="J"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeDecl" name="fUnresolvedTypeName" map="K"/>
  <field class="org.apache.xerces.impl.xs.XSAttributeDecl" name="fName" map="L"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeDecl" name="org.apache.xerces.impl.dv.ValidatedInfo getValInfo()" map="G"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeDecl" name="org.apache.xerces.xs.XSSimpleTypeDefinition getTypeDefinition()" map="E"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeDecl" name="short getScope()" map="F"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeDecl" name="void setValues(java.lang.String, java.lang.String, org.apache.xerces.impl.dv.XSSimpleType, short, short, org.apache.xerces.impl.dv.ValidatedInfo, org.apache.xerces.impl.xs.XSComplexTypeDecl, org.apache.xerces.xs.XSObjectList)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeDecl" name="void setNamespaceItem(org.apache.xerces.xs.XSNamespaceItem)" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeDecl" name="short getConstraintType()" map="H"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeDecl" name="java.lang.String getNamespace()" map="D"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeDecl" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeDecl" name="short getType()" map="A"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeDecl" name="org.apache.xerces.xs.XSObjectList getAnnotations()" map="I"/>
  <method class="org.apache.xerces.impl.xs.XSAttributeDecl" name="org.apache.xerces.xs.XSNamespaceItem getNamespaceItem()" map="C"/>
  <class name="org.apache.xerces.impl.xs.XSMessageFormatter" map="_"/>
  <field class="org.apache.xerces.impl.xs.XSMessageFormatter" name="fLocale" map="A"/>
  <field class="org.apache.xerces.impl.xs.XSMessageFormatter" name="fResourceBundle" map="B"/>
  <method class="org.apache.xerces.impl.xs.XSMessageFormatter" name="java.lang.String formatMessage(java.util.Locale, java.lang.String, java.lang.Object[])" map="A"/>
  <package name="org.apache.xerces.impl.dv" map="D"/>
  <package name="org.apache.xerces.impl.dv.util" map="A"/>
  <class name="org.apache.xerces.impl.dv.util.HexBin" map="A"/>
  <field class="org.apache.xerces.impl.dv.util.HexBin" name="hexNumberTable" map="A"/>
  <field class="org.apache.xerces.impl.dv.util.HexBin" name="lookUpHexAlphabet" map="B"/>
  <method class="org.apache.xerces.impl.dv.util.HexBin" name="java.lang.String encode(byte[])" map="A"/>
  <method class="org.apache.xerces.impl.dv.util.HexBin" name="byte[] decode(java.lang.String)" map="A"/>
  <class name="org.apache.xerces.impl.dv.util.Base64" map="B"/>
  <field class="org.apache.xerces.impl.dv.util.Base64" name="base64Alphabet" map="A"/>
  <field class="org.apache.xerces.impl.dv.util.Base64" name="lookUpBase64Alphabet" map="B"/>
  <method class="org.apache.xerces.impl.dv.util.Base64" name="int removeWhiteSpace(char[])" map="A"/>
  <method class="org.apache.xerces.impl.dv.util.Base64" name="java.lang.String encode(byte[])" map="A"/>
  <method class="org.apache.xerces.impl.dv.util.Base64" name="boolean isWhiteSpace(char)" map="A"/>
  <method class="org.apache.xerces.impl.dv.util.Base64" name="byte[] decode(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.dv.util.Base64" name="boolean isData(char)" map="B"/>
  <method class="org.apache.xerces.impl.dv.util.Base64" name="boolean isPad(char)" map="C"/>
  <class name="org.apache.xerces.impl.dv.util.ByteListImpl" map="C"/>
  <field class="org.apache.xerces.impl.dv.util.ByteListImpl" name="canonical" map="A"/>
  <field class="org.apache.xerces.impl.dv.util.ByteListImpl" name="data" map="B"/>
  <method class="org.apache.xerces.impl.dv.util.ByteListImpl" name="int size()" map="size"/>
  <method class="org.apache.xerces.impl.dv.util.ByteListImpl" name="int getLength()" map="A"/>
  <method class="org.apache.xerces.impl.dv.util.ByteListImpl" name="java.lang.Object get(int)" map="get"/>
  <package name="org.apache.xerces.impl.dv.xs" map="B"/>
  <class name="org.apache.xerces.impl.dv.xs.AnySimpleDV" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AnySimpleDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AnySimpleDV" name="short getAllowedFacets()" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.AnyURIDV" map="B"/>
  <field class="org.apache.xerces.impl.dv.xs.AnyURIDV" name="BASE_URI" map="A"/>
  <field class="org.apache.xerces.impl.dv.xs.AnyURIDV" name="gNeedEscaping" map="B"/>
  <field class="org.apache.xerces.impl.dv.xs.AnyURIDV" name="gHexChs" map="C"/>
  <field class="org.apache.xerces.impl.dv.xs.AnyURIDV" name="gAfterEscaping2" map="D"/>
  <field class="org.apache.xerces.impl.dv.xs.AnyURIDV" name="gAfterEscaping1" map="E"/>
  <method class="org.apache.xerces.impl.dv.xs.AnyURIDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AnyURIDV" name="java.lang.String encode(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AnyURIDV" name="short getAllowedFacets()" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.AnyAtomicDV" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.AnyAtomicDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AnyAtomicDV" name="short getAllowedFacets()" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.YearMonthDurationDV" map="D"/>
  <method class="org.apache.xerces.impl.dv.xs.YearMonthDurationDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" map="_A"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="canonical" map="A"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="utc" map="B"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="unNormSecond" map="C"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="type" map="D"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="timezoneHr" map="E"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="hour" map="F"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="unNormHour" map="G"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="unNormDay" map="H"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="year" map="I"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="unNormMonth" map="J"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="unNormYear" map="K"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="minute" map="L"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="normalized" map="M"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="timezoneMin" map="N"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="day" map="O"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="unNormMinute" map="P"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="month" map="Q"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="second" map="R"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="originalValue" map="S"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="position" map="T"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="java.lang.Object clone()" map="clone"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" map="E"/>
  <field class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="datatypeFactory" map="F"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="void append2(java.lang.StringBuffer, double)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="int maxDayInMonthFor(int, int)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="void cloneDate(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData, org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="int mod(int, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="short getAllowedFacets()" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="int compare(java.lang.Object, java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="void append(java.lang.StringBuffer, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="int modulo(int, int, int)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="void normalize(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="int getYearMonth(java.lang.String, int, int, org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="boolean isLeapYear(int)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="void append3(java.lang.StringBuffer, double)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="void getTimeZone(java.lang.String, org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="boolean isNextCharUTCSign(java.lang.String, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="void saveUnnormalized(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="void parseTimeZone(java.lang.String, int, int, org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="void validateDateTime(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="D"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="double parseSecond(java.lang.String, int, int)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="int findUTCSign(java.lang.String, int, int)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="void append(java.lang.StringBuffer, double)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="int getDate(java.lang.String, int, int, org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="int parseInt(java.lang.String, int, int)" map="D"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="int fQuotient(int, int)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="short compareDates(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData, org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="void resetDateObj(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="E"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="int parseIntYear(java.lang.String, int)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="int indexOf(java.lang.String, int, int, char)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="int fQuotient(int, int, int)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="void getTime(java.lang.String, int, int, org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="D"/>
  <method class="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV" name="short compareOrder(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData, org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="B"/>
  <class name="org.apache.xerces.impl.dv.xs.YearMonthDV" map="F"/>
  <method class="org.apache.xerces.impl.dv.xs.YearMonthDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.YearMonthDV" name="java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.YearMonthDV" name="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String)" map="B"/>
  <class name="org.apache.xerces.impl.dv.xs.IDREFDV" map="G"/>
  <method class="org.apache.xerces.impl.dv.xs.IDREFDV" name="void checkExtraRules(java.lang.Object, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.IDREFDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.IDREFDV" name="short getAllowedFacets()" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.IntegerDV" map="H"/>
  <method class="org.apache.xerces.impl.dv.xs.IntegerDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.Base64BinaryDV$XBase64" map="_A"/>
  <method class="org.apache.xerces.impl.dv.xs.Base64BinaryDV$XBase64" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.dv.xs.Base64BinaryDV$XBase64" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.xerces.impl.dv.xs.Base64BinaryDV$XBase64" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.dv.xs.Base64BinaryDV" map="I"/>
  <method class="org.apache.xerces.impl.dv.xs.Base64BinaryDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.Base64BinaryDV" name="int getDataLength(java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.Base64BinaryDV" name="short getAllowedFacets()" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.TimeDV" map="J"/>
  <method class="org.apache.xerces.impl.dv.xs.TimeDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.TimeDV" name="java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.TimeDV" name="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String)" map="C"/>
  <class name="org.apache.xerces.impl.dv.xs.EntityDV" map="K"/>
  <method class="org.apache.xerces.impl.dv.xs.EntityDV" name="void checkExtraRules(java.lang.Object, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.EntityDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.EntityDV" name="short getAllowedFacets()" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.SchemaDateTimeException" map="L"/>
  <class name="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" map="_A"/>
  <field class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="canonical" map="A"/>
  <field class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="totalDigits" map="B"/>
  <field class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="fracDigits" map="C"/>
  <field class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="sign" map="D"/>
  <field class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="ivalue" map="E"/>
  <field class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="fvalue" map="F"/>
  <field class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="pvalue" map="G"/>
  <field class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="intDigits" map="H"/>
  <method class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="int compareTo(org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="void truncateTrailingZeros(java.lang.StringBuffer, java.lang.StringBuffer)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="int compareDecimal(java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="int compare(org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="void makeCanonical()" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="void initD(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="int intComp(org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV$XPrecisionDecimal" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV" map="M"/>
  <method class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV" name="int getFractionDigits(java.lang.Object)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV" name="short getAllowedFacets()" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV" name="int getTotalDigits(java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.PrecisionDecimalDV" name="int compare(java.lang.Object, java.lang.Object)" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.DoubleDV$XDouble" map="_A"/>
  <field class="org.apache.xerces.impl.dv.xs.DoubleDV$XDouble" name="canonical" map="A"/>
  <field class="org.apache.xerces.impl.dv.xs.DoubleDV$XDouble" name="value" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.DoubleDV$XDouble" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.dv.xs.DoubleDV$XDouble" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.xerces.impl.dv.xs.DoubleDV$XDouble" name="int access$000(org.apache.xerces.impl.dv.xs.DoubleDV$XDouble, org.apache.xerces.impl.dv.xs.DoubleDV$XDouble)" map="access$000"/>
  <method class="org.apache.xerces.impl.dv.xs.DoubleDV$XDouble" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.dv.xs.DoubleDV$XDouble" name="int compareTo(org.apache.xerces.impl.dv.xs.DoubleDV$XDouble)" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.DoubleDV" map="N"/>
  <method class="org.apache.xerces.impl.dv.xs.DoubleDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.DoubleDV" name="boolean isPossibleFP(java.lang.String)" map="I"/>
  <method class="org.apache.xerces.impl.dv.xs.DoubleDV" name="short getAllowedFacets()" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.DoubleDV" name="int compare(java.lang.Object, java.lang.Object)" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.BaseSchemaDVFactory" map="O"/>
  <method class="org.apache.xerces.impl.dv.xs.BaseSchemaDVFactory" name="void createBuiltInTypes(org.apache.xerces.util.SymbolHash, org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.BaseSchemaDVFactory" name="void setDeclPool(org.apache.xerces.impl.xs.XSDeclarationPool)" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.StringDV" map="P"/>
  <method class="org.apache.xerces.impl.dv.xs.StringDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.StringDV" name="short getAllowedFacets()" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$2" map="2"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$2" name="boolean needExtraChecking()" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$2" name="java.lang.String getURI(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$2" name="boolean isIdDeclared(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$2" name="java.lang.String getSymbol(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$2" name="void addId(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$2" name="void addIdRef(java.lang.String)" map="E"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$2" name="java.util.Locale getLocale()" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$2" name="boolean useNamespaces()" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$2" name="boolean needFacetChecking()" map="D"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$2" name="boolean isEntityUnparsed(java.lang.String)" map="F"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$2" name="boolean needToNormalize()" map="E"/>
  <class name="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$1" map="1"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$1" name="boolean needExtraChecking()" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$1" name="java.lang.String getURI(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$1" name="boolean isIdDeclared(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$1" name="java.lang.String getSymbol(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$1" name="void addId(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$1" name="void addIdRef(java.lang.String)" map="E"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$1" name="java.util.Locale getLocale()" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$1" name="boolean useNamespaces()" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$1" name="boolean needFacetChecking()" map="D"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$1" name="boolean isEntityUnparsed(java.lang.String)" map="F"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$1" name="boolean needToNormalize()" map="E"/>
  <class name="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl" map="_A"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl" name="fNSContext" map="A"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl" name="fExternal" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl" name="boolean needExtraChecking()" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl" name="java.lang.String getURI(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl" name="boolean isIdDeclared(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl" name="java.lang.String getSymbol(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl" name="void addId(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl" name="void setNSContext(org.apache.xerces.xni.NamespaceContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl" name="void addIdRef(java.lang.String)" map="E"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl" name="java.util.Locale getLocale()" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl" name="boolean useNamespaces()" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl" name="boolean needFacetChecking()" map="D"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl" name="boolean isEntityUnparsed(java.lang.String)" map="F"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl$ValidationContextImpl" name="boolean needToNormalize()" map="E"/>
  <class name="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" map="Q"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="SPECIAL_PATTERN_STRING" map="&#x00f4;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fFractionDigits" map="&#x00f5;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fPattern" map="&#x00f6;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fFixedFacet" map="&#x00f8;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fFacetsDefined" map="&#x00f9;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="minInclusiveAnnotation" map="&#x00fa;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fLength" map="&#x00fb;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="gDVs" map="&#x00fc;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="minExclusiveAnnotation" map="&#x00fd;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fWhiteSpace" map="&#x00fe;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fPatternStr" map="&#x00ff;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fValidationDV" map="&#x0100;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fMemberTypes" map="&#x0101;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="patternAnnotations" map="&#x0102;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fEmptyContext" map="&#x0103;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fVariety" map="&#x0104;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fMinLength" map="&#x0105;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fBase" map="&#x0106;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fPatternType" map="&#x0107;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fTotalDigits" map="&#x0108;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="minLengthAnnotation" map="&#x0109;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fMaxInclusive" map="&#x010a;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="WS_FACET_STRING" map="&#x010b;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="enumerationAnnotations" map="&#x010c;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fIsImmutable" map="&#x010d;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fDVNormalizeType" map="&#x010e;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fAnnotations" map="&#x010f;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fMaxExclusive" map="&#x0110;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="lengthAnnotation" map="&#x0111;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="maxInclusiveAnnotation" map="&#x0112;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fItemType" map="&#x0113;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fTypeName" map="&#x0114;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fDummyContext" map="&#x0115;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="maxExclusiveAnnotation" map="&#x0116;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fNumeric" map="&#x0117;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="totalDigitsAnnotation" map="&#x0118;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fDVs" map="&#x0119;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fFinite" map="&#x011a;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fMaxLength" map="&#x011b;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="maxLengthAnnotation" map="&#x011c;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fAnySimpleType" map="&#x011d;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fNamespaceItem" map="&#x011e;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fBuiltInKind" map="&#x011f;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="whiteSpaceAnnotation" map="&#x0120;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fMinInclusive" map="&#x0121;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fTargetNamespace" map="&#x0122;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fEnumerationSize" map="&#x0123;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fOrdered" map="&#x0124;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fAnyAtomicType" map="&#x0125;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fAnonymous" map="&#x0126;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fMinExclusive" map="&#x0127;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fractionDigitsAnnotation" map="&#x0128;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fEnumeration" map="&#x0129;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fFinalSet" map="&#x012a;"/>
  <field class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="fBounded" map="&#x012b;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void setAnonymous(boolean)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void setNamespaceItem(org.apache.xerces.xs.XSNamespaceItem)" map="F"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="java.lang.String normalize(java.lang.Object, short)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void setOrdered()" map="&#x00eb;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="org.apache.xerces.xs.XSSimpleTypeDefinition getItemType()" map="&#x00e7;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="java.lang.Object getActualValue(java.lang.Object, org.apache.xerces.impl.dv.ValidationContext, org.apache.xerces.impl.dv.ValidatedInfo, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="short getType()" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void calcFundamentalFacets()" map="&#x00ec;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="java.lang.String whiteSpaceValue(short)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void applyFacets1(org.apache.xerces.impl.dv.XSFacets, short, short)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="short getWhitespace()" map="&#x00e8;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void setBounded()" map="&#x00ed;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="boolean getAnonymous()" map="r"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="java.lang.Object validate(java.lang.Object, org.apache.xerces.impl.dv.ValidationContext, org.apache.xerces.impl.dv.ValidatedInfo)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="short getBuiltInKind()" map="&#x00e2;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void setCardinality()" map="&#x00ee;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void setNumeric()" map="&#x00ef;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="short getPrimitiveKind()" map="&#x00ea;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void appendEnumString(java.lang.StringBuffer)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="short convertToPrimitiveKind(short)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void applyFacets(org.apache.xerces.impl.dv.XSFacets, short, short, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void checkFacets(org.apache.xerces.impl.dv.ValidatedInfo)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void applyFacets1(org.apache.xerces.impl.dv.XSFacets, short, short, short)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="org.apache.xerces.xs.XSTypeDefinition getBaseType()" map="s"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="java.lang.Object validate(java.lang.String, org.apache.xerces.impl.dv.ValidationContext, org.apache.xerces.impl.dv.ValidatedInfo)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="org.apache.xerces.xs.XSNamespaceItem getNamespaceItem()" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="java.lang.String getNamespace()" map="D"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="org.apache.xerces.xs.XSObjectList getMemberTypes()" map="&#x00e5;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="boolean specialCardinalityCheck()" map="&#x00f0;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="short getTypeCategory()" map="u"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void checkExtraRules(org.apache.xerces.impl.dv.ValidationContext, org.apache.xerces.impl.dv.ValidatedInfo)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="org.apache.xerces.xs.XSSimpleTypeDefinition getPrimitiveType()" map="&#x00e0;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="boolean isIDType()" map="&#x00e9;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void applyFacets(org.apache.xerces.impl.dv.XSFacets, short, short, short, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="short getDefinedFacets()" map="&#x00e3;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="boolean getBounded()" map="&#x00f1;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void validate(org.apache.xerces.impl.dv.ValidationContext, org.apache.xerces.impl.dv.ValidatedInfo)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="java.lang.String normalize(java.lang.String, short)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="short getFinal()" map="t"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="short getVariety()" map="&#x00e6;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="org.apache.xerces.impl.dv.ValidatedInfo validateWithInfo(java.lang.String, org.apache.xerces.impl.dv.ValidationContext, org.apache.xerces.impl.dv.ValidatedInfo)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="void reportError(java.lang.String, java.lang.Object[])" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="short getPrimitiveDV(short)" map="D"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="org.apache.xerces.impl.dv.ValidatedInfo getActualEnumValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext, org.apache.xerces.impl.dv.ValidatedInfo)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="boolean getNumeric()" map="&#x00e4;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="java.lang.String getTypeName()" map="&#x00f2;"/>
  <method class="org.apache.xerces.impl.dv.xs.XSSimpleTypeDecl" name="boolean getFinite()" map="&#x00e1;"/>
  <class name="org.apache.xerces.impl.dv.xs.ListDV$ListData" map="_A"/>
  <field class="org.apache.xerces.impl.dv.xs.ListDV$ListData" name="canonical" map="D"/>
  <field class="org.apache.xerces.impl.dv.xs.ListDV$ListData" name="data" map="E"/>
  <method class="org.apache.xerces.impl.dv.xs.ListDV$ListData" name="int size()" map="size"/>
  <method class="org.apache.xerces.impl.dv.xs.ListDV$ListData" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.dv.xs.ListDV$ListData" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.xerces.impl.dv.xs.ListDV$ListData" name="java.lang.Object item(int)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.ListDV$ListData" name="int getLength()" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.ListDV$ListData" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.dv.xs.ListDV$ListData" name="java.lang.Object get(int)" map="get"/>
  <method class="org.apache.xerces.impl.dv.xs.ListDV$ListData" name="boolean contains(java.lang.Object)" map="contains"/>
  <class name="org.apache.xerces.impl.dv.xs.ListDV" map="R"/>
  <method class="org.apache.xerces.impl.dv.xs.ListDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.ListDV" name="int getDataLength(java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.ListDV" name="short getAllowedFacets()" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.MonthDV" map="S"/>
  <method class="org.apache.xerces.impl.dv.xs.MonthDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.MonthDV" name="java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.MonthDV" name="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String)" map="D"/>
  <class name="org.apache.xerces.impl.dv.xs.FloatDV$XFloat" map="_A"/>
  <field class="org.apache.xerces.impl.dv.xs.FloatDV$XFloat" name="canonical" map="A"/>
  <field class="org.apache.xerces.impl.dv.xs.FloatDV$XFloat" name="value" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.FloatDV$XFloat" name="int access$000(org.apache.xerces.impl.dv.xs.FloatDV$XFloat, org.apache.xerces.impl.dv.xs.FloatDV$XFloat)" map="access$000"/>
  <method class="org.apache.xerces.impl.dv.xs.FloatDV$XFloat" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.dv.xs.FloatDV$XFloat" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.xerces.impl.dv.xs.FloatDV$XFloat" name="int compareTo(org.apache.xerces.impl.dv.xs.FloatDV$XFloat)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.FloatDV$XFloat" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.dv.xs.FloatDV" map="T"/>
  <method class="org.apache.xerces.impl.dv.xs.FloatDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.FloatDV" name="short getAllowedFacets()" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.FloatDV" name="int compare(java.lang.Object, java.lang.Object)" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.DayDV" map="U"/>
  <method class="org.apache.xerces.impl.dv.xs.DayDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.DayDV" name="java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.DayDV" name="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String)" map="E"/>
  <class name="org.apache.xerces.impl.dv.xs.MonthDayDV" map="V"/>
  <method class="org.apache.xerces.impl.dv.xs.MonthDayDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.MonthDayDV" name="java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.MonthDayDV" name="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String)" map="F"/>
  <class name="org.apache.xerces.impl.dv.xs.DayTimeDurationDV" map="W"/>
  <method class="org.apache.xerces.impl.dv.xs.DayTimeDurationDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.BooleanDV" map="X"/>
  <method class="org.apache.xerces.impl.dv.xs.BooleanDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.BooleanDV" name="short getAllowedFacets()" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.TypeValidator" map="Y"/>
  <method class="org.apache.xerces.impl.dv.xs.TypeValidator" name="int compare(java.lang.Object, java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.TypeValidator" name="boolean isDigit(char)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.TypeValidator" name="int getDataLength(java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.TypeValidator" name="void checkExtraRules(java.lang.Object, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.TypeValidator" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.TypeValidator" name="int getDigit(char)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.TypeValidator" name="short getAllowedFacets()" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.TypeValidator" name="int getTotalDigits(java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.TypeValidator" name="int getFractionDigits(java.lang.Object)" map="C"/>
  <class name="org.apache.xerces.impl.dv.xs.SchemaDVFactoryImpl" map="Z"/>
  <field class="org.apache.xerces.impl.dv.xs.SchemaDVFactoryImpl" name="fBuiltInTypes" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.SchemaDVFactoryImpl" name="void createBuiltInTypes()" map="C"/>
  <class name="org.apache.xerces.impl.dv.xs.DateTimeDV" map="_"/>
  <method class="org.apache.xerces.impl.dv.xs.DateTimeDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.DateTimeDV" name="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String)" map="G"/>
  <class name="org.apache.xerces.impl.dv.xs.IDDV" map="a"/>
  <method class="org.apache.xerces.impl.dv.xs.IDDV" name="void checkExtraRules(java.lang.Object, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.IDDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.IDDV" name="short getAllowedFacets()" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" map="_A"/>
  <field class="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" name="canonical" map="A"/>
  <field class="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" name="totalDigits" map="B"/>
  <field class="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" name="fracDigits" map="C"/>
  <field class="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" name="sign" map="D"/>
  <field class="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" name="integer" map="E"/>
  <field class="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" name="ivalue" map="F"/>
  <field class="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" name="fvalue" map="G"/>
  <field class="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" name="intDigits" map="H"/>
  <method class="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" name="void initI(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" name="void makeCanonical()" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" name="int intComp(org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" name="void initD(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal" name="int compareTo(org.apache.xerces.impl.dv.xs.DecimalDV$XDecimal)" map="B"/>
  <class name="org.apache.xerces.impl.dv.xs.DecimalDV" map="b"/>
  <method class="org.apache.xerces.impl.dv.xs.DecimalDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.DecimalDV" name="int getFractionDigits(java.lang.Object)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.DecimalDV" name="short getAllowedFacets()" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.DecimalDV" name="int getTotalDigits(java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.DecimalDV" name="int compare(java.lang.Object, java.lang.Object)" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.YearDV" map="c"/>
  <method class="org.apache.xerces.impl.dv.xs.YearDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.YearDV" name="java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.YearDV" name="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String)" map="H"/>
  <class name="org.apache.xerces.impl.dv.xs.QNameDV$XQName" map="_A"/>
  <method class="org.apache.xerces.impl.dv.xs.QNameDV$XQName" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.dv.xs.QNameDV$XQName" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.dv.xs.QNameDV" map="d"/>
  <field class="org.apache.xerces.impl.dv.xs.QNameDV" name="EMPTY_STRING" map="H"/>
  <method class="org.apache.xerces.impl.dv.xs.QNameDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.QNameDV" name="int getDataLength(java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.QNameDV" name="short getAllowedFacets()" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.HexBinaryDV$XHex" map="_A"/>
  <method class="org.apache.xerces.impl.dv.xs.HexBinaryDV$XHex" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.dv.xs.HexBinaryDV$XHex" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.xerces.impl.dv.xs.HexBinaryDV$XHex" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.dv.xs.HexBinaryDV" map="e"/>
  <method class="org.apache.xerces.impl.dv.xs.HexBinaryDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.HexBinaryDV" name="int getDataLength(java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.HexBinaryDV" name="short getAllowedFacets()" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.UnionDV" map="f"/>
  <method class="org.apache.xerces.impl.dv.xs.UnionDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.UnionDV" name="short getAllowedFacets()" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.DurationDV" map="g"/>
  <field class="org.apache.xerces.impl.dv.xs.DurationDV" name="DATETIMES" map="G"/>
  <method class="org.apache.xerces.impl.dv.xs.DurationDV" name="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String, int)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.DurationDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.DurationDV" name="double parseSecond(java.lang.String, int, int)" map="B"/>
  <method class="org.apache.xerces.impl.dv.xs.DurationDV" name="short compareResults(short, short, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.DurationDV" name="java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.DurationDV" name="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData addDuration(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData, org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData, org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.DurationDV" name="short compareDates(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData, org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData, boolean)" map="A"/>
  <class name="org.apache.xerces.impl.dv.xs.DateDV" map="h"/>
  <method class="org.apache.xerces.impl.dv.xs.DateDV" name="java.lang.Object getActualValue(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.xs.DateDV" name="java.lang.String dateToString(org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData)" map="C"/>
  <method class="org.apache.xerces.impl.dv.xs.DateDV" name="org.apache.xerces.impl.dv.xs.AbstractDateTimeDV$DateTimeData parse(java.lang.String)" map="G"/>
  <package name="org.apache.xerces.impl.dv.dtd" map="C"/>
  <class name="org.apache.xerces.impl.dv.dtd.IDDatatypeValidator" map="A"/>
  <method class="org.apache.xerces.impl.dv.dtd.IDDatatypeValidator" name="void validate(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <class name="org.apache.xerces.impl.dv.dtd.NMTOKENDatatypeValidator" map="B"/>
  <method class="org.apache.xerces.impl.dv.dtd.NMTOKENDatatypeValidator" name="void validate(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <class name="org.apache.xerces.impl.dv.dtd.StringDatatypeValidator" map="C"/>
  <method class="org.apache.xerces.impl.dv.dtd.StringDatatypeValidator" name="void validate(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <class name="org.apache.xerces.impl.dv.dtd.ListDatatypeValidator" map="D"/>
  <field class="org.apache.xerces.impl.dv.dtd.ListDatatypeValidator" name="fItemValidator" map="A"/>
  <method class="org.apache.xerces.impl.dv.dtd.ListDatatypeValidator" name="void validate(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <class name="org.apache.xerces.impl.dv.dtd.ENTITYDatatypeValidator" map="E"/>
  <method class="org.apache.xerces.impl.dv.dtd.ENTITYDatatypeValidator" name="void validate(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <class name="org.apache.xerces.impl.dv.dtd.NOTATIONDatatypeValidator" map="F"/>
  <method class="org.apache.xerces.impl.dv.dtd.NOTATIONDatatypeValidator" name="void validate(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <class name="org.apache.xerces.impl.dv.dtd.IDREFDatatypeValidator" map="G"/>
  <method class="org.apache.xerces.impl.dv.dtd.IDREFDatatypeValidator" name="void validate(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <class name="org.apache.xerces.impl.dv.dtd.DTDDVFactoryImpl" map="H"/>
  <field class="org.apache.xerces.impl.dv.dtd.DTDDVFactoryImpl" name="fBuiltInTypes" map="A"/>
  <method class="org.apache.xerces.impl.dv.dtd.DTDDVFactoryImpl" name="void createBuiltInTypes()" map="B"/>
  <method class="org.apache.xerces.impl.dv.dtd.DTDDVFactoryImpl" name="java.util.Hashtable getBuiltInTypes()" map="C"/>
  <method class="org.apache.xerces.impl.dv.dtd.DTDDVFactoryImpl" name="org.apache.xerces.impl.dv.DatatypeValidator getBuiltInDV(java.lang.String)" map="B"/>
  <class name="org.apache.xerces.impl.dv.SecuritySupport$4" map="4"/>
  <field class="org.apache.xerces.impl.dv.SecuritySupport$4" name="val$propName" map="val$propName"/>
  <method class="org.apache.xerces.impl.dv.SecuritySupport$4" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.impl.dv.SecuritySupport$3" map="3"/>
  <field class="org.apache.xerces.impl.dv.SecuritySupport$3" name="val$cl" map="val$cl"/>
  <method class="org.apache.xerces.impl.dv.SecuritySupport$3" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.impl.dv.SecuritySupport$2" map="2"/>
  <method class="org.apache.xerces.impl.dv.SecuritySupport$2" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.impl.dv.SecuritySupport$1" map="1"/>
  <method class="org.apache.xerces.impl.dv.SecuritySupport$1" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.impl.dv.SecuritySupport" map="A"/>
  <method class="org.apache.xerces.impl.dv.SecuritySupport" name="java.lang.ClassLoader getContextClassLoader()" map="A"/>
  <method class="org.apache.xerces.impl.dv.SecuritySupport" name="java.lang.ClassLoader getSystemClassLoader()" map="B"/>
  <method class="org.apache.xerces.impl.dv.SecuritySupport" name="java.lang.String getSystemProperty(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.dv.SecuritySupport" name="java.lang.ClassLoader getParentClassLoader(java.lang.ClassLoader)" map="A"/>
  <class name="org.apache.xerces.impl.dv.ValidationContext" map="B"/>
  <method class="org.apache.xerces.impl.dv.ValidationContext" name="boolean needExtraChecking()" map="A"/>
  <method class="org.apache.xerces.impl.dv.ValidationContext" name="java.lang.String getURI(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.dv.ValidationContext" name="boolean isIdDeclared(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.dv.ValidationContext" name="java.lang.String getSymbol(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.dv.ValidationContext" name="void addId(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.impl.dv.ValidationContext" name="void addIdRef(java.lang.String)" map="E"/>
  <method class="org.apache.xerces.impl.dv.ValidationContext" name="java.util.Locale getLocale()" map="B"/>
  <method class="org.apache.xerces.impl.dv.ValidationContext" name="boolean useNamespaces()" map="C"/>
  <method class="org.apache.xerces.impl.dv.ValidationContext" name="boolean needFacetChecking()" map="D"/>
  <method class="org.apache.xerces.impl.dv.ValidationContext" name="boolean isEntityUnparsed(java.lang.String)" map="F"/>
  <method class="org.apache.xerces.impl.dv.ValidationContext" name="boolean needToNormalize()" map="E"/>
  <class name="org.apache.xerces.impl.dv.DatatypeValidator" map="C"/>
  <method class="org.apache.xerces.impl.dv.DatatypeValidator" name="void validate(java.lang.String, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <class name="org.apache.xerces.impl.dv.DTDDVFactory" map="D"/>
  <method class="org.apache.xerces.impl.dv.DTDDVFactory" name="org.apache.xerces.impl.dv.DTDDVFactory getInstance(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.dv.DTDDVFactory" name="org.apache.xerces.impl.dv.DatatypeValidator getBuiltInDV(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.dv.DTDDVFactory" name="org.apache.xerces.impl.dv.DTDDVFactory getInstance()" map="A"/>
  <class name="org.apache.xerces.impl.dv.ValidatedInfo" map="E"/>
  <field class="org.apache.xerces.impl.dv.ValidatedInfo" name="memberTypes" map="A"/>
  <field class="org.apache.xerces.impl.dv.ValidatedInfo" name="actualValueType" map="B"/>
  <field class="org.apache.xerces.impl.dv.ValidatedInfo" name="actualType" map="C"/>
  <field class="org.apache.xerces.impl.dv.ValidatedInfo" name="memberType" map="D"/>
  <field class="org.apache.xerces.impl.dv.ValidatedInfo" name="normalizedValue" map="E"/>
  <field class="org.apache.xerces.impl.dv.ValidatedInfo" name="itemValueTypes" map="F"/>
  <field class="org.apache.xerces.impl.dv.ValidatedInfo" name="actualValue" map="G"/>
  <method class="org.apache.xerces.impl.dv.ValidatedInfo" name="short convertToPrimitiveKind(short)" map="A"/>
  <method class="org.apache.xerces.impl.dv.ValidatedInfo" name="org.apache.xerces.xs.XSSimpleTypeDefinition getTypeDefinition()" map="C"/>
  <method class="org.apache.xerces.impl.dv.ValidatedInfo" name="void reset()" map="H"/>
  <method class="org.apache.xerces.impl.dv.ValidatedInfo" name="void copyFrom(org.apache.xerces.xs.XSValue)" map="A"/>
  <method class="org.apache.xerces.impl.dv.ValidatedInfo" name="java.lang.String getNormalizedValue()" map="A"/>
  <method class="org.apache.xerces.impl.dv.ValidatedInfo" name="short getActualValueType()" map="E"/>
  <method class="org.apache.xerces.impl.dv.ValidatedInfo" name="org.apache.xerces.xs.XSObjectList getMemberTypeDefinitions()" map="D"/>
  <method class="org.apache.xerces.impl.dv.ValidatedInfo" name="java.lang.Object getActualValue()" map="G"/>
  <method class="org.apache.xerces.impl.dv.ValidatedInfo" name="org.apache.xerces.xs.XSSimpleTypeDefinition getMemberTypeDefinition()" map="F"/>
  <method class="org.apache.xerces.impl.dv.ValidatedInfo" name="boolean isComparable(org.apache.xerces.impl.dv.ValidatedInfo, org.apache.xerces.impl.dv.ValidatedInfo)" map="A"/>
  <method class="org.apache.xerces.impl.dv.ValidatedInfo" name="java.lang.String stringValue()" map="I"/>
  <method class="org.apache.xerces.impl.dv.ValidatedInfo" name="org.apache.xerces.xs.ShortList getListValueTypes()" map="B"/>
  <class name="org.apache.xerces.impl.dv.DatatypeException" map="F"/>
  <field class="org.apache.xerces.impl.dv.DatatypeException" name="args" map="A"/>
  <field class="org.apache.xerces.impl.dv.DatatypeException" name="key" map="B"/>
  <method class="org.apache.xerces.impl.dv.DatatypeException" name="java.lang.String getMessage()" map="getMessage"/>
  <method class="org.apache.xerces.impl.dv.DatatypeException" name="java.lang.String getKey()" map="A"/>
  <method class="org.apache.xerces.impl.dv.DatatypeException" name="java.lang.Object[] getArgs()" map="B"/>
  <class name="org.apache.xerces.impl.dv.XSSimpleType" map="G"/>
  <method class="org.apache.xerces.impl.dv.XSSimpleType" name="void applyFacets(org.apache.xerces.impl.dv.XSFacets, short, short, org.apache.xerces.impl.dv.ValidationContext)" map="A"/>
  <method class="org.apache.xerces.impl.dv.XSSimpleType" name="short getWhitespace()" map="&#x00e8;"/>
  <method class="org.apache.xerces.impl.dv.XSSimpleType" name="boolean isIDType()" map="&#x00e9;"/>
  <method class="org.apache.xerces.impl.dv.XSSimpleType" name="java.lang.Object validate(java.lang.String, org.apache.xerces.impl.dv.ValidationContext, org.apache.xerces.impl.dv.ValidatedInfo)" map="A"/>
  <method class="org.apache.xerces.impl.dv.XSSimpleType" name="java.lang.Object validate(java.lang.Object, org.apache.xerces.impl.dv.ValidationContext, org.apache.xerces.impl.dv.ValidatedInfo)" map="A"/>
  <method class="org.apache.xerces.impl.dv.XSSimpleType" name="short getPrimitiveKind()" map="&#x00ea;"/>
  <class name="org.apache.xerces.impl.dv.ObjectFactory$ConfigurationError" map="_A"/>
  <field class="org.apache.xerces.impl.dv.ObjectFactory$ConfigurationError" name="exception" map="A"/>
  <class name="org.apache.xerces.impl.dv.ObjectFactory" map="H"/>
  <field class="org.apache.xerces.impl.dv.ObjectFactory" name="class$org$apache$xerces$impl$dv$ObjectFactory" map="class$F$C$A$G$D$H"/>
  <field class="org.apache.xerces.impl.dv.ObjectFactory" name="fLastModified" map="A"/>
  <field class="org.apache.xerces.impl.dv.ObjectFactory" name="DEBUG" map="B"/>
  <field class="org.apache.xerces.impl.dv.ObjectFactory" name="fXercesProperties" map="C"/>
  <method class="org.apache.xerces.impl.dv.ObjectFactory" name="void debugPrintln(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.dv.ObjectFactory" name="java.lang.ClassLoader findClassLoader()" map="A"/>
  <method class="org.apache.xerces.impl.dv.ObjectFactory" name="boolean isDebugEnabled()" map="B"/>
  <method class="org.apache.xerces.impl.dv.ObjectFactory" name="java.lang.Class findProviderClass(java.lang.String, java.lang.ClassLoader, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.dv.ObjectFactory" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.apache.xerces.impl.dv.ObjectFactory" name="java.lang.Object newInstance(java.lang.String, java.lang.ClassLoader, boolean)" map="B"/>
  <class name="org.apache.xerces.impl.dv.InvalidDatatypeValueException" map="I"/>
  <class name="org.apache.xerces.impl.dv.InvalidDatatypeFacetException" map="J"/>
  <class name="org.apache.xerces.impl.dv.SchemaDVFactory" map="K"/>
  <method class="org.apache.xerces.impl.dv.SchemaDVFactory" name="org.apache.xerces.impl.dv.XSSimpleType createTypeUnion(java.lang.String, java.lang.String, short, org.apache.xerces.impl.dv.XSSimpleType[], org.apache.xerces.xs.XSObjectList)" map="A"/>
  <method class="org.apache.xerces.impl.dv.SchemaDVFactory" name="org.apache.xerces.impl.dv.SchemaDVFactory getInstance(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.dv.SchemaDVFactory" name="org.apache.xerces.impl.dv.XSSimpleType createTypeRestriction(java.lang.String, java.lang.String, short, org.apache.xerces.impl.dv.XSSimpleType, org.apache.xerces.xs.XSObjectList)" map="A"/>
  <method class="org.apache.xerces.impl.dv.SchemaDVFactory" name="org.apache.xerces.impl.dv.XSSimpleType createTypeList(java.lang.String, java.lang.String, short, org.apache.xerces.impl.dv.XSSimpleType, org.apache.xerces.xs.XSObjectList)" map="B"/>
  <method class="org.apache.xerces.impl.dv.SchemaDVFactory" name="org.apache.xerces.impl.dv.XSSimpleType getBuiltInType(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.dv.SchemaDVFactory" name="org.apache.xerces.impl.dv.SchemaDVFactory getInstance()" map="A"/>
  <method class="org.apache.xerces.impl.dv.SchemaDVFactory" name="org.apache.xerces.util.SymbolHash getBuiltInTypes()" map="B"/>
  <class name="org.apache.xerces.impl.dv.XSFacets" map="L"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="fractionDigitsAnnotation" map="A"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="whiteSpace" map="B"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="patternAnnotations" map="C"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="length" map="D"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="minInclusive" map="E"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="totalDigitsAnnotation" map="F"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="maxLength" map="G"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="maxInclusiveAnnotation" map="H"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="minExclusive" map="I"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="maxExclusiveAnnotation" map="J"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="enumNSDecls" map="K"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="enumeration" map="L"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="fractionDigits" map="M"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="minInclusiveAnnotation" map="N"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="minExclusiveAnnotation" map="O"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="maxLengthAnnotation" map="P"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="minLengthAnnotation" map="Q"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="enumAnnotations" map="R"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="totalDigits" map="S"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="pattern" map="T"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="maxInclusive" map="U"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="maxExclusive" map="V"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="whiteSpaceAnnotation" map="W"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="minLength" map="X"/>
  <field class="org.apache.xerces.impl.dv.XSFacets" name="lengthAnnotation" map="Y"/>
  <method class="org.apache.xerces.impl.dv.XSFacets" name="void reset()" map="A"/>
  <class name="org.apache.xerces.impl.dv.DVFactoryException" map="M"/>
  <package name="org.apache.xerces.impl.dtd" map="E"/>
  <package name="org.apache.xerces.impl.dtd.models" map="A"/>
  <class name="org.apache.xerces.impl.dtd.models.CMUniOp" map="A"/>
  <field class="org.apache.xerces.impl.dtd.models.CMUniOp" name="fChild" map="J"/>
  <method class="org.apache.xerces.impl.dtd.models.CMUniOp" name="boolean isNullable()" map="D"/>
  <method class="org.apache.xerces.impl.dtd.models.CMUniOp" name="org.apache.xerces.impl.dtd.models.CMNode getChild()" map="I"/>
  <method class="org.apache.xerces.impl.dtd.models.CMUniOp" name="void calcFirstPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.models.CMUniOp" name="void calcLastPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="A"/>
  <class name="org.apache.xerces.impl.dtd.models.CMBinOp" map="B"/>
  <field class="org.apache.xerces.impl.dtd.models.CMBinOp" name="fRightChild" map="K"/>
  <field class="org.apache.xerces.impl.dtd.models.CMBinOp" name="fLeftChild" map="L"/>
  <method class="org.apache.xerces.impl.dtd.models.CMBinOp" name="boolean isNullable()" map="D"/>
  <method class="org.apache.xerces.impl.dtd.models.CMBinOp" name="org.apache.xerces.impl.dtd.models.CMNode getLeft()" map="J"/>
  <method class="org.apache.xerces.impl.dtd.models.CMBinOp" name="void calcFirstPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.models.CMBinOp" name="org.apache.xerces.impl.dtd.models.CMNode getRight()" map="K"/>
  <method class="org.apache.xerces.impl.dtd.models.CMBinOp" name="void calcLastPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="A"/>
  <class name="org.apache.xerces.impl.dtd.models.CMNode" map="C"/>
  <field class="org.apache.xerces.impl.dtd.models.CMNode" name="fLastPos" map="A"/>
  <field class="org.apache.xerces.impl.dtd.models.CMNode" name="fFollowPos" map="B"/>
  <field class="org.apache.xerces.impl.dtd.models.CMNode" name="fMaxStates" map="C"/>
  <field class="org.apache.xerces.impl.dtd.models.CMNode" name="fFirstPos" map="D"/>
  <field class="org.apache.xerces.impl.dtd.models.CMNode" name="fCompactedForUPA" map="E"/>
  <field class="org.apache.xerces.impl.dtd.models.CMNode" name="fType" map="F"/>
  <method class="org.apache.xerces.impl.dtd.models.CMNode" name="int type()" map="A"/>
  <method class="org.apache.xerces.impl.dtd.models.CMNode" name="void setMaxStates(int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.models.CMNode" name="org.apache.xerces.impl.dtd.models.CMStateSet lastPos()" map="B"/>
  <method class="org.apache.xerces.impl.dtd.models.CMNode" name="void calcLastPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.models.CMNode" name="void calcFirstPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.models.CMNode" name="org.apache.xerces.impl.dtd.models.CMStateSet firstPos()" map="C"/>
  <method class="org.apache.xerces.impl.dtd.models.CMNode" name="boolean isNullable()" map="D"/>
  <method class="org.apache.xerces.impl.dtd.models.CMNode" name="boolean isCompactedForUPA()" map="E"/>
  <method class="org.apache.xerces.impl.dtd.models.CMNode" name="void setIsCompactUPAModel(boolean)" map="A"/>
  <class name="org.apache.xerces.impl.dtd.models.MixedContentModel" map="D"/>
  <field class="org.apache.xerces.impl.dtd.models.MixedContentModel" name="fCount" map="U"/>
  <field class="org.apache.xerces.impl.dtd.models.MixedContentModel" name="fChildrenType" map="V"/>
  <field class="org.apache.xerces.impl.dtd.models.MixedContentModel" name="fChildren" map="W"/>
  <field class="org.apache.xerces.impl.dtd.models.MixedContentModel" name="fOrdered" map="X"/>
  <method class="org.apache.xerces.impl.dtd.models.MixedContentModel" name="int validate(org.apache.xerces.xni.QName[], int, int)" map="A"/>
  <class name="org.apache.xerces.impl.dtd.models.DFAContentModel" map="E"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fElemMap" map="A"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fTransTable" map="B"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fEpsilonString" map="C"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fTransTableSize" map="D"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fEmptyContentIsValid" map="E"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fHeadNode" map="F"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fEOCString" map="G"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fLeafListType" map="H"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fElemMapType" map="I"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fQName" map="J"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fFinalStateFlags" map="K"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fMixed" map="L"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fFollowList" map="M"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fElemMapSize" map="N"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fLeafList" map="O"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fLeafCount" map="P"/>
  <field class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="fEOCPos" map="Q"/>
  <method class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="int postTreeBuildInit(org.apache.xerces.impl.dtd.models.CMNode, int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="void buildDFA(org.apache.xerces.impl.dtd.models.CMNode)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="int validate(org.apache.xerces.xni.QName[], int, int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="int[] makeDefStateList()" map="A"/>
  <method class="org.apache.xerces.impl.dtd.models.DFAContentModel" name="void calcFollowList(org.apache.xerces.impl.dtd.models.CMNode)" map="B"/>
  <class name="org.apache.xerces.impl.dtd.models.CMLeaf" map="F"/>
  <field class="org.apache.xerces.impl.dtd.models.CMLeaf" name="fElement" map="M"/>
  <field class="org.apache.xerces.impl.dtd.models.CMLeaf" name="fPosition" map="N"/>
  <method class="org.apache.xerces.impl.dtd.models.CMLeaf" name="boolean isNullable()" map="D"/>
  <method class="org.apache.xerces.impl.dtd.models.CMLeaf" name="void calcFirstPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.models.CMLeaf" name="org.apache.xerces.xni.QName getElement()" map="L"/>
  <method class="org.apache.xerces.impl.dtd.models.CMLeaf" name="void calcLastPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.models.CMLeaf" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.dtd.models.CMLeaf" name="void setPosition(int)" map="B"/>
  <class name="org.apache.xerces.impl.dtd.models.CMAny" map="G"/>
  <field class="org.apache.xerces.impl.dtd.models.CMAny" name="fURI" map="O"/>
  <field class="org.apache.xerces.impl.dtd.models.CMAny" name="fPosition" map="P"/>
  <field class="org.apache.xerces.impl.dtd.models.CMAny" name="fType" map="Q"/>
  <method class="org.apache.xerces.impl.dtd.models.CMAny" name="java.lang.String getURI()" map="M"/>
  <method class="org.apache.xerces.impl.dtd.models.CMAny" name="boolean isNullable()" map="D"/>
  <method class="org.apache.xerces.impl.dtd.models.CMAny" name="void calcFirstPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.models.CMAny" name="void calcLastPos(org.apache.xerces.impl.dtd.models.CMStateSet)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.models.CMAny" name="int getPosition()" map="N"/>
  <method class="org.apache.xerces.impl.dtd.models.CMAny" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.xerces.impl.dtd.models.SimpleContentModel" map="H"/>
  <field class="org.apache.xerces.impl.dtd.models.SimpleContentModel" name="fFirstChild" map="R"/>
  <field class="org.apache.xerces.impl.dtd.models.SimpleContentModel" name="fSecondChild" map="S"/>
  <field class="org.apache.xerces.impl.dtd.models.SimpleContentModel" name="fOperator" map="T"/>
  <method class="org.apache.xerces.impl.dtd.models.SimpleContentModel" name="int validate(org.apache.xerces.xni.QName[], int, int)" map="A"/>
  <class name="org.apache.xerces.impl.dtd.models.ContentModelValidator" map="I"/>
  <method class="org.apache.xerces.impl.dtd.models.ContentModelValidator" name="int validate(org.apache.xerces.xni.QName[], int, int)" map="A"/>
  <class name="org.apache.xerces.impl.dtd.models.CMStateSet" map="J"/>
  <field class="org.apache.xerces.impl.dtd.models.CMStateSet" name="fBitCount" map="A"/>
  <field class="org.apache.xerces.impl.dtd.models.CMStateSet" name="fByteCount" map="B"/>
  <field class="org.apache.xerces.impl.dtd.models.CMStateSet" name="fBits2" map="C"/>
  <field class="org.apache.xerces.impl.dtd.models.CMStateSet" name="fBits1" map="D"/>
  <field class="org.apache.xerces.impl.dtd.models.CMStateSet" name="fByteArray" map="E"/>
  <method class="org.apache.xerces.impl.dtd.models.CMStateSet" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.xerces.impl.dtd.models.CMStateSet" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.dtd.models.CMStateSet" name="void union(org.apache.xerces.impl.dtd.models.CMStateSet)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.models.CMStateSet" name="void setTo(org.apache.xerces.impl.dtd.models.CMStateSet)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.models.CMStateSet" name="boolean getBit(int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.models.CMStateSet" name="void setBit(int)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.models.CMStateSet" name="void zeroBits()" map="A"/>
  <method class="org.apache.xerces.impl.dtd.models.CMStateSet" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.dtd.models.CMStateSet" name="boolean isEmpty()" map="B"/>
  <method class="org.apache.xerces.impl.dtd.models.CMStateSet" name="boolean isSameSet(org.apache.xerces.impl.dtd.models.CMStateSet)" map="C"/>
  <class name="org.apache.xerces.impl.dtd.DTDGrammarBucket" map="A"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammarBucket" name="fIsStandalone" map="A"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammarBucket" name="fActiveGrammar" map="B"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammarBucket" name="fGrammars" map="C"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammarBucket" name="org.apache.xerces.impl.dtd.DTDGrammar getActiveGrammar()" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammarBucket" name="void clear()" map="B"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammarBucket" name="boolean getStandalone()" map="C"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammarBucket" name="void setActiveGrammar(org.apache.xerces.impl.dtd.DTDGrammar)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammarBucket" name="void putGrammar(org.apache.xerces.impl.dtd.DTDGrammar)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammarBucket" name="void setStandalone(boolean)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammarBucket" name="org.apache.xerces.impl.dtd.DTDGrammar getGrammar(org.apache.xerces.xni.grammars.XMLGrammarDescription)" map="A"/>
  <class name="org.apache.xerces.impl.dtd.XMLAttributeDecl" map="B"/>
  <field class="org.apache.xerces.impl.dtd.XMLAttributeDecl" name="optional" map="A"/>
  <field class="org.apache.xerces.impl.dtd.XMLAttributeDecl" name="name" map="B"/>
  <field class="org.apache.xerces.impl.dtd.XMLAttributeDecl" name="simpleType" map="C"/>
  <method class="org.apache.xerces.impl.dtd.XMLAttributeDecl" name="void setValues(org.apache.xerces.xni.QName, org.apache.xerces.impl.dtd.XMLSimpleType, boolean)" map="A"/>
  <class name="org.apache.xerces.impl.dtd.XMLNSDTDValidator" map="C"/>
  <field class="org.apache.xerces.impl.dtd.XMLNSDTDValidator" name="fAttributeQName" map="&#x0414;"/>
  <method class="org.apache.xerces.impl.dtd.XMLNSDTDValidator" name="void endNamespaceScope(org.apache.xerces.xni.QName, org.apache.xerces.xni.Augmentations, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLNSDTDValidator" name="void startNamespaceScope(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="E"/>
  <class name="org.apache.xerces.impl.dtd.XMLElementDecl" map="D"/>
  <field class="org.apache.xerces.impl.dtd.XMLElementDecl" name="name" map="A"/>
  <field class="org.apache.xerces.impl.dtd.XMLElementDecl" name="contentModelValidator" map="B"/>
  <field class="org.apache.xerces.impl.dtd.XMLElementDecl" name="type" map="C"/>
  <field class="org.apache.xerces.impl.dtd.XMLElementDecl" name="scope" map="D"/>
  <field class="org.apache.xerces.impl.dtd.XMLElementDecl" name="simpleType" map="E"/>
  <class name="org.apache.xerces.impl.dtd.XMLDTDValidatorFilter" map="E"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidatorFilter" name="boolean validate()" map="G"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidatorFilter" name="boolean hasGrammar()" map="H"/>
  <class name="org.apache.xerces.impl.dtd.XML11NSDTDValidator" map="F"/>
  <field class="org.apache.xerces.impl.dtd.XML11NSDTDValidator" name="fAttributeQName" map="&#x0415;"/>
  <method class="org.apache.xerces.impl.dtd.XML11NSDTDValidator" name="void endNamespaceScope(org.apache.xerces.xni.QName, org.apache.xerces.xni.Augmentations, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XML11NSDTDValidator" name="void startNamespaceScope(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="E"/>
  <class name="org.apache.xerces.impl.dtd.XMLDTDLoader" map="G"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDLoader" name="fStrictURI" map="e"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDLoader" name="fLocale" map="f"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDLoader" name="fEntityResolver" map="g"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDLoader" name="LOADER_RECOGNIZED_FEATURES" map="h"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDLoader" name="LOADER_RECOGNIZED_PROPERTIES" map="i"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDLoader" name="fDTDScanner" map="j"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDLoader" name="fEntityManager" map="k"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDLoader" name="fBalanceSyntaxTrees" map="l"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDLoader" name="void reset()" map="I"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDLoader" name="void setProperty(java.lang.String, java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDLoader" name="void setFeature(java.lang.String, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDLoader" name="java.lang.String[] getRecognizedFeatures()" map="E"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDLoader" name="org.apache.xerces.impl.XMLDTDScannerImpl createDTDScanner(org.apache.xerces.util.SymbolTable, org.apache.xerces.impl.XMLErrorReporter, org.apache.xerces.impl.XMLEntityManager)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDLoader" name="void setLocale(java.util.Locale)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDLoader" name="java.lang.String[] getRecognizedProperties()" map="F"/>
  <class name="org.apache.xerces.impl.dtd.XML11DTDProcessor" map="H"/>
  <method class="org.apache.xerces.impl.dtd.XML11DTDProcessor" name="boolean isValidNmtoken(java.lang.String)" map="E"/>
  <method class="org.apache.xerces.impl.dtd.XML11DTDProcessor" name="org.apache.xerces.impl.XMLDTDScannerImpl createDTDScanner(org.apache.xerces.util.SymbolTable, org.apache.xerces.impl.XMLErrorReporter, org.apache.xerces.impl.XMLEntityManager)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XML11DTDProcessor" name="boolean isValidName(java.lang.String)" map="D"/>
  <class name="org.apache.xerces.impl.dtd.DTDGrammar$QNameHashtable" map="_A"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar$QNameHashtable" name="fHashTable" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar$QNameHashtable" name="void put(java.lang.String, int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar$QNameHashtable" name="int get(java.lang.String)" map="A"/>
  <class name="org.apache.xerces.impl.dtd.DTDGrammar$ChildrenList" map="_B"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar$ChildrenList" name="type" map="A"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar$ChildrenList" name="length" map="B"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar$ChildrenList" name="qname" map="C"/>
  <class name="org.apache.xerces.impl.dtd.DTDGrammar" map="I"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fAttributeDeclIsExternal" map="&#x0196;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fAttributeDeclType" map="&#x0197;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="valueIndex" map="&#x0198;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fEpsilonIndex" map="&#x0199;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fDTDContentModelSource" map="&#x019a;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fNotationName" map="&#x019b;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fAttributeDeclDefaultValue" map="&#x019c;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fEntityBaseSystemId" map="&#x019d;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fElementDeclIsExternal" map="&#x019e;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fElementDecl" map="&#x019f;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fElementDeclName" map="&#x01a0;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fEntityPublicId" map="&#x01a1;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fEntitySystemId" map="&#x01a2;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fReadingExternalDTD" map="&#x01a3;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fPEntityStack" map="&#x01a4;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="prevNodeIndex" map="&#x01a5;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fOpStack" map="&#x01a6;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fSimpleType" map="&#x01a7;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fEntityIndexMap" map="&#x01a8;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="nodeIndex" map="&#x01a9;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fAttributeDeclCount" map="&#x01aa;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fNodeIndexStack" map="&#x01ab;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fAttributeDeclName" map="&#x01ac;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fElementIndexMap" map="&#x01ad;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fElementDeclFirstAttributeDeclIndex" map="&#x01ae;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fQName2" map="&#x01af;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fIsImmutable" map="&#x01b0;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fCurrentElementIndex" map="&#x01b1;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fNotationPublicId" map="&#x01b2;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fElementDeclTab" map="&#x01b3;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fAttributeDecl" map="&#x01b4;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fNotationSystemId" map="&#x01b5;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fDepth" map="&#x01b6;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fContentSpec" map="&#x01b7;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fAttributeDeclDefaultType" map="&#x01b8;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fNotationIndexMap" map="&#x01b9;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fEntityNotation" map="&#x01ba;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fEntityDecl" map="&#x01bb;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fContentSpecType" map="&#x01bc;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fSymbolTable" map="&#x01bd;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fAttributeDeclDatatypeValidator" map="&#x01be;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fQName" map="&#x01bf;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fEntityIsPE" map="&#x01c0;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fElementDeclContentSpecIndex" map="&#x01c1;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fAttributeDeclEnumeration" map="&#x01c2;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fElementDeclLastAttributeDeclIndex" map="&#x01c3;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fPEDepth" map="&#x01c4;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fElementDeclContentModelValidator" map="&#x01c5;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fMixed" map="&#x01c6;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fNotationBaseSystemId" map="&#x01c7;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fEntityInExternal" map="&#x01c8;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fContentSpecValue" map="&#x01c9;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fAttributeDeclNextAttributeDeclIndex" map="&#x01ca;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fDTDSource" map="&#x01cb;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fElementDeclCount" map="&#x01cc;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fContentSpecCount" map="&#x01cd;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fEntityValue" map="&#x01ce;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fElementDeclType" map="&#x01cf;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fEntityCount" map="&#x01d0;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fLeafCount" map="&#x01d1;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fPrevNodeIndexStack" map="&#x01d2;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fNotationCount" map="&#x01d3;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fGrammarDescription" map="&#x01d4;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fAttributeDeclNonNormalizedDefaultValue" map="&#x01d5;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fContentSpecOtherValue" map="&#x01d6;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fCurrentAttributeIndex" map="&#x01d7;"/>
  <field class="org.apache.xerces.impl.dtd.DTDGrammar" name="fEntityName" map="&#x01d8;"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int getElementDeclIndex(java.lang.String)" map="c"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="boolean isImmutable()" map="&#x00c7;"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int addContentSpecNode(short, int, int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void endExternalSubset(org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void ignoredCharacters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="boolean getAttributeDeclIsExternal(int)" map="W"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void internalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="java.lang.String[][][] resize(java.lang.String[][][], int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void endParameterEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void startContentModel(java.lang.String, org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void element(java.lang.String, org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void endConditional(org.apache.xerces.xni.Augmentations)" map="F"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void externalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="short getContentSpecType(int)" map="X"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="org.apache.xerces.impl.dtd.models.CMNode buildSyntaxTree(int, org.apache.xerces.impl.dtd.XMLContentSpec)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void setDTDContentModelSource(org.apache.xerces.xni.parser.XMLDTDContentModelSource)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void ensureAttributeDeclCapacity(int)" map="Y"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int createNotationDecl()" map="&#x00c8;"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="boolean getContentSpec(int, org.apache.xerces.impl.dtd.XMLContentSpec)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void setContentSpec(int, org.apache.xerces.impl.dtd.XMLContentSpec)" map="C"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void pcdata(org.apache.xerces.xni.Augmentations)" map="J"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="byte[][] resize(byte[][], int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="boolean isEntityUnparsed(java.lang.String)" map="R"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void setAttributeDecl(int, int, org.apache.xerces.impl.dtd.XMLAttributeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int[][] resize(int[][], int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void ensureElementDeclCapacity(int)" map="Z"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void endGroup(org.apache.xerces.xni.Augmentations)" map="H"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="boolean getEntityDecl(int, org.apache.xerces.impl.dtd.XMLEntityDecl)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void processingInstruction(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void startParameterEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="java.lang.String[][] resize(java.lang.String[][], int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void textDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="java.lang.String getContentSpecAsString(int)" map="_"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void setNotationDecl(int, org.apache.xerces.impl.dtd.XMLNotationDecl)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="boolean getAttributeDecl(int, org.apache.xerces.impl.dtd.XMLAttributeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void startGroup(org.apache.xerces.xni.Augmentations)" map="I"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void endAttlist(org.apache.xerces.xni.Augmentations)" map="G"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int createContentSpec()" map="&#x00c9;"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void startExternalSubset(org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void contentSpecTree(int, org.apache.xerces.impl.dtd.XMLContentSpec, org.apache.xerces.impl.dtd.DTDGrammar$ChildrenList)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="java.lang.Object[][] resize(java.lang.Object[][], int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int createElementDecl()" map="&#x00ca;"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int getContentSpecIndex(int)" map="a"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void ensureContentSpecCapacity(int)" map="b"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void setEntityDecl(int, org.apache.xerces.impl.dtd.XMLEntityDecl)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int addContentSpecNode(short, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void ensureEntityDeclCapacity(int)" map="c"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int getNotationDeclIndex(java.lang.String)" map="d"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void elementDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void startConditional(short, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void setContentSpecIndex(int, int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="boolean getElementDecl(int, org.apache.xerces.impl.dtd.XMLElementDecl)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void endDTD(org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void endContentModel(org.apache.xerces.xni.Augmentations)" map="M"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void ensureNotationDeclCapacity(int)" map="d"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int createAttributeDecl()" map="&#x00cb;"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="org.apache.xerces.xni.QName[][] resize(org.apache.xerces.xni.QName[][], int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void startDTD(org.apache.xerces.xni.XMLLocator, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void setElementDecl(int, org.apache.xerces.impl.dtd.XMLElementDecl)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="org.apache.xerces.impl.dtd.models.ContentModelValidator[][] resize(org.apache.xerces.impl.dtd.models.ContentModelValidator[][], int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int getElementDeclIndex(org.apache.xerces.xni.QName)" map="E"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void empty(org.apache.xerces.xni.Augmentations)" map="K"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int getNextAttributeDeclIndex(int)" map="e"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="boolean getElementDeclIsExternal(int)" map="f"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void any(org.apache.xerces.xni.Augmentations)" map="L"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="org.apache.xerces.xni.grammars.XMLGrammarDescription getGrammarDescription()" map="&#x00cc;"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="short[][] resize(short[][], int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int getEntityDeclIndex(java.lang.String)" map="e"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int getAttributeDeclIndex(int, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="org.apache.xerces.xni.QName getElementDeclName(int)" map="g"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="org.apache.xerces.impl.dv.DatatypeValidator[][] resize(org.apache.xerces.impl.dv.DatatypeValidator[][], int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int getFirstAttributeDeclIndex(int)" map="h"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void separator(short, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void appendContentSpec(org.apache.xerces.impl.dtd.XMLContentSpec, java.lang.StringBuffer, boolean, int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void unparsedEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int createEntityDecl()" map="&#x00cd;"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int addUniqueLeafNode(java.lang.String)" map="f"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void attributeDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String[], java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void comment(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void addContentSpecToElement(org.apache.xerces.impl.dtd.XMLElementDecl)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void occurrence(short, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="org.apache.xerces.impl.dtd.models.ContentModelValidator createChildModel(int)" map="i"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="org.apache.xerces.impl.dtd.models.ContentModelValidator getElementContentModelValidator(int)" map="j"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int getFirstElementDeclIndex()" map="&#x00ce;"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void initializeContentModelStack()" map="&#x00cf;"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void startAttlist(java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="int getNextElementDeclIndex(int)" map="k"/>
  <method class="org.apache.xerces.impl.dtd.DTDGrammar" name="void notationDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="B"/>
  <class name="org.apache.xerces.impl.dtd.XMLDTDProcessor" map="J"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fValidation" map="C"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fDTDElementDecls" map="D"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fDTDElementDeclName" map="E"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fDTDContentModelHandler" map="F"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fGrammarBucket" map="G"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fDTDValidation" map="H"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fDTDSource" map="I"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fWarnOnUndeclaredElemdef" map="J"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fNDataDeclNotations" map="K"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="RECOGNIZED_FEATURES" map="L"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fGrammarPool" map="M"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fDTDGrammar" map="N"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fMixed" map="O"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="PROPERTY_DEFAULTS" map="P"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fDTDContentModelSource" map="Q"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fErrorReporter" map="R"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fValidator" map="S"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fTableOfNOTATIONAttributeNames" map="T"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fNotationEnumVals" map="U"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fMixedElementTypes" map="V"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fEntityDecl" map="W"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fSymbolTable" map="X"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fWarnDuplicateAttdef" map="Y"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="RECOGNIZED_PROPERTIES" map="Z"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fInDTDIgnore" map="_"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fPerformValidation" map="a"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fTableOfIDAttributeNames" map="b"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="fDTDHandler" map="c"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="FEATURE_DEFAULTS" map="d"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void element(java.lang.String, org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void startContentModel(java.lang.String, org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void notationDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="boolean isValidName(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void setFeature(java.lang.String, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void unparsedEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="java.lang.String[] getRecognizedFeatures()" map="E"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="java.lang.String[] getRecognizedProperties()" map="F"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void processingInstruction(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void endConditional(org.apache.xerces.xni.Augmentations)" map="F"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="boolean isValidNmtoken(java.lang.String)" map="E"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void endExternalSubset(org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void elementDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void checkStandaloneEntityRef(java.lang.String, org.apache.xerces.impl.dtd.DTDGrammar, org.apache.xerces.impl.dtd.XMLEntityDecl, org.apache.xerces.impl.XMLErrorReporter)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void empty(org.apache.xerces.xni.Augmentations)" map="K"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void startParameterEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void endGroup(org.apache.xerces.xni.Augmentations)" map="H"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void comment(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void startAttlist(java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void startExternalSubset(org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void occurrence(short, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void endContentModel(org.apache.xerces.xni.Augmentations)" map="M"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void endParameterEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void externalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void checkDeclaredElements(org.apache.xerces.impl.dtd.DTDGrammar)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void startDTD(org.apache.xerces.xni.XMLLocator, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void reset()" map="I"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void startConditional(short, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void any(org.apache.xerces.xni.Augmentations)" map="L"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void startGroup(org.apache.xerces.xni.Augmentations)" map="I"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void ignoredCharacters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void separator(short, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="java.lang.Boolean getFeatureDefault(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void internalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void attributeDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String[], java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void checkDeclaredElements(org.apache.xerces.impl.dtd.DTDGrammar, int, int, org.apache.xerces.impl.dtd.XMLContentSpec)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void setProperty(java.lang.String, java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void pcdata(org.apache.xerces.xni.Augmentations)" map="J"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void endAttlist(org.apache.xerces.xni.Augmentations)" map="G"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void setDTDContentModelSource(org.apache.xerces.xni.parser.XMLDTDContentModelSource)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="java.lang.Object getPropertyDefault(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void endDTD(org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="boolean normalizeDefaultAttrValue(org.apache.xerces.xni.XMLString)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDProcessor" name="void textDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <class name="org.apache.xerces.impl.dtd.XML11DTDValidator" map="K"/>
  <method class="org.apache.xerces.impl.dtd.XML11DTDValidator" name="void init()" map="&#x00ec;"/>
  <method class="org.apache.xerces.impl.dtd.XML11DTDValidator" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <class name="org.apache.xerces.impl.dtd.XMLDTDValidator" map="L"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fGrammarBucket" map="&#x03ca;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fDocumentHandler" map="&#x03cb;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fDTDValidation" map="&#x03cc;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fElementIndexStack" map="&#x03cd;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fValNMTOKENS" map="&#x03ce;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="RECOGNIZED_PROPERTIES" map="&#x03d0;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="RECOGNIZED_FEATURES" map="&#x03d1;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fValIDRefs" map="&#x03d2;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fBuffer" map="&#x03d3;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fElementDepth" map="&#x03d4;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fInCDATASection" map="&#x03d5;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fGrammarPool" map="&#x03d6;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fValENTITIES" map="&#x03da;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="PROPERTY_DEFAULTS" map="&#x03dc;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fDatatypeValidatorFactory" map="&#x03de;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fRootElement" map="&#x03e0;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fWarnDuplicateAttdef" map="&#x03e2;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fContentSpecTypeStack" map="&#x03e3;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fCurrentElementIndex" map="&#x03e4;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fElementChildrenOffsetStack" map="&#x03e5;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fDTDGrammar" map="&#x03e6;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fValNMTOKEN" map="&#x03e7;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fValIDRef" map="&#x03e8;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fCurrentElement" map="&#x03e9;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fValidation" map="&#x03ea;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fEntityDecl" map="&#x03eb;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fValENTITY" map="&#x03ec;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fSymbolTable" map="&#x03ed;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fCurrentContentSpecType" map="&#x03ee;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fDocumentSource" map="&#x03ef;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fDocLocation" map="&#x03f0;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fNamespaces" map="&#x03f1;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fElementChildrenLength" map="&#x03f2;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fSeenDoctypeDecl" map="&#x03f3;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fElementChildren" map="&#x0401;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="FEATURE_DEFAULTS" map="&#x0402;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fPerformValidation" map="&#x0403;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fElementQNamePartsStack" map="&#x0404;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fBalanceSyntaxTrees" map="&#x0405;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fDynamicValidation" map="&#x0406;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fValID" map="&#x0407;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fTempAttDecl" map="&#x0408;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fErrorReporter" map="&#x0409;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fValidationState" map="&#x040a;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fSeenRootElement" map="&#x040b;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fSchemaType" map="&#x040c;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fValidationManager" map="&#x040e;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fTempQName" map="&#x040f;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fValNOTATION" map="&#x0410;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fInElementContent" map="&#x0411;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fTempElementDecl" map="&#x0412;"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="fNamespaceContext" map="&#x0413;"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="boolean handleStartElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void startElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="org.apache.xerces.impl.dtd.DTDGrammarBucket getGrammarBucket()" map="&#x00ea;"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="java.lang.String getAttributeTypeName(org.apache.xerces.impl.dtd.XMLAttributeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void setFeature(java.lang.String, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="boolean hasGrammar()" map="H"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="java.lang.String[] getRecognizedFeatures()" map="E"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void ensureStackCapacity(int)" map="m"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="java.lang.String[] getRecognizedProperties()" map="F"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void startCDATA(org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void startGeneralEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void processingInstruction(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="boolean isSpace(int)" map="n"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="org.apache.xerces.xni.parser.XMLDocumentSource getDocumentSource()" map="C"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void endElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void characters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void xmlDecl(java.lang.String, java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void endGeneralEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void validateDTDattribute(org.apache.xerces.xni.QName, java.lang.String, org.apache.xerces.impl.dtd.XMLAttributeDecl)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void ignorableWhitespace(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void handleEndElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.Augmentations, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void doctypeDecl(java.lang.String, java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void comment(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void startNamespaceScope(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="boolean normalizeAttrValue(org.apache.xerces.xni.XMLAttributes, int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void startDocument(org.apache.xerces.xni.XMLLocator, java.lang.String, org.apache.xerces.xni.NamespaceContext, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void endDocument(org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="java.lang.String getExternalEntityRefInAttrValue(java.lang.String)" map="m"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void endNamespaceScope(org.apache.xerces.xni.QName, org.apache.xerces.xni.Augmentations, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="java.lang.Boolean getFeatureDefault(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void emptyElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void addDTDDefaultAttrsAndValidate(org.apache.xerces.xni.QName, int, org.apache.xerces.xni.XMLAttributes)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void setProperty(java.lang.String, java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="org.apache.xerces.xni.XMLDocumentHandler getDocumentHandler()" map="D"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void charDataInContent()" map="&#x00eb;"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="java.lang.Object getPropertyDefault(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void endCDATA(org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void rootElementSpecified(org.apache.xerces.xni.QName)" map="G"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="int checkContent(int, org.apache.xerces.xni.QName[], int, int)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void textDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="boolean validate()" map="G"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDValidator" name="void init()" map="&#x00ec;"/>
  <class name="org.apache.xerces.impl.dtd.XMLContentSpec" map="M"/>
  <field class="org.apache.xerces.impl.dtd.XMLContentSpec" name="otherValue" map="A"/>
  <field class="org.apache.xerces.impl.dtd.XMLContentSpec" name="type" map="B"/>
  <field class="org.apache.xerces.impl.dtd.XMLContentSpec" name="value" map="C"/>
  <method class="org.apache.xerces.impl.dtd.XMLContentSpec" name="void clear()" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLContentSpec" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.dtd.XMLContentSpec" name="void setValues(short, java.lang.Object, java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLContentSpec" name="int hashCode()" map="hashCode"/>
  <class name="org.apache.xerces.impl.dtd.XMLDTDDescription" map="N"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDDescription" name="fPossibleRoots" map="G"/>
  <field class="org.apache.xerces.impl.dtd.XMLDTDDescription" name="fRootName" map="H"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDDescription" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDDescription" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDDescription" name="void setRootName(java.lang.String)" map="E"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDDescription" name="void setPossibleRoots(java.util.ArrayList)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDDescription" name="java.lang.String getRootName()" map="I"/>
  <method class="org.apache.xerces.impl.dtd.XMLDTDDescription" name="java.lang.String getGrammarType()" map="H"/>
  <class name="org.apache.xerces.impl.dtd.XMLNotationDecl" map="O"/>
  <field class="org.apache.xerces.impl.dtd.XMLNotationDecl" name="systemId" map="A"/>
  <field class="org.apache.xerces.impl.dtd.XMLNotationDecl" name="name" map="B"/>
  <field class="org.apache.xerces.impl.dtd.XMLNotationDecl" name="baseSystemId" map="C"/>
  <field class="org.apache.xerces.impl.dtd.XMLNotationDecl" name="publicId" map="D"/>
  <method class="org.apache.xerces.impl.dtd.XMLNotationDecl" name="void setValues(java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <class name="org.apache.xerces.impl.dtd.BalancedDTDGrammar" map="P"/>
  <field class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="fGroupIndexStackSizes" map="&#x01d9;"/>
  <field class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="fOpStack" map="&#x01da;"/>
  <field class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="fDepth" map="&#x01db;"/>
  <field class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="fGroupIndexStack" map="&#x01dc;"/>
  <field class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="fMixed" map="&#x01dd;"/>
  <method class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="void initializeContentModelStacks()" map="&#x00d0;"/>
  <method class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="void startGroup(org.apache.xerces.xni.Augmentations)" map="I"/>
  <method class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="void endDTD(org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="void endGroup(org.apache.xerces.xni.Augmentations)" map="H"/>
  <method class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="void addToCurrentGroup(int)" map="l"/>
  <method class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="void separator(short, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="void pcdata(org.apache.xerces.xni.Augmentations)" map="J"/>
  <method class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="void addContentSpecToElement(org.apache.xerces.impl.dtd.XMLElementDecl)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="void element(java.lang.String, org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="void startContentModel(java.lang.String, org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="int addContentSpecNodes(int, int)" map="B"/>
  <method class="org.apache.xerces.impl.dtd.BalancedDTDGrammar" name="void occurrence(short, org.apache.xerces.xni.Augmentations)" map="C"/>
  <class name="org.apache.xerces.impl.dtd.XMLEntityDecl" map="Q"/>
  <field class="org.apache.xerces.impl.dtd.XMLEntityDecl" name="systemId" map="A"/>
  <field class="org.apache.xerces.impl.dtd.XMLEntityDecl" name="name" map="B"/>
  <field class="org.apache.xerces.impl.dtd.XMLEntityDecl" name="notation" map="C"/>
  <field class="org.apache.xerces.impl.dtd.XMLEntityDecl" name="baseSystemId" map="D"/>
  <field class="org.apache.xerces.impl.dtd.XMLEntityDecl" name="value" map="E"/>
  <field class="org.apache.xerces.impl.dtd.XMLEntityDecl" name="inExternal" map="F"/>
  <field class="org.apache.xerces.impl.dtd.XMLEntityDecl" name="isPE" map="G"/>
  <field class="org.apache.xerces.impl.dtd.XMLEntityDecl" name="publicId" map="H"/>
  <method class="org.apache.xerces.impl.dtd.XMLEntityDecl" name="void setValues(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, boolean, boolean)" map="A"/>
  <class name="org.apache.xerces.impl.dtd.XMLSimpleType" map="R"/>
  <field class="org.apache.xerces.impl.dtd.XMLSimpleType" name="datatypeValidator" map="A"/>
  <field class="org.apache.xerces.impl.dtd.XMLSimpleType" name="defaultValue" map="B"/>
  <field class="org.apache.xerces.impl.dtd.XMLSimpleType" name="name" map="C"/>
  <field class="org.apache.xerces.impl.dtd.XMLSimpleType" name="nonNormalizedDefaultValue" map="D"/>
  <field class="org.apache.xerces.impl.dtd.XMLSimpleType" name="type" map="E"/>
  <field class="org.apache.xerces.impl.dtd.XMLSimpleType" name="list" map="F"/>
  <field class="org.apache.xerces.impl.dtd.XMLSimpleType" name="enumeration" map="G"/>
  <field class="org.apache.xerces.impl.dtd.XMLSimpleType" name="defaultType" map="H"/>
  <method class="org.apache.xerces.impl.dtd.XMLSimpleType" name="void clear()" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLSimpleType" name="void setValues(short, java.lang.String, java.lang.String[], boolean, short, java.lang.String, java.lang.String, org.apache.xerces.impl.dv.DatatypeValidator)" map="A"/>
  <method class="org.apache.xerces.impl.dtd.XMLSimpleType" name="void setValues(org.apache.xerces.impl.dtd.XMLSimpleType)" map="A"/>
  <package name="org.apache.xerces.impl.msg" map="F"/>
  <class name="org.apache.xerces.impl.msg.XMLMessageFormatter" map="A"/>
  <field class="org.apache.xerces.impl.msg.XMLMessageFormatter" name="fLocale" map="C"/>
  <field class="org.apache.xerces.impl.msg.XMLMessageFormatter" name="fResourceBundle" map="D"/>
  <method class="org.apache.xerces.impl.msg.XMLMessageFormatter" name="java.lang.String formatMessage(java.util.Locale, java.lang.String, java.lang.Object[])" map="A"/>
  <package name="org.apache.xerces.impl.io" map="G"/>
  <class name="org.apache.xerces.impl.io.UTF16Reader" map="A"/>
  <field class="org.apache.xerces.impl.io.UTF16Reader" name="fFormatter" map="A"/>
  <field class="org.apache.xerces.impl.io.UTF16Reader" name="fLocale" map="B"/>
  <field class="org.apache.xerces.impl.io.UTF16Reader" name="fBuffer" map="C"/>
  <field class="org.apache.xerces.impl.io.UTF16Reader" name="fIsBigEndian" map="D"/>
  <field class="org.apache.xerces.impl.io.UTF16Reader" name="fInputStream" map="E"/>
  <method class="org.apache.xerces.impl.io.UTF16Reader" name="void reset()" map="reset"/>
  <method class="org.apache.xerces.impl.io.UTF16Reader" name="void expectedTwoBytes()" map="A"/>
  <method class="org.apache.xerces.impl.io.UTF16Reader" name="void close()" map="close"/>
  <method class="org.apache.xerces.impl.io.UTF16Reader" name="boolean markSupported()" map="markSupported"/>
  <method class="org.apache.xerces.impl.io.UTF16Reader" name="void mark(int)" map="mark"/>
  <method class="org.apache.xerces.impl.io.UTF16Reader" name="boolean ready()" map="ready"/>
  <method class="org.apache.xerces.impl.io.UTF16Reader" name="int read()" map="read"/>
  <method class="org.apache.xerces.impl.io.UTF16Reader" name="void processBE(char[], int, int)" map="A"/>
  <method class="org.apache.xerces.impl.io.UTF16Reader" name="void processLE(char[], int, int)" map="B"/>
  <method class="org.apache.xerces.impl.io.UTF16Reader" name="int read(char[], int, int)" map="read"/>
  <method class="org.apache.xerces.impl.io.UTF16Reader" name="long skip(long)" map="skip"/>
  <class name="org.apache.xerces.impl.io.UCSReader" map="B"/>
  <field class="org.apache.xerces.impl.io.UCSReader" name="fBuffer" map="A"/>
  <field class="org.apache.xerces.impl.io.UCSReader" name="fEncoding" map="B"/>
  <field class="org.apache.xerces.impl.io.UCSReader" name="fInputStream" map="C"/>
  <method class="org.apache.xerces.impl.io.UCSReader" name="long skip(long)" map="skip"/>
  <method class="org.apache.xerces.impl.io.UCSReader" name="int read()" map="read"/>
  <method class="org.apache.xerces.impl.io.UCSReader" name="void reset()" map="reset"/>
  <method class="org.apache.xerces.impl.io.UCSReader" name="int read(char[], int, int)" map="read"/>
  <method class="org.apache.xerces.impl.io.UCSReader" name="void mark(int)" map="mark"/>
  <method class="org.apache.xerces.impl.io.UCSReader" name="boolean ready()" map="ready"/>
  <method class="org.apache.xerces.impl.io.UCSReader" name="void close()" map="close"/>
  <method class="org.apache.xerces.impl.io.UCSReader" name="boolean markSupported()" map="markSupported"/>
  <class name="org.apache.xerces.impl.io.Latin1Reader" map="C"/>
  <field class="org.apache.xerces.impl.io.Latin1Reader" name="fBuffer" map="A"/>
  <field class="org.apache.xerces.impl.io.Latin1Reader" name="fInputStream" map="B"/>
  <method class="org.apache.xerces.impl.io.Latin1Reader" name="long skip(long)" map="skip"/>
  <method class="org.apache.xerces.impl.io.Latin1Reader" name="int read()" map="read"/>
  <method class="org.apache.xerces.impl.io.Latin1Reader" name="void reset()" map="reset"/>
  <method class="org.apache.xerces.impl.io.Latin1Reader" name="int read(char[], int, int)" map="read"/>
  <method class="org.apache.xerces.impl.io.Latin1Reader" name="void mark(int)" map="mark"/>
  <method class="org.apache.xerces.impl.io.Latin1Reader" name="boolean ready()" map="ready"/>
  <method class="org.apache.xerces.impl.io.Latin1Reader" name="void close()" map="close"/>
  <method class="org.apache.xerces.impl.io.Latin1Reader" name="boolean markSupported()" map="markSupported"/>
  <class name="org.apache.xerces.impl.io.ASCIIReader" map="D"/>
  <field class="org.apache.xerces.impl.io.ASCIIReader" name="fFormatter" map="A"/>
  <field class="org.apache.xerces.impl.io.ASCIIReader" name="fLocale" map="B"/>
  <field class="org.apache.xerces.impl.io.ASCIIReader" name="fBuffer" map="C"/>
  <field class="org.apache.xerces.impl.io.ASCIIReader" name="fInputStream" map="D"/>
  <method class="org.apache.xerces.impl.io.ASCIIReader" name="long skip(long)" map="skip"/>
  <method class="org.apache.xerces.impl.io.ASCIIReader" name="int read()" map="read"/>
  <method class="org.apache.xerces.impl.io.ASCIIReader" name="void reset()" map="reset"/>
  <method class="org.apache.xerces.impl.io.ASCIIReader" name="int read(char[], int, int)" map="read"/>
  <method class="org.apache.xerces.impl.io.ASCIIReader" name="void mark(int)" map="mark"/>
  <method class="org.apache.xerces.impl.io.ASCIIReader" name="boolean ready()" map="ready"/>
  <method class="org.apache.xerces.impl.io.ASCIIReader" name="void close()" map="close"/>
  <method class="org.apache.xerces.impl.io.ASCIIReader" name="boolean markSupported()" map="markSupported"/>
  <class name="org.apache.xerces.impl.io.UTF8Reader" map="E"/>
  <field class="org.apache.xerces.impl.io.UTF8Reader" name="fFormatter" map="A"/>
  <field class="org.apache.xerces.impl.io.UTF8Reader" name="fLocale" map="B"/>
  <field class="org.apache.xerces.impl.io.UTF8Reader" name="fBuffer" map="C"/>
  <field class="org.apache.xerces.impl.io.UTF8Reader" name="fSurrogate" map="D"/>
  <field class="org.apache.xerces.impl.io.UTF8Reader" name="fOffset" map="E"/>
  <field class="org.apache.xerces.impl.io.UTF8Reader" name="fInputStream" map="F"/>
  <method class="org.apache.xerces.impl.io.UTF8Reader" name="void reset()" map="reset"/>
  <method class="org.apache.xerces.impl.io.UTF8Reader" name="void close()" map="close"/>
  <method class="org.apache.xerces.impl.io.UTF8Reader" name="boolean markSupported()" map="markSupported"/>
  <method class="org.apache.xerces.impl.io.UTF8Reader" name="void mark(int)" map="mark"/>
  <method class="org.apache.xerces.impl.io.UTF8Reader" name="boolean ready()" map="ready"/>
  <method class="org.apache.xerces.impl.io.UTF8Reader" name="void expectedByte(int, int)" map="A"/>
  <method class="org.apache.xerces.impl.io.UTF8Reader" name="int read()" map="read"/>
  <method class="org.apache.xerces.impl.io.UTF8Reader" name="void invalidSurrogate(int)" map="A"/>
  <method class="org.apache.xerces.impl.io.UTF8Reader" name="int read(char[], int, int)" map="read"/>
  <method class="org.apache.xerces.impl.io.UTF8Reader" name="long skip(long)" map="skip"/>
  <method class="org.apache.xerces.impl.io.UTF8Reader" name="void invalidByte(int, int, int)" map="A"/>
  <class name="org.apache.xerces.impl.io.MalformedByteSequenceException" map="F"/>
  <field class="org.apache.xerces.impl.io.MalformedByteSequenceException" name="fFormatter" map="A"/>
  <field class="org.apache.xerces.impl.io.MalformedByteSequenceException" name="fArguments" map="B"/>
  <field class="org.apache.xerces.impl.io.MalformedByteSequenceException" name="fLocale" map="C"/>
  <field class="org.apache.xerces.impl.io.MalformedByteSequenceException" name="fKey" map="D"/>
  <field class="org.apache.xerces.impl.io.MalformedByteSequenceException" name="fMessage" map="E"/>
  <field class="org.apache.xerces.impl.io.MalformedByteSequenceException" name="fDomain" map="F"/>
  <method class="org.apache.xerces.impl.io.MalformedByteSequenceException" name="java.lang.String getMessage()" map="getMessage"/>
  <method class="org.apache.xerces.impl.io.MalformedByteSequenceException" name="java.lang.String getDomain()" map="A"/>
  <method class="org.apache.xerces.impl.io.MalformedByteSequenceException" name="java.lang.String getKey()" map="B"/>
  <method class="org.apache.xerces.impl.io.MalformedByteSequenceException" name="java.lang.Object[] getArguments()" map="C"/>
  <class name="org.apache.xerces.impl.RevalidationHandler" map="A"/>
  <class name="org.apache.xerces.impl.XMLEntityManager$ByteBufferPool" map="_A"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ByteBufferPool" name="fDepth" map="A"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ByteBufferPool" name="fByteBufferPool" map="B"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ByteBufferPool" name="fBufferSize" map="C"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ByteBufferPool" name="fPoolSize" map="D"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ByteBufferPool" name="void setBufferSize(int)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ByteBufferPool" name="byte[] getBuffer()" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ByteBufferPool" name="void returnBuffer(byte[])" map="A"/>
  <class name="org.apache.xerces.impl.XMLEntityManager$EncodingInfo" map="_B"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$EncodingInfo" name="isBigEndian" map="A"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$EncodingInfo" name="UTF_16_BIG_ENDIAN" map="B"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$EncodingInfo" name="encoding" map="C"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$EncodingInfo" name="UCS_4_LITTLE_ENDIAN" map="D"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$EncodingInfo" name="UTF_16_BIG_ENDIAN_WITH_BOM" map="E"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$EncodingInfo" name="EBCDIC" map="F"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$EncodingInfo" name="UCS_4_UNUSUAL_BYTE_ORDER" map="G"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$EncodingInfo" name="UTF_8" map="H"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$EncodingInfo" name="UTF_16_LITTLE_ENDIAN_WITH_BOM" map="I"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$EncodingInfo" name="UCS_4_BIG_ENDIAN" map="J"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$EncodingInfo" name="UTF_16_LITTLE_ENDIAN" map="K"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$EncodingInfo" name="hasBOM" map="L"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$EncodingInfo" name="UTF_8_WITH_BOM" map="M"/>
  <class name="org.apache.xerces.impl.XMLEntityManager$ExternalEntity" map="_C"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ExternalEntity" name="entityLocation" map="V"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ExternalEntity" name="notation" map="W"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ExternalEntity" name="boolean isUnparsed()" map="B"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ExternalEntity" name="boolean isExternal()" map="C"/>
  <class name="org.apache.xerces.impl.XMLEntityManager$Entity" map="_D"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$Entity" name="inExternalSubset" map="A"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$Entity" name="name" map="B"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$Entity" name="boolean isEntityDeclInExternalSubset()" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$Entity" name="boolean isUnparsed()" map="B"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$Entity" name="boolean isExternal()" map="C"/>
  <class name="org.apache.xerces.impl.XMLEntityManager$CharacterBuffer" map="_E"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$CharacterBuffer" name="isExternal" map="A"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$CharacterBuffer" name="ch" map="B"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$CharacterBuffer" name="char[] access$300(org.apache.xerces.impl.XMLEntityManager$CharacterBuffer)" map="access$300"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$CharacterBuffer" name="boolean access$500(org.apache.xerces.impl.XMLEntityManager$CharacterBuffer)" map="access$500"/>
  <class name="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" map="_F"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="reader" map="C"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="columnNumber" map="D"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="encoding" map="E"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="mayReadChunks" map="F"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="stream" map="G"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="count" map="H"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="fByteBuffer" map="I"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="startPosition" map="J"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="entityLocation" map="K"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="ch" map="L"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="externallySpecifiedEncoding" map="M"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="isExternal" map="N"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="lineNumber" map="O"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="literal" map="P"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="xmlVersion" map="Q"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="fCharacterBuffer" map="R"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="baseCharOffset" map="S"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="this$0" map="this$0"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="position" map="T"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="boolean isUnparsed()" map="B"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="boolean isEncodingExternallySpecified()" map="D"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="void setEncodingExternallySpecified(boolean)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="org.apache.xerces.impl.XMLEntityManager$CharacterBuffer access$000(org.apache.xerces.impl.XMLEntityManager$ScannedEntity)" map="access$000"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="java.lang.String getExpandedSystemId()" map="E"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="java.lang.String getLiteralSystemId()" map="F"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="int getLineNumber()" map="G"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="void setReader(java.io.InputStream, java.lang.String, java.lang.Boolean)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="int getColumnNumber()" map="H"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="byte[] access$100(org.apache.xerces.impl.XMLEntityManager$ScannedEntity)" map="access$100"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="boolean isExternal()" map="C"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$ScannedEntity" name="int getCharacterOffset()" map="I"/>
  <class name="org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool" map="_G"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool" name="fInternalTop" map="A"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool" name="fInternalBufferSize" map="B"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool" name="fExternalBufferSize" map="C"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool" name="fExternalBufferPool" map="D"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool" name="fInternalBufferPool" map="E"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool" name="fPoolSize" map="F"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool" name="fExternalTop" map="G"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool" name="void setExternalBufferSize(int)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool" name="void returnBuffer(org.apache.xerces.impl.XMLEntityManager$CharacterBuffer)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool" name="void init()" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool" name="org.apache.xerces.impl.XMLEntityManager$CharacterBuffer getBuffer(boolean)" map="A"/>
  <class name="org.apache.xerces.impl.XMLEntityManager$InternalEntity" map="_H"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$InternalEntity" name="text" map="U"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$InternalEntity" name="boolean isUnparsed()" map="B"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$InternalEntity" name="boolean isExternal()" map="C"/>
  <class name="org.apache.xerces.impl.XMLEntityManager$1" map="1"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$1" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" map="_I"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="this$0" map="this$0"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="fData" map="A"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="fMark" map="B"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="fStartOffset" map="C"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="fLength" map="D"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="fOffset" map="E"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="fEndOffset" map="F"/>
  <field class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="fInputStream" map="G"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="void reset()" map="reset"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="void close()" map="close"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="boolean markSupported()" map="markSupported"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="void mark(int)" map="mark"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="int read()" map="read"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="int readAndBuffer()" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="int read(byte[], int, int)" map="read"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="long skip(long)" map="skip"/>
  <method class="org.apache.xerces.impl.XMLEntityManager$RewindableInputStream" name="int available()" map="available"/>
  <class name="org.apache.xerces.impl.XMLEntityManager" map="B"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fXML10EntityScanner" map="&#x0418;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fResourceIdentifier" map="&#x0419;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="gHexChs" map="&#x041a;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fEntityAugs" map="&#x041b;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fDeclaredEntities" map="&#x041c;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="RECOGNIZED_PROPERTIES" map="&#x041d;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="RECOGNIZED_FEATURES" map="&#x041e;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fReaderStack" map="&#x041f;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fSecurityManager" map="&#x0420;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fStrictURI" map="&#x0421;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fCharacterBufferPool" map="&#x0422;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fBufferSize" map="&#x0423;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="GET_USER_DIR_SYSTEM_PROPERTY" map="&#x0424;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="PROPERTY_DEFAULTS" map="&#x0425;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fExternalGeneralEntities" map="&#x0426;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fEntityScanner" map="&#x0427;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fEntityExpansionLimit" map="&#x0428;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="gUserDir" map="&#x0429;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fAllowJavaEncodings" map="&#x042a;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="gAfterEscaping2" map="&#x042b;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="gAfterEscaping1" map="&#x042c;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fSmallByteBufferPool" map="&#x042d;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fLargeByteBufferPool" map="&#x042e;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="XMLEntity" map="&#x042f;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fEntityStack" map="&#x0430;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fEntities" map="&#x0431;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="DTDEntity" map="&#x0432;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fValidation" map="&#x0433;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="gUserDirURI" map="&#x0434;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fTempByteBuffer" map="&#x0435;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fSymbolTable" map="&#x0436;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fCurrentEntity" map="&#x0437;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fStandalone" map="&#x0438;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fHasPEReferences" map="&#x0439;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fWarnDuplicateEntityDef" map="&#x043a;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="FEATURE_DEFAULTS" map="&#x043b;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fEntityExpansionCount" map="&#x043c;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fInExternalSubset" map="&#x043d;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fExternalParameterEntities" map="&#x043e;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fXML11EntityScanner" map="&#x043f;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fErrorReporter" map="&#x0440;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fEntityHandler" map="&#x0441;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fValidationManager" map="&#x0442;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="fEntityResolver" map="&#x0443;"/>
  <field class="org.apache.xerces.impl.XMLEntityManager" name="gNeedEscaping" map="&#x0444;"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="java.lang.String expandSystemIdStrictOff(java.lang.String, java.lang.String)" map="K"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void setFeature(java.lang.String, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void print(org.apache.xerces.impl.XMLEntityManager$ScannedEntity)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="java.lang.String setupCurrentEntity(java.lang.String, org.apache.xerces.xni.parser.XMLInputSource, boolean, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="java.lang.String[] getRecognizedFeatures()" map="E"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="boolean isUnparsedEntity(java.lang.String)" map="n"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="org.apache.xerces.impl.XMLEntityManager$EncodingInfo getEncodingInfo(byte[], int)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="java.lang.String[] getRecognizedProperties()" map="F"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="java.lang.String fixURI(java.lang.String)" map="o"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void closeReaders()" map="&#x00ef;"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="java.io.Reader createReader(java.io.InputStream, java.lang.String, java.lang.Boolean)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void setScannerVersion(short)" map="C"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void addExternalEntity(java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void setEntityHandler(org.apache.xerces.impl.XMLEntityHandler)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="org.apache.xerces.util.URI getUserDir()" map="&#x00f0;"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void setStandalone(boolean)" map="J"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="java.io.Reader createLatin1Reader(java.io.InputStream)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void endExternalSubset()" map="&#x00f1;"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void startDTDEntity(org.apache.xerces.xni.parser.XMLInputSource)" map="G"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="boolean isDeclaredEntity(java.lang.String)" map="p"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="java.lang.String expandSystemIdStrictOn(java.lang.String, java.lang.String)" map="L"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void startExternalSubset()" map="&#x00f2;"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="org.apache.xerces.impl.XMLEntityManager$CharacterBufferPool access$200(org.apache.xerces.impl.XMLEntityManager)" map="access$200"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void startEntity(java.lang.String, org.apache.xerces.xni.parser.XMLInputSource, boolean, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void reset()" map="&#x00f3;"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="org.apache.xerces.xni.parser.XMLInputSource resolveEntity(org.apache.xerces.xni.XMLResourceIdentifier)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="boolean isEntityDeclInExternalSubset(java.lang.String)" map="q"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="java.lang.String expandSystemId(java.lang.String, java.lang.String, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="boolean hasPEReferences()" map="&#x00f4;"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void addUnparsedEntity(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="java.lang.Boolean getFeatureDefault(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="boolean isExternalEntity(java.lang.String)" map="r"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="org.apache.xerces.impl.XMLEntityManager$ScannedEntity getCurrentEntity()" map="&#x00f5;"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="org.apache.xerces.impl.XMLEntityScanner getEntityScanner()" map="&#x00f6;"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void endEntity()" map="&#x00f8;"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void addInternalEntity(java.lang.String, java.lang.String)" map="M"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void setProperty(java.lang.String, java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="java.util.Hashtable getDeclaredEntities()" map="&#x00f9;"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void notifyHasPEReferences()" map="&#x00fa;"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="java.io.Reader createUTF16Reader(java.io.InputStream, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="byte[] access$402(org.apache.xerces.impl.XMLEntityManager, byte[])" map="access$402"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="org.apache.xerces.xni.XMLResourceIdentifier getCurrentResourceIdentifier()" map="&#x00fb;"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="byte[] access$400(org.apache.xerces.impl.XMLEntityManager)" map="access$400"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="java.lang.Object getPropertyDefault(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="java.io.Reader createASCIIReader(java.io.InputStream)" map="B"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="void startEntity(java.lang.String, boolean)" map="F"/>
  <method class="org.apache.xerces.impl.XMLEntityManager" name="java.io.Reader createUTF8Reader(java.io.InputStream)" map="C"/>
  <class name="org.apache.xerces.impl.XML11DocumentScannerImpl" map="C"/>
  <field class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="fStringBuffer" map="&#x015e;"/>
  <field class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="fStringBuffer3" map="&#x015f;"/>
  <field class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="fString" map="&#x0160;"/>
  <field class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="fStringBuffer2" map="&#x0161;"/>
  <method class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="int scanContent()" map="x"/>
  <method class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="boolean isInvalid(int)" map="O"/>
  <method class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="boolean isValidNCName(int)" map="N"/>
  <method class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="void normalizeWhitespace(org.apache.xerces.xni.XMLString)" map="C"/>
  <method class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="boolean isInvalidLiteral(int)" map="K"/>
  <method class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="java.lang.String getVersionNotSupportedKey()" map="e"/>
  <method class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="boolean isValidNameChar(int)" map="J"/>
  <method class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="boolean versionSupported(java.lang.String)" map="O"/>
  <method class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="boolean scanAttributeValue(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, java.lang.String, boolean, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="boolean isValidNameStartHighSurrogate(int)" map="M"/>
  <method class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="int isUnchangedByNormalization(org.apache.xerces.xni.XMLString)" map="D"/>
  <method class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="void normalizeWhitespace(org.apache.xerces.xni.XMLString, int)" map="A"/>
  <method class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="boolean scanPubidLiteral(org.apache.xerces.xni.XMLString)" map="E"/>
  <method class="org.apache.xerces.impl.XML11DocumentScannerImpl" name="boolean isValidNameStartChar(int)" map="L"/>
  <class name="org.apache.xerces.impl.XMLDocumentScannerImpl$PrologDispatcher" map="_A"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl$PrologDispatcher" name="this$0" map="this$0"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl$PrologDispatcher" name="boolean dispatch(boolean)" map="A"/>
  <class name="org.apache.xerces.impl.XMLDocumentScannerImpl$TrailingMiscDispatcher" map="_B"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl$TrailingMiscDispatcher" name="this$0" map="this$0"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl$TrailingMiscDispatcher" name="boolean dispatch(boolean)" map="A"/>
  <class name="org.apache.xerces.impl.XMLDocumentScannerImpl$XMLDeclDispatcher" map="_C"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl$XMLDeclDispatcher" name="this$0" map="this$0"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl$XMLDeclDispatcher" name="boolean dispatch(boolean)" map="A"/>
  <class name="org.apache.xerces.impl.XMLDocumentScannerImpl$ContentDispatcher" map="_D"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl$ContentDispatcher" name="this$0" map="this$0"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl$ContentDispatcher" name="void endOfFileHook(java.io.EOFException)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl$ContentDispatcher" name="boolean elementDepthIsZeroHook()" map="A"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl$ContentDispatcher" name="boolean scanForDoctypeHook()" map="B"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl$ContentDispatcher" name="boolean scanRootElementHook()" map="C"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl$ContentDispatcher" name="void resolveExternalSubsetAndRead()" map="D"/>
  <class name="org.apache.xerces.impl.XMLDocumentScannerImpl$DTDDispatcher" map="_E"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl$DTDDispatcher" name="this$0" map="this$0"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl$DTDDispatcher" name="boolean dispatch(boolean)" map="A"/>
  <class name="org.apache.xerces.impl.XMLDocumentScannerImpl" map="D"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fSeenDoctypeDecl" map="&#x0147;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fDTDScanner" map="&#x0148;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="RECOGNIZED_FEATURES" map="&#x0149;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fDisallowDoctype" map="&#x014a;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="PROPERTY_DEFAULTS" map="&#x014b;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fPrologDispatcher" map="&#x014c;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fString" map="&#x014d;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fDoctypeName" map="&#x014e;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fExternalSubsetSource" map="&#x014f;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fDoctypePublicId" map="&#x0150;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fNamespaceContext" map="&#x0151;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fScanningDTD" map="&#x0152;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fXMLDeclDispatcher" map="&#x0153;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fLoadExternalDTD" map="&#x0154;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fValidationManager" map="&#x0155;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fDoctypeSystemId" map="&#x0156;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fDTDDescription" map="&#x0157;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fTrailingMiscDispatcher" map="&#x0158;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fStringBuffer" map="&#x0159;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fStrings" map="&#x015a;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="RECOGNIZED_PROPERTIES" map="&#x015b;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="fDTDDispatcher" map="&#x015c;"/>
  <field class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="FEATURE_DEFAULTS" map="&#x015d;"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="java.lang.Object getPropertyDefault(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="void startEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher createContentDispatcher()" map="w"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="org.apache.xerces.xni.XMLString access$100(org.apache.xerces.impl.XMLDocumentScannerImpl)" map="access$100"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="java.lang.String getScannerStateName(int)" map="U"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="java.lang.String[] getRecognizedProperties()" map="F"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="void setProperty(java.lang.String, java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="org.apache.xerces.xni.parser.XMLInputSource access$200(org.apache.xerces.impl.XMLDocumentScannerImpl)" map="access$200"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="java.lang.Boolean getFeatureDefault(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="void endEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="F"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="org.apache.xerces.impl.dtd.XMLDTDDescription access$300(org.apache.xerces.impl.XMLDocumentScannerImpl)" map="access$300"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="org.apache.xerces.util.XMLStringBuffer access$000(org.apache.xerces.impl.XMLDocumentScannerImpl)" map="access$000"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="void setFeature(java.lang.String, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="boolean scanDoctypeDecl()" map="&#x00a2;"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="org.apache.xerces.xni.parser.XMLInputSource access$202(org.apache.xerces.impl.XMLDocumentScannerImpl, org.apache.xerces.xni.parser.XMLInputSource)" map="access$202"/>
  <method class="org.apache.xerces.impl.XMLDocumentScannerImpl" name="java.lang.String[] getRecognizedFeatures()" map="E"/>
  <class name="org.apache.xerces.impl.XML11NSDocumentScannerImpl$NS11ContentDispatcher" map="_A"/>
  <field class="org.apache.xerces.impl.XML11NSDocumentScannerImpl$NS11ContentDispatcher" name="this$0" map="this$0"/>
  <method class="org.apache.xerces.impl.XML11NSDocumentScannerImpl$NS11ContentDispatcher" name="boolean scanRootElementHook()" map="C"/>
  <method class="org.apache.xerces.impl.XML11NSDocumentScannerImpl$NS11ContentDispatcher" name="void reconfigurePipeline()" map="E"/>
  <class name="org.apache.xerces.impl.XML11NSDocumentScannerImpl" map="E"/>
  <field class="org.apache.xerces.impl.XML11NSDocumentScannerImpl" name="fSawSpace" map="&#x0162;"/>
  <field class="org.apache.xerces.impl.XML11NSDocumentScannerImpl" name="fPerformValidation" map="&#x0163;"/>
  <field class="org.apache.xerces.impl.XML11NSDocumentScannerImpl" name="fBindNamespaces" map="&#x0164;"/>
  <field class="org.apache.xerces.impl.XML11NSDocumentScannerImpl" name="fDTDValidator" map="&#x0165;"/>
  <method class="org.apache.xerces.impl.XML11NSDocumentScannerImpl" name="boolean scanStartElement()" map="y"/>
  <method class="org.apache.xerces.impl.XML11NSDocumentScannerImpl" name="void setDTDValidator(org.apache.xerces.impl.dtd.XMLDTDValidatorFilter)" map="A"/>
  <method class="org.apache.xerces.impl.XML11NSDocumentScannerImpl" name="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher createContentDispatcher()" map="w"/>
  <method class="org.apache.xerces.impl.XML11NSDocumentScannerImpl" name="void scanAttribute(org.apache.xerces.util.XMLAttributesImpl)" map="A"/>
  <method class="org.apache.xerces.impl.XML11NSDocumentScannerImpl" name="org.apache.xerces.impl.dtd.XMLDTDValidatorFilter access$000(org.apache.xerces.impl.XML11NSDocumentScannerImpl)" map="access$000"/>
  <method class="org.apache.xerces.impl.XML11NSDocumentScannerImpl" name="int scanEndElement()" map="s"/>
  <method class="org.apache.xerces.impl.XML11NSDocumentScannerImpl" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.impl.XML11NSDocumentScannerImpl" name="boolean scanStartElementAfterName()" map="z"/>
  <method class="org.apache.xerces.impl.XML11NSDocumentScannerImpl" name="void scanStartElementName()" map="u"/>
  <class name="org.apache.xerces.impl.Constants$ArrayEnumeration" map="_A"/>
  <field class="org.apache.xerces.impl.Constants$ArrayEnumeration" name="index" map="A"/>
  <field class="org.apache.xerces.impl.Constants$ArrayEnumeration" name="array" map="B"/>
  <method class="org.apache.xerces.impl.Constants$ArrayEnumeration" name="boolean hasMoreElements()" map="hasMoreElements"/>
  <method class="org.apache.xerces.impl.Constants$ArrayEnumeration" name="java.lang.Object nextElement()" map="nextElement"/>
  <class name="org.apache.xerces.impl.Constants" map="F"/>
  <field class="org.apache.xerces.impl.Constants" name="fgSAXFeatures" map="A"/>
  <field class="org.apache.xerces.impl.Constants" name="fgXercesProperties" map="B"/>
  <field class="org.apache.xerces.impl.Constants" name="NS_XMLSCHEMA" map="C"/>
  <field class="org.apache.xerces.impl.Constants" name="fgEmptyEnumeration" map="D"/>
  <field class="org.apache.xerces.impl.Constants" name="fgXercesFeatures" map="E"/>
  <field class="org.apache.xerces.impl.Constants" name="NS_DTD" map="F"/>
  <field class="org.apache.xerces.impl.Constants" name="fgSAXProperties" map="G"/>
  <method class="org.apache.xerces.impl.Constants" name="java.util.Enumeration getSAXFeatures()" map="A"/>
  <method class="org.apache.xerces.impl.Constants" name="java.util.Enumeration getXercesFeatures()" map="B"/>
  <class name="org.apache.xerces.impl.XMLVersionDetector" map="G"/>
  <field class="org.apache.xerces.impl.XMLVersionDetector" name="fSymbolTable" map="A"/>
  <field class="org.apache.xerces.impl.XMLVersionDetector" name="fExpectedVersionString" map="B"/>
  <field class="org.apache.xerces.impl.XMLVersionDetector" name="fEncoding" map="C"/>
  <field class="org.apache.xerces.impl.XMLVersionDetector" name="fErrorReporter" map="D"/>
  <field class="org.apache.xerces.impl.XMLVersionDetector" name="fXMLSymbol" map="E"/>
  <field class="org.apache.xerces.impl.XMLVersionDetector" name="fVersionSymbol" map="F"/>
  <field class="org.apache.xerces.impl.XMLVersionDetector" name="XML11_VERSION" map="G"/>
  <field class="org.apache.xerces.impl.XMLVersionDetector" name="fEntityManager" map="H"/>
  <method class="org.apache.xerces.impl.XMLVersionDetector" name="short determineDocVersion(org.apache.xerces.xni.parser.XMLInputSource)" map="A"/>
  <method class="org.apache.xerces.impl.XMLVersionDetector" name="void startDocumentParsing(org.apache.xerces.impl.XMLEntityHandler, short)" map="A"/>
  <method class="org.apache.xerces.impl.XMLVersionDetector" name="void fixupCurrentEntity(org.apache.xerces.impl.XMLEntityManager, char[], int)" map="A"/>
  <method class="org.apache.xerces.impl.XMLVersionDetector" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <class name="org.apache.xerces.impl.XMLErrorReporter$1" map="1"/>
  <field class="org.apache.xerces.impl.XMLErrorReporter$1" name="this$0" map="this$0"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter$1" name="org.apache.xerces.xni.parser.XMLErrorHandler getErrorHandler()" map="G"/>
  <class name="org.apache.xerces.impl.XMLErrorReporter" map="H"/>
  <field class="org.apache.xerces.impl.XMLErrorReporter" name="FEATURE_DEFAULTS" map="&#x0445;"/>
  <field class="org.apache.xerces.impl.XMLErrorReporter" name="fSaxProxy" map="&#x0446;"/>
  <field class="org.apache.xerces.impl.XMLErrorReporter" name="fErrorHandler" map="&#x0447;"/>
  <field class="org.apache.xerces.impl.XMLErrorReporter" name="fLocale" map="&#x0448;"/>
  <field class="org.apache.xerces.impl.XMLErrorReporter" name="RECOGNIZED_PROPERTIES" map="&#x0449;"/>
  <field class="org.apache.xerces.impl.XMLErrorReporter" name="fDefaultErrorHandler" map="&#x044a;"/>
  <field class="org.apache.xerces.impl.XMLErrorReporter" name="fMessageFormatters" map="&#x044b;"/>
  <field class="org.apache.xerces.impl.XMLErrorReporter" name="PROPERTY_DEFAULTS" map="&#x044c;"/>
  <field class="org.apache.xerces.impl.XMLErrorReporter" name="fLocator" map="&#x044d;"/>
  <field class="org.apache.xerces.impl.XMLErrorReporter" name="fContinueAfterFatalError" map="&#x044e;"/>
  <field class="org.apache.xerces.impl.XMLErrorReporter" name="RECOGNIZED_FEATURES" map="&#x044f;"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="org.apache.xerces.xni.parser.XMLErrorHandler getErrorHandler()" map="&#x00fc;"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="void setProperty(java.lang.String, java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="org.xml.sax.ErrorHandler getSAXErrorHandler()" map="&#x00fd;"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="java.lang.String[] getRecognizedFeatures()" map="E"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="java.lang.String reportError(org.apache.xerces.xni.XMLLocator, java.lang.String, java.lang.String, java.lang.Object[], short)" map="A"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="java.util.Locale getLocale()" map="&#x00fe;"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="java.lang.String reportError(java.lang.String, java.lang.String, java.lang.Object[], short)" map="A"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="java.lang.String reportError(java.lang.String, java.lang.String, java.lang.Object[], short, java.lang.Exception)" map="A"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="java.lang.Boolean getFeatureDefault(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="java.lang.String reportError(org.apache.xerces.xni.XMLLocator, java.lang.String, java.lang.String, java.lang.Object[], short, java.lang.Exception)" map="A"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="org.apache.xerces.util.MessageFormatter getMessageFormatter(java.lang.String)" map="s"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="java.lang.Object getPropertyDefault(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="boolean getFeature(java.lang.String)" map="t"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="void setLocale(java.util.Locale)" map="E"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="void setDocumentLocator(org.apache.xerces.xni.XMLLocator)" map="B"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="void setFeature(java.lang.String, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="void putMessageFormatter(java.lang.String, org.apache.xerces.util.MessageFormatter)" map="A"/>
  <method class="org.apache.xerces.impl.XMLErrorReporter" name="java.lang.String[] getRecognizedProperties()" map="F"/>
  <class name="org.apache.xerces.impl.XMLNSDocumentScannerImpl$NSContentDispatcher" map="_A"/>
  <field class="org.apache.xerces.impl.XMLNSDocumentScannerImpl$NSContentDispatcher" name="this$0" map="this$0"/>
  <method class="org.apache.xerces.impl.XMLNSDocumentScannerImpl$NSContentDispatcher" name="boolean scanRootElementHook()" map="C"/>
  <method class="org.apache.xerces.impl.XMLNSDocumentScannerImpl$NSContentDispatcher" name="void reconfigurePipeline()" map="F"/>
  <class name="org.apache.xerces.impl.XMLNSDocumentScannerImpl" map="I"/>
  <field class="org.apache.xerces.impl.XMLNSDocumentScannerImpl" name="fSawSpace" map="&#x0166;"/>
  <field class="org.apache.xerces.impl.XMLNSDocumentScannerImpl" name="fPerformValidation" map="&#x0167;"/>
  <field class="org.apache.xerces.impl.XMLNSDocumentScannerImpl" name="fBindNamespaces" map="&#x0168;"/>
  <field class="org.apache.xerces.impl.XMLNSDocumentScannerImpl" name="fDTDValidator" map="&#x0169;"/>
  <method class="org.apache.xerces.impl.XMLNSDocumentScannerImpl" name="boolean scanStartElement()" map="y"/>
  <method class="org.apache.xerces.impl.XMLNSDocumentScannerImpl" name="void setDTDValidator(org.apache.xerces.impl.dtd.XMLDTDValidatorFilter)" map="B"/>
  <method class="org.apache.xerces.impl.XMLNSDocumentScannerImpl" name="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher createContentDispatcher()" map="w"/>
  <method class="org.apache.xerces.impl.XMLNSDocumentScannerImpl" name="void scanAttribute(org.apache.xerces.util.XMLAttributesImpl)" map="B"/>
  <method class="org.apache.xerces.impl.XMLNSDocumentScannerImpl" name="int scanEndElement()" map="s"/>
  <method class="org.apache.xerces.impl.XMLNSDocumentScannerImpl" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.impl.XMLNSDocumentScannerImpl" name="boolean scanStartElementAfterName()" map="z"/>
  <method class="org.apache.xerces.impl.XMLNSDocumentScannerImpl" name="org.apache.xerces.impl.dtd.XMLDTDValidatorFilter access$000(org.apache.xerces.impl.XMLNSDocumentScannerImpl)" map="access$000"/>
  <method class="org.apache.xerces.impl.XMLNSDocumentScannerImpl" name="void scanStartElementName()" map="u"/>
  <class name="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher" map="_A"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher" name="boolean dispatch(boolean)" map="A"/>
  <class name="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$ElementStack" map="_B"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$ElementStack" name="fElements" map="A"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$ElementStack" name="fSize" map="B"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$ElementStack" name="void clear()" map="A"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$ElementStack" name="void popElement(org.apache.xerces.xni.QName)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$ElementStack" name="org.apache.xerces.xni.QName pushElement(org.apache.xerces.xni.QName)" map="B"/>
  <class name="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher" map="_C"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher" name="this$0" map="this$0"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher" name="void endOfFileHook(java.io.EOFException)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher" name="boolean elementDepthIsZeroHook()" map="A"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher" name="boolean scanForDoctypeHook()" map="B"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher" name="boolean scanRootElementHook()" map="C"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher" name="boolean dispatch(boolean)" map="A"/>
  <class name="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" map="J"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fSingleChar" map="&#x0129;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fScannerState" map="&#x012a;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fNotifyBuiltInRefs" map="&#x012b;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="RECOGNIZED_FEATURES" map="&#x012c;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="PROPERTY_DEFAULTS" map="&#x012d;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fIsEntityDeclaredVC" map="&#x012e;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fStringBuffer2" map="&#x012f;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fTempString2" map="&#x0130;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fElementStack" map="&#x0131;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fSawSpace" map="&#x0132;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fAttributes" map="&#x0133;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fMarkupDepth" map="&#x0134;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fTempAugmentations" map="&#x0135;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fCurrentElement" map="&#x0136;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fInScanContent" map="&#x0137;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fStandalone" map="&#x0138;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fQName" map="&#x0139;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fDocumentHandler" map="&#x013a;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fTempString" map="&#x013b;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fStringBuffer" map="&#x013c;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fStrings" map="&#x013d;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fHasExternalDTD" map="&#x013e;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fDispatcher" map="&#x013f;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fContentDispatcher" map="&#x0140;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="RECOGNIZED_PROPERTIES" map="&#x0141;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fEntityStack" map="&#x0142;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fElementQName" map="&#x0143;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fAttributeQName" map="&#x0144;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="fExternalSubsetResolver" map="&#x0145;"/>
  <field class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="FEATURE_DEFAULTS" map="&#x0146;"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void setScannerState(int)" map="T"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void scanComment()" map="r"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="int scanEndElement()" map="s"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="org.apache.xerces.util.XMLStringBuffer access$000(org.apache.xerces.impl.XMLDocumentFragmentScannerImpl)" map="access$000"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void setProperty(java.lang.String, java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void scanPIData(java.lang.String, org.apache.xerces.xni.XMLString)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="java.lang.String[] getRecognizedFeatures()" map="E"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void scanCharReference()" map="t"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void scanXMLDeclOrTextDecl(boolean)" map="E"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="java.lang.Boolean getFeatureDefault(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void setDispatcher(org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="org.apache.xerces.xni.XMLDocumentHandler getDocumentHandler()" map="D"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="boolean scanCDATASection(boolean)" map="F"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void startEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="java.lang.Object getPropertyDefault(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void scanStartElementName()" map="u"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void scanEntityReference()" map="v"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void handleCharacter(char, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$Dispatcher createContentDispatcher()" map="w"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="java.lang.String getScannerStateName(int)" map="U"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="int scanContent()" map="x"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void scanAttribute(org.apache.xerces.xni.XMLAttributes)" map="E"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="boolean scanStartElement()" map="y"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void setFeature(java.lang.String, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="boolean scanDocument(boolean)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="boolean scanStartElementAfterName()" map="z"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="void endEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="F"/>
  <method class="org.apache.xerces.impl.XMLDocumentFragmentScannerImpl" name="java.lang.String[] getRecognizedProperties()" map="F"/>
  <class name="org.apache.xerces.impl.XML11DTDScannerImpl" map="K"/>
  <field class="org.apache.xerces.impl.XML11DTDScannerImpl" name="fStringBuffer" map="&#x0128;"/>
  <method class="org.apache.xerces.impl.XML11DTDScannerImpl" name="boolean isInvalid(int)" map="O"/>
  <method class="org.apache.xerces.impl.XML11DTDScannerImpl" name="void normalizeWhitespace(org.apache.xerces.xni.XMLString)" map="C"/>
  <method class="org.apache.xerces.impl.XML11DTDScannerImpl" name="boolean isValidNCName(int)" map="N"/>
  <method class="org.apache.xerces.impl.XML11DTDScannerImpl" name="boolean isInvalidLiteral(int)" map="K"/>
  <method class="org.apache.xerces.impl.XML11DTDScannerImpl" name="java.lang.String getVersionNotSupportedKey()" map="e"/>
  <method class="org.apache.xerces.impl.XML11DTDScannerImpl" name="boolean isValidNameChar(int)" map="J"/>
  <method class="org.apache.xerces.impl.XML11DTDScannerImpl" name="boolean versionSupported(java.lang.String)" map="O"/>
  <method class="org.apache.xerces.impl.XML11DTDScannerImpl" name="int isUnchangedByNormalization(org.apache.xerces.xni.XMLString)" map="D"/>
  <method class="org.apache.xerces.impl.XML11DTDScannerImpl" name="void normalizeWhitespace(org.apache.xerces.xni.XMLString, int)" map="A"/>
  <method class="org.apache.xerces.impl.XML11DTDScannerImpl" name="boolean scanPubidLiteral(org.apache.xerces.xni.XMLString)" map="E"/>
  <class name="org.apache.xerces.impl.XMLEntityHandler" map="L"/>
  <method class="org.apache.xerces.impl.XMLEntityHandler" name="void startEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.impl.XMLEntityHandler" name="void endEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="F"/>
  <class name="org.apache.xerces.impl.XMLDTDScannerImpl" map="M"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fMarkUpDepth" map="&#x010c;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fContentStack" map="&#x010d;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fScannerState" map="&#x010e;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fDTDContentModelHandler" map="&#x010f;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fPEStack" map="&#x0110;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fSeenPEReferences" map="&#x0111;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="RECOGNIZED_FEATURES" map="&#x0112;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="PROPERTY_DEFAULTS" map="&#x0113;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fLiteral" map="&#x0114;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fStringBuffer2" map="&#x0115;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fString" map="&#x0116;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fStartDTDCalled" map="&#x0117;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fStandalone" map="&#x0118;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fLiteral2" map="&#x0119;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fContentDepth" map="&#x011a;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fExtEntityDepth" map="&#x011b;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fPEReport" map="&#x011c;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fSeenExternalDTD" map="&#x011d;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fIgnoreConditionalBuffer" map="&#x011e;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fEnumerationCount" map="&#x011f;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fStringBuffer" map="&#x0120;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fStrings" map="&#x0121;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="RECOGNIZED_PROPERTIES" map="&#x0122;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fPEDepth" map="&#x0123;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fIncludeSectDepth" map="&#x0124;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fDTDHandler" map="&#x0125;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="FEATURE_DEFAULTS" map="&#x0126;"/>
  <field class="org.apache.xerces.impl.XMLDTDScannerImpl" name="fEnumeration" map="&#x0127;"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="int skipInvalidEnumerationValue()" map="f"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="int popPEStack()" map="g"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="java.lang.String[] getRecognizedFeatures()" map="E"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void scanNotationDecl()" map="h"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void scanPIData(java.lang.String, org.apache.xerces.xni.XMLString)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="java.lang.String[] getRecognizedProperties()" map="F"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="boolean scanDecls(boolean)" map="D"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="boolean scanTextDecl()" map="i"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void pushPEStack(int, boolean)" map="C"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="java.lang.String scanAttDefaultDecl(java.lang.String, java.lang.String, java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void scanComment()" map="j"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void ensureEnumerationSize(int)" map="P"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="java.lang.String scanAttType(java.lang.String, java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void scanElementDecl()" map="k"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void endEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="F"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="boolean scanDTDExternalSubset(boolean)" map="C"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void startEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void reset()" map="b"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="boolean skipSeparator(boolean, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="java.lang.Boolean getFeatureDefault(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void startPE(java.lang.String, boolean)" map="C"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void setInputSource(org.apache.xerces.xni.parser.XMLInputSource)" map="B"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="boolean scanningInternalSubset()" map="l"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void scanConditionalSect(int)" map="Q"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void scanAttlistDecl()" map="m"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="boolean peekReportEntity()" map="n"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void scanChildren(java.lang.String)" map="P"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void setScannerState(int)" map="R"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="java.lang.Object getPropertyDefault(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void scanEntityValue(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="boolean scanDTDInternalSubset(boolean, boolean, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void scanEntityDecl()" map="o"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void pushContentStack(int)" map="S"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void scanMixed(java.lang.String)" map="Q"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="void init()" map="p"/>
  <method class="org.apache.xerces.impl.XMLDTDScannerImpl" name="int popContentStack()" map="q"/>
  <class name="org.apache.xerces.impl.XMLScanner" map="N"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fValidation" map="&#x00f2;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fScanningAttribute" map="&#x00f3;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fVersionSymbol" map="&#x00f4;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fAposSymbol" map="&#x00f5;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fStringBuffer3" map="&#x00f6;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fStringBuffer2" map="&#x00f8;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fEntityManager" map="&#x00f9;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fErrorReporter" map="&#x00fa;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fString" map="&#x00fb;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fParserSettings" map="&#x00fc;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fResourceIdentifier" map="&#x00fd;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fNamespaces" map="&#x00fe;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fEntityDepth" map="&#x00ff;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fNotifyCharRefs" map="&#x0100;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fQuotSymbol" map="&#x0101;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fGtSymbol" map="&#x0102;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fLtSymbol" map="&#x0103;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fStandaloneSymbol" map="&#x0104;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fSymbolTable" map="&#x0105;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fStringBuffer" map="&#x0106;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fEncodingSymbol" map="&#x0107;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fReportEntity" map="&#x0108;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fAmpSymbol" map="&#x0109;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fEntityScanner" map="&#x010a;"/>
  <field class="org.apache.xerces.impl.XMLScanner" name="fCharRefLiteral" map="&#x010b;"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="boolean scanSurrogates(org.apache.xerces.util.XMLStringBuffer)" map="A"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="void setProperty(java.lang.String, java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="void scanPIData(java.lang.String, org.apache.xerces.xni.XMLString)" map="A"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="java.lang.String[] getRecognizedFeatures()" map="E"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="boolean isValidNameChar(int)" map="J"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="void normalizeWhitespace(org.apache.xerces.xni.XMLString)" map="C"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="boolean isInvalidLiteral(int)" map="K"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="java.lang.Boolean getFeatureDefault(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="boolean isValidNameStartChar(int)" map="L"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="void reset()" map="b"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="void scanPI()" map="c"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="boolean isValidNameStartHighSurrogate(int)" map="M"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="boolean versionSupported(java.lang.String)" map="O"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="boolean isValidNCName(int)" map="N"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="void scanComment(org.apache.xerces.util.XMLStringBuffer)" map="B"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="void init()" map="d"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="void scanXMLDeclOrTextDecl(boolean, java.lang.String[])" map="A"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="void startEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="int scanCharReferenceValue(org.apache.xerces.util.XMLStringBuffer, org.apache.xerces.util.XMLStringBuffer)" map="A"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="java.lang.Object getPropertyDefault(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="int isUnchangedByNormalization(org.apache.xerces.xni.XMLString)" map="D"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="boolean scanAttributeValue(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, java.lang.String, boolean, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="java.lang.String scanPseudoAttribute(boolean, org.apache.xerces.xni.XMLString)" map="A"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="void normalizeWhitespace(org.apache.xerces.xni.XMLString, int)" map="A"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="boolean scanPubidLiteral(org.apache.xerces.xni.XMLString)" map="E"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="boolean isInvalid(int)" map="O"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="void setFeature(java.lang.String, boolean)" map="B"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="void scanExternalID(java.lang.String[], boolean)" map="A"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="java.lang.String getVersionNotSupportedKey()" map="e"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="void endEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="F"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="java.lang.String[] getRecognizedProperties()" map="F"/>
  <method class="org.apache.xerces.impl.XMLScanner" name="void reportFatalError(java.lang.String, java.lang.Object[])" map="C"/>
  <class name="org.apache.xerces.impl.XMLEntityScanner$1" map="1"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner$1" name="java.lang.Throwable fillInStackTrace()" map="fillInStackTrace"/>
  <class name="org.apache.xerces.impl.XMLEntityScanner" map="O"/>
  <field class="org.apache.xerces.impl.XMLEntityScanner" name="fSymbolTable" map="J"/>
  <field class="org.apache.xerces.impl.XMLEntityScanner" name="fCurrentEntity" map="K"/>
  <field class="org.apache.xerces.impl.XMLEntityScanner" name="END_OF_DOCUMENT_ENTITY" map="L"/>
  <field class="org.apache.xerces.impl.XMLEntityScanner" name="fErrorReporter" map="M"/>
  <field class="org.apache.xerces.impl.XMLEntityScanner" name="fBufferSize" map="N"/>
  <field class="org.apache.xerces.impl.XMLEntityScanner" name="fEntityManager" map="O"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="java.lang.String getBaseSystemId()" map="G"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="boolean skipDeclSpaces()" map="H"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="boolean scanQName(org.apache.xerces.xni.QName)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="void reset(org.apache.xerces.util.SymbolTable, org.apache.xerces.impl.XMLEntityManager, org.apache.xerces.impl.XMLErrorReporter)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="java.lang.String getExpandedSystemId()" map="E"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="int getLineNumber()" map="D"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="void setBufferSize(int)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="void setCurrentEntity(org.apache.xerces.impl.XMLEntityManager$ScannedEntity)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="boolean skipString(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="boolean skipChar(int)" map="B"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="int getCharacterOffset()" map="B"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="int scanContent(org.apache.xerces.xni.XMLString)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="boolean isExternal()" map="I"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="java.lang.String getLiteralSystemId()" map="F"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="java.lang.String scanNCName()" map="J"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="boolean skipSpaces()" map="K"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="int peekChar()" map="L"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="void setXMLVersion(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="java.lang.String scanNmtoken()" map="M"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="boolean load(int, boolean)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="int getColumnNumber()" map="C"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="java.lang.String getPublicId()" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="boolean scanData(java.lang.String, org.apache.xerces.util.XMLStringBuffer)" map="A"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="int scanChar()" map="N"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="void setEncoding(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="java.lang.String scanName()" map="O"/>
  <method class="org.apache.xerces.impl.XMLEntityScanner" name="int scanLiteral(int, org.apache.xerces.xni.XMLString)" map="A"/>
  <class name="org.apache.xerces.impl.XML11EntityScanner" map="P"/>
  <method class="org.apache.xerces.impl.XML11EntityScanner" name="boolean skipString(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.impl.XML11EntityScanner" name="int scanChar()" map="N"/>
  <method class="org.apache.xerces.impl.XML11EntityScanner" name="java.lang.String scanNmtoken()" map="M"/>
  <method class="org.apache.xerces.impl.XML11EntityScanner" name="java.lang.String scanName()" map="O"/>
  <method class="org.apache.xerces.impl.XML11EntityScanner" name="java.lang.String scanNCName()" map="J"/>
  <method class="org.apache.xerces.impl.XML11EntityScanner" name="int scanContent(org.apache.xerces.xni.XMLString)" map="A"/>
  <method class="org.apache.xerces.impl.XML11EntityScanner" name="int scanLiteral(int, org.apache.xerces.xni.XMLString)" map="A"/>
  <method class="org.apache.xerces.impl.XML11EntityScanner" name="boolean scanData(java.lang.String, org.apache.xerces.util.XMLStringBuffer)" map="A"/>
  <method class="org.apache.xerces.impl.XML11EntityScanner" name="boolean scanQName(org.apache.xerces.xni.QName)" map="A"/>
  <method class="org.apache.xerces.impl.XML11EntityScanner" name="boolean skipSpaces()" map="K"/>
  <method class="org.apache.xerces.impl.XML11EntityScanner" name="int peekChar()" map="L"/>
  <method class="org.apache.xerces.impl.XML11EntityScanner" name="boolean skipChar(int)" map="B"/>
  <class name="org.apache.xerces.impl.ExternalSubsetResolver" map="Q"/>
  <method class="org.apache.xerces.impl.ExternalSubsetResolver" name="org.apache.xerces.xni.parser.XMLInputSource getExternalSubset(org.apache.xerces.xni.grammars.XMLDTDDescription)" map="A"/>
  <class name="org.apache.xerces.impl.XMLEntityDescription" map="R"/>
  <method class="org.apache.xerces.impl.XMLEntityDescription" name="java.lang.String getEntityName()" map="G"/>
  <package name="org.apache.xerces.xinclude" map="H"/>
  <class name="org.apache.xerces.xinclude.SecuritySupport$4" map="4"/>
  <field class="org.apache.xerces.xinclude.SecuritySupport$4" name="val$propName" map="val$propName"/>
  <method class="org.apache.xerces.xinclude.SecuritySupport$4" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.xinclude.SecuritySupport$3" map="3"/>
  <field class="org.apache.xerces.xinclude.SecuritySupport$3" name="val$cl" map="val$cl"/>
  <method class="org.apache.xerces.xinclude.SecuritySupport$3" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.xinclude.SecuritySupport$2" map="2"/>
  <method class="org.apache.xerces.xinclude.SecuritySupport$2" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.xinclude.SecuritySupport$1" map="1"/>
  <method class="org.apache.xerces.xinclude.SecuritySupport$1" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.xinclude.SecuritySupport" map="A"/>
  <method class="org.apache.xerces.xinclude.SecuritySupport" name="java.lang.ClassLoader getContextClassLoader()" map="A"/>
  <method class="org.apache.xerces.xinclude.SecuritySupport" name="java.lang.ClassLoader getSystemClassLoader()" map="B"/>
  <method class="org.apache.xerces.xinclude.SecuritySupport" name="java.lang.String getSystemProperty(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xinclude.SecuritySupport" name="java.lang.ClassLoader getParentClassLoader(java.lang.ClassLoader)" map="A"/>
  <class name="org.apache.xerces.xinclude.XIncludeNamespaceSupport" map="B"/>
  <field class="org.apache.xerces.xinclude.XIncludeNamespaceSupport" name="fValidContext" map="K"/>
  <method class="org.apache.xerces.xinclude.XIncludeNamespaceSupport" name="void pushContext()" map="D"/>
  <method class="org.apache.xerces.xinclude.XIncludeNamespaceSupport" name="java.lang.String getURIFromIncludeParent(java.lang.String)" map="D"/>
  <method class="org.apache.xerces.xinclude.XIncludeNamespaceSupport" name="void setContextInvalid()" map="J"/>
  <class name="org.apache.xerces.xinclude.XIncludeTextReader" map="C"/>
  <field class="org.apache.xerces.xinclude.XIncludeTextReader" name="fReader" map="A"/>
  <field class="org.apache.xerces.xinclude.XIncludeTextReader" name="fErrorReporter" map="B"/>
  <field class="org.apache.xerces.xinclude.XIncludeTextReader" name="fHandler" map="C"/>
  <field class="org.apache.xerces.xinclude.XIncludeTextReader" name="fSource" map="D"/>
  <field class="org.apache.xerces.xinclude.XIncludeTextReader" name="fTempString" map="E"/>
  <method class="org.apache.xerces.xinclude.XIncludeTextReader" name="boolean isValid(int)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeTextReader" name="void setBufferSize(int)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeTextReader" name="void close()" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeTextReader" name="void setErrorReporter(org.apache.xerces.impl.XMLErrorReporter)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeTextReader" name="java.lang.String consumeBOM(java.io.InputStream, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeTextReader" name="java.io.Reader createUTF16Reader(java.io.InputStream, boolean)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeTextReader" name="java.io.Reader createUTF8Reader(java.io.InputStream)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeTextReader" name="java.lang.String getEncodingName(byte[])" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeTextReader" name="java.io.Reader getReader(org.apache.xerces.xni.parser.XMLInputSource)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeTextReader" name="java.lang.String getEncodingName(java.io.InputStream)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeTextReader" name="void setInputSource(org.apache.xerces.xni.parser.XMLInputSource)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeTextReader" name="void parse()" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeTextReader" name="java.io.Reader createLatin1Reader(java.io.InputStream)" map="C"/>
  <method class="org.apache.xerces.xinclude.XIncludeTextReader" name="java.io.Reader createASCIIReader(java.io.InputStream)" map="D"/>
  <class name="org.apache.xerces.xinclude.XIncludeHandler$UnparsedEntity" map="_A"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler$UnparsedEntity" name="systemId" map="A"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler$UnparsedEntity" name="augmentations" map="B"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler$UnparsedEntity" name="name" map="C"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler$UnparsedEntity" name="notation" map="D"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler$UnparsedEntity" name="expandedSystemId" map="E"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler$UnparsedEntity" name="publicId" map="F"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler$UnparsedEntity" name="baseURI" map="G"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler$UnparsedEntity" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler$UnparsedEntity" name="boolean isEqual(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler$UnparsedEntity" name="boolean isDuplicate(java.lang.Object)" map="A"/>
  <class name="org.apache.xerces.xinclude.XIncludeHandler$Notation" map="_B"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler$Notation" name="systemId" map="A"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler$Notation" name="augmentations" map="B"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler$Notation" name="name" map="C"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler$Notation" name="expandedSystemId" map="D"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler$Notation" name="publicId" map="E"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler$Notation" name="baseURI" map="F"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler$Notation" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler$Notation" name="boolean isEqual(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler$Notation" name="boolean isDuplicate(java.lang.Object)" map="A"/>
  <class name="org.apache.xerces.xinclude.XIncludeHandler" map="D"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="XINCLUDE_ATTR_PARSE" map="m"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fParentXIncludeHandler" map="n"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fXInclude10TextReader" map="o"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fDocumentHandler" map="p"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="gHexChs" map="q"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="XINCLUDE_ATTR_HREF" map="r"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="XINCLUDE_INCLUDED" map="s"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="XML_BASE_QNAME" map="t"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="RECOGNIZED_PROPERTIES" map="u"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="RECOGNIZED_FEATURES" map="v"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fHasIncludeReportedContent" map="w"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fCurrentBaseURI" map="x"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fSecurityManager" map="y"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="XINCLUDE_LANG" map="z"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fBufferSize" map="&#x00a2;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fDTDHandler" map="&#x00a3;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fBaseURIScope" map="&#x00a4;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fFixupLanguage" map="&#x00a5;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fUnparsedEntities" map="&#x00aa;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="PROPERTY_DEFAULTS" map="&#x00b5;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fSawInclude" map="&#x00ba;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fState" map="&#x00c0;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fLanguageStack" map="&#x00c1;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fXPointerChildConfig" map="&#x00c2;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="XINCLUDE_NS_URI" map="&#x00c3;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fChildConfig" map="&#x00c4;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="gAfterEscaping2" map="&#x00c5;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fLiteralSystemID" map="&#x00c6;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="gAfterEscaping1" map="&#x00c7;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fXInclude11TextReader" map="&#x00c8;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="XINCLUDE_ATTR_ACCEPT" map="&#x00c9;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fSawFallback" map="&#x00ca;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fHrefFromParent" map="&#x00cb;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="XINCLUDE_BASE" map="&#x00cc;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fDepth" map="&#x00cd;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fParentRelativeURI" map="&#x00ce;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fSymbolTable" map="&#x00cf;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="XINCLUDE_INCLUDE" map="&#x00d0;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fXIncludeChildConfig" map="&#x00d1;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="XINCLUDE_FALLBACK" map="&#x00d2;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fLanguageScope" map="&#x00d3;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fDocumentSource" map="&#x00d4;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fXPtrProcessor" map="&#x00d5;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fDocLocation" map="&#x00d6;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fIsXML11" map="&#x00d8;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fXIncludeMessageFormatter" map="&#x00d9;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="XINCLUDE_PARSE_XML" map="&#x00da;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="XINCLUDE_ATTR_ACCEPT_LANGUAGE" map="&#x00db;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="NEW_NS_ATTR_QNAME" map="&#x00dc;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="FEATURE_DEFAULTS" map="&#x00dd;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fDTDSource" map="&#x00de;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fInDTD" map="&#x00df;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="XINCLUDE_ATTR_ENCODING" map="&#x00e0;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fBaseURI" map="&#x00e1;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fXIncludeLocator" map="&#x00e2;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fNotations" map="&#x00e3;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fSettings" map="&#x00e4;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="XML_LANG_QNAME" map="&#x00e5;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="XINCLUDE_PARSE_TEXT" map="&#x00e6;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fErrorReporter" map="&#x00e7;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fSendUEAndNotationEvents" map="&#x00e8;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fSeenRootElement" map="&#x00e9;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fCurrentLanguage" map="&#x00ea;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fFixupBaseURIs" map="&#x00eb;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fResultDepth" map="&#x00ec;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fEntityResolver" map="&#x00ed;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="gNeedEscaping" map="&#x00ee;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fNamespaceContext" map="&#x00ef;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fNeedCopyFeatures" map="&#x00f0;"/>
  <field class="org.apache.xerces.xinclude.XIncludeHandler" name="fExpandedSystemID" map="&#x00f1;"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void setErrorReporter(org.apache.xerces.impl.XMLErrorReporter)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="org.apache.xerces.xni.Augmentations modifyAugmentations(org.apache.xerces.xni.Augmentations, boolean)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean isTopLevelIncludedItem()" map="J"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void setParent(org.apache.xerces.xinclude.XIncludeHandler)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean isFallbackElement(org.apache.xerces.xni.QName)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="org.apache.xerces.xni.Augmentations modifyAugmentations(org.apache.xerces.xni.Augmentations)" map="N"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean sameLanguageAsIncludeParent()" map="K"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void endExternalSubset(org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void copyFeatures(org.apache.xerces.xni.parser.XMLComponentManager, org.apache.xerces.util.ParserConfigurationSettings)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void ignoredCharacters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void restoreBaseURI()" map="L"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void reportFatalError(java.lang.String, java.lang.Object[])" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void checkWhitespace(org.apache.xerces.xni.XMLString)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean isRootDocument()" map="M"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void processXMLBaseAttributes(org.apache.xerces.xni.XMLAttributes)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void internalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="java.lang.String escapeHref(java.lang.String)" map="F"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void endParameterEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="int getState()" map="N"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void endConditional(org.apache.xerces.xni.Augmentations)" map="F"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void externalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void handleFallbackElement()" map="O"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="java.lang.String getIncludeParentLanguage()" map="P"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void reportResourceError(java.lang.String, java.lang.Object[])" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void setState(int)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void doctypeDecl(java.lang.String, java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void endGeneralEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean isTopLevelIncludedItemViaFallback()" map="Q"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="int scopeOfLanguage(int)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void copyFeatures1(java.util.Enumeration, java.lang.String, org.apache.xerces.xni.parser.XMLComponentManager, org.apache.xerces.util.ParserConfigurationSettings)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="java.lang.String getRelativeURI(int)" map="C"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean getSawFallback(int)" map="D"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void startGeneralEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="java.lang.String getIncludeParentBaseURI()" map="R"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void reportFatalError(java.lang.String)" map="G"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="java.lang.String getBaseURI(int)" map="E"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void endCDATA(org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void saveBaseURI()" map="S"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void addNotation(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="java.lang.String getLanguage(int)" map="F"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void processingInstruction(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void startParameterEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="int getState(int)" map="G"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void addUnparsedEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void textDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void checkUnparsedEntity(java.lang.String)" map="H"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="java.lang.String[] getRecognizedFeatures()" map="E"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void characters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void startCDATA(org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean getSawInclude(int)" map="H"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void emptyElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void copyFeatures1(java.util.Enumeration, java.lang.String, org.apache.xerces.xni.parser.XMLComponentManager, org.apache.xerces.xni.parser.XMLParserConfiguration)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void endAttlist(org.apache.xerces.xni.Augmentations)" map="G"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void startExternalSubset(org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void startDocument(org.apache.xerces.xni.XMLLocator, java.lang.String, org.apache.xerces.xni.NamespaceContext, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void reset(org.apache.xerces.xni.parser.XMLComponentManager)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean isTopLevelIncludedItemViaInclude()" map="T"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="java.lang.String restoreLanguage()" map="U"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void setFeature(java.lang.String, boolean)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="int getIncludeParentDepth()" map="V"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void saveLanguage(java.lang.String)" map="I"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="int getResultDepth()" map="W"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void xmlDecl(java.lang.String, java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void elementDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void endDocument(org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean isIncludeElement(org.apache.xerces.xni.QName)" map="C"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void setProperty(java.lang.String, java.lang.Object)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void startConditional(short, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="org.apache.xerces.xni.parser.XMLInputSource createInputSource(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void checkNotation(java.lang.String)" map="J"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void reportFatalError(java.lang.String, java.lang.Object[], java.lang.Exception)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void copyFeatures(org.apache.xerces.xni.parser.XMLComponentManager, org.apache.xerces.xni.parser.XMLParserConfiguration)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void endDTD(org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean isValidInHTTPHeader(java.lang.String)" map="K"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean getRootElementProcessed()" map="X"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void startDTD(org.apache.xerces.xni.XMLLocator, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void ignorableWhitespace(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void checkMultipleRootElements()" map="Y"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="java.lang.Object getPropertyDefault(java.lang.String)" map="C"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void setHref(java.lang.String)" map="L"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void reportResourceError(java.lang.String, java.lang.Object[], java.lang.Exception)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="java.lang.Boolean getFeatureDefault(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void setXIncludeLocator(org.apache.xerces.util.XMLLocatorWrapper)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void startElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void endElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean isEqual(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void setSawInclude(int, boolean)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean handleIncludeElement(org.apache.xerces.xni.XMLAttributes)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="org.apache.xerces.xni.XMLDocumentHandler getDocumentHandler()" map="D"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="java.lang.String[] getRecognizedProperties()" map="F"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void setupCurrentBaseURI(org.apache.xerces.xni.XMLLocator)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void unparsedEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void processXMLLangAttributes(org.apache.xerces.xni.XMLAttributes)" map="C"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="java.lang.String getRelativeBaseURI()" map="Z"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void attributeDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String[], java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void setSawFallback(int, boolean)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void comment(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void checkAndSendNotation(org.apache.xerces.xinclude.XIncludeHandler$Notation)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void reportError(java.lang.String, java.lang.Object[], short, java.lang.Exception)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean searchForRecursiveIncludes(java.lang.String)" map="M"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean hasXIncludeNamespace(org.apache.xerces.xni.QName)" map="D"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="org.apache.xerces.xni.XMLAttributes processAttributes(org.apache.xerces.xni.XMLAttributes)" map="D"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void startAttlist(java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void checkAndSendUnparsedEntity(org.apache.xerces.xinclude.XIncludeHandler$UnparsedEntity)" map="A"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void notationDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="void setRootElementProcessed(boolean)" map="B"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="boolean sameBaseURIAsIncludeParent()" map="_"/>
  <method class="org.apache.xerces.xinclude.XIncludeHandler" name="int scopeOfBaseURI(int)" map="I"/>
  <class name="org.apache.xerces.xinclude.ObjectFactory$ConfigurationError" map="_A"/>
  <field class="org.apache.xerces.xinclude.ObjectFactory$ConfigurationError" name="exception" map="A"/>
  <class name="org.apache.xerces.xinclude.ObjectFactory" map="E"/>
  <field class="org.apache.xerces.xinclude.ObjectFactory" name="fLastModified" map="A"/>
  <field class="org.apache.xerces.xinclude.ObjectFactory" name="class$org$apache$xerces$xinclude$ObjectFactory" map="class$F$C$A$H$E"/>
  <field class="org.apache.xerces.xinclude.ObjectFactory" name="DEBUG" map="B"/>
  <field class="org.apache.xerces.xinclude.ObjectFactory" name="fXercesProperties" map="C"/>
  <method class="org.apache.xerces.xinclude.ObjectFactory" name="void debugPrintln(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xinclude.ObjectFactory" name="java.lang.ClassLoader findClassLoader()" map="A"/>
  <method class="org.apache.xerces.xinclude.ObjectFactory" name="boolean isDebugEnabled()" map="B"/>
  <method class="org.apache.xerces.xinclude.ObjectFactory" name="java.lang.Class findProviderClass(java.lang.String, java.lang.ClassLoader, boolean)" map="A"/>
  <method class="org.apache.xerces.xinclude.ObjectFactory" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.apache.xerces.xinclude.ObjectFactory" name="java.lang.Object newInstance(java.lang.String, java.lang.ClassLoader, boolean)" map="B"/>
  <class name="org.apache.xerces.xinclude.MultipleScopeNamespaceSupport" map="F"/>
  <field class="org.apache.xerces.xinclude.MultipleScopeNamespaceSupport" name="fCurrentScope" map="I"/>
  <field class="org.apache.xerces.xinclude.MultipleScopeNamespaceSupport" name="fScope" map="J"/>
  <method class="org.apache.xerces.xinclude.MultipleScopeNamespaceSupport" name="java.lang.String getURI(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.xinclude.MultipleScopeNamespaceSupport" name="void popScope()" map="H"/>
  <method class="org.apache.xerces.xinclude.MultipleScopeNamespaceSupport" name="void reset()" map="A"/>
  <method class="org.apache.xerces.xinclude.MultipleScopeNamespaceSupport" name="void pushScope()" map="I"/>
  <method class="org.apache.xerces.xinclude.MultipleScopeNamespaceSupport" name="int getScopeForContext(int)" map="B"/>
  <method class="org.apache.xerces.xinclude.MultipleScopeNamespaceSupport" name="java.lang.String getPrefix(java.lang.String, int, int)" map="A"/>
  <method class="org.apache.xerces.xinclude.MultipleScopeNamespaceSupport" name="java.lang.String getURI(java.lang.String, int, int)" map="B"/>
  <method class="org.apache.xerces.xinclude.MultipleScopeNamespaceSupport" name="java.lang.String getPrefix(java.lang.String)" map="B"/>
  <method class="org.apache.xerces.xinclude.MultipleScopeNamespaceSupport" name="java.lang.String getURI(java.lang.String, int)" map="A"/>
  <method class="org.apache.xerces.xinclude.MultipleScopeNamespaceSupport" name="java.util.Enumeration getAllPrefixes()" map="E"/>
  <class name="org.apache.xerces.xinclude.XInclude11TextReader" map="G"/>
  <method class="org.apache.xerces.xinclude.XInclude11TextReader" name="boolean isValid(int)" map="A"/>
  <class name="org.apache.xerces.xinclude.XIncludeMessageFormatter" map="H"/>
  <field class="org.apache.xerces.xinclude.XIncludeMessageFormatter" name="fLocale" map="E"/>
  <field class="org.apache.xerces.xinclude.XIncludeMessageFormatter" name="fResourceBundle" map="F"/>
  <method class="org.apache.xerces.xinclude.XIncludeMessageFormatter" name="java.lang.String formatMessage(java.util.Locale, java.lang.String, java.lang.Object[])" map="A"/>
  <package name="org.apache.xerces.jaxp" map="I"/>
  <package name="org.apache.xerces.jaxp.datatype" map="A"/>
  <class name="org.apache.xerces.jaxp.datatype.DatatypeFactoryImpl" map="A"/>
  <package name="org.apache.xerces.parsers" map="J"/>
  <class name="org.apache.xerces.parsers.SecuritySupport$6" map="6"/>
  <field class="org.apache.xerces.parsers.SecuritySupport$6" name="val$name" map="val$name"/>
  <field class="org.apache.xerces.parsers.SecuritySupport$6" name="val$cl" map="val$cl"/>
  <method class="org.apache.xerces.parsers.SecuritySupport$6" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.parsers.SecuritySupport$5" map="5"/>
  <field class="org.apache.xerces.parsers.SecuritySupport$5" name="val$file" map="val$file"/>
  <method class="org.apache.xerces.parsers.SecuritySupport$5" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.parsers.SecuritySupport$4" map="4"/>
  <field class="org.apache.xerces.parsers.SecuritySupport$4" name="val$propName" map="val$propName"/>
  <method class="org.apache.xerces.parsers.SecuritySupport$4" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.parsers.SecuritySupport$3" map="3"/>
  <field class="org.apache.xerces.parsers.SecuritySupport$3" name="val$cl" map="val$cl"/>
  <method class="org.apache.xerces.parsers.SecuritySupport$3" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.parsers.SecuritySupport$2" map="2"/>
  <method class="org.apache.xerces.parsers.SecuritySupport$2" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.parsers.SecuritySupport$1" map="1"/>
  <method class="org.apache.xerces.parsers.SecuritySupport$1" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.parsers.SecuritySupport$8" map="8"/>
  <field class="org.apache.xerces.parsers.SecuritySupport$8" name="val$f" map="val$f"/>
  <method class="org.apache.xerces.parsers.SecuritySupport$8" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.parsers.SecuritySupport$7" map="7"/>
  <field class="org.apache.xerces.parsers.SecuritySupport$7" name="val$f" map="val$f"/>
  <method class="org.apache.xerces.parsers.SecuritySupport$7" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.xerces.parsers.SecuritySupport" map="A"/>
  <method class="org.apache.xerces.parsers.SecuritySupport" name="java.io.InputStream getResourceAsStream(java.lang.ClassLoader, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.parsers.SecuritySupport" name="java.lang.ClassLoader getContextClassLoader()" map="A"/>
  <method class="org.apache.xerces.parsers.SecuritySupport" name="java.lang.ClassLoader getSystemClassLoader()" map="B"/>
  <method class="org.apache.xerces.parsers.SecuritySupport" name="boolean getFileExists(java.io.File)" map="A"/>
  <method class="org.apache.xerces.parsers.SecuritySupport" name="java.io.FileInputStream getFileInputStream(java.io.File)" map="B"/>
  <method class="org.apache.xerces.parsers.SecuritySupport" name="long getLastModified(java.io.File)" map="C"/>
  <method class="org.apache.xerces.parsers.SecuritySupport" name="java.lang.String getSystemProperty(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.parsers.SecuritySupport" name="java.lang.ClassLoader getParentClassLoader(java.lang.ClassLoader)" map="A"/>
  <class name="org.apache.xerces.parsers.XML11DTDConfiguration" map="B"/>
  <method class="org.apache.xerces.parsers.XML11DTDConfiguration" name="void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler)" map="B"/>
  <method class="org.apache.xerces.parsers.XML11DTDConfiguration" name="java.util.Locale getLocale()" map="&#x00d6;"/>
  <method class="org.apache.xerces.parsers.XML11DTDConfiguration" name="boolean getFeature(java.lang.String)" map="h"/>
  <method class="org.apache.xerces.parsers.XML11DTDConfiguration" name="void setProperty(java.lang.String, java.lang.Object)" map="D"/>
  <method class="org.apache.xerces.parsers.XML11DTDConfiguration" name="void setEntityResolver(org.apache.xerces.xni.parser.XMLEntityResolver)" map="B"/>
  <method class="org.apache.xerces.parsers.XML11DTDConfiguration" name="void parse(org.apache.xerces.xni.parser.XMLInputSource)" map="D"/>
  <method class="org.apache.xerces.parsers.XML11DTDConfiguration" name="void setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler)" map="B"/>
  <method class="org.apache.xerces.parsers.XML11DTDConfiguration" name="void setFeature(java.lang.String, boolean)" map="E"/>
  <method class="org.apache.xerces.parsers.XML11DTDConfiguration" name="void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler)" map="B"/>
  <class name="org.apache.xerces.parsers.BasicParserConfiguration" map="C"/>
  <field class="org.apache.xerces.parsers.BasicParserConfiguration" name="fLastComponent" map="&#x0273;"/>
  <field class="org.apache.xerces.parsers.BasicParserConfiguration" name="fComponents" map="&#x0274;"/>
  <field class="org.apache.xerces.parsers.BasicParserConfiguration" name="fLocale" map="&#x0275;"/>
  <field class="org.apache.xerces.parsers.BasicParserConfiguration" name="fSymbolTable" map="&#x0276;"/>
  <field class="org.apache.xerces.parsers.BasicParserConfiguration" name="fDTDContentModelHandler" map="&#x0277;"/>
  <field class="org.apache.xerces.parsers.BasicParserConfiguration" name="fDTDHandler" map="&#x0278;"/>
  <field class="org.apache.xerces.parsers.BasicParserConfiguration" name="fDocumentHandler" map="&#x0279;"/>
  <method class="org.apache.xerces.parsers.BasicParserConfiguration" name="void reset()" map="&#x00df;"/>
  <method class="org.apache.xerces.parsers.BasicParserConfiguration" name="void checkProperty(java.lang.String)" map="j"/>
  <method class="org.apache.xerces.parsers.BasicParserConfiguration" name="void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler)" map="B"/>
  <method class="org.apache.xerces.parsers.BasicParserConfiguration" name="java.util.Locale getLocale()" map="&#x00d6;"/>
  <method class="org.apache.xerces.parsers.BasicParserConfiguration" name="void setProperty(java.lang.String, java.lang.Object)" map="D"/>
  <method class="org.apache.xerces.parsers.BasicParserConfiguration" name="void setEntityResolver(org.apache.xerces.xni.parser.XMLEntityResolver)" map="B"/>
  <method class="org.apache.xerces.parsers.BasicParserConfiguration" name="void parse(org.apache.xerces.xni.parser.XMLInputSource)" map="D"/>
  <method class="org.apache.xerces.parsers.BasicParserConfiguration" name="void setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler)" map="B"/>
  <method class="org.apache.xerces.parsers.BasicParserConfiguration" name="void checkFeature(java.lang.String)" map="k"/>
  <method class="org.apache.xerces.parsers.BasicParserConfiguration" name="void setLocale(java.util.Locale)" map="C"/>
  <method class="org.apache.xerces.parsers.BasicParserConfiguration" name="void setFeature(java.lang.String, boolean)" map="E"/>
  <method class="org.apache.xerces.parsers.BasicParserConfiguration" name="void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler)" map="B"/>
  <method class="org.apache.xerces.parsers.BasicParserConfiguration" name="void addComponent(org.apache.xerces.xni.parser.XMLComponent)" map="E"/>
  <class name="org.apache.xerces.parsers.SAXParser" map="D"/>
  <field class="org.apache.xerces.parsers.SAXParser" name="RECOGNIZED_FEATURES" map="&#x01fb;"/>
  <field class="org.apache.xerces.parsers.SAXParser" name="RECOGNIZED_PROPERTIES" map="&#x01fc;"/>
  <class name="org.apache.xerces.parsers.XML11Configuration" map="E"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fXML11NSDocScanner" map="&#x0212;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fDocumentHandler" map="&#x0213;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fNamespaceScanner" map="&#x0214;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fCurrentDVFactory" map="&#x0215;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fDTDProcessor" map="&#x0216;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fLocale" map="&#x0217;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fConfigUpdated" map="&#x0250;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fDTDValidator" map="&#x0251;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fXML11DTDProcessor" map="&#x0252;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fXML11DocScanner" map="&#x0253;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fGrammarPool" map="&#x0254;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fEntityManager" map="&#x0255;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fCommonComponents" map="&#x0256;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fXML11DTDScanner" map="&#x0257;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fDTDHandler" map="&#x0258;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fSchemaValidator" map="&#x0259;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fXML11DTDValidator" map="&#x025a;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fDatatypeValidatorFactory" map="&#x025b;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fDTDContentModelHandler" map="&#x025c;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="f11Initialized" map="&#x025d;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fCurrentScanner" map="&#x025e;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fComponents" map="&#x025f;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fLastComponent" map="&#x0260;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fVersionDetector" map="&#x0261;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fXML11DatatypeFactory" map="&#x0262;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fNonNSScanner" map="&#x0263;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fSymbolTable" map="&#x0264;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fParseInProgress" map="&#x0265;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fInputSource" map="&#x0266;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fCurrentDTDScanner" map="&#x0267;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fDTDScanner" map="&#x0268;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fErrorReporter" map="&#x0269;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fNonNSDTDValidator" map="&#x026a;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fValidationManager" map="&#x026b;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fXML11Components" map="&#x026c;"/>
  <field class="org.apache.xerces.parsers.XML11Configuration" name="fXML11NSDTDValidator" map="&#x026d;"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void checkProperty(java.lang.String)" map="j"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void setInputSource(org.apache.xerces.xni.parser.XMLInputSource)" map="E"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void checkFeature(java.lang.String)" map="k"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler)" map="B"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="boolean getFeature0(java.lang.String)" map="l"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void configurePipeline()" map="&#x00d8;"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void setProperty(java.lang.String, java.lang.Object)" map="D"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="java.util.Locale getLocale()" map="&#x00d6;"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void configureXML11Pipeline()" map="&#x00d9;"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void setEntityResolver(org.apache.xerces.xni.parser.XMLEntityResolver)" map="B"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void reset()" map="&#x00da;"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void addXML11Component(org.apache.xerces.xni.parser.XMLComponent)" map="A"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler)" map="B"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void addCommonComponent(org.apache.xerces.xni.parser.XMLComponent)" map="B"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void parse(org.apache.xerces.xni.parser.XMLInputSource)" map="D"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="boolean parse(boolean)" map="H"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void addRecognizedParamsAndSetDefaults(org.apache.xerces.xni.parser.XMLComponent)" map="C"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="java.lang.Object getProperty(java.lang.String)" map="i"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void resetXML11()" map="&#x00db;"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void initXML11Components()" map="&#x00dc;"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void addComponent(org.apache.xerces.xni.parser.XMLComponent)" map="D"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void cleanup()" map="&#x00dd;"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler)" map="B"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="boolean getFeature(java.lang.String)" map="h"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void setLocale(java.util.Locale)" map="B"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void resetCommon()" map="&#x00de;"/>
  <method class="org.apache.xerces.parsers.XML11Configuration" name="void setFeature(java.lang.String, boolean)" map="E"/>
  <class name="org.apache.xerces.parsers.XIncludeAwareParserConfiguration" map="F"/>
  <field class="org.apache.xerces.parsers.XIncludeAwareParserConfiguration" name="fXIncludeNSContext" map="&#x026e;"/>
  <field class="org.apache.xerces.parsers.XIncludeAwareParserConfiguration" name="fXIncludeEnabled" map="&#x026f;"/>
  <field class="org.apache.xerces.parsers.XIncludeAwareParserConfiguration" name="fCurrentNSContext" map="&#x0270;"/>
  <field class="org.apache.xerces.parsers.XIncludeAwareParserConfiguration" name="fNonXIncludeNSContext" map="&#x0271;"/>
  <field class="org.apache.xerces.parsers.XIncludeAwareParserConfiguration" name="fXIncludeHandler" map="&#x0272;"/>
  <method class="org.apache.xerces.parsers.XIncludeAwareParserConfiguration" name="void setFeature(java.lang.String, boolean)" map="E"/>
  <method class="org.apache.xerces.parsers.XIncludeAwareParserConfiguration" name="void configurePipeline()" map="&#x00d8;"/>
  <method class="org.apache.xerces.parsers.XIncludeAwareParserConfiguration" name="boolean getFeature(java.lang.String)" map="h"/>
  <method class="org.apache.xerces.parsers.XIncludeAwareParserConfiguration" name="void configureXML11Pipeline()" map="&#x00d9;"/>
  <class name="org.apache.xerces.parsers.XMLParser" map="G"/>
  <field class="org.apache.xerces.parsers.XMLParser" name="fConfiguration" map="A"/>
  <field class="org.apache.xerces.parsers.XMLParser" name="RECOGNIZED_PROPERTIES" map="B"/>
  <method class="org.apache.xerces.parsers.XMLParser" name="void parse(org.apache.xerces.xni.parser.XMLInputSource)" map="A"/>
  <method class="org.apache.xerces.parsers.XMLParser" name="void reset()" map="B"/>
  <class name="org.apache.xerces.parsers.XML11Configurable" map="H"/>
  <class name="org.apache.xerces.parsers.ObjectFactory$ConfigurationError" map="_A"/>
  <field class="org.apache.xerces.parsers.ObjectFactory$ConfigurationError" name="exception" map="A"/>
  <class name="org.apache.xerces.parsers.ObjectFactory" map="I"/>
  <field class="org.apache.xerces.parsers.ObjectFactory" name="fLastModified" map="A"/>
  <field class="org.apache.xerces.parsers.ObjectFactory" name="DEBUG" map="B"/>
  <field class="org.apache.xerces.parsers.ObjectFactory" name="fXercesProperties" map="C"/>
  <field class="org.apache.xerces.parsers.ObjectFactory" name="class$org$apache$xerces$parsers$ObjectFactory" map="class$F$C$A$J$I"/>
  <method class="org.apache.xerces.parsers.ObjectFactory" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.apache.xerces.parsers.ObjectFactory" name="boolean isDebugEnabled()" map="A"/>
  <method class="org.apache.xerces.parsers.ObjectFactory" name="java.lang.Object createObject(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.parsers.ObjectFactory" name="java.lang.ClassLoader findClassLoader()" map="B"/>
  <method class="org.apache.xerces.parsers.ObjectFactory" name="java.lang.Object createObject(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xerces.parsers.ObjectFactory" name="java.lang.Object newInstance(java.lang.String, java.lang.ClassLoader, boolean)" map="A"/>
  <method class="org.apache.xerces.parsers.ObjectFactory" name="java.lang.Object findJarServiceProvider(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.parsers.ObjectFactory" name="java.lang.Class findProviderClass(java.lang.String, java.lang.ClassLoader, boolean)" map="B"/>
  <method class="org.apache.xerces.parsers.ObjectFactory" name="void debugPrintln(java.lang.String)" map="B"/>
  <class name="org.apache.xerces.parsers.AbstractSAXParser$LocatorProxy" map="_A"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser$LocatorProxy" name="fLocator" map="E"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser$LocatorProxy" name="java.lang.String getPublicId()" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser$LocatorProxy" name="int getColumnNumber()" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser$LocatorProxy" name="int getLineNumber()" map="C"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser$LocatorProxy" name="java.lang.String getSystemId()" map="D"/>
  <class name="org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy" map="_B"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy" name="fAttributes" map="C"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy" name="java.lang.String getURI(int)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy" name="java.lang.String getQName(int)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy" name="java.lang.String getValue(int)" map="C"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy" name="java.lang.String getLocalName(int)" map="D"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy" name="void setAttributes(org.apache.xerces.xni.XMLAttributes)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy" name="int getLength()" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy" name="java.lang.String getType(int)" map="E"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser$AttributesProxy" name="java.lang.String getName(int)" map="G"/>
  <class name="org.apache.xerces.parsers.AbstractSAXParser" map="J"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fUseEntityResolver2" map="&#x01e2;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fDeclaredAttrs" map="&#x01e3;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fAugmentations" map="&#x01e4;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="RECOGNIZED_FEATURES" map="&#x01e5;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fXMLNSURIs" map="&#x01e6;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fNamespacePrefixes" map="&#x01e7;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fDeclHandler" map="&#x01e8;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fNamespaceContext" map="&#x01e9;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fNamespaces" map="&#x01ea;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fResolveDTDURIs" map="&#x01eb;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fStandalone" map="&#x01ec;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fLexicalHandlerParameterEntities" map="&#x01ed;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fQName" map="&#x01ee;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fContentHandler" map="&#x01ef;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fDocumentHandler" map="&#x01f0;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fVersion" map="&#x01f1;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="RECOGNIZED_PROPERTIES" map="&#x01f2;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fAttributesProxy" map="&#x01f3;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fDTDHandler" map="&#x01f4;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fParseInProgress" map="&#x01f5;"/>
  <field class="org.apache.xerces.parsers.AbstractSAXParser" name="fLexicalHandler" map="&#x01fa;"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void startElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="boolean getFeature(java.lang.String)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void notationDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void setFeature(java.lang.String, boolean)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void unparsedEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void startCDATA(org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void startGeneralEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void processingInstruction(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void parse(org.xml.sax.InputSource)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void endElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void characters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void endExternalSubset(org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void xmlDecl(java.lang.String, java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void elementDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void endGeneralEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void ignorableWhitespace(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void startParameterEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void doctypeDecl(java.lang.String, java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void comment(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void setDTDHandler(org.xml.sax.DTDHandler)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void startExternalSubset(org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void startDocument(org.apache.xerces.xni.XMLLocator, java.lang.String, org.apache.xerces.xni.NamespaceContext, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void endDocument(org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void endParameterEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void setDocumentHandler(org.xml.sax.DocumentHandler)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void externalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void startNamespaceMapping()" map="&#x00d1;"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void reset()" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void setContentHandler(org.xml.sax.ContentHandler)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="org.xml.sax.EntityResolver getEntityResolver()" map="&#x00d2;"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void internalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void attributeDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String[], java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void endNamespaceMapping()" map="&#x00d3;"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void setLexicalHandler(org.xml.sax.ext.LexicalHandler)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void setProperty(java.lang.String, java.lang.Object)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void setEntityResolver(org.xml.sax.EntityResolver)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void setErrorHandler(org.xml.sax.ErrorHandler)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void setDeclHandler(org.xml.sax.ext.DeclHandler)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void endCDATA(org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.parsers.AbstractSAXParser" name="void endDTD(org.apache.xerces.xni.Augmentations)" map="D"/>
  <class name="org.apache.xerces.parsers.XML11NonValidatingConfiguration" map="K"/>
  <method class="org.apache.xerces.parsers.XML11NonValidatingConfiguration" name="void setDTDHandler(org.apache.xerces.xni.XMLDTDHandler)" map="B"/>
  <method class="org.apache.xerces.parsers.XML11NonValidatingConfiguration" name="java.util.Locale getLocale()" map="&#x00d6;"/>
  <method class="org.apache.xerces.parsers.XML11NonValidatingConfiguration" name="boolean getFeature(java.lang.String)" map="h"/>
  <method class="org.apache.xerces.parsers.XML11NonValidatingConfiguration" name="void setProperty(java.lang.String, java.lang.Object)" map="D"/>
  <method class="org.apache.xerces.parsers.XML11NonValidatingConfiguration" name="void setEntityResolver(org.apache.xerces.xni.parser.XMLEntityResolver)" map="B"/>
  <method class="org.apache.xerces.parsers.XML11NonValidatingConfiguration" name="void parse(org.apache.xerces.xni.parser.XMLInputSource)" map="D"/>
  <method class="org.apache.xerces.parsers.XML11NonValidatingConfiguration" name="void setDTDContentModelHandler(org.apache.xerces.xni.XMLDTDContentModelHandler)" map="B"/>
  <method class="org.apache.xerces.parsers.XML11NonValidatingConfiguration" name="void setFeature(java.lang.String, boolean)" map="E"/>
  <method class="org.apache.xerces.parsers.XML11NonValidatingConfiguration" name="void setDocumentHandler(org.apache.xerces.xni.XMLDocumentHandler)" map="B"/>
  <class name="org.apache.xerces.parsers.NonValidatingConfiguration" map="L"/>
  <method class="org.apache.xerces.parsers.NonValidatingConfiguration" name="void parse(org.apache.xerces.xni.parser.XMLInputSource)" map="D"/>
  <method class="org.apache.xerces.parsers.NonValidatingConfiguration" name="void setProperty(java.lang.String, java.lang.Object)" map="D"/>
  <method class="org.apache.xerces.parsers.NonValidatingConfiguration" name="void setFeature(java.lang.String, boolean)" map="E"/>
  <method class="org.apache.xerces.parsers.NonValidatingConfiguration" name="boolean getFeature(java.lang.String)" map="h"/>
  <method class="org.apache.xerces.parsers.NonValidatingConfiguration" name="java.lang.Object getProperty(java.lang.String)" map="i"/>
  <class name="org.apache.xerces.parsers.AbstractXMLDocumentParser" map="M"/>
  <field class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="fInDTD" map="&#x01de;"/>
  <field class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="fDTDSource" map="&#x01df;"/>
  <field class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="fDocumentSource" map="&#x01e0;"/>
  <field class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="fDTDContentModelSource" map="&#x01e1;"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void startElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void element(java.lang.String, org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void startContentModel(java.lang.String, org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void notationDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void unparsedEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void startCDATA(org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void startGeneralEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void processingInstruction(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void endConditional(org.apache.xerces.xni.Augmentations)" map="F"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void endElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void characters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void endExternalSubset(org.apache.xerces.xni.Augmentations)" map="E"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void xmlDecl(java.lang.String, java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void elementDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void endGeneralEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void ignorableWhitespace(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void empty(org.apache.xerces.xni.Augmentations)" map="K"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void startParameterEntity(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void endGroup(org.apache.xerces.xni.Augmentations)" map="H"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void doctypeDecl(java.lang.String, java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void comment(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void startAttlist(java.lang.String, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void startExternalSubset(org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void occurrence(short, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void endContentModel(org.apache.xerces.xni.Augmentations)" map="M"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void startDocument(org.apache.xerces.xni.XMLLocator, java.lang.String, org.apache.xerces.xni.NamespaceContext, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void setDocumentSource(org.apache.xerces.xni.parser.XMLDocumentSource)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void endDocument(org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void endParameterEntity(java.lang.String, org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void externalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLResourceIdentifier, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void reset()" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void startDTD(org.apache.xerces.xni.XMLLocator, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void startConditional(short, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void any(org.apache.xerces.xni.Augmentations)" map="L"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void startGroup(org.apache.xerces.xni.Augmentations)" map="I"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void ignoredCharacters(org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void separator(short, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void internalEntityDecl(java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void attributeDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String[], java.lang.String, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.XMLString, org.apache.xerces.xni.Augmentations)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void emptyElement(org.apache.xerces.xni.QName, org.apache.xerces.xni.XMLAttributes, org.apache.xerces.xni.Augmentations)" map="B"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void pcdata(org.apache.xerces.xni.Augmentations)" map="J"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void endAttlist(org.apache.xerces.xni.Augmentations)" map="G"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void setDTDContentModelSource(org.apache.xerces.xni.parser.XMLDTDContentModelSource)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void endCDATA(org.apache.xerces.xni.Augmentations)" map="C"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void endDTD(org.apache.xerces.xni.Augmentations)" map="D"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void setDTDSource(org.apache.xerces.xni.parser.XMLDTDSource)" map="A"/>
  <method class="org.apache.xerces.parsers.AbstractXMLDocumentParser" name="void textDecl(java.lang.String, java.lang.String, org.apache.xerces.xni.Augmentations)" map="A"/>
  <class name="org.apache.xerces.parsers.DTDConfiguration" map="N"/>
  <method class="org.apache.xerces.parsers.DTDConfiguration" name="void parse(org.apache.xerces.xni.parser.XMLInputSource)" map="D"/>
  <method class="org.apache.xerces.parsers.DTDConfiguration" name="void setProperty(java.lang.String, java.lang.Object)" map="D"/>
  <method class="org.apache.xerces.parsers.DTDConfiguration" name="java.lang.Object getProperty(java.lang.String)" map="i"/>
  <package name="org.apache.jcp" map="B"/>
  <package name="org.apache.jcp.xml" map="A"/>
  <package name="org.apache.jcp.xml.dsig" map="A"/>
  <package name="org.apache.jcp.xml.dsig.internal" map="A"/>
  <package name="org.apache.jcp.xml.dsig.internal.dom" map="A"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$RSA" map="_A"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$RSA" name="modulus" map="B"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$RSA" name="exponent" map="C"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$DSA" map="_B"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$DSA" name="g" map="D"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$DSA" name="q" map="E"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$DSA" name="p" map="F"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$DSA" name="y" map="G"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$EC$1" map="1"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$EC$1" name="this$0" map="A"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$EC$1" name="java.lang.Object run()" map="run"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$EC$1" name="java.lang.Void run()" map="A"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$EC" map="_C"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$EC" name="decodePoint" map="H"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$EC" name="getCurveName" map="I"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$EC" name="ecParams" map="J"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$EC" name="getECParameterSpec" map="K"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$EC" name="ecPublicKey" map="L"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$EC" name="encodePoint" map="M"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue$EC" name="void getMethods()" map="D"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue" map="A"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue" name="publicKey" map="A"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyValue" name="java.security.PublicKey getPublicKey()" map="C"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.DOMKeyInfo" map="B"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyInfo" name="keyInfoTypes" map="U"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyInfo" name="id" map="V"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyInfo" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyInfo" name="java.lang.String getId()" map="A"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyInfo" name="java.util.List getContent()" map="B"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.XMLDSigRI$1" map="1"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.XMLDSigRI$1" name="this$0" map="A"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.XMLDSigRI$1" name="val$map" map="B"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.XMLDSigRI$1" name="java.lang.Object run()" map="run"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.XMLDSigRI$1" name="java.lang.Void run()" map="A"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.XMLDSigRI" map="C"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.DOMStructure" map="D"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.DOMSignedInfo" map="E"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMSignedInfo" name="log" map="N"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMSignedInfo" name="java.util.List getReferences()" map="E"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMSignedInfo" name="void canonicalize(javax.xml.crypto.XMLCryptoContext, java.io.ByteArrayOutputStream)" map="A"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.DOMKeyInfoFactory" map="F"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyInfoFactory" name="javax.xml.crypto.dsig.keyinfo.KeyInfo newKeyInfo(java.util.List)" map="A"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyInfoFactory" name="javax.xml.crypto.dsig.keyinfo.X509Data newX509Data(java.util.List)" map="B"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyInfoFactory" name="javax.xml.crypto.dsig.keyinfo.KeyInfo newKeyInfo(java.util.List, java.lang.String)" map="A"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMKeyInfoFactory" name="javax.xml.crypto.dsig.keyinfo.KeyValue newKeyValue(java.security.PublicKey)" map="A"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.DOMX509Data" map="G"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMX509Data" name="content" map="O"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMX509Data" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMX509Data" name="java.util.List getContent()" map="F"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.DOMXMLSignature" map="H"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMXMLSignature" name="log" map="P"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMXMLSignature" name="void marshal(org.w3c.dom.Node, org.w3c.dom.Node, java.lang.String, javax.xml.crypto.dom.DOMCryptoContext)" map="A"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.DOMReference$1" map="1"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMReference$1" name="java.lang.Object run()" map="run"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMReference$1" name="java.lang.Boolean run()" map="A"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.DOMReference" map="I"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMReference" name="useC14N11" map="Q"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMReference" name="log" map="R"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMReference" name="void digest(javax.xml.crypto.dsig.XMLSignContext)" map="A"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.DOMUtils" map="J"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMUtils" name="java.lang.String getNSPrefix(javax.xml.crypto.XMLCryptoContext, java.lang.String)" map="A"/>
  <method class="org.apache.jcp.xml.dsig.internal.dom.DOMUtils" name="java.lang.String getSignaturePrefix(javax.xml.crypto.XMLCryptoContext)" map="A"/>
  <class name="org.apache.jcp.xml.dsig.internal.dom.DOMCryptoBinary" map="K"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMCryptoBinary" name="bigNum" map="S"/>
  <field class="org.apache.jcp.xml.dsig.internal.dom.DOMCryptoBinary" name="value" map="T"/>
  <package name="org.apache.xml" map="C"/>
  <package name="org.apache.xml.security" map="A"/>
  <package name="org.apache.xml.security.utils" map="A"/>
  <package name="org.apache.xml.security.utils.resolver" map="A"/>
  <package name="org.apache.xml.security.utils.resolver.implementations" map="A"/>
  <class name="org.apache.xml.security.utils.resolver.implementations.ResolverXPointer" map="A"/>
  <field class="org.apache.xml.security.utils.resolver.implementations.ResolverXPointer" name="log" map="H"/>
  <field class="org.apache.xml.security.utils.resolver.implementations.ResolverXPointer" name="XP_LENGTH" map="I"/>
  <class name="org.apache.xml.security.utils.resolver.implementations.ResolverLocalFilesystem" map="B"/>
  <field class="org.apache.xml.security.utils.resolver.implementations.ResolverLocalFilesystem" name="FILE_URI_LENGTH" map="C"/>
  <field class="org.apache.xml.security.utils.resolver.implementations.ResolverLocalFilesystem" name="log" map="D"/>
  <class name="org.apache.xml.security.utils.resolver.implementations.ResolverFragment" map="C"/>
  <field class="org.apache.xml.security.utils.resolver.implementations.ResolverFragment" name="log" map="E"/>
  <class name="org.apache.xml.security.utils.resolver.implementations.ResolverDirectHTTP" map="D"/>
  <field class="org.apache.xml.security.utils.resolver.implementations.ResolverDirectHTTP" name="properties" map="F"/>
  <field class="org.apache.xml.security.utils.resolver.implementations.ResolverDirectHTTP" name="log" map="G"/>
  <class name="org.apache.xml.security.utils.resolver.ResourceResolver" map="A"/>
  <field class="org.apache.xml.security.utils.resolver.ResourceResolver" name="resolverList" map="A"/>
  <field class="org.apache.xml.security.utils.resolver.ResourceResolver" name="log" map="B"/>
  <field class="org.apache.xml.security.utils.resolver.ResourceResolver" name="resolverSpi" map="C"/>
  <method class="org.apache.xml.security.utils.resolver.ResourceResolver" name="void register(java.lang.Class, boolean)" map="A"/>
  <method class="org.apache.xml.security.utils.resolver.ResourceResolver" name="void register(org.apache.xml.security.utils.resolver.ResourceResolverSpi, boolean)" map="A"/>
  <method class="org.apache.xml.security.utils.resolver.ResourceResolver" name="void registerDefaultResolvers()" map="A"/>
  <method class="org.apache.xml.security.utils.resolver.ResourceResolver" name="void register(java.lang.String)" map="A"/>
  <class name="org.apache.xml.security.utils.resolver.ResourceResolverSpi" map="B"/>
  <field class="org.apache.xml.security.utils.resolver.ResourceResolverSpi" name="properties" map="A"/>
  <field class="org.apache.xml.security.utils.resolver.ResourceResolverSpi" name="log" map="B"/>
  <class name="org.apache.xml.security.utils.ClassLoaderUtils" map="A"/>
  <field class="org.apache.xml.security.utils.ClassLoaderUtils" name="log" map="A"/>
  <method class="org.apache.xml.security.utils.ClassLoaderUtils" name="java.lang.Class loadClass(java.lang.String, java.lang.Class)" map="A"/>
  <method class="org.apache.xml.security.utils.ClassLoaderUtils" name="java.lang.Class loadClass2(java.lang.String, java.lang.Class)" map="B"/>
  <class name="org.apache.xml.security.utils.I18n" map="B"/>
  <field class="org.apache.xml.security.utils.I18n" name="alreadyInitialized" map="A"/>
  <field class="org.apache.xml.security.utils.I18n" name="resourceBundle" map="B"/>
  <method class="org.apache.xml.security.utils.I18n" name="java.lang.String getExceptionMessage(java.lang.String)" map="A"/>
  <method class="org.apache.xml.security.utils.I18n" name="void init(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xml.security.utils.I18n" name="java.lang.String getExceptionMessage(java.lang.String, java.lang.Object[])" map="A"/>
  <method class="org.apache.xml.security.utils.I18n" name="java.lang.String translate(java.lang.String)" map="B"/>
  <method class="org.apache.xml.security.utils.I18n" name="java.lang.String translate(java.lang.String, java.lang.Object[])" map="B"/>
  <class name="org.apache.xml.security.utils.SignatureElementProxy" map="C"/>
  <class name="org.apache.xml.security.utils.ElementProxy" map="D"/>
  <field class="org.apache.xml.security.utils.ElementProxy" name="log" map="A"/>
  <field class="org.apache.xml.security.utils.ElementProxy" name="prefixMappings" map="B"/>
  <method class="org.apache.xml.security.utils.ElementProxy" name="void setDefaultPrefix(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.xml.security.utils.ElementProxy" name="void registerDefaultPrefixes()" map="A"/>
  <class name="org.apache.xml.security.utils.XMLUtils$1" map="1"/>
  <method class="org.apache.xml.security.utils.XMLUtils$1" name="java.lang.Object run()" map="run"/>
  <method class="org.apache.xml.security.utils.XMLUtils$1" name="java.lang.Boolean run()" map="A"/>
  <class name="org.apache.xml.security.utils.XMLUtils" map="E"/>
  <field class="org.apache.xml.security.utils.XMLUtils" name="ignoreLineBreaks" map="A"/>
  <field class="org.apache.xml.security.utils.XMLUtils" name="log" map="B"/>
  <field class="org.apache.xml.security.utils.XMLUtils" name="dsPrefix" map="C"/>
  <field class="org.apache.xml.security.utils.XMLUtils" name="xencPrefix" map="D"/>
  <field class="org.apache.xml.security.utils.XMLUtils" name="xenc11Prefix" map="E"/>
  <method class="org.apache.xml.security.utils.XMLUtils" name="void setXencPrefix(java.lang.String)" map="A"/>
  <method class="org.apache.xml.security.utils.XMLUtils" name="void setDsPrefix(java.lang.String)" map="B"/>
  <method class="org.apache.xml.security.utils.XMLUtils" name="boolean ignoreLineBreaks()" map="A"/>
  <method class="org.apache.xml.security.utils.XMLUtils" name="org.w3c.dom.Element[] selectNodes(org.w3c.dom.Node, java.lang.String, java.lang.String)" map="A"/>
  <class name="org.apache.xml.security.utils.Base64" map="F"/>
  <field class="org.apache.xml.security.utils.Base64" name="base64Alphabet" map="A"/>
  <field class="org.apache.xml.security.utils.Base64" name="lookUpBase64Alphabet" map="B"/>
  <method class="org.apache.xml.security.utils.Base64" name="java.lang.String encode(byte[])" map="A"/>
  <method class="org.apache.xml.security.utils.Base64" name="byte[] getBytes(java.math.BigInteger, int)" map="A"/>
  <method class="org.apache.xml.security.utils.Base64" name="java.lang.String encode(byte[], int)" map="A"/>
  <method class="org.apache.xml.security.utils.Base64" name="java.lang.String encode(java.math.BigInteger)" map="A"/>
  <package name="org.apache.xml.security.signature" map="B"/>
  <class name="org.apache.xml.security.signature.XMLSignatureException" map="A"/>
  <package name="org.apache.xml.security.exceptions" map="C"/>
  <class name="org.apache.xml.security.exceptions.AlgorithmAlreadyRegisteredException" map="A"/>
  <class name="org.apache.xml.security.exceptions.XMLSecurityException" map="B"/>
  <field class="org.apache.xml.security.exceptions.XMLSecurityException" name="msgID" map="A"/>
  <method class="org.apache.xml.security.exceptions.XMLSecurityException" name="void printStackTrace()" map="printStackTrace"/>
  <method class="org.apache.xml.security.exceptions.XMLSecurityException" name="void printStackTrace(java.io.PrintWriter)" map="printStackTrace"/>
  <method class="org.apache.xml.security.exceptions.XMLSecurityException" name="void printStackTrace(java.io.PrintStream)" map="printStackTrace"/>
  <method class="org.apache.xml.security.exceptions.XMLSecurityException" name="java.lang.String toString()" map="toString"/>
  <package name="org.apache.xml.security.transforms" map="D"/>
  <package name="org.apache.xml.security.transforms.implementations" map="A"/>
  <class name="org.apache.xml.security.transforms.implementations.TransformXSLT" map="A"/>
  <field class="org.apache.xml.security.transforms.implementations.TransformXSLT" name="log" map="A"/>
  <class name="org.apache.xml.security.transforms.implementations.TransformC14NExclusiveWithComments" map="B"/>
  <class name="org.apache.xml.security.transforms.implementations.TransformC14NExclusive" map="C"/>
  <class name="org.apache.xml.security.transforms.implementations.TransformC14N11" map="D"/>
  <class name="org.apache.xml.security.transforms.implementations.TransformXPath" map="E"/>
  <class name="org.apache.xml.security.transforms.implementations.TransformC14N" map="F"/>
  <class name="org.apache.xml.security.transforms.implementations.TransformC14N11_WithComments" map="G"/>
  <class name="org.apache.xml.security.transforms.implementations.TransformEnvelopedSignature" map="H"/>
  <class name="org.apache.xml.security.transforms.implementations.TransformXPath2Filter" map="I"/>
  <class name="org.apache.xml.security.transforms.implementations.TransformBase64Decode" map="J"/>
  <class name="org.apache.xml.security.transforms.implementations.TransformC14NWithComments" map="K"/>
  <class name="org.apache.xml.security.transforms.Transform" map="A"/>
  <field class="org.apache.xml.security.transforms.Transform" name="log" map="C"/>
  <field class="org.apache.xml.security.transforms.Transform" name="transformSpiHash" map="D"/>
  <method class="org.apache.xml.security.transforms.Transform" name="void registerDefaultAlgorithms()" map="B"/>
  <method class="org.apache.xml.security.transforms.Transform" name="void register(java.lang.String, java.lang.String)" map="B"/>
  <class name="org.apache.xml.security.transforms.InvalidTransformException" map="B"/>
  <class name="org.apache.xml.security.transforms.TransformSpi" map="C"/>
  <package name="org.apache.xml.security.algorithms" map="E"/>
  <package name="org.apache.xml.security.algorithms.implementations" map="A"/>
  <class name="org.apache.xml.security.algorithms.implementations.IntegrityHmac$IntegrityHmacSHA256" map="_A"/>
  <class name="org.apache.xml.security.algorithms.implementations.IntegrityHmac$IntegrityHmacSHA1" map="_B"/>
  <class name="org.apache.xml.security.algorithms.implementations.IntegrityHmac$IntegrityHmacRIPEMD160" map="_C"/>
  <class name="org.apache.xml.security.algorithms.implementations.IntegrityHmac$IntegrityHmacSHA384" map="_D"/>
  <class name="org.apache.xml.security.algorithms.implementations.IntegrityHmac$IntegrityHmacMD5" map="_E"/>
  <class name="org.apache.xml.security.algorithms.implementations.IntegrityHmac$IntegrityHmacSHA512" map="_F"/>
  <class name="org.apache.xml.security.algorithms.implementations.IntegrityHmac" map="A"/>
  <field class="org.apache.xml.security.algorithms.implementations.IntegrityHmac" name="log" map="D"/>
  <class name="org.apache.xml.security.algorithms.implementations.SignatureECDSA$SignatureECDSASHA256" map="_A"/>
  <class name="org.apache.xml.security.algorithms.implementations.SignatureECDSA$SignatureECDSASHA384" map="_B"/>
  <class name="org.apache.xml.security.algorithms.implementations.SignatureECDSA$SignatureECDSASHA1" map="_C"/>
  <class name="org.apache.xml.security.algorithms.implementations.SignatureECDSA$SignatureECDSASHA512" map="_D"/>
  <class name="org.apache.xml.security.algorithms.implementations.SignatureECDSA" map="B"/>
  <field class="org.apache.xml.security.algorithms.implementations.SignatureECDSA" name="log" map="A"/>
  <class name="org.apache.xml.security.algorithms.implementations.SignatureDSA" map="C"/>
  <field class="org.apache.xml.security.algorithms.implementations.SignatureDSA" name="log" map="B"/>
  <class name="org.apache.xml.security.algorithms.implementations.SignatureBaseRSA$SignatureRSAMD5" map="_A"/>
  <class name="org.apache.xml.security.algorithms.implementations.SignatureBaseRSA$SignatureRSASHA384" map="_B"/>
  <class name="org.apache.xml.security.algorithms.implementations.SignatureBaseRSA$SignatureRSASHA512" map="_C"/>
  <class name="org.apache.xml.security.algorithms.implementations.SignatureBaseRSA$SignatureRSARIPEMD160" map="_D"/>
  <class name="org.apache.xml.security.algorithms.implementations.SignatureBaseRSA$SignatureRSASHA1" map="_E"/>
  <class name="org.apache.xml.security.algorithms.implementations.SignatureBaseRSA$SignatureRSASHA256" map="_F"/>
  <class name="org.apache.xml.security.algorithms.implementations.SignatureBaseRSA" map="D"/>
  <field class="org.apache.xml.security.algorithms.implementations.SignatureBaseRSA" name="log" map="C"/>
  <class name="org.apache.xml.security.algorithms.Algorithm" map="A"/>
  <class name="org.apache.xml.security.algorithms.SignatureAlgorithm" map="B"/>
  <field class="org.apache.xml.security.algorithms.SignatureAlgorithm" name="log" map="E"/>
  <field class="org.apache.xml.security.algorithms.SignatureAlgorithm" name="algorithmHash" map="F"/>
  <method class="org.apache.xml.security.algorithms.SignatureAlgorithm" name="void registerDefaultAlgorithms()" map="C"/>
  <method class="org.apache.xml.security.algorithms.SignatureAlgorithm" name="void register(java.lang.String, java.lang.String)" map="C"/>
  <class name="org.apache.xml.security.algorithms.JCEMapper$Algorithm" map="_A"/>
  <field class="org.apache.xml.security.algorithms.JCEMapper$Algorithm" name="algorithmClass" map="A"/>
  <field class="org.apache.xml.security.algorithms.JCEMapper$Algorithm" name="keyLength" map="B"/>
  <field class="org.apache.xml.security.algorithms.JCEMapper$Algorithm" name="jceName" map="C"/>
  <field class="org.apache.xml.security.algorithms.JCEMapper$Algorithm" name="requiredKey" map="D"/>
  <class name="org.apache.xml.security.algorithms.JCEMapper" map="C"/>
  <field class="org.apache.xml.security.algorithms.JCEMapper" name="algorithmsMap" map="A"/>
  <field class="org.apache.xml.security.algorithms.JCEMapper" name="log" map="B"/>
  <field class="org.apache.xml.security.algorithms.JCEMapper" name="providerName" map="C"/>
  <method class="org.apache.xml.security.algorithms.JCEMapper" name="void registerDefaultAlgorithms()" map="A"/>
  <method class="org.apache.xml.security.algorithms.JCEMapper" name="void register(java.lang.String, org.apache.xml.security.algorithms.JCEMapper$Algorithm)" map="A"/>
  <class name="org.apache.xml.security.algorithms.SignatureAlgorithmSpi" map="D"/>
  <package name="org.apache.xml.security.keys" map="F"/>
  <package name="org.apache.xml.security.keys.keyresolver" map="A"/>
  <package name="org.apache.xml.security.keys.keyresolver.implementations" map="A"/>
  <class name="org.apache.xml.security.keys.keyresolver.implementations.RetrievalMethodResolver" map="A"/>
  <field class="org.apache.xml.security.keys.keyresolver.implementations.RetrievalMethodResolver" name="log" map="I"/>
  <class name="org.apache.xml.security.keys.keyresolver.implementations.RSAKeyValueResolver" map="B"/>
  <field class="org.apache.xml.security.keys.keyresolver.implementations.RSAKeyValueResolver" name="log" map="C"/>
  <class name="org.apache.xml.security.keys.keyresolver.implementations.X509SubjectNameResolver" map="C"/>
  <field class="org.apache.xml.security.keys.keyresolver.implementations.X509SubjectNameResolver" name="log" map="D"/>
  <class name="org.apache.xml.security.keys.keyresolver.implementations.X509CertificateResolver" map="D"/>
  <field class="org.apache.xml.security.keys.keyresolver.implementations.X509CertificateResolver" name="log" map="E"/>
  <class name="org.apache.xml.security.keys.keyresolver.implementations.X509SKIResolver" map="E"/>
  <field class="org.apache.xml.security.keys.keyresolver.implementations.X509SKIResolver" name="log" map="F"/>
  <class name="org.apache.xml.security.keys.keyresolver.implementations.X509IssuerSerialResolver" map="F"/>
  <field class="org.apache.xml.security.keys.keyresolver.implementations.X509IssuerSerialResolver" name="log" map="G"/>
  <class name="org.apache.xml.security.keys.keyresolver.implementations.DSAKeyValueResolver" map="G"/>
  <field class="org.apache.xml.security.keys.keyresolver.implementations.DSAKeyValueResolver" name="log" map="H"/>
  <class name="org.apache.xml.security.keys.keyresolver.KeyResolverSpi" map="A"/>
  <field class="org.apache.xml.security.keys.keyresolver.KeyResolverSpi" name="globalResolver" map="A"/>
  <field class="org.apache.xml.security.keys.keyresolver.KeyResolverSpi" name="properties" map="B"/>
  <method class="org.apache.xml.security.keys.keyresolver.KeyResolverSpi" name="void setGlobalResolver(boolean)" map="A"/>
  <class name="org.apache.xml.security.keys.keyresolver.KeyResolver" map="B"/>
  <field class="org.apache.xml.security.keys.keyresolver.KeyResolver" name="resolverVector" map="A"/>
  <field class="org.apache.xml.security.keys.keyresolver.KeyResolver" name="log" map="B"/>
  <field class="org.apache.xml.security.keys.keyresolver.KeyResolver" name="resolverSpi" map="C"/>
  <method class="org.apache.xml.security.keys.keyresolver.KeyResolver" name="void registerClassNames(java.util.List)" map="A"/>
  <method class="org.apache.xml.security.keys.keyresolver.KeyResolver" name="void registerDefaultResolvers()" map="A"/>
  <package name="org.apache.xml.security.c14n" map="G"/>
  <package name="org.apache.xml.security.c14n.implementations" map="A"/>
  <class name="org.apache.xml.security.c14n.implementations.Canonicalizer20010315ExclOmitComments" map="A"/>
  <class name="org.apache.xml.security.c14n.implementations.CanonicalizerBase" map="B"/>
  <field class="org.apache.xml.security.c14n.implementations.CanonicalizerBase" name="END_COMM" map="A"/>
  <field class="org.apache.xml.security.c14n.implementations.CanonicalizerBase" name="END_PI" map="B"/>
  <field class="org.apache.xml.security.c14n.implementations.CanonicalizerBase" name="END_TAG" map="C"/>
  <field class="org.apache.xml.security.c14n.implementations.CanonicalizerBase" name="nullNode" map="D"/>
  <field class="org.apache.xml.security.c14n.implementations.CanonicalizerBase" name="QUOT" map="E"/>
  <field class="org.apache.xml.security.c14n.implementations.CanonicalizerBase" name="BEGIN_PI" map="F"/>
  <field class="org.apache.xml.security.c14n.implementations.CanonicalizerBase" name="XD" map="G"/>
  <field class="org.apache.xml.security.c14n.implementations.CanonicalizerBase" name="COMPARE" map="H"/>
  <field class="org.apache.xml.security.c14n.implementations.CanonicalizerBase" name="XA" map="I"/>
  <field class="org.apache.xml.security.c14n.implementations.CanonicalizerBase" name="GT" map="J"/>
  <field class="org.apache.xml.security.c14n.implementations.CanonicalizerBase" name="AMP" map="K"/>
  <field class="org.apache.xml.security.c14n.implementations.CanonicalizerBase" name="LT" map="L"/>
  <field class="org.apache.xml.security.c14n.implementations.CanonicalizerBase" name="X9" map="M"/>
  <field class="org.apache.xml.security.c14n.implementations.CanonicalizerBase" name="BEGIN_COMM" map="N"/>
  <field class="org.apache.xml.security.c14n.implementations.CanonicalizerBase" name="equalsStr" map="O"/>
  <class name="org.apache.xml.security.c14n.implementations.Canonicalizer11_WithComments" map="C"/>
  <class name="org.apache.xml.security.c14n.implementations.Canonicalizer20010315WithComments" map="D"/>
  <class name="org.apache.xml.security.c14n.implementations.Canonicalizer20010315Excl" map="E"/>
  <class name="org.apache.xml.security.c14n.implementations.Canonicalizer20010315ExclWithComments" map="F"/>
  <class name="org.apache.xml.security.c14n.implementations.Canonicalizer11_OmitComments" map="G"/>
  <class name="org.apache.xml.security.c14n.implementations.Canonicalizer20010315OmitComments" map="H"/>
  <class name="org.apache.xml.security.c14n.implementations.Canonicalizer11" map="I"/>
  <field class="org.apache.xml.security.c14n.implementations.Canonicalizer11" name="log" map="P"/>
  <class name="org.apache.xml.security.c14n.implementations.Canonicalizer20010315" map="J"/>
  <package name="org.apache.xml.security.c14n.helper" map="B"/>
  <class name="org.apache.xml.security.c14n.helper.AttrCompare" map="A"/>
  <method class="org.apache.xml.security.c14n.helper.AttrCompare" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <method class="org.apache.xml.security.c14n.helper.AttrCompare" name="int compare(org.w3c.dom.Attr, org.w3c.dom.Attr)" map="A"/>
  <class name="org.apache.xml.security.c14n.Canonicalizer" map="A"/>
  <field class="org.apache.xml.security.c14n.Canonicalizer" name="canonicalizerHash" map="A"/>
  <method class="org.apache.xml.security.c14n.Canonicalizer" name="void registerDefaultAlgorithms()" map="A"/>
  <method class="org.apache.xml.security.c14n.Canonicalizer" name="void register(java.lang.String, java.lang.String)" map="A"/>
  <class name="org.apache.xml.security.c14n.CanonicalizerSpi" map="B"/>
  <class name="org.apache.xml.security.Init$1" map="1"/>
  <method class="org.apache.xml.security.Init$1" name="java.lang.Object run()" map="run"/>
  <method class="org.apache.xml.security.Init$1" name="java.io.InputStream run()" map="A"/>
  <class name="org.apache.xml.security.Init" map="A"/>
  <field class="org.apache.xml.security.Init" name="alreadyInitialized" map="A"/>
  <field class="org.apache.xml.security.Init" name="log" map="B"/>
  <method class="org.apache.xml.security.Init" name="void dynamicInit()" map="A"/>
  <method class="org.apache.xml.security.Init" name="void fileInit(java.io.InputStream)" map="A"/>
  <method class="org.apache.xml.security.Init" name="boolean isInitialized()" map="B"/>
  <method class="org.apache.xml.security.Init" name="void init()" map="C"/>
  <package name="org.apache.html" map="D"/>
  <package name="org.apache.html.dom" map="A"/>
  <class name="org.apache.html.dom.HTMLUListElementImpl" map="A"/>
  <class name="org.apache.html.dom.HTMLMenuElementImpl" map="B"/>
  <class name="org.apache.html.dom.HTMLDivElementImpl" map="C"/>
  <class name="org.apache.html.dom.HTMLAreaElementImpl" map="D"/>
  <class name="org.apache.html.dom.HTMLFrameSetElementImpl" map="E"/>
  <class name="org.apache.html.dom.HTMLModElementImpl" map="F"/>
  <class name="org.apache.html.dom.HTMLButtonElementImpl" map="G"/>
  <class name="org.apache.html.dom.HTMLSelectElementImpl" map="H"/>
  <method class="org.apache.html.dom.HTMLSelectElementImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <method class="org.apache.html.dom.HTMLSelectElementImpl" name="org.w3c.dom.NodeList getChildNodes()" map="y"/>
  <class name="org.apache.html.dom.HTMLTableCellElementImpl" map="I"/>
  <class name="org.apache.html.dom.HTMLIFrameElementImpl" map="J"/>
  <class name="org.apache.html.dom.HTMLQuoteElementImpl" map="K"/>
  <class name="org.apache.html.dom.HTMLParamElementImpl" map="L"/>
  <class name="org.apache.html.dom.HTMLOListElementImpl" map="M"/>
  <class name="org.apache.html.dom.HTMLStyleElementImpl" map="N"/>
  <class name="org.apache.html.dom.HTMLElementImpl" map="O"/>
  <method class="org.apache.html.dom.HTMLElementImpl" name="org.w3c.dom.Attr getAttributeNode(java.lang.String)" map="G"/>
  <method class="org.apache.html.dom.HTMLElementImpl" name="java.lang.String getAttributeNS(java.lang.String, java.lang.String)" map="D"/>
  <method class="org.apache.html.dom.HTMLElementImpl" name="org.w3c.dom.NodeList getElementsByTagName(java.lang.String)" map="H"/>
  <method class="org.apache.html.dom.HTMLElementImpl" name="java.lang.String getAttribute(java.lang.String)" map="I"/>
  <method class="org.apache.html.dom.HTMLElementImpl" name="org.w3c.dom.Attr getAttributeNodeNS(java.lang.String, java.lang.String)" map="E"/>
  <class name="org.apache.html.dom.HTMLBaseElementImpl" map="P"/>
  <class name="org.apache.html.dom.HTMLImageElementImpl" map="Q"/>
  <class name="org.apache.html.dom.HTMLFormControl" map="R"/>
  <class name="org.apache.html.dom.NameNodeListImpl" map="S"/>
  <class name="org.apache.html.dom.HTMLParagraphElementImpl" map="T"/>
  <class name="org.apache.html.dom.HTMLOptGroupElementImpl" map="U"/>
  <class name="org.apache.html.dom.HTMLHtmlElementImpl" map="V"/>
  <class name="org.apache.html.dom.HTMLMetaElementImpl" map="W"/>
  <class name="org.apache.html.dom.HTMLTableRowElementImpl" map="X"/>
  <method class="org.apache.html.dom.HTMLTableRowElementImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <class name="org.apache.html.dom.HTMLAppletElementImpl" map="Y"/>
  <class name="org.apache.html.dom.HTMLBRElementImpl" map="Z"/>
  <class name="org.apache.html.dom.HTMLFontElementImpl" map="_"/>
  <class name="org.apache.html.dom.HTMLFormElementImpl" map="a"/>
  <method class="org.apache.html.dom.HTMLFormElementImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <method class="org.apache.html.dom.HTMLFormElementImpl" name="org.w3c.dom.NodeList getChildNodes()" map="y"/>
  <class name="org.apache.html.dom.HTMLOptionElementImpl" map="b"/>
  <class name="org.apache.html.dom.HTMLDirectoryElementImpl" map="c"/>
  <class name="org.apache.html.dom.HTMLTableColElementImpl" map="d"/>
  <class name="org.apache.html.dom.HTMLTableSectionElementImpl" map="e"/>
  <method class="org.apache.html.dom.HTMLTableSectionElementImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <class name="org.apache.html.dom.HTMLBaseFontElementImpl" map="f"/>
  <class name="org.apache.html.dom.HTMLAnchorElementImpl" map="g"/>
  <class name="org.apache.html.dom.HTMLLIElementImpl" map="h"/>
  <class name="org.apache.html.dom.HTMLDListElementImpl" map="i"/>
  <class name="org.apache.html.dom.HTMLIsIndexElementImpl" map="j"/>
  <class name="org.apache.html.dom.HTMLHeadElementImpl" map="k"/>
  <class name="org.apache.html.dom.HTMLLegendElementImpl" map="l"/>
  <class name="org.apache.html.dom.HTMLHRElementImpl" map="m"/>
  <class name="org.apache.html.dom.HTMLFrameElementImpl" map="n"/>
  <class name="org.apache.html.dom.HTMLTextAreaElementImpl" map="o"/>
  <class name="org.apache.html.dom.HTMLBodyElementImpl" map="p"/>
  <class name="org.apache.html.dom.HTMLFieldSetElementImpl" map="q"/>
  <class name="org.apache.html.dom.HTMLInputElementImpl" map="r"/>
  <class name="org.apache.html.dom.HTMLMapElementImpl" map="s"/>
  <method class="org.apache.html.dom.HTMLMapElementImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <class name="org.apache.html.dom.HTMLTableElementImpl" map="t"/>
  <method class="org.apache.html.dom.HTMLTableElementImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <class name="org.apache.html.dom.HTMLTitleElementImpl" map="u"/>
  <class name="org.apache.html.dom.HTMLObjectElementImpl" map="v"/>
  <class name="org.apache.html.dom.HTMLScriptElementImpl" map="w"/>
  <class name="org.apache.html.dom.HTMLTableCaptionElementImpl" map="x"/>
  <class name="org.apache.html.dom.HTMLLinkElementImpl" map="y"/>
  <class name="org.apache.html.dom.HTMLPreElementImpl" map="z"/>
  <class name="org.apache.html.dom.HTMLHeadingElementImpl" map="$A"/>
  <class name="org.apache.html.dom.HTMLDocumentImpl" map="AA"/>
  <field class="org.apache.html.dom.HTMLDocumentImpl" name="class$org$apache$html$dom$HTMLDocumentImpl" map="class$F$C$D$A$AA"/>
  <field class="org.apache.html.dom.HTMLDocumentImpl" name="_elemClassSigHTML" map="&#x00ee;"/>
  <field class="org.apache.html.dom.HTMLDocumentImpl" name="class$java$lang$String" map="class$java$lang$String"/>
  <method class="org.apache.html.dom.HTMLDocumentImpl" name="org.w3c.dom.Element createElementNS(java.lang.String, java.lang.String)" map="I"/>
  <method class="org.apache.html.dom.HTMLDocumentImpl" name="org.w3c.dom.NodeList getElementsByTagNameNS(java.lang.String, java.lang.String)" map="G"/>
  <method class="org.apache.html.dom.HTMLDocumentImpl" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <method class="org.apache.html.dom.HTMLDocumentImpl" name="org.w3c.dom.Element getDocumentElement()" map="&#x00d3;"/>
  <method class="org.apache.html.dom.HTMLDocumentImpl" name="org.w3c.dom.NodeList getElementsByTagName(java.lang.String)" map="L"/>
  <method class="org.apache.html.dom.HTMLDocumentImpl" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.apache.html.dom.HTMLDocumentImpl" name="org.w3c.dom.Element createElement(java.lang.String)" map="K"/>
  <class name="org.apache.html.dom.HTMLLabelElementImpl" map="BA"/>
  <package name="org.apache.commons" map="E"/>
  <package name="org.apache.commons.logging" map="A"/>
  <package name="org.apache.commons.logging.impl" map="A"/>
  <class name="org.apache.commons.logging.impl.LogFactoryImpl$2" map="2"/>
  <field class="org.apache.commons.logging.impl.LogFactoryImpl$2" name="val$key" map="val$key"/>
  <field class="org.apache.commons.logging.impl.LogFactoryImpl$2" name="val$def" map="val$def"/>
  <method class="org.apache.commons.logging.impl.LogFactoryImpl$2" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.commons.logging.impl.LogFactoryImpl$1" map="1"/>
  <method class="org.apache.commons.logging.impl.LogFactoryImpl$1" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.commons.logging.impl.LogFactoryImpl" map="A"/>
  <field class="org.apache.commons.logging.impl.LogFactoryImpl" name="PKG_LEN" map="F"/>
  <field class="org.apache.commons.logging.impl.LogFactoryImpl" name="classesToDiscover" map="G"/>
  <method class="org.apache.commons.logging.impl.LogFactoryImpl" name="java.lang.ClassLoader getClassLoader(java.lang.Class)" map="D"/>
  <method class="org.apache.commons.logging.impl.LogFactoryImpl" name="boolean isDiagnosticsEnabled()" map="D"/>
  <method class="org.apache.commons.logging.impl.LogFactoryImpl" name="java.lang.ClassLoader access$000()" map="access$000"/>
  <method class="org.apache.commons.logging.impl.LogFactoryImpl" name="java.lang.String getSystemProperty(java.lang.String, java.lang.String)" map="B"/>
  <method class="org.apache.commons.logging.impl.LogFactoryImpl" name="java.lang.ClassLoader getContextClassLoaderInternal()" map="G"/>
  <method class="org.apache.commons.logging.impl.LogFactoryImpl" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <class name="org.apache.commons.logging.Log" map="A"/>
  <method class="org.apache.commons.logging.Log" name="void warn(java.lang.Object, java.lang.Throwable)" map="A"/>
  <method class="org.apache.commons.logging.Log" name="boolean isDebugEnabled()" map="A"/>
  <method class="org.apache.commons.logging.Log" name="void warn(java.lang.Object)" map="A"/>
  <method class="org.apache.commons.logging.Log" name="void error(java.lang.Object, java.lang.Throwable)" map="B"/>
  <method class="org.apache.commons.logging.Log" name="void error(java.lang.Object)" map="B"/>
  <method class="org.apache.commons.logging.Log" name="void debug(java.lang.Object)" map="C"/>
  <class name="org.apache.commons.logging.LogFactory$6" map="6"/>
  <field class="org.apache.commons.logging.LogFactory$6" name="val$key" map="val$key"/>
  <field class="org.apache.commons.logging.LogFactory$6" name="val$def" map="val$def"/>
  <method class="org.apache.commons.logging.LogFactory$6" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.commons.logging.LogFactory$5" map="5"/>
  <field class="org.apache.commons.logging.LogFactory$5" name="val$url" map="val$url"/>
  <method class="org.apache.commons.logging.LogFactory$5" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.commons.logging.LogFactory$4" map="4"/>
  <field class="org.apache.commons.logging.LogFactory$4" name="val$name" map="val$name"/>
  <field class="org.apache.commons.logging.LogFactory$4" name="val$loader" map="val$loader"/>
  <method class="org.apache.commons.logging.LogFactory$4" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.commons.logging.LogFactory$3" map="3"/>
  <field class="org.apache.commons.logging.LogFactory$3" name="val$name" map="val$name"/>
  <field class="org.apache.commons.logging.LogFactory$3" name="val$loader" map="val$loader"/>
  <method class="org.apache.commons.logging.LogFactory$3" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.commons.logging.LogFactory$2" map="2"/>
  <field class="org.apache.commons.logging.LogFactory$2" name="val$classLoader" map="val$classLoader"/>
  <field class="org.apache.commons.logging.LogFactory$2" name="val$factoryClass" map="val$factoryClass"/>
  <method class="org.apache.commons.logging.LogFactory$2" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.commons.logging.LogFactory$1" map="1"/>
  <method class="org.apache.commons.logging.LogFactory$1" name="java.lang.Object run()" map="run"/>
  <class name="org.apache.commons.logging.LogFactory" map="B"/>
  <field class="org.apache.commons.logging.LogFactory" name="nullClassLoaderFactory" map="A"/>
  <field class="org.apache.commons.logging.LogFactory" name="diagnosticPrefix" map="B"/>
  <field class="org.apache.commons.logging.LogFactory" name="factories" map="C"/>
  <field class="org.apache.commons.logging.LogFactory" name="thisClassLoader" map="D"/>
  <field class="org.apache.commons.logging.LogFactory" name="diagnosticsStream" map="E"/>
  <field class="org.apache.commons.logging.LogFactory" name="class$org$apache$commons$logging$LogFactory" map="class$F$C$E$A$B"/>
  <method class="org.apache.commons.logging.LogFactory" name="java.util.Enumeration getResources(java.lang.ClassLoader, java.lang.String)" map="A"/>
  <method class="org.apache.commons.logging.LogFactory" name="java.lang.String objectId(java.lang.Object)" map="A"/>
  <method class="org.apache.commons.logging.LogFactory" name="void logDiagnostic(java.lang.String)" map="A"/>
  <method class="org.apache.commons.logging.LogFactory" name="void setAttribute(java.lang.String, java.lang.Object)" map="A"/>
  <method class="org.apache.commons.logging.LogFactory" name="org.apache.commons.logging.Log getLog(java.lang.Class)" map="A"/>
  <method class="org.apache.commons.logging.LogFactory" name="java.util.Properties getProperties(java.net.URL)" map="A"/>
  <method class="org.apache.commons.logging.LogFactory" name="org.apache.commons.logging.LogFactory getFactory()" map="A"/>
  <method class="org.apache.commons.logging.LogFactory" name="java.lang.String trim(java.lang.String)" map="B"/>
  <method class="org.apache.commons.logging.LogFactory" name="java.io.InputStream getResourceAsStream(java.lang.ClassLoader, java.lang.String)" map="B"/>
  <method class="org.apache.commons.logging.LogFactory" name="java.util.Hashtable createFactoryStore()" map="B"/>
  <method class="org.apache.commons.logging.LogFactory" name="java.lang.ClassLoader getContextClassLoaderInternal()" map="C"/>
  <method class="org.apache.commons.logging.LogFactory" name="void access$000(java.lang.String)" map="access$000"/>
  <method class="org.apache.commons.logging.LogFactory" name="java.util.Properties getConfigurationFile(java.lang.ClassLoader, java.lang.String)" map="C"/>
  <method class="org.apache.commons.logging.LogFactory" name="void logClassLoaderEnvironment(java.lang.Class)" map="B"/>
  <method class="org.apache.commons.logging.LogFactory" name="boolean implementsLogFactory(java.lang.Class)" map="C"/>
  <method class="org.apache.commons.logging.LogFactory" name="void cacheFactory(java.lang.ClassLoader, org.apache.commons.logging.LogFactory)" map="A"/>
  <method class="org.apache.commons.logging.LogFactory" name="org.apache.commons.logging.LogFactory getCachedFactory(java.lang.ClassLoader)" map="A"/>
  <method class="org.apache.commons.logging.LogFactory" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.apache.commons.logging.LogFactory" name="void handleThrowable(java.lang.Throwable)" map="A"/>
  <method class="org.apache.commons.logging.LogFactory" name="java.lang.ClassLoader getClassLoader(java.lang.Class)" map="D"/>
  <method class="org.apache.commons.logging.LogFactory" name="boolean isDiagnosticsEnabled()" map="D"/>
  <method class="org.apache.commons.logging.LogFactory" name="java.lang.Object createFactory(java.lang.String, java.lang.ClassLoader)" map="A"/>
  <method class="org.apache.commons.logging.LogFactory" name="void logHierarchy(java.lang.String, java.lang.ClassLoader)" map="B"/>
  <method class="org.apache.commons.logging.LogFactory" name="java.lang.String getSystemProperty(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.commons.logging.LogFactory" name="org.apache.commons.logging.LogFactory newFactory(java.lang.String, java.lang.ClassLoader, java.lang.ClassLoader)" map="A"/>
  <method class="org.apache.commons.logging.LogFactory" name="java.lang.ClassLoader directGetContextClassLoader()" map="E"/>
  <method class="org.apache.commons.logging.LogFactory" name="java.io.PrintStream initDiagnostics()" map="F"/>
  <method class="org.apache.commons.logging.LogFactory" name="org.apache.commons.logging.Log getInstance(java.lang.Class)" map="E"/>
  <class name="org.apache.commons.logging.LogConfigurationException" map="C"/>
  <field class="org.apache.commons.logging.LogConfigurationException" name="cause" map="A"/>
  <method class="org.apache.commons.logging.LogConfigurationException" name="java.lang.Throwable getCause()" map="getCause"/>
  <package name="org.apache.commons.imaging" map="B"/>
  <package name="org.apache.commons.imaging.formats" map="A"/>
  <package name="org.apache.commons.imaging.formats.dcx" map="A"/>
  <class name="org.apache.commons.imaging.formats.dcx.DcxImageParser$DcxHeader" map="_A"/>
  <field class="org.apache.commons.imaging.formats.dcx.DcxImageParser$DcxHeader" name="pageTable" map="A"/>
  <field class="org.apache.commons.imaging.formats.dcx.DcxImageParser$DcxHeader" name="id" map="B"/>
  <class name="org.apache.commons.imaging.formats.dcx.DcxImageParser" map="A"/>
  <field class="org.apache.commons.imaging.formats.dcx.DcxImageParser" name="ACCEPTED_EXTENSIONS" map="&#x00c7;"/>
  <method class="org.apache.commons.imaging.formats.dcx.DcxImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.formats.dcx.DcxImageParser" name="org.apache.commons.imaging.formats.dcx.DcxImageParser$DcxHeader readDcxHeader(org.apache.commons.imaging.common.bytesource.ByteSource)" map="A"/>
  <method class="org.apache.commons.imaging.formats.dcx.DcxImageParser" name="java.util.List getAllBufferedImages(org.apache.commons.imaging.common.bytesource.ByteSource)" map="B"/>
  <method class="org.apache.commons.imaging.formats.dcx.DcxImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.dcx.DcxImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.dcx.DcxImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.formats.dcx.DcxImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.formats.dcx.DcxImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <method class="org.apache.commons.imaging.formats.dcx.DcxImageParser" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="B"/>
  <package name="org.apache.commons.imaging.formats.jpeg" map="B"/>
  <package name="org.apache.commons.imaging.formats.jpeg.segments" map="A"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.AppnSegment" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.AppnSegment" name="java.lang.String getDescription()" map="C"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.Segment" map="B"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.Segment" name="marker" map="C"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.Segment" name="length" map="D"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.Segment" name="java.lang.String getDescription()" map="C"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.Segment" name="java.lang.String getSegmentType()" map="D"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.Segment" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.ComSegment" map="C"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.ComSegment" name="comment" map="E"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.ComSegment" name="java.lang.String getDescription()" map="C"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.DqtSegment$QuantizationTable" map="_A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.DqtSegment$QuantizationTable" name="precision" map="A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.DqtSegment$QuantizationTable" name="destinationIdentifier" map="B"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.DqtSegment$QuantizationTable" name="elements" map="C"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.DqtSegment" map="D"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.DqtSegment" name="quantizationTables" map="F"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.DqtSegment" name="java.lang.String getDescription()" map="C"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.App14Segment" map="E"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.App14Segment" name="adobePrefix" map="N"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.App14Segment" name="int getAdobeColorTransform()" map="E"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.App14Segment" name="boolean isAdobeJpegSegment()" map="F"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.UnknownSegment" map="F"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.UnknownSegment" name="java.lang.String getDescription()" map="C"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.App13Segment" map="G"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.App13Segment" name="parser" map="O"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.App13Segment" name="boolean isPhotoshopJpegSegment()" map="G"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.App13Segment" name="org.apache.commons.imaging.formats.jpeg.iptc.PhotoshopApp13Data parsePhotoshopSegment(java.util.Map)" map="A"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.DhtSegment$HuffmanTable" map="_A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.DhtSegment$HuffmanTable" name="destinationIdentifier" map="A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.DhtSegment$HuffmanTable" name="huffVal" map="B"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.DhtSegment$HuffmanTable" name="minCode" map="C"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.DhtSegment$HuffmanTable" name="valPtr" map="D"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.DhtSegment$HuffmanTable" name="huffSize" map="E"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.DhtSegment$HuffmanTable" name="tableClass" map="F"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.DhtSegment$HuffmanTable" name="huffCode" map="G"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.DhtSegment$HuffmanTable" name="bits" map="H"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.DhtSegment$HuffmanTable" name="maxCode" map="I"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.DhtSegment" map="H"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.DhtSegment" name="huffmanTables" map="G"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.DhtSegment" name="java.lang.String getDescription()" map="C"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.SofnSegment$Component" map="_A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SofnSegment$Component" name="horizontalSamplingFactor" map="A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SofnSegment$Component" name="verticalSamplingFactor" map="B"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SofnSegment$Component" name="componentIdentifier" map="C"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SofnSegment$Component" name="quantTabDestSelector" map="D"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.SofnSegment" map="I"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SofnSegment" name="height" map="H"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SofnSegment" name="precision" map="I"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SofnSegment" name="width" map="J"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SofnSegment" name="components" map="K"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SofnSegment" name="numberOfComponents" map="L"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.SofnSegment" name="java.lang.String getDescription()" map="C"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.GenericSegment" map="J"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.GenericSegment" name="bytes" map="M"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.App2Segment" map="K"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.App2Segment" name="icc_bytes" map="P"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.App2Segment" name="num_markers" map="Q"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.App2Segment" name="cur_marker" map="R"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.App2Segment" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.App2Segment" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.App2Segment" name="int compareTo(org.apache.commons.imaging.formats.jpeg.segments.App2Segment)" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.App2Segment" name="int compareTo(java.lang.Object)" map="compareTo"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.JfifSegment" map="L"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.JfifSegment" name="thumbnailSize" map="&#x043b;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.JfifSegment" name="jfifMinorVersion" map="&#x043c;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.JfifSegment" name="densityUnits" map="&#x043d;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.JfifSegment" name="jfifMajorVersion" map="&#x043e;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.JfifSegment" name="yDensity" map="&#x043f;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.JfifSegment" name="xDensity" map="&#x0440;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.JfifSegment" name="xThumbnail" map="&#x0441;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.JfifSegment" name="yThumbnail" map="&#x0442;"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.JfifSegment" name="java.lang.String getDescription()" map="C"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.SosSegment$Component" map="_A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SosSegment$Component" name="acCodingTableSelector" map="A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SosSegment$Component" name="dcCodingTableSelector" map="B"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SosSegment$Component" name="scanComponentSelector" map="C"/>
  <class name="org.apache.commons.imaging.formats.jpeg.segments.SosSegment" map="M"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SosSegment" name="endOfSpectralSelection" map="&#x0443;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SosSegment" name="successiveApproximationBitHigh" map="&#x0444;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SosSegment" name="successiveApproximationBitLow" map="&#x0445;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SosSegment" name="startOfSpectralSelection" map="&#x0446;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SosSegment" name="components" map="&#x0447;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.segments.SosSegment" name="numberOfComponents" map="&#x0448;"/>
  <method class="org.apache.commons.imaging.formats.jpeg.segments.SosSegment" name="java.lang.String getDescription()" map="C"/>
  <package name="org.apache.commons.imaging.formats.jpeg.iptc" map="B"/>
  <class name="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypeLookup" map="A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypeLookup" name="IPTC_TYPE_MAP" map="b"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypeLookup" name="org.apache.commons.imaging.formats.jpeg.iptc.IptcType getIptcType(int)" map="A"/>
  <class name="org.apache.commons.imaging.formats.jpeg.iptc.IptcType" map="B"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcType" name="int getType()" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcType" name="java.lang.String getName()" map="B"/>
  <class name="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes$1" map="1"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes$1" name="val$type" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes$1" name="int getType()" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes$1" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes$1" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" map="C"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="SPECIAL_INSTRUCTIONS" map="B"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="SOURCE" map="C"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="KEYWORDS" map="D"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="AUDIO_SAMPLING_RESOLUTION" map="E"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="CONTENT_LOCATION_NAME" map="F"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="WRITER_EDITOR" map="G"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="COUNTRY_PRIMARY_LOCATION_NAME" map="H"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="REFERENCE_SERVICE" map="I"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="IMAGE_TYPE" map="J"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="CATEGORY" map="K"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="EXPIRATION_TIME" map="L"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="BYLINE" map="M"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="TIME_CREATED" map="N"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="FIXTURE_IDENTIFIER" map="O"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="name" map="P"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="HEADLINE" map="Q"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="OBJECT_NAME" map="R"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="EXPIRATION_DATE" map="S"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="AUDIO_TYPE" map="T"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="PROGRAM_VERSION" map="U"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="CAPTION_ABSTRACT" map="V"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="BYLINE_TITLE" map="W"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="EDIT_STATUS" map="X"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="OBJECT_DATA_PREVIEW_DATA" map="Y"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="SUBLOCATION" map="Z"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="ACTION_ADVISED" map="_"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="ORIGINAL_TRANSMISSION_REFERENCE" map="a"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="AUDIO_SAMPLING_RATE" map="b"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="OBJECT_ATTRIBUTE_REFERENCE" map="c"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="AUDIO_OUTCUE" map="d"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="OBJECT_CYCLE" map="e"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="RELEASE_TIME" map="f"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="REFERENCE_DATE" map="g"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="DIGITAL_CREATION_TIME" map="h"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="URGENCY" map="i"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="DATE_CREATED" map="j"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="RECORD_VERSION" map="k"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="RELEASE_DATE" map="l"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="EDITORIAL_UPDATE" map="m"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="$VALUES" map="n"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="DIGITAL_CREATION_DATE" map="o"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="OBJECT_DATA_PREVIEW_FILE_FORMAT" map="p"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="RASTERIZED_CAPTION" map="q"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="OBJECT_TYPE_REFERENCE" map="r"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="SUBJECT_REFERENCE" map="s"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="REFERENCE_NUMBER" map="t"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="CITY" map="u"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="OBJECT_DATA_PREVIEW_FILE_FORMAT_VERSION" map="v"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="CONTACT" map="w"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="COPYRIGHT_NOTICE" map="x"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="SUPPLEMENTAL_CATEGORY" map="y"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="IMAGE_ORIENTATION" map="z"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="CREDIT" map="&#x00a2;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="AUDIO_DURATION" map="&#x00a3;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="LANGUAGE_IDENTIFIER" map="&#x00a4;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="PROVINCE_STATE" map="&#x00a5;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="CONTENT_LOCATION_CODE" map="&#x00aa;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="ORIGINATING_PROGRAM" map="&#x00b5;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="COUNTRY_PRIMARY_LOCATION_CODE" map="&#x00ba;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="type" map="&#x00c0;"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="int getType()" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="org.apache.commons.imaging.formats.jpeg.iptc.IptcType getUnknown(int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes[] values()" map="values"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes valueOf(java.lang.String)" map="valueOf"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcTypes" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.commons.imaging.formats.jpeg.iptc.IptcConstants" map="D"/>
  <class name="org.apache.commons.imaging.formats.jpeg.iptc.PhotoshopApp13Data" map="E"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.PhotoshopApp13Data" name="records" map="c"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.PhotoshopApp13Data" name="rawBlocks" map="d"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.PhotoshopApp13Data" name="java.util.List getRecords()" map="H"/>
  <class name="org.apache.commons.imaging.formats.jpeg.iptc.IptcParser" map="F"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcParser" name="APP13_BYTE_ORDER" map="e"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcParser" name="java.util.List parseAllBlocks(byte[], boolean, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcParser" name="java.util.List parseIPTCBlock(byte[], boolean)" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcParser" name="org.apache.commons.imaging.formats.jpeg.iptc.PhotoshopApp13Data parsePhotoshopSegment(byte[], boolean, boolean)" map="B"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcParser" name="org.apache.commons.imaging.formats.jpeg.iptc.PhotoshopApp13Data parsePhotoshopSegment(byte[], java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcParser" name="boolean isPhotoshopJpegSegment(byte[])" map="D"/>
  <class name="org.apache.commons.imaging.formats.jpeg.iptc.IptcRecord$1" map="1"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcRecord$1" name="int compare(org.apache.commons.imaging.formats.jpeg.iptc.IptcRecord, org.apache.commons.imaging.formats.jpeg.iptc.IptcRecord)" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcRecord$1" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="org.apache.commons.imaging.formats.jpeg.iptc.IptcRecord" map="G"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcRecord" name="bytes" map="A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcRecord" name="iptcType" map="B"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcRecord" name="COMPARATOR" map="C"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcRecord" name="value" map="D"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcRecord" name="java.lang.String getValue()" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcRecord" name="java.lang.String getIptcTypeName()" map="B"/>
  <class name="org.apache.commons.imaging.formats.jpeg.iptc.IptcBlock" map="H"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcBlock" name="blockType" map="A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcBlock" name="blockData" map="B"/>
  <field class="org.apache.commons.imaging.formats.jpeg.iptc.IptcBlock" name="blockNameBytes" map="C"/>
  <method class="org.apache.commons.imaging.formats.jpeg.iptc.IptcBlock" name="boolean isIPTCBlock()" map="A"/>
  <package name="org.apache.commons.imaging.formats.jpeg.decoder" map="C"/>
  <class name="org.apache.commons.imaging.formats.jpeg.decoder.JpegInputStream" map="A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.JpegInputStream" name="b" map="A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.JpegInputStream" name="cnt" map="B"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.JpegInputStream" name="is" map="C"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.JpegInputStream" name="int nextBit()" map="A"/>
  <class name="org.apache.commons.imaging.formats.jpeg.decoder.YCbCrConverter" map="B"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.YCbCrConverter" name="greens2" map="A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.YCbCrConverter" name="greens1" map="B"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.YCbCrConverter" name="blues" map="C"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.YCbCrConverter" name="reds" map="D"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.YCbCrConverter" name="int fastRound(float)" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.YCbCrConverter" name="int convertYCbCrToRGB(int, int, int)" map="A"/>
  <class name="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" map="C"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="blockInt" map="&#x042f;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="sofnSegment" map="&#x0430;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="huffmanDCTables" map="&#x0431;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="scaledQuantizationTables" map="&#x0432;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="zz" map="&#x0433;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="quantizationTables" map="&#x0434;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="image" map="&#x0435;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="block" map="&#x0436;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="ioException" map="&#x0437;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="huffmanACTables" map="&#x0438;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="imageReadException" map="&#x0439;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="sosSegment" map="&#x043a;"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="int extend(int, int)" map="D"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="org.apache.commons.imaging.formats.jpeg.Block[] allocateMCUMemory()" map="f"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="int receive(int, org.apache.commons.imaging.formats.jpeg.decoder.JpegInputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="boolean visitSegment(int, byte[], int, byte[], byte[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="void visitSOS(int, byte[], byte[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="int decode(org.apache.commons.imaging.formats.jpeg.decoder.JpegInputStream, org.apache.commons.imaging.formats.jpeg.segments.DhtSegment$HuffmanTable)" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="java.awt.image.BufferedImage decode(org.apache.commons.imaging.common.bytesource.ByteSource)" map="Q"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="boolean beginSOS()" map="e"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="void readMCU(org.apache.commons.imaging.formats.jpeg.decoder.JpegInputStream, int[], org.apache.commons.imaging.formats.jpeg.Block[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="int fastRound(float)" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.JpegDecoder" name="void rescaleMCU(org.apache.commons.imaging.formats.jpeg.Block[], int, int, org.apache.commons.imaging.formats.jpeg.Block[])" map="A"/>
  <class name="org.apache.commons.imaging.formats.jpeg.decoder.Dct" map="D"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.Dct" name="A5" map="A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.Dct" name="A4" map="B"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.Dct" name="A3" map="C"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.Dct" name="A2" map="D"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.Dct" name="A1" map="E"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.Dct" name="C6" map="F"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.Dct" name="R" map="G"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.Dct" name="C4" map="H"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.Dct" name="Q" map="I"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.Dct" name="C2" map="J"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.Dct" name="idctScalingFactors" map="K"/>
  <field class="org.apache.commons.imaging.formats.jpeg.decoder.Dct" name="dctScalingFactors" map="L"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.Dct" name="void scaleDequantizationMatrix(float[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.decoder.Dct" name="void inverseDCT8x8(float[])" map="B"/>
  <class name="org.apache.commons.imaging.formats.jpeg.JpegPhotoshopMetadata" map="A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegPhotoshopMetadata" name="photoshopApp13Data" map="&#x0428;"/>
  <class name="org.apache.commons.imaging.formats.jpeg.Block" map="B"/>
  <field class="org.apache.commons.imaging.formats.jpeg.Block" name="height" map="A"/>
  <field class="org.apache.commons.imaging.formats.jpeg.Block" name="samples" map="B"/>
  <field class="org.apache.commons.imaging.formats.jpeg.Block" name="width" map="C"/>
  <class name="org.apache.commons.imaging.formats.jpeg.JpegImageMetadata" map="C"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegImageMetadata" name="newline" map="f"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegImageMetadata" name="exif" map="g"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegImageMetadata" name="photoshop" map="h"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageMetadata" name="java.lang.String toString(java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageMetadata" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageMetadata" name="org.apache.commons.imaging.formats.tiff.TiffField findEXIFValue(org.apache.commons.imaging.formats.tiff.taginfos.TagInfo)" map="A"/>
  <class name="org.apache.commons.imaging.formats.jpeg.ZigZag" map="D"/>
  <field class="org.apache.commons.imaging.formats.jpeg.ZigZag" name="zigZag" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.ZigZag" name="void zigZagToBlock(int[], int[])" map="A"/>
  <class name="org.apache.commons.imaging.formats.jpeg.JpegImageParser$1" map="1"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegImageParser$1" name="this$0" map="&#x0429;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegImageParser$1" name="val$parser" map="&#x042a;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegImageParser$1" name="val$result" map="&#x042b;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegImageParser$1" name="val$returnAfterFirst" map="&#x042c;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegImageParser$1" name="val$sofnSegments" map="&#x042d;"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegImageParser$1" name="val$markers" map="&#x042e;"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser$1" name="boolean beginSOS()" map="e"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser$1" name="void visitSOS(int, byte[], byte[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser$1" name="boolean visitSegment(int, byte[], int, byte[], byte[])" map="A"/>
  <class name="org.apache.commons.imaging.formats.jpeg.JpegImageParser" map="E"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="ACCEPTED_EXTENSIONS" map="&#x00c8;"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="boolean access$000(org.apache.commons.imaging.formats.jpeg.JpegImageParser, int, int[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="boolean keepMarker(int, int[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="java.util.List filterAPP1Segments(java.util.List)" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="org.apache.commons.imaging.formats.jpeg.JpegPhotoshopMetadata getPhotoshopMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="D"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="boolean isExifAPP1Segment(org.apache.commons.imaging.formats.jpeg.segments.GenericSegment)" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="byte[] getExifRawData(org.apache.commons.imaging.common.bytesource.ByteSource)" map="C"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="org.apache.commons.imaging.formats.tiff.TiffImageMetadata getExifMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="E"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="java.util.List readSegments(org.apache.commons.imaging.common.bytesource.ByteSource, int[], boolean, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegImageParser" name="java.util.List readSegments(org.apache.commons.imaging.common.bytesource.ByteSource, int[], boolean)" map="A"/>
  <class name="org.apache.commons.imaging.formats.jpeg.JpegConstants" map="F"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegConstants" name="EXIF_IDENTIFIER_CODE" map="S"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegConstants" name="JFIF0_SIGNATURE" map="T"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegConstants" name="XMP_IDENTIFIER" map="U"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegConstants" name="CONST_8BIM" map="V"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegConstants" name="PHOTOSHOP_IDENTIFICATION_STRING" map="W"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegConstants" name="EOI" map="X"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegConstants" name="SOI" map="Y"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegConstants" name="JFIF0_SIGNATURE_ALTERNATIVE" map="Z"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegConstants" name="icc_profile_label" map="_"/>
  <field class="org.apache.commons.imaging.formats.jpeg.JpegConstants" name="MARKERS" map="a"/>
  <class name="org.apache.commons.imaging.formats.jpeg.JpegUtils$Visitor" map="_A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegUtils$Visitor" name="boolean beginSOS()" map="e"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegUtils$Visitor" name="void visitSOS(int, byte[], byte[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegUtils$Visitor" name="boolean visitSegment(int, byte[], int, byte[], byte[])" map="A"/>
  <class name="org.apache.commons.imaging.formats.jpeg.JpegUtils" map="G"/>
  <method class="org.apache.commons.imaging.formats.jpeg.JpegUtils" name="void traverseJFIF(org.apache.commons.imaging.common.bytesource.ByteSource, org.apache.commons.imaging.formats.jpeg.JpegUtils$Visitor)" map="A"/>
  <package name="org.apache.commons.imaging.formats.rgbe" map="C"/>
  <class name="org.apache.commons.imaging.formats.rgbe.RgbeConstants" map="A"/>
  <field class="org.apache.commons.imaging.formats.rgbe.RgbeConstants" name="HEADER" map="A"/>
  <class name="org.apache.commons.imaging.formats.rgbe.RgbeInfo" map="B"/>
  <field class="org.apache.commons.imaging.formats.rgbe.RgbeInfo" name="height" map="G"/>
  <field class="org.apache.commons.imaging.formats.rgbe.RgbeInfo" name="in" map="H"/>
  <field class="org.apache.commons.imaging.formats.rgbe.RgbeInfo" name="RESOLUTION_STRING" map="I"/>
  <field class="org.apache.commons.imaging.formats.rgbe.RgbeInfo" name="metadata" map="J"/>
  <field class="org.apache.commons.imaging.formats.rgbe.RgbeInfo" name="width" map="K"/>
  <field class="org.apache.commons.imaging.formats.rgbe.RgbeInfo" name="TWO_TWO" map="L"/>
  <method class="org.apache.commons.imaging.formats.rgbe.RgbeInfo" name="void readMetadata()" map="F"/>
  <method class="org.apache.commons.imaging.formats.rgbe.RgbeInfo" name="void close()" map="G"/>
  <method class="org.apache.commons.imaging.formats.rgbe.RgbeInfo" name="int getWidth()" map="H"/>
  <method class="org.apache.commons.imaging.formats.rgbe.RgbeInfo" name="org.apache.commons.imaging.common.IImageMetadata getMetadata()" map="I"/>
  <method class="org.apache.commons.imaging.formats.rgbe.RgbeInfo" name="float[][] getPixelData()" map="J"/>
  <method class="org.apache.commons.imaging.formats.rgbe.RgbeInfo" name="void readDimensions()" map="K"/>
  <method class="org.apache.commons.imaging.formats.rgbe.RgbeInfo" name="void decompress(java.io.InputStream, byte[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.rgbe.RgbeInfo" name="int getHeight()" map="L"/>
  <class name="org.apache.commons.imaging.formats.rgbe.RgbeImageParser" map="C"/>
  <method class="org.apache.commons.imaging.formats.rgbe.RgbeImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.rgbe.RgbeImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.formats.rgbe.RgbeImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.formats.rgbe.RgbeImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.rgbe.RgbeImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.formats.rgbe.RgbeImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <class name="org.apache.commons.imaging.formats.rgbe.InfoHeaderReader" map="D"/>
  <field class="org.apache.commons.imaging.formats.rgbe.InfoHeaderReader" name="is" map="A"/>
  <method class="org.apache.commons.imaging.formats.rgbe.InfoHeaderReader" name="char read()" map="A"/>
  <method class="org.apache.commons.imaging.formats.rgbe.InfoHeaderReader" name="java.lang.String readNextLine()" map="B"/>
  <package name="org.apache.commons.imaging.formats.xbm" map="D"/>
  <class name="org.apache.commons.imaging.formats.xbm.XbmImageParser$XbmParseResult" map="_A"/>
  <field class="org.apache.commons.imaging.formats.xbm.XbmImageParser$XbmParseResult" name="cParser" map="A"/>
  <field class="org.apache.commons.imaging.formats.xbm.XbmImageParser$XbmParseResult" name="xbmHeader" map="B"/>
  <class name="org.apache.commons.imaging.formats.xbm.XbmImageParser$1" map="1"/>
  <class name="org.apache.commons.imaging.formats.xbm.XbmImageParser$XbmHeader" map="_B"/>
  <field class="org.apache.commons.imaging.formats.xbm.XbmImageParser$XbmHeader" name="height" map="A"/>
  <field class="org.apache.commons.imaging.formats.xbm.XbmImageParser$XbmHeader" name="yHot" map="B"/>
  <field class="org.apache.commons.imaging.formats.xbm.XbmImageParser$XbmHeader" name="width" map="C"/>
  <field class="org.apache.commons.imaging.formats.xbm.XbmImageParser$XbmHeader" name="xHot" map="D"/>
  <class name="org.apache.commons.imaging.formats.xbm.XbmImageParser" map="A"/>
  <field class="org.apache.commons.imaging.formats.xbm.XbmImageParser" name="ACCEPTED_EXTENSIONS" map="&#x00c9;"/>
  <method class="org.apache.commons.imaging.formats.xbm.XbmImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.formats.xbm.XbmImageParser" name="org.apache.commons.imaging.formats.xbm.XbmImageParser$XbmHeader readXbmHeader(org.apache.commons.imaging.common.bytesource.ByteSource)" map="D"/>
  <method class="org.apache.commons.imaging.formats.xbm.XbmImageParser" name="org.apache.commons.imaging.formats.xbm.XbmImageParser$XbmParseResult parseXbmHeader(org.apache.commons.imaging.common.bytesource.ByteSource)" map="E"/>
  <method class="org.apache.commons.imaging.formats.xbm.XbmImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.xbm.XbmImageParser" name="java.lang.String toPrettyHex(int)" map="B"/>
  <method class="org.apache.commons.imaging.formats.xbm.XbmImageParser" name="java.lang.String randomName()" map="P"/>
  <method class="org.apache.commons.imaging.formats.xbm.XbmImageParser" name="java.awt.image.BufferedImage readXbmImage(org.apache.commons.imaging.formats.xbm.XbmImageParser$XbmHeader, org.apache.commons.imaging.common.BasicCParser)" map="A"/>
  <method class="org.apache.commons.imaging.formats.xbm.XbmImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.xbm.XbmImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.formats.xbm.XbmImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.formats.xbm.XbmImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <method class="org.apache.commons.imaging.formats.xbm.XbmImageParser" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="B"/>
  <package name="org.apache.commons.imaging.formats.pnm" map="E"/>
  <class name="org.apache.commons.imaging.formats.pnm.PpmWriter" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PpmWriter" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="C"/>
  <class name="org.apache.commons.imaging.formats.pnm.PnmImageParser" map="B"/>
  <field class="org.apache.commons.imaging.formats.pnm.PnmImageParser" name="ACCEPTED_EXTENSIONS" map="&#x00cb;"/>
  <method class="org.apache.commons.imaging.formats.pnm.PnmImageParser" name="org.apache.commons.imaging.formats.pnm.FileInfo readHeader(java.io.InputStream)" map="B"/>
  <method class="org.apache.commons.imaging.formats.pnm.PnmImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.formats.pnm.PnmImageParser" name="org.apache.commons.imaging.formats.pnm.FileInfo readHeader(org.apache.commons.imaging.common.bytesource.ByteSource)" map="F"/>
  <method class="org.apache.commons.imaging.formats.pnm.PnmImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PnmImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.pnm.PnmImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.formats.pnm.PnmImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.formats.pnm.PnmImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <method class="org.apache.commons.imaging.formats.pnm.PnmImageParser" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="B"/>
  <class name="org.apache.commons.imaging.formats.pnm.FileInfo" map="C"/>
  <field class="org.apache.commons.imaging.formats.pnm.FileInfo" name="height" map="A"/>
  <field class="org.apache.commons.imaging.formats.pnm.FileInfo" name="width" map="B"/>
  <field class="org.apache.commons.imaging.formats.pnm.FileInfo" name="RAWBITS" map="C"/>
  <method class="org.apache.commons.imaging.formats.pnm.FileInfo" name="int getColorType()" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.FileInfo" name="void newline()" map="B"/>
  <method class="org.apache.commons.imaging.formats.pnm.FileInfo" name="int readSample(java.io.InputStream, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.FileInfo" name="java.lang.String getMIMEType()" map="C"/>
  <method class="org.apache.commons.imaging.formats.pnm.FileInfo" name="int getNumComponents()" map="D"/>
  <method class="org.apache.commons.imaging.formats.pnm.FileInfo" name="int getRGB(java.io.InputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.FileInfo" name="int getBitDepth()" map="E"/>
  <method class="org.apache.commons.imaging.formats.pnm.FileInfo" name="java.lang.String getImageTypeDescription()" map="F"/>
  <method class="org.apache.commons.imaging.formats.pnm.FileInfo" name="int scaleSample(int, float, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.FileInfo" name="void readImage(org.apache.commons.imaging.common.ImageBuilder, java.io.InputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.FileInfo" name="int getRGB(org.apache.commons.imaging.formats.pnm.WhiteSpaceReader)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.FileInfo" name="org.apache.commons.imaging.ImageFormat getImageType()" map="G"/>
  <method class="org.apache.commons.imaging.formats.pnm.FileInfo" name="boolean hasAlpha()" map="H"/>
  <class name="org.apache.commons.imaging.formats.pnm.WhiteSpaceReader" map="D"/>
  <field class="org.apache.commons.imaging.formats.pnm.WhiteSpaceReader" name="is" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.WhiteSpaceReader" name="char read()" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.WhiteSpaceReader" name="char nextChar()" map="B"/>
  <method class="org.apache.commons.imaging.formats.pnm.WhiteSpaceReader" name="java.lang.String readLine()" map="C"/>
  <method class="org.apache.commons.imaging.formats.pnm.WhiteSpaceReader" name="java.lang.String readtoWhiteSpace()" map="D"/>
  <class name="org.apache.commons.imaging.formats.pnm.PpmFileInfo" map="E"/>
  <field class="org.apache.commons.imaging.formats.pnm.PpmFileInfo" name="max" map="D"/>
  <field class="org.apache.commons.imaging.formats.pnm.PpmFileInfo" name="bytesPerSample" map="E"/>
  <field class="org.apache.commons.imaging.formats.pnm.PpmFileInfo" name="scale" map="F"/>
  <method class="org.apache.commons.imaging.formats.pnm.PpmFileInfo" name="int getColorType()" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PpmFileInfo" name="java.lang.String getMIMEType()" map="C"/>
  <method class="org.apache.commons.imaging.formats.pnm.PpmFileInfo" name="int getNumComponents()" map="D"/>
  <method class="org.apache.commons.imaging.formats.pnm.PpmFileInfo" name="int getRGB(java.io.InputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PpmFileInfo" name="int getBitDepth()" map="E"/>
  <method class="org.apache.commons.imaging.formats.pnm.PpmFileInfo" name="java.lang.String getImageTypeDescription()" map="F"/>
  <method class="org.apache.commons.imaging.formats.pnm.PpmFileInfo" name="int getRGB(org.apache.commons.imaging.formats.pnm.WhiteSpaceReader)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PpmFileInfo" name="org.apache.commons.imaging.ImageFormat getImageType()" map="G"/>
  <method class="org.apache.commons.imaging.formats.pnm.PpmFileInfo" name="boolean hasAlpha()" map="H"/>
  <class name="org.apache.commons.imaging.formats.pnm.PamFileInfo$TupleReader" map="_A"/>
  <field class="org.apache.commons.imaging.formats.pnm.PamFileInfo$TupleReader" name="this$0" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo$TupleReader" name="int getColorType()" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo$TupleReader" name="int getRGB(java.io.InputStream)" map="A"/>
  <class name="org.apache.commons.imaging.formats.pnm.PamFileInfo$GrayscaleTupleReader" map="_B"/>
  <field class="org.apache.commons.imaging.formats.pnm.PamFileInfo$GrayscaleTupleReader" name="this$0" map="A"/>
  <field class="org.apache.commons.imaging.formats.pnm.PamFileInfo$GrayscaleTupleReader" name="colorType" map="B"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo$GrayscaleTupleReader" name="int getColorType()" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo$GrayscaleTupleReader" name="int getRGB(java.io.InputStream)" map="A"/>
  <class name="org.apache.commons.imaging.formats.pnm.PamFileInfo$1" map="1"/>
  <class name="org.apache.commons.imaging.formats.pnm.PamFileInfo$ColorTupleReader" map="_C"/>
  <field class="org.apache.commons.imaging.formats.pnm.PamFileInfo$ColorTupleReader" name="this$0" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo$ColorTupleReader" name="int getColorType()" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo$ColorTupleReader" name="int getRGB(java.io.InputStream)" map="A"/>
  <class name="org.apache.commons.imaging.formats.pnm.PamFileInfo" map="F"/>
  <field class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="maxval" map="G"/>
  <field class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="hasAlpha" map="H"/>
  <field class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="bytesPerSample" map="I"/>
  <field class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="scale" map="J"/>
  <field class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="depth" map="K"/>
  <field class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="tupleReader" map="L"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="int getColorType()" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="java.lang.String getMIMEType()" map="C"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="int getNumComponents()" map="D"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="int access$400(org.apache.commons.imaging.formats.pnm.PamFileInfo)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="boolean access$500(org.apache.commons.imaging.formats.pnm.PamFileInfo)" map="B"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="int getRGB(java.io.InputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="int getBitDepth()" map="E"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="java.lang.String getImageTypeDescription()" map="F"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="float access$300(org.apache.commons.imaging.formats.pnm.PamFileInfo)" map="C"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="int access$200(org.apache.commons.imaging.formats.pnm.PamFileInfo)" map="D"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="int getRGB(org.apache.commons.imaging.formats.pnm.WhiteSpaceReader)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="org.apache.commons.imaging.ImageFormat getImageType()" map="G"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamFileInfo" name="boolean hasAlpha()" map="H"/>
  <class name="org.apache.commons.imaging.formats.pnm.PnmWriter" map="G"/>
  <field class="org.apache.commons.imaging.formats.pnm.PnmWriter" name="RAWBITS" map="&#x00ca;"/>
  <method class="org.apache.commons.imaging.formats.pnm.PnmWriter" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="C"/>
  <class name="org.apache.commons.imaging.formats.pnm.PbmWriter" map="H"/>
  <method class="org.apache.commons.imaging.formats.pnm.PbmWriter" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="C"/>
  <class name="org.apache.commons.imaging.formats.pnm.PgmWriter" map="I"/>
  <method class="org.apache.commons.imaging.formats.pnm.PgmWriter" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="C"/>
  <class name="org.apache.commons.imaging.formats.pnm.PamWriter" map="J"/>
  <method class="org.apache.commons.imaging.formats.pnm.PamWriter" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="C"/>
  <class name="org.apache.commons.imaging.formats.pnm.PgmFileInfo" map="K"/>
  <field class="org.apache.commons.imaging.formats.pnm.PgmFileInfo" name="max" map="M"/>
  <field class="org.apache.commons.imaging.formats.pnm.PgmFileInfo" name="bytesPerSample" map="N"/>
  <field class="org.apache.commons.imaging.formats.pnm.PgmFileInfo" name="scale" map="O"/>
  <method class="org.apache.commons.imaging.formats.pnm.PgmFileInfo" name="int getColorType()" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PgmFileInfo" name="java.lang.String getMIMEType()" map="C"/>
  <method class="org.apache.commons.imaging.formats.pnm.PgmFileInfo" name="int getNumComponents()" map="D"/>
  <method class="org.apache.commons.imaging.formats.pnm.PgmFileInfo" name="int getRGB(java.io.InputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PgmFileInfo" name="int getBitDepth()" map="E"/>
  <method class="org.apache.commons.imaging.formats.pnm.PgmFileInfo" name="java.lang.String getImageTypeDescription()" map="F"/>
  <method class="org.apache.commons.imaging.formats.pnm.PgmFileInfo" name="int getRGB(org.apache.commons.imaging.formats.pnm.WhiteSpaceReader)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PgmFileInfo" name="org.apache.commons.imaging.ImageFormat getImageType()" map="G"/>
  <method class="org.apache.commons.imaging.formats.pnm.PgmFileInfo" name="boolean hasAlpha()" map="H"/>
  <class name="org.apache.commons.imaging.formats.pnm.PbmFileInfo" map="L"/>
  <field class="org.apache.commons.imaging.formats.pnm.PbmFileInfo" name="bits_in_cache" map="P"/>
  <field class="org.apache.commons.imaging.formats.pnm.PbmFileInfo" name="bitcache" map="Q"/>
  <method class="org.apache.commons.imaging.formats.pnm.PbmFileInfo" name="int getColorType()" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PbmFileInfo" name="void newline()" map="B"/>
  <method class="org.apache.commons.imaging.formats.pnm.PbmFileInfo" name="java.lang.String getMIMEType()" map="C"/>
  <method class="org.apache.commons.imaging.formats.pnm.PbmFileInfo" name="int getNumComponents()" map="D"/>
  <method class="org.apache.commons.imaging.formats.pnm.PbmFileInfo" name="int getRGB(java.io.InputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PbmFileInfo" name="int getBitDepth()" map="E"/>
  <method class="org.apache.commons.imaging.formats.pnm.PbmFileInfo" name="java.lang.String getImageTypeDescription()" map="F"/>
  <method class="org.apache.commons.imaging.formats.pnm.PbmFileInfo" name="int getRGB(org.apache.commons.imaging.formats.pnm.WhiteSpaceReader)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pnm.PbmFileInfo" name="org.apache.commons.imaging.ImageFormat getImageType()" map="G"/>
  <method class="org.apache.commons.imaging.formats.pnm.PbmFileInfo" name="boolean hasAlpha()" map="H"/>
  <class name="org.apache.commons.imaging.formats.pnm.PnmConstants" map="M"/>
  <package name="org.apache.commons.imaging.formats.xpm" map="F"/>
  <class name="org.apache.commons.imaging.formats.xpm.XpmImageParser$PaletteEntry" map="_A"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$PaletteEntry" name="colorArgb" map="A"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$PaletteEntry" name="haveGray4Level" map="B"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$PaletteEntry" name="monoArgb" map="C"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$PaletteEntry" name="grayArgb" map="D"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$PaletteEntry" name="haveMono" map="E"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$PaletteEntry" name="gray4LevelArgb" map="F"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$PaletteEntry" name="index" map="G"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$PaletteEntry" name="haveGray" map="H"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$PaletteEntry" name="haveColor" map="I"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser$PaletteEntry" name="int getBestARGB()" map="A"/>
  <class name="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmHeader" map="_B"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmHeader" name="height" map="A"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmHeader" name="palette" map="B"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmHeader" name="numColors" map="C"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmHeader" name="width" map="D"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmHeader" name="xpmExt" map="E"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmHeader" name="numCharsPerPixel" map="F"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmHeader" name="yHotSpot" map="G"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmHeader" name="xHotSpot" map="H"/>
  <class name="org.apache.commons.imaging.formats.xpm.XpmImageParser$1" map="1"/>
  <class name="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmParseResult" map="_C"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmParseResult" name="cParser" map="A"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmParseResult" name="xpmHeader" map="B"/>
  <class name="org.apache.commons.imaging.formats.xpm.XpmImageParser" map="A"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="writePalette" map="&#x00cc;"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="ACCEPTED_EXTENSIONS" map="&#x00cd;"/>
  <field class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="colorNames" map="&#x00ce;"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmParseResult parseXpmHeader(org.apache.commons.imaging.common.bytesource.ByteSource)" map="G"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmHeader parseXpmHeader(org.apache.commons.imaging.common.BasicCParser)" map="A"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmHeader parseXpmValuesSection(java.lang.String)" map="D"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="java.lang.String pixelsForIndex(int, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="void populatePaletteEntry(org.apache.commons.imaging.formats.xpm.XpmImageParser$PaletteEntry, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="boolean parseNextString(org.apache.commons.imaging.common.BasicCParser, java.lang.StringBuilder)" map="A"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmHeader readXpmHeader(org.apache.commons.imaging.common.bytesource.ByteSource)" map="H"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="java.lang.String toColor(int)" map="C"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="int parseColor(java.lang.String)" map="E"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="void parsePaletteEntries(org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmHeader, org.apache.commons.imaging.common.BasicCParser)" map="A"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="java.awt.image.BufferedImage readXpmImage(org.apache.commons.imaging.formats.xpm.XpmImageParser$XpmHeader, org.apache.commons.imaging.common.BasicCParser)" map="B"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="boolean loadColorNames()" map="Q"/>
  <method class="org.apache.commons.imaging.formats.xpm.XpmImageParser" name="java.lang.String randomName()" map="R"/>
  <package name="org.apache.commons.imaging.formats.gif" map="G"/>
  <class name="org.apache.commons.imaging.formats.gif.ImageDescriptor" map="A"/>
  <field class="org.apache.commons.imaging.formats.gif.ImageDescriptor" name="imageData" map="H"/>
  <field class="org.apache.commons.imaging.formats.gif.ImageDescriptor" name="sizeOfLocalColorTable" map="I"/>
  <field class="org.apache.commons.imaging.formats.gif.ImageDescriptor" name="localColorTable" map="J"/>
  <field class="org.apache.commons.imaging.formats.gif.ImageDescriptor" name="interlaceFlag" map="K"/>
  <field class="org.apache.commons.imaging.formats.gif.ImageDescriptor" name="imageTopPosition" map="L"/>
  <field class="org.apache.commons.imaging.formats.gif.ImageDescriptor" name="localColorTableFlag" map="M"/>
  <field class="org.apache.commons.imaging.formats.gif.ImageDescriptor" name="sortFlag" map="N"/>
  <field class="org.apache.commons.imaging.formats.gif.ImageDescriptor" name="packedFields" map="O"/>
  <field class="org.apache.commons.imaging.formats.gif.ImageDescriptor" name="imageHeight" map="P"/>
  <field class="org.apache.commons.imaging.formats.gif.ImageDescriptor" name="imageWidth" map="Q"/>
  <field class="org.apache.commons.imaging.formats.gif.ImageDescriptor" name="imageLeftPosition" map="R"/>
  <class name="org.apache.commons.imaging.formats.gif.GraphicControlExtension" map="B"/>
  <field class="org.apache.commons.imaging.formats.gif.GraphicControlExtension" name="transparency" map="B"/>
  <field class="org.apache.commons.imaging.formats.gif.GraphicControlExtension" name="packed" map="C"/>
  <field class="org.apache.commons.imaging.formats.gif.GraphicControlExtension" name="delay" map="D"/>
  <field class="org.apache.commons.imaging.formats.gif.GraphicControlExtension" name="dispose" map="E"/>
  <field class="org.apache.commons.imaging.formats.gif.GraphicControlExtension" name="transparentColorIndex" map="F"/>
  <class name="org.apache.commons.imaging.formats.gif.GenericGifBlock" map="C"/>
  <field class="org.apache.commons.imaging.formats.gif.GenericGifBlock" name="subblocks" map="G"/>
  <method class="org.apache.commons.imaging.formats.gif.GenericGifBlock" name="byte[] appendSubBlocks()" map="A"/>
  <method class="org.apache.commons.imaging.formats.gif.GenericGifBlock" name="byte[] appendSubBlocks(boolean)" map="A"/>
  <class name="org.apache.commons.imaging.formats.gif.GifImageParser" map="D"/>
  <field class="org.apache.commons.imaging.formats.gif.GifImageParser" name="XMP_APPLICATION_ID_AND_AUTH_CODE" map="&#x00cf;"/>
  <field class="org.apache.commons.imaging.formats.gif.GifImageParser" name="GIF_HEADER_SIGNATURE" map="&#x00d0;"/>
  <field class="org.apache.commons.imaging.formats.gif.GifImageParser" name="ACCEPTED_EXTENSIONS" map="&#x00d1;"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="org.apache.commons.imaging.formats.gif.GifHeaderInfo readHeader(java.io.InputStream, org.apache.commons.imaging.FormatCompliance)" map="A"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="java.util.List readBlocks(org.apache.commons.imaging.formats.gif.GifHeaderInfo, java.io.InputStream, boolean, org.apache.commons.imaging.FormatCompliance)" map="A"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="java.util.List getComments(java.util.List)" map="B"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="org.apache.commons.imaging.formats.gif.ImageDescriptor readImageDescriptor(org.apache.commons.imaging.formats.gif.GifHeaderInfo, int, java.io.InputStream, boolean, org.apache.commons.imaging.FormatCompliance)" map="A"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="org.apache.commons.imaging.formats.gif.ImageContents readFile(org.apache.commons.imaging.common.bytesource.ByteSource, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="byte[] readColorTable(java.io.InputStream, int, org.apache.commons.imaging.FormatCompliance)" map="A"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="int simple_pow(int, int)" map="B"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="void writeAsSubBlocks(java.io.OutputStream, byte[])" map="B"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="org.apache.commons.imaging.formats.gif.GenericGifBlock readGenericGIFBlock(java.io.InputStream, int, byte[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="int convertColorTableSize(int)" map="D"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="org.apache.commons.imaging.formats.gif.GraphicControlExtension readGraphicControlExtension(int, java.io.InputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="byte[] readSubBlock(java.io.InputStream)" map="C"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="org.apache.commons.imaging.formats.gif.GenericGifBlock readGenericGIFBlock(java.io.InputStream, int)" map="C"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="org.apache.commons.imaging.formats.gif.ImageContents readFile(org.apache.commons.imaging.common.bytesource.ByteSource, boolean, org.apache.commons.imaging.FormatCompliance)" map="A"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="int[] getColorTable(byte[])" map="E"/>
  <method class="org.apache.commons.imaging.formats.gif.GifImageParser" name="org.apache.commons.imaging.formats.gif.GifBlock findBlock(java.util.List, int)" map="A"/>
  <class name="org.apache.commons.imaging.formats.gif.GifHeaderInfo" map="E"/>
  <field class="org.apache.commons.imaging.formats.gif.GifHeaderInfo" name="sizeOfGlobalColorTable" map="A"/>
  <field class="org.apache.commons.imaging.formats.gif.GifHeaderInfo" name="backgroundColorIndex" map="B"/>
  <field class="org.apache.commons.imaging.formats.gif.GifHeaderInfo" name="version1" map="C"/>
  <field class="org.apache.commons.imaging.formats.gif.GifHeaderInfo" name="logicalScreenHeight" map="D"/>
  <field class="org.apache.commons.imaging.formats.gif.GifHeaderInfo" name="pixelAspectRatio" map="E"/>
  <field class="org.apache.commons.imaging.formats.gif.GifHeaderInfo" name="logicalScreenWidth" map="F"/>
  <field class="org.apache.commons.imaging.formats.gif.GifHeaderInfo" name="sortFlag" map="G"/>
  <field class="org.apache.commons.imaging.formats.gif.GifHeaderInfo" name="packedFields" map="H"/>
  <field class="org.apache.commons.imaging.formats.gif.GifHeaderInfo" name="identifier3" map="I"/>
  <field class="org.apache.commons.imaging.formats.gif.GifHeaderInfo" name="globalColorTableFlag" map="J"/>
  <field class="org.apache.commons.imaging.formats.gif.GifHeaderInfo" name="identifier2" map="K"/>
  <field class="org.apache.commons.imaging.formats.gif.GifHeaderInfo" name="identifier1" map="L"/>
  <field class="org.apache.commons.imaging.formats.gif.GifHeaderInfo" name="colorResolution" map="M"/>
  <field class="org.apache.commons.imaging.formats.gif.GifHeaderInfo" name="version3" map="N"/>
  <field class="org.apache.commons.imaging.formats.gif.GifHeaderInfo" name="version2" map="O"/>
  <class name="org.apache.commons.imaging.formats.gif.ImageContents" map="F"/>
  <field class="org.apache.commons.imaging.formats.gif.ImageContents" name="gifHeaderInfo" map="A"/>
  <field class="org.apache.commons.imaging.formats.gif.ImageContents" name="globalColorTable" map="B"/>
  <field class="org.apache.commons.imaging.formats.gif.ImageContents" name="blocks" map="C"/>
  <class name="org.apache.commons.imaging.formats.gif.GifBlock" map="G"/>
  <field class="org.apache.commons.imaging.formats.gif.GifBlock" name="blockCode" map="A"/>
  <package name="org.apache.commons.imaging.formats.wbmp" map="H"/>
  <class name="org.apache.commons.imaging.formats.wbmp.WbmpImageParser$WbmpHeader" map="_A"/>
  <field class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser$WbmpHeader" name="height" map="A"/>
  <field class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser$WbmpHeader" name="width" map="B"/>
  <field class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser$WbmpHeader" name="fixHeaderField" map="C"/>
  <field class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser$WbmpHeader" name="typeField" map="D"/>
  <class name="org.apache.commons.imaging.formats.wbmp.WbmpImageParser" map="A"/>
  <field class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser" name="ACCEPTED_EXTENSIONS" map="&#x00d2;"/>
  <method class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser" name="org.apache.commons.imaging.formats.wbmp.WbmpImageParser$WbmpHeader readWbmpHeader(org.apache.commons.imaging.common.bytesource.ByteSource)" map="I"/>
  <method class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser" name="void writeMultiByteInteger(java.io.OutputStream, int)" map="B"/>
  <method class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser" name="java.awt.image.BufferedImage readImage(org.apache.commons.imaging.formats.wbmp.WbmpImageParser$WbmpHeader, java.io.InputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser" name="int readMultiByteInteger(java.io.InputStream)" map="D"/>
  <method class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser" name="org.apache.commons.imaging.formats.wbmp.WbmpImageParser$WbmpHeader readWbmpHeader(java.io.InputStream)" map="E"/>
  <method class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <method class="org.apache.commons.imaging.formats.wbmp.WbmpImageParser" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="B"/>
  <package name="org.apache.commons.imaging.formats.bmp" map="I"/>
  <package name="org.apache.commons.imaging.formats.bmp.pixelparsers" map="A"/>
  <class name="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserRle" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserRle" name="int getSamplesPerByte()" map="C"/>
  <method class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserRle" name="int[] convertDataToSamples(int)" map="C"/>
  <method class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserRle" name="void processImage(org.apache.commons.imaging.common.ImageBuilder)" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserRle" name="int processByteOfData(int[], int, int, int, int, int, org.apache.commons.imaging.common.ImageBuilder)" map="A"/>
  <class name="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParser" map="B"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParser" name="colorTable" map="A"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParser" name="is" map="B"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParser" name="bhi" map="C"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParser" name="imageData" map="D"/>
  <method class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParser" name="int getColorTableRGB(int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParser" name="void processImage(org.apache.commons.imaging.common.ImageBuilder)" map="A"/>
  <class name="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserSimple" map="C"/>
  <method class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserSimple" name="void processImage(org.apache.commons.imaging.common.ImageBuilder)" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserSimple" name="void newline()" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserSimple" name="int getNextRGB()" map="B"/>
  <class name="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserRgb" map="D"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserRgb" name="pixelCount" map="E"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserRgb" name="bytecount" map="F"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserRgb" name="cached_byte" map="G"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserRgb" name="cached_bit_count" map="H"/>
  <method class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserRgb" name="void newline()" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserRgb" name="int getNextRGB()" map="B"/>
  <class name="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserBitFields" map="E"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserBitFields" name="alphaMask" map="I"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserBitFields" name="bytecount" map="J"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserBitFields" name="blueShift" map="K"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserBitFields" name="blueMask" map="L"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserBitFields" name="redMask" map="M"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserBitFields" name="greenMask" map="N"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserBitFields" name="alphaShift" map="O"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserBitFields" name="greenShift" map="P"/>
  <field class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserBitFields" name="redShift" map="Q"/>
  <method class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserBitFields" name="int getMaskShift(int)" map="B"/>
  <method class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserBitFields" name="void newline()" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.pixelparsers.PixelParserBitFields" name="int getNextRGB()" map="B"/>
  <package name="org.apache.commons.imaging.formats.bmp.writers" map="B"/>
  <class name="org.apache.commons.imaging.formats.bmp.writers.BmpWriterRgb" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.writers.BmpWriterRgb" name="int getPaletteSize()" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.writers.BmpWriterRgb" name="byte[] getImageData(java.awt.image.BufferedImage)" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.writers.BmpWriterRgb" name="int getBitsPerPixel()" map="B"/>
  <method class="org.apache.commons.imaging.formats.bmp.writers.BmpWriterRgb" name="void writePalette(org.apache.commons.imaging.common.BinaryOutputStream)" map="A"/>
  <class name="org.apache.commons.imaging.formats.bmp.writers.BmpWriter" map="B"/>
  <method class="org.apache.commons.imaging.formats.bmp.writers.BmpWriter" name="int getPaletteSize()" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.writers.BmpWriter" name="byte[] getImageData(java.awt.image.BufferedImage)" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.writers.BmpWriter" name="int getBitsPerPixel()" map="B"/>
  <method class="org.apache.commons.imaging.formats.bmp.writers.BmpWriter" name="void writePalette(org.apache.commons.imaging.common.BinaryOutputStream)" map="A"/>
  <class name="org.apache.commons.imaging.formats.bmp.writers.BmpWriterPalette" map="C"/>
  <field class="org.apache.commons.imaging.formats.bmp.writers.BmpWriterPalette" name="palette" map="A"/>
  <field class="org.apache.commons.imaging.formats.bmp.writers.BmpWriterPalette" name="bitsPerSample" map="B"/>
  <method class="org.apache.commons.imaging.formats.bmp.writers.BmpWriterPalette" name="int getPaletteSize()" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.writers.BmpWriterPalette" name="byte[] getImageData(java.awt.image.BufferedImage)" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.writers.BmpWriterPalette" name="int getBitsPerPixel()" map="B"/>
  <method class="org.apache.commons.imaging.formats.bmp.writers.BmpWriterPalette" name="void writePalette(org.apache.commons.imaging.common.BinaryOutputStream)" map="A"/>
  <class name="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo$ColorSpaceCoordinate" map="_A"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo$ColorSpaceCoordinate" name="x" map="A"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo$ColorSpaceCoordinate" name="z" map="B"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo$ColorSpaceCoordinate" name="y" map="C"/>
  <class name="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo$ColorSpace" map="_B"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo$ColorSpace" name="blue" map="A"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo$ColorSpace" name="green" map="B"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo$ColorSpace" name="red" map="C"/>
  <class name="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" map="A"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="profileSize" map="A"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="colorsUsed" map="B"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="bitmapDataOffset" map="C"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="greenMask" map="D"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="redMask" map="E"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="vResolution" map="F"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="colorsImportant" map="G"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="bitmapDataSize" map="H"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="bitmapHeaderSize" map="I"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="gammaRed" map="J"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="reserved" map="K"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="profileData" map="L"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="reservedV5" map="M"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="alphaMask" map="N"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="fileSize" map="O"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="height" map="P"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="hResolution" map="Q"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="planes" map="R"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="width" map="S"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="blueMask" map="T"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="identifier2" map="U"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="identifier1" map="V"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="gammaGreen" map="W"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="bitsPerPixel" map="X"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="colorSpace" map="Y"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="colorSpaceType" map="Z"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="intent" map="_"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="gammaBlue" map="a"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo" name="compression" map="b"/>
  <class name="org.apache.commons.imaging.formats.bmp.BmpImageParser" map="B"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpImageParser" name="BMP_HEADER_SIGNATURE" map="&#x00d3;"/>
  <field class="org.apache.commons.imaging.formats.bmp.BmpImageParser" name="ACCEPTED_EXTENSIONS" map="&#x00d4;"/>
  <method class="org.apache.commons.imaging.formats.bmp.BmpImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.formats.bmp.BmpImageParser" name="java.awt.image.BufferedImage getBufferedImage(java.io.InputStream, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.BmpImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.BmpImageParser" name="java.lang.String getBmpTypeDescription(int, int)" map="C"/>
  <method class="org.apache.commons.imaging.formats.bmp.BmpImageParser" name="byte[] getRLEBytes(java.io.InputStream, int)" map="D"/>
  <method class="org.apache.commons.imaging.formats.bmp.BmpImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.bmp.BmpImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.formats.bmp.BmpImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.formats.bmp.BmpImageParser" name="org.apache.commons.imaging.formats.bmp.BmpHeaderInfo readBmpHeaderInfo(java.io.InputStream, org.apache.commons.imaging.FormatCompliance, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.formats.bmp.BmpImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <method class="org.apache.commons.imaging.formats.bmp.BmpImageParser" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.bmp.BmpImageParser" name="org.apache.commons.imaging.formats.bmp.ImageContents readImageContents(java.io.InputStream, org.apache.commons.imaging.FormatCompliance, boolean)" map="B"/>
  <class name="org.apache.commons.imaging.formats.bmp.ImageContents" map="C"/>
  <field class="org.apache.commons.imaging.formats.bmp.ImageContents" name="colorTable" map="A"/>
  <field class="org.apache.commons.imaging.formats.bmp.ImageContents" name="pixelParser" map="B"/>
  <field class="org.apache.commons.imaging.formats.bmp.ImageContents" name="bhi" map="C"/>
  <field class="org.apache.commons.imaging.formats.bmp.ImageContents" name="imageData" map="D"/>
  <package name="org.apache.commons.imaging.formats.ico" map="J"/>
  <class name="org.apache.commons.imaging.formats.ico.IcoImageParser$IconData" map="_A"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$IconData" name="iconInfo" map="A"/>
  <method class="org.apache.commons.imaging.formats.ico.IcoImageParser$IconData" name="java.awt.image.BufferedImage readBufferedImage()" map="A"/>
  <class name="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapHeader" map="_B"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapHeader" name="BitCount" map="A"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapHeader" name="Height" map="B"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapHeader" name="YPelsPerMeter" map="C"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapHeader" name="Size" map="D"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapHeader" name="SizeImage" map="E"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapHeader" name="Compression" map="F"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapHeader" name="ColorsUsed" map="G"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapHeader" name="Planes" map="H"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapHeader" name="ColorsImportant" map="I"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapHeader" name="XPelsPerMeter" map="J"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapHeader" name="Width" map="K"/>
  <class name="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapIconData" map="_C"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapIconData" name="bufferedImage" map="B"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapIconData" name="header" map="C"/>
  <method class="org.apache.commons.imaging.formats.ico.IcoImageParser$BitmapIconData" name="java.awt.image.BufferedImage readBufferedImage()" map="A"/>
  <class name="org.apache.commons.imaging.formats.ico.IcoImageParser$IconInfo" map="_D"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$IconInfo" name="Width" map="A"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$IconInfo" name="Reserved" map="B"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$IconInfo" name="ImageOffset" map="C"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$IconInfo" name="Planes" map="D"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$IconInfo" name="BitCount" map="E"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$IconInfo" name="ImageSize" map="F"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$IconInfo" name="ColorCount" map="G"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$IconInfo" name="Height" map="H"/>
  <class name="org.apache.commons.imaging.formats.ico.IcoImageParser$FileHeader" map="_E"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$FileHeader" name="reserved" map="A"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$FileHeader" name="iconType" map="B"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$FileHeader" name="iconCount" map="C"/>
  <class name="org.apache.commons.imaging.formats.ico.IcoImageParser$ImageContents" map="_F"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$ImageContents" name="fileHeader" map="A"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$ImageContents" name="iconDatas" map="B"/>
  <class name="org.apache.commons.imaging.formats.ico.IcoImageParser$PNGIconData" map="_G"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser$PNGIconData" name="bufferedImage" map="D"/>
  <method class="org.apache.commons.imaging.formats.ico.IcoImageParser$PNGIconData" name="java.awt.image.BufferedImage readBufferedImage()" map="A"/>
  <class name="org.apache.commons.imaging.formats.ico.IcoImageParser" map="A"/>
  <field class="org.apache.commons.imaging.formats.ico.IcoImageParser" name="ACCEPTED_EXTENSIONS" map="&#x00d5;"/>
  <method class="org.apache.commons.imaging.formats.ico.IcoImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.formats.ico.IcoImageParser" name="org.apache.commons.imaging.formats.ico.IcoImageParser$IconData readBitmapIconData(byte[], org.apache.commons.imaging.formats.ico.IcoImageParser$IconInfo)" map="A"/>
  <method class="org.apache.commons.imaging.formats.ico.IcoImageParser" name="org.apache.commons.imaging.formats.ico.IcoImageParser$FileHeader readFileHeader(java.io.InputStream)" map="F"/>
  <method class="org.apache.commons.imaging.formats.ico.IcoImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.ico.IcoImageParser" name="org.apache.commons.imaging.formats.ico.IcoImageParser$IconData readIconData(byte[], org.apache.commons.imaging.formats.ico.IcoImageParser$IconInfo)" map="B"/>
  <method class="org.apache.commons.imaging.formats.ico.IcoImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.ico.IcoImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.formats.ico.IcoImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.formats.ico.IcoImageParser" name="org.apache.commons.imaging.formats.ico.IcoImageParser$ImageContents readImage(org.apache.commons.imaging.common.bytesource.ByteSource)" map="J"/>
  <method class="org.apache.commons.imaging.formats.ico.IcoImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <method class="org.apache.commons.imaging.formats.ico.IcoImageParser" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.ico.IcoImageParser" name="org.apache.commons.imaging.formats.ico.IcoImageParser$IconInfo readIconInfo(java.io.InputStream)" map="G"/>
  <package name="org.apache.commons.imaging.formats.png" map="K"/>
  <package name="org.apache.commons.imaging.formats.png.scanlinefilters" map="A"/>
  <class name="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilterUp" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilterUp" name="void unfilter(byte[], byte[], byte[])" map="A"/>
  <class name="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilterPaeth" map="B"/>
  <field class="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilterPaeth" name="BytesPerPixel" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilterPaeth" name="void unfilter(byte[], byte[], byte[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilterPaeth" name="int PaethPredictor(int, int, int)" map="A"/>
  <class name="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilter" map="C"/>
  <method class="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilter" name="void unfilter(byte[], byte[], byte[])" map="A"/>
  <class name="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilterAverage" map="D"/>
  <field class="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilterAverage" name="BytesPerPixel" map="B"/>
  <method class="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilterAverage" name="void unfilter(byte[], byte[], byte[])" map="A"/>
  <class name="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilterSub" map="E"/>
  <field class="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilterSub" name="BytesPerPixel" map="C"/>
  <method class="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilterSub" name="void unfilter(byte[], byte[], byte[])" map="A"/>
  <class name="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilterNone" map="F"/>
  <method class="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilterNone" name="void unfilter(byte[], byte[], byte[])" map="A"/>
  <package name="org.apache.commons.imaging.formats.png.transparencyfilters" map="B"/>
  <class name="org.apache.commons.imaging.formats.png.transparencyfilters.TransparencyFilterIndexedColor" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.transparencyfilters.TransparencyFilterIndexedColor" name="int filter(int, int)" map="E"/>
  <class name="org.apache.commons.imaging.formats.png.transparencyfilters.TransparencyFilter" map="B"/>
  <field class="org.apache.commons.imaging.formats.png.transparencyfilters.TransparencyFilter" name="bytes" map="&#x0449;"/>
  <method class="org.apache.commons.imaging.formats.png.transparencyfilters.TransparencyFilter" name="int filter(int, int)" map="E"/>
  <class name="org.apache.commons.imaging.formats.png.transparencyfilters.TransparencyFilterTrueColor" map="C"/>
  <field class="org.apache.commons.imaging.formats.png.transparencyfilters.TransparencyFilterTrueColor" name="transparent_green" map="&#x044a;"/>
  <field class="org.apache.commons.imaging.formats.png.transparencyfilters.TransparencyFilterTrueColor" name="transparent_red" map="&#x044b;"/>
  <field class="org.apache.commons.imaging.formats.png.transparencyfilters.TransparencyFilterTrueColor" name="transparent_color" map="&#x044c;"/>
  <field class="org.apache.commons.imaging.formats.png.transparencyfilters.TransparencyFilterTrueColor" name="transparent_blue" map="&#x044d;"/>
  <method class="org.apache.commons.imaging.formats.png.transparencyfilters.TransparencyFilterTrueColor" name="int filter(int, int)" map="E"/>
  <class name="org.apache.commons.imaging.formats.png.transparencyfilters.TransparencyFilterGrayscale" map="D"/>
  <field class="org.apache.commons.imaging.formats.png.transparencyfilters.TransparencyFilterGrayscale" name="transparent_color" map="&#x044e;"/>
  <method class="org.apache.commons.imaging.formats.png.transparencyfilters.TransparencyFilterGrayscale" name="int filter(int, int)" map="E"/>
  <package name="org.apache.commons.imaging.formats.png.chunks" map="C"/>
  <class name="org.apache.commons.imaging.formats.png.chunks.PngChunkItxt" map="A"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkItxt" name="languageTag" map="&#x0466;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkItxt" name="keyword" map="&#x0467;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkItxt" name="text" map="&#x0468;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkItxt" name="translatedKeyword" map="&#x0469;"/>
  <method class="org.apache.commons.imaging.formats.png.chunks.PngChunkItxt" name="java.lang.String getKeyword()" map="h"/>
  <method class="org.apache.commons.imaging.formats.png.chunks.PngChunkItxt" name="java.lang.String getText()" map="i"/>
  <method class="org.apache.commons.imaging.formats.png.chunks.PngChunkItxt" name="org.apache.commons.imaging.formats.png.PngText getContents()" map="j"/>
  <class name="org.apache.commons.imaging.formats.png.chunks.PngChunkGama" map="B"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkGama" name="Gamma" map="&#x0459;"/>
  <method class="org.apache.commons.imaging.formats.png.chunks.PngChunkGama" name="double getGamma()" map="g"/>
  <class name="org.apache.commons.imaging.formats.png.chunks.PngChunkPhys" map="C"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkPhys" name="PixelsPerUnitYAxis" map="&#x045a;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkPhys" name="PixelsPerUnitXAxis" map="&#x045b;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkPhys" name="UnitSpecifier" map="&#x045c;"/>
  <class name="org.apache.commons.imaging.formats.png.chunks.PngChunk" map="D"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunk" name="length" map="&#x044f;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunk" name="reserved" map="&#x0451;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunk" name="safeToCopy" map="&#x0452;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunk" name="propertyBits" map="&#x0453;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunk" name="crc" map="&#x0454;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunk" name="isPrivate" map="&#x0455;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunk" name="ancillary" map="&#x0456;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunk" name="bytes" map="&#x0457;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunk" name="chunkType" map="&#x0458;"/>
  <class name="org.apache.commons.imaging.formats.png.chunks.PngChunkIhdr" map="E"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkIhdr" name="height" map="&#x045e;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkIhdr" name="colorType" map="&#x045f;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkIhdr" name="filterMethod" map="&#x0460;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkIhdr" name="width" map="&#x0461;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkIhdr" name="interlaceMethod" map="&#x0462;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkIhdr" name="compressionMethod" map="&#x0463;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkIhdr" name="bitDepth" map="&#x0464;"/>
  <class name="org.apache.commons.imaging.formats.png.chunks.PngChunkPlte" map="F"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkPlte" name="rgb" map="&#x0465;"/>
  <method class="org.apache.commons.imaging.formats.png.chunks.PngChunkPlte" name="int getRGB(int)" map="M"/>
  <method class="org.apache.commons.imaging.formats.png.chunks.PngChunkPlte" name="void correct(org.apache.commons.imaging.formats.png.GammaCorrection)" map="A"/>
  <class name="org.apache.commons.imaging.formats.png.chunks.PngChunkIdat" map="G"/>
  <class name="org.apache.commons.imaging.formats.png.chunks.PngChunkZtxt" map="H"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkZtxt" name="keyword" map="&#x046a;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkZtxt" name="text" map="&#x046b;"/>
  <method class="org.apache.commons.imaging.formats.png.chunks.PngChunkZtxt" name="java.lang.String getKeyword()" map="h"/>
  <method class="org.apache.commons.imaging.formats.png.chunks.PngChunkZtxt" name="java.lang.String getText()" map="i"/>
  <method class="org.apache.commons.imaging.formats.png.chunks.PngChunkZtxt" name="org.apache.commons.imaging.formats.png.PngText getContents()" map="k"/>
  <class name="org.apache.commons.imaging.formats.png.chunks.PngTextChunk" map="I"/>
  <method class="org.apache.commons.imaging.formats.png.chunks.PngTextChunk" name="java.lang.String getKeyword()" map="h"/>
  <method class="org.apache.commons.imaging.formats.png.chunks.PngTextChunk" name="java.lang.String getText()" map="i"/>
  <class name="org.apache.commons.imaging.formats.png.chunks.PngChunkIccp" map="J"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkIccp" name="CompressedProfile" map="&#x046e;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkIccp" name="CompressionMethod" map="&#x046f;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkIccp" name="ProfileName" map="&#x0470;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkIccp" name="UncompressedProfile" map="&#x0471;"/>
  <class name="org.apache.commons.imaging.formats.png.chunks.PngChunkText" map="K"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkText" name="keyword" map="&#x046c;"/>
  <field class="org.apache.commons.imaging.formats.png.chunks.PngChunkText" name="text" map="&#x046d;"/>
  <method class="org.apache.commons.imaging.formats.png.chunks.PngChunkText" name="java.lang.String getKeyword()" map="h"/>
  <method class="org.apache.commons.imaging.formats.png.chunks.PngChunkText" name="java.lang.String getText()" map="i"/>
  <method class="org.apache.commons.imaging.formats.png.chunks.PngChunkText" name="org.apache.commons.imaging.formats.png.PngText getContents()" map="l"/>
  <class name="org.apache.commons.imaging.formats.png.PngWriter$TransparentPalette" map="_A"/>
  <field class="org.apache.commons.imaging.formats.png.PngWriter$TransparentPalette" name="palette" map="E"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter$TransparentPalette" name="int getPaletteIndex(int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter$TransparentPalette" name="int getEntry(int)" map="B"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter$TransparentPalette" name="int length()" map="A"/>
  <class name="org.apache.commons.imaging.formats.png.PngWriter$ImageHeader" map="_B"/>
  <field class="org.apache.commons.imaging.formats.png.PngWriter$ImageHeader" name="height" map="A"/>
  <field class="org.apache.commons.imaging.formats.png.PngWriter$ImageHeader" name="colorType" map="B"/>
  <field class="org.apache.commons.imaging.formats.png.PngWriter$ImageHeader" name="filterMethod" map="C"/>
  <field class="org.apache.commons.imaging.formats.png.PngWriter$ImageHeader" name="bit_depth" map="D"/>
  <field class="org.apache.commons.imaging.formats.png.PngWriter$ImageHeader" name="width" map="E"/>
  <field class="org.apache.commons.imaging.formats.png.PngWriter$ImageHeader" name="interlaceMethod" map="F"/>
  <field class="org.apache.commons.imaging.formats.png.PngWriter$ImageHeader" name="compressionMethod" map="G"/>
  <class name="org.apache.commons.imaging.formats.png.PngWriter" map="A"/>
  <field class="org.apache.commons.imaging.formats.png.PngWriter" name="verbose" map="&#x00c6;"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter" name="void writeChunkIEND(java.io.OutputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter" name="void writeChunktEXt(java.io.OutputStream, org.apache.commons.imaging.formats.png.PngText$Text)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter" name="byte getColourType(boolean, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter" name="void writeChunkPLTE(java.io.OutputStream, org.apache.commons.imaging.palette.Palette)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter" name="void writeChunk(java.io.OutputStream, byte[], byte[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter" name="byte getBitDepth(byte, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter" name="void writeChunkIDAT(java.io.OutputStream, byte[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter" name="void writeChunkXmpiTXt(java.io.OutputStream, java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter" name="void writeChunkPHYS(java.io.OutputStream, int, int, byte)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter" name="void writeInt(java.io.OutputStream, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter" name="void writeChunkzTXt(java.io.OutputStream, org.apache.commons.imaging.formats.png.PngText$Ztxt)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter" name="void writeChunkIHDR(java.io.OutputStream, org.apache.commons.imaging.formats.png.PngWriter$ImageHeader)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter" name="void writeChunkTRNS(java.io.OutputStream, org.apache.commons.imaging.palette.Palette)" map="B"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngWriter" name="void writeChunkiTXt(java.io.OutputStream, org.apache.commons.imaging.formats.png.PngText$Itxt)" map="A"/>
  <class name="org.apache.commons.imaging.formats.png.PngImageInfo" map="B"/>
  <field class="org.apache.commons.imaging.formats.png.PngImageInfo" name="textChunks" map="S"/>
  <class name="org.apache.commons.imaging.formats.png.ScanExpediter" map="C"/>
  <field class="org.apache.commons.imaging.formats.png.ScanExpediter" name="width" map="&#x0472;"/>
  <field class="org.apache.commons.imaging.formats.png.ScanExpediter" name="bitDepth" map="&#x0473;"/>
  <field class="org.apache.commons.imaging.formats.png.ScanExpediter" name="transparencyFilter" map="&#x0474;"/>
  <field class="org.apache.commons.imaging.formats.png.ScanExpediter" name="bi" map="&#x0475;"/>
  <field class="org.apache.commons.imaging.formats.png.ScanExpediter" name="pngChunkPLTE" map="&#x0476;"/>
  <field class="org.apache.commons.imaging.formats.png.ScanExpediter" name="is" map="&#x0477;"/>
  <field class="org.apache.commons.imaging.formats.png.ScanExpediter" name="gammaCorrection" map="&#x0478;"/>
  <field class="org.apache.commons.imaging.formats.png.ScanExpediter" name="colorType" map="&#x0479;"/>
  <field class="org.apache.commons.imaging.formats.png.ScanExpediter" name="bytesPerPixel" map="&#x047a;"/>
  <field class="org.apache.commons.imaging.formats.png.ScanExpediter" name="bitsPerPixel" map="&#x047b;"/>
  <field class="org.apache.commons.imaging.formats.png.ScanExpediter" name="height" map="&#x047c;"/>
  <method class="org.apache.commons.imaging.formats.png.ScanExpediter" name="byte[] unfilterScanline(int, byte[], byte[], int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.ScanExpediter" name="org.apache.commons.imaging.formats.png.scanlinefilters.ScanlineFilter getScanlineFilter(int, int)" map="F"/>
  <method class="org.apache.commons.imaging.formats.png.ScanExpediter" name="void drive()" map="m"/>
  <method class="org.apache.commons.imaging.formats.png.ScanExpediter" name="int getPixelRGB(int, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.ScanExpediter" name="int getPixelARGB(int, int, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.ScanExpediter" name="byte[] getNextScanline(java.io.InputStream, int, byte[], int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.ScanExpediter" name="int getBitsToBytesRoundingUp(int)" map="N"/>
  <method class="org.apache.commons.imaging.formats.png.ScanExpediter" name="int getRGB(org.apache.commons.imaging.formats.png.BitParser, int)" map="A"/>
  <class name="org.apache.commons.imaging.formats.png.ScanExpediterSimple" map="D"/>
  <method class="org.apache.commons.imaging.formats.png.ScanExpediterSimple" name="void drive()" map="m"/>
  <class name="org.apache.commons.imaging.formats.png.PngText$Itxt" map="_A"/>
  <field class="org.apache.commons.imaging.formats.png.PngText$Itxt" name="languageTag" map="C"/>
  <field class="org.apache.commons.imaging.formats.png.PngText$Itxt" name="translatedKeyword" map="D"/>
  <class name="org.apache.commons.imaging.formats.png.PngText$Ztxt" map="_B"/>
  <class name="org.apache.commons.imaging.formats.png.PngText$Text" map="_C"/>
  <class name="org.apache.commons.imaging.formats.png.PngText" map="E"/>
  <field class="org.apache.commons.imaging.formats.png.PngText" name="keyword" map="A"/>
  <field class="org.apache.commons.imaging.formats.png.PngText" name="text" map="B"/>
  <class name="org.apache.commons.imaging.formats.png.ScanExpediterInterlaced" map="F"/>
  <field class="org.apache.commons.imaging.formats.png.ScanExpediterInterlaced" name="Col_Increment" map="&#x047d;"/>
  <field class="org.apache.commons.imaging.formats.png.ScanExpediterInterlaced" name="Starting_Row" map="&#x047e;"/>
  <field class="org.apache.commons.imaging.formats.png.ScanExpediterInterlaced" name="Row_Increment" map="&#x047f;"/>
  <field class="org.apache.commons.imaging.formats.png.ScanExpediterInterlaced" name="Starting_Col" map="&#x0480;"/>
  <method class="org.apache.commons.imaging.formats.png.ScanExpediterInterlaced" name="void drive()" map="m"/>
  <method class="org.apache.commons.imaging.formats.png.ScanExpediterInterlaced" name="void visit(int, int, java.awt.image.BufferedImage, org.apache.commons.imaging.formats.png.BitParser, int, int, org.apache.commons.imaging.formats.png.chunks.PngChunkPlte, org.apache.commons.imaging.formats.png.GammaCorrection)" map="A"/>
  <class name="org.apache.commons.imaging.formats.png.PngConstants" map="G"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="IEND_CHUNK_TYPE" map="r"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="PLTE" map="s"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="IHDR" map="t"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="gAMA" map="u"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="zTXt" map="v"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="IEND" map="w"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="TRNS_CHUNK_TYPE" map="x"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="PNG_Signature" map="y"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="sRGB" map="z"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="iTXt_CHUNK_TYPE" map="&#x00a2;"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="pHYs" map="&#x00a3;"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="tRNS" map="&#x00a4;"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="IDAT_CHUNK_TYPE" map="&#x00a5;"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="iTXt" map="&#x00aa;"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="IPHYS_CHUNK_TYPE" map="&#x00b5;"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="IHDR_CHUNK_TYPE" map="&#x00ba;"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="PLTE_CHUNK_TYPE" map="&#x00c0;"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="zTXt_CHUNK_TYPE" map="&#x00c1;"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="iCCP" map="&#x00c2;"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="IDAT" map="&#x00c3;"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="tEXt_CHUNK_TYPE" map="&#x00c4;"/>
  <field class="org.apache.commons.imaging.formats.png.PngConstants" name="tEXt" map="&#x00c5;"/>
  <class name="org.apache.commons.imaging.formats.png.PngCrc" map="H"/>
  <field class="org.apache.commons.imaging.formats.png.PngCrc" name="crc_table_computed" map="A"/>
  <field class="org.apache.commons.imaging.formats.png.PngCrc" name="crc_table" map="B"/>
  <method class="org.apache.commons.imaging.formats.png.PngCrc" name="long finish_partial_crc(long)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngCrc" name="void make_crc_table()" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngCrc" name="long start_partial_crc(byte[], int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngCrc" name="long continue_partial_crc(long, byte[], int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngCrc" name="long update_crc(long, byte[])" map="A"/>
  <class name="org.apache.commons.imaging.formats.png.BitParser" map="I"/>
  <field class="org.apache.commons.imaging.formats.png.BitParser" name="bytes" map="A"/>
  <field class="org.apache.commons.imaging.formats.png.BitParser" name="bitDepth" map="B"/>
  <field class="org.apache.commons.imaging.formats.png.BitParser" name="bitsPerPixel" map="C"/>
  <method class="org.apache.commons.imaging.formats.png.BitParser" name="int getSample(int, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.BitParser" name="int getSampleAsByte(int, int)" map="B"/>
  <class name="org.apache.commons.imaging.formats.png.PngImageParser" map="J"/>
  <field class="org.apache.commons.imaging.formats.png.PngImageParser" name="ACCEPTED_EXTENSIONS" map="&#x0412;"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="java.util.List readChunks(org.apache.commons.imaging.common.bytesource.ByteSource, int[], boolean)" map="B"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="org.apache.commons.imaging.formats.png.transparencyfilters.TransparencyFilter getTransparencyFilter(int, org.apache.commons.imaging.formats.png.chunks.PngChunk)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="boolean hasAlphaChannel(int)" map="J"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="boolean isGrayscale(int)" map="K"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="int samplesPerPixel(int)" map="L"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="java.util.List readChunks(java.io.InputStream, int[], boolean)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="java.util.List filterChunks(java.util.List, int)" map="B"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="boolean keepChunk(int, int[])" map="C"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.png.PngImageParser" name="void readSignature(java.io.InputStream)" map="M"/>
  <class name="org.apache.commons.imaging.formats.png.GammaCorrection" map="K"/>
  <field class="org.apache.commons.imaging.formats.png.GammaCorrection" name="lookupTable" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.GammaCorrection" name="int correctSample(int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.GammaCorrection" name="int correctSample(int, double, double)" map="A"/>
  <method class="org.apache.commons.imaging.formats.png.GammaCorrection" name="int correctARGB(int)" map="B"/>
  <package name="org.apache.commons.imaging.formats.tiff" map="L"/>
  <package name="org.apache.commons.imaging.formats.tiff.photometricinterpreters" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterLogLuv" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterLogLuv" name="void dumpstats()" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterLogLuv" name="void interpretPixel(org.apache.commons.imaging.common.ImageBuilder, int[], int, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterLogLuv" name="float cube(float)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterCieLab" map="B"/>
  <method class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterCieLab" name="void dumpstats()" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterCieLab" name="void interpretPixel(org.apache.commons.imaging.common.ImageBuilder, int[], int, int)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter" map="C"/>
  <field class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter" name="height" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter" name="predictor" map="B"/>
  <field class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter" name="bitsPerSample" map="C"/>
  <field class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter" name="width" map="D"/>
  <field class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter" name="samplesPerPixel" map="E"/>
  <method class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter" name="void dumpstats()" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter" name="void interpretPixel(org.apache.commons.imaging.common.ImageBuilder, int[], int, int)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterCmyk" map="D"/>
  <method class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterCmyk" name="void interpretPixel(org.apache.commons.imaging.common.ImageBuilder, int[], int, int)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterRgb" map="E"/>
  <method class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterRgb" name="void interpretPixel(org.apache.commons.imaging.common.ImageBuilder, int[], int, int)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterPalette" map="F"/>
  <field class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterPalette" name="indexColorMap" map="F"/>
  <method class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterPalette" name="void interpretPixel(org.apache.commons.imaging.common.ImageBuilder, int[], int, int)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterYCbCr" map="G"/>
  <method class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterYCbCr" name="void interpretPixel(org.apache.commons.imaging.common.ImageBuilder, int[], int, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterYCbCr" name="int limit(int, int, int)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterBiLevel" map="H"/>
  <field class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterBiLevel" name="invert" map="G"/>
  <method class="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreterBiLevel" name="void interpretPixel(org.apache.commons.imaging.common.ImageBuilder, int[], int, int)" map="A"/>
  <package name="org.apache.commons.imaging.formats.tiff.datareaders" map="B"/>
  <class name="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderTiled" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderTiled" name="compression" map="&#x03ce;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderTiled" name="byteOrder" map="&#x03d0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderTiled" name="bitsPerPixel" map="&#x03d1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderTiled" name="tileLength" map="&#x03d2;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderTiled" name="imageData" map="&#x03d3;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderTiled" name="tileWidth" map="&#x03d4;"/>
  <method class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderTiled" name="void readImageData(org.apache.commons.imaging.common.ImageBuilder)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderTiled" name="void interpretTile(org.apache.commons.imaging.common.ImageBuilder, byte[], int, int, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderTiled" name="java.awt.image.BufferedImage readImageData(java.awt.Rectangle)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.datareaders.DataReader" map="B"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReader" name="height" map="&#x03c6;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReader" name="predictor" map="&#x03c7;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReader" name="directory" map="&#x03c8;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReader" name="bitsPerSample" map="&#x03c9;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReader" name="width" map="&#x03ca;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReader" name="photometricInterpreter" map="&#x03cb;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReader" name="last" map="&#x03cc;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReader" name="samplesPerPixel" map="&#x03cd;"/>
  <method class="org.apache.commons.imaging.formats.tiff.datareaders.DataReader" name="void resetPredictor()" map="U"/>
  <method class="org.apache.commons.imaging.formats.tiff.datareaders.DataReader" name="void readImageData(org.apache.commons.imaging.common.ImageBuilder)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.datareaders.DataReader" name="byte[] decompress(byte[], int, int, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.datareaders.DataReader" name="java.awt.image.BufferedImage readImageData(java.awt.Rectangle)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.datareaders.DataReader" name="int[] applyPredictor(int[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.datareaders.DataReader" name="void getSamplesAsBytes(org.apache.commons.imaging.common.BitInputStream, int[])" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderStrips" map="C"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderStrips" name="x" map="&#x03d5;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderStrips" name="rowsPerStrip" map="&#x03d6;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderStrips" name="compression" map="&#x03da;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderStrips" name="byteOrder" map="&#x03dc;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderStrips" name="bitsPerPixel" map="&#x03de;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderStrips" name="y" map="&#x03e0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderStrips" name="imageData" map="&#x03e2;"/>
  <method class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderStrips" name="void interpretStrip(org.apache.commons.imaging.common.ImageBuilder, byte[], int, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderStrips" name="void readImageData(org.apache.commons.imaging.common.ImageBuilder)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.datareaders.DataReaderStrips" name="java.awt.image.BufferedImage readImageData(java.awt.Rectangle)" map="A"/>
  <package name="org.apache.commons.imaging.formats.tiff.constants" map="C"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.HylaFaxTagConstants" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.HylaFaxTagConstants" name="EXIF_TAG_FAX_RECV_PARAMS" map="&#x01e7;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.HylaFaxTagConstants" name="EXIF_TAG_FAX_RECV_TIME" map="&#x01e8;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.HylaFaxTagConstants" name="ALL_HYLAFAX_TAGS" map="&#x01e9;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.HylaFaxTagConstants" name="EXIF_TAG_FAX_SUB_ADDRESS" map="&#x01ea;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.HylaFaxTagConstants" name="EXIF_TAG_FAX_DCS" map="&#x01eb;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.WangTagConstants" map="B"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.WangTagConstants" name="EXIF_TAG_WANG_ANNOTATION" map="&#x03bf;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.WangTagConstants" name="ALL_WANG_TAGS" map="&#x03c0;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.AllTagConstants" map="C"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.AllTagConstants" name="ALL_TAGS" map="&#x03c1;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.OceScanjobTagConstants" map="D"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.OceScanjobTagConstants" name="ALL_OCE_SCANJOB_TAGS" map="&#x0280;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.OceScanjobTagConstants" name="EXIF_TAG_OCE_IMAGE_LOGIC_CHARACTERISTICS" map="&#x0281;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.OceScanjobTagConstants" name="EXIF_TAG_OCE_IDENTIFICATION_NUMBER" map="&#x0282;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.OceScanjobTagConstants" name="EXIF_TAG_OCE_APPLICATION_SELECTOR" map="&#x0283;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.OceScanjobTagConstants" name="EXIF_TAG_OCE_SCANJOB_DESCRIPTION" map="&#x0284;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.TagConstantsUtils" map="E"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TagConstantsUtils" name="tiffDirectoryTypes" map="q"/>
  <method class="org.apache.commons.imaging.formats.tiff.constants.TagConstantsUtils" name="org.apache.commons.imaging.common.BinaryConstant createMicrosoftHdPhotoGuidEndingWith(byte)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.constants.TagConstantsUtils" name="java.util.List mergeTagLists(java.util.List[])" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.AdobePageMaker6TagConstants" map="F"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.AdobePageMaker6TagConstants" name="TIFF_TAG_XCLIP_PATH_UNITS" map="&#x00da;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.AdobePageMaker6TagConstants" name="TIFF_TAG_INDEXED" map="&#x00db;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.AdobePageMaker6TagConstants" name="TIFF_TAG_OPIPROXY" map="&#x00dc;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.AdobePageMaker6TagConstants" name="TIFF_TAG_IMAGE_ID" map="&#x00dd;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.AdobePageMaker6TagConstants" name="TIFF_TAG_CLIP_PATH" map="&#x00de;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.AdobePageMaker6TagConstants" name="TIFF_TAG_SUB_IFD" map="&#x00df;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.AdobePageMaker6TagConstants" name="TIFF_TAG_YCLIP_PATH_UNITS" map="&#x00e0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.AdobePageMaker6TagConstants" name="ALL_ADOBE_PAGEMAKER_6_TAGS" map="&#x00e1;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.AdobePhotoshopTagConstants" map="G"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.AdobePhotoshopTagConstants" name="EXIF_TAG_JPEGTABLES" map="&#x00d6;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.AdobePhotoshopTagConstants" name="ALL_ADOBE_PHOTOSHOP_TAGS" map="&#x00d8;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.AdobePhotoshopTagConstants" name="EXIF_TAG_IMAGE_SOURCE_DATA" map="&#x00d9;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.GeoTiffTagConstants" map="H"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GeoTiffTagConstants" name="EXIF_TAG_GEO_ASCII_PARAMS_TAG" map="&#x01bc;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GeoTiffTagConstants" name="EXIF_TAG_MODEL_TIEPOINT_TAG" map="&#x01bd;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GeoTiffTagConstants" name="ALL_GEO_TIFF_TAGS" map="&#x01be;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GeoTiffTagConstants" name="EXIF_TAG_MODEL_TRANSFORMATION_TAG" map="&#x01bf;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GeoTiffTagConstants" name="EXIF_TAG_MODEL_PIXEL_SCALE_TAG" map="&#x01c0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GeoTiffTagConstants" name="EXIF_TAG_GEO_KEY_DIRECTORY_TAG" map="&#x01c1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GeoTiffTagConstants" name="EXIF_TAG_INTERGRAPH_MATRIX_TAG" map="&#x01c2;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GeoTiffTagConstants" name="EXIF_TAG_GEO_DOUBLE_PARAMS_TAG" map="&#x01c3;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.AliasSketchbookProTagConstants" map="I"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.AliasSketchbookProTagConstants" name="ALL_ALIAS_SKETCHBOOK_PRO_TAGS" map="&#x00e2;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.AliasSketchbookProTagConstants" name="EXIF_TAG_ALIAS_LAYER_METADATA" map="&#x00e3;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.MolecularDynamicsGelTagConstants" map="J"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MolecularDynamicsGelTagConstants" name="EXIF_TAG_MD_PREP_DATE" map="&#x0277;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MolecularDynamicsGelTagConstants" name="EXIF_TAG_MD_PREP_TIME" map="&#x0278;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MolecularDynamicsGelTagConstants" name="EXIF_TAG_MD_FILE_TAG" map="&#x0279;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MolecularDynamicsGelTagConstants" name="EXIF_TAG_MD_COLOR_TABLE" map="&#x027a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MolecularDynamicsGelTagConstants" name="EXIF_TAG_MD_SAMPLE_INFO" map="&#x027b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MolecularDynamicsGelTagConstants" name="ALL_MOLECULAR_DYNAMICS_GEL_TAGS" map="&#x027c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MolecularDynamicsGelTagConstants" name="EXIF_TAG_MD_LAB_NAME" map="&#x027d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MolecularDynamicsGelTagConstants" name="EXIF_TAG_MD_SCALE_PIXEL" map="&#x027e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MolecularDynamicsGelTagConstants" name="EXIF_TAG_MD_FILE_UNITS" map="&#x027f;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" map="K"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_TRANSFER_FUNCTION" map="&#x02b0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_FREE_BYTE_COUNTS" map="&#x02b1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_THRESHHOLDING" map="&#x02b2;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_TILE_LENGTH" map="&#x02b3;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_YPOSITION" map="&#x02b4;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_JPEG_ACTABLES" map="&#x02b5;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_JPEG_POINT_TRANSFORMS" map="&#x02b6;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_ROWS_PER_STRIP" map="&#x02b7;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_IMAGE_DESCRIPTION" map="&#x02b8;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_FREE_OFFSETS" map="&#x02bb;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_REFERENCE_BLACK_WHITE" map="&#x02bc;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_SMIN_SAMPLE_VALUE" map="&#x02bd;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_SAMPLES_PER_PIXEL" map="&#x02be;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_JPEG_LOSSLESS_PREDICTORS" map="&#x02bf;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_DOCUMENT_NAME" map="&#x02c0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_COPYRIGHT" map="&#x02c1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_INK_NAMES" map="&#x02d0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_SMAX_SAMPLE_VALUE" map="&#x02d1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_SAMPLE_FORMAT" map="&#x02e0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_ORIENTATION" map="&#x02e1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_STRIP_BYTE_COUNTS" map="&#x02e2;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_NUMBER_OF_INKS" map="&#x02e3;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_MIN_SAMPLE_VALUE" map="&#x02e4;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_FILL_ORDER" map="&#x037a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_RESOLUTION_UNIT" map="&#x0386;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_YCBCR_COEFFICIENTS" map="&#x0388;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_PAGE_NAME" map="&#x0389;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_PREDICTOR" map="&#x038a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_XRESOLUTION" map="&#x038c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_DATE_TIME" map="&#x038e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_NEW_SUBFILE_TYPE" map="&#x038f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_GRAY_RESPONSE_UNIT" map="&#x0390;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_PLANAR_CONFIGURATION" map="&#x0391;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_SOFTWARE" map="&#x0392;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="ALL_TIFF_TAGS" map="&#x0393;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_JPEG_PROC" map="&#x0394;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_HOST_COMPUTER" map="&#x0395;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_MAX_SAMPLE_VALUE" map="&#x0396;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_CELL_LENGTH" map="&#x0397;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_JPEG_DCTABLES" map="&#x0398;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_YCBCR_POSITIONING" map="&#x0399;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_XPOSITION" map="&#x039a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_COMPRESSION" map="&#x039b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_UNKNOWN" map="&#x039c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_XMP" map="&#x039d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_MODEL" map="&#x039e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_MAKE" map="&#x039f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_HALFTONE_HINTS" map="&#x03a0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_WHITE_POINT" map="&#x03a1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_TILE_OFFSETS" map="&#x03a3;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_YRESOLUTION" map="&#x03a4;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH" map="&#x03a5;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_DOT_RANGE" map="&#x03a6;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_JPEG_RESTART_INTERVAL" map="&#x03a7;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_PAGE_NUMBER" map="&#x03a8;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_PHOTOMETRIC_INTERPRETATION" map="&#x03a9;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_PRIMARY_CHROMATICITIES" map="&#x03aa;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_CELL_WIDTH" map="&#x03ab;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_IMAGE_LENGTH" map="&#x03ac;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_JPEG_QTABLES" map="&#x03ad;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_T6_OPTIONS" map="&#x03ae;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_IMAGE_WIDTH" map="&#x03af;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_BITS_PER_SAMPLE" map="&#x03b0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_TILE_BYTE_COUNTS" map="&#x03b1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_EXTRA_SAMPLES" map="&#x03b2;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_STRIP_OFFSETS" map="&#x03b3;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_TILE_WIDTH" map="&#x03b4;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_SUBFILE_TYPE" map="&#x03b5;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_YCBCR_SUB_SAMPLING" map="&#x03b6;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_ARTIST" map="&#x03b7;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_JPEG_INTERCHANGE_FORMAT" map="&#x03b8;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_T4_OPTIONS" map="&#x03b9;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_TARGET_PRINTER" map="&#x03ba;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_GRAY_RESPONSE_CURVE" map="&#x03bb;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_INK_SET" map="&#x03bc;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_TRANSFER_RANGE" map="&#x03bd;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants" name="TIFF_TAG_COLOR_MAP" map="&#x03be;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" map="L"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="EXIF_DIRECTORY_INTEROP_IFD" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="TIFF_DIRECTORY_ROOT" map="B"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="EXIF_DIRECTORY_UNKNOWN" map="C"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="EXIF_DIRECTORY_SUB_IFD2" map="D"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="EXIF_DIRECTORY_SUB_IFD1" map="E"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="EXIF_DIRECTORY_MAKER_NOTES" map="F"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="$VALUES" map="G"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="isImageDirectory" map="H"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="EXIF_DIRECTORY_EXIF_IFD" map="I"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="EXIF_DIRECTORY_IFD3" map="J"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="EXIF_DIRECTORY_IFD2" map="K"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="EXIF_DIRECTORY_IFD1" map="L"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="directoryType" map="M"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="EXIF_DIRECTORY_IFD0" map="N"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="EXIF_DIRECTORY_SUB_IFD" map="O"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="TIFF_DIRECTORY_IFD3" map="P"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="EXIF_DIRECTORY_GPS" map="Q"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="TIFF_DIRECTORY_IFD2" map="R"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="TIFF_DIRECTORY_IFD1" map="S"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="TIFF_DIRECTORY_IFD0" map="T"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="name" map="U"/>
  <method class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType[] values()" map="values"/>
  <method class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="boolean isImageDirectory()" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType" name="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryType valueOf(java.lang.String)" map="valueOf"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.Tiff4TagConstants" map="M"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Tiff4TagConstants" name="TIFF_TAG_COLOR_RESPONSE_UNIT" map="&#x0293;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Tiff4TagConstants" name="ALL_TIFF_4_TAGS" map="&#x0294;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" map="N"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_FLASH_ENERGY" map="&#x0295;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_IMAGE_NUMBER_EXIF_IFD" map="&#x0296;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_FOCAL_PLANE_YRESOLUTION" map="&#x0297;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_SPATIAL_FREQUENCY_RESPONSE_1" map="&#x0298;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_SELF_TIMER_MODE" map="&#x0299;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_INTER_COLOR_PROFILE" map="&#x029a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_SENSING_METHOD" map="&#x029b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_BATTERY_LEVEL" map="&#x029c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_IMAGE_HISTORY_EXIF_IFD" map="&#x029d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_SECURITY_CLASSIFICATION_EXIF_IFD" map="&#x029e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_FOCAL_PLANE_XRESOLUTION" map="&#x029f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_TIFF_EPSTANDARD_ID_1" map="&#x02a0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_FOCAL_PLANE_RESOLUTION_UNIT" map="&#x02a1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_CFAPATTERN_2" map="&#x02a2;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_EXPOSURE_INDEX" map="&#x02a3;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_CFAREPEAT_PATTERN_DIM" map="&#x02a4;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_TIME_ZONE_OFFSET" map="&#x02a5;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_INTERLACE" map="&#x02a6;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="EXIF_TAG_NOISE_1" map="&#x02a7;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffEpTagConstants" name="ALL_TIFF_EP_TAGS" map="&#x02a8;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.MicrosoftTagConstants" map="O"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftTagConstants" name="EXIF_TAG_XPSUBJECT" map="&#x01ec;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftTagConstants" name="EXIF_TAG_XPKEYWORDS" map="&#x01ed;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftTagConstants" name="EXIF_TAG_XPTITLE" map="&#x01ee;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftTagConstants" name="EXIF_TAG_RATING_PERCENT" map="&#x01ef;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftTagConstants" name="ALL_MICROSOFT_TAGS" map="&#x01f0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftTagConstants" name="EXIF_TAG_XPCOMMENT" map="&#x01f1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftTagConstants" name="EXIF_TAG_XPAUTHOR" map="&#x01f2;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftTagConstants" name="EXIF_TAG_RATING" map="&#x01f3;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" map="P"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_32_BIT_CMYK" map="&#x01f4;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="EXIF_TAG_IMAGE_TYPE" map="&#x01f5;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_BLACK_AND_WHITE" map="&#x01fa;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="EXIF_TAG_WIDTH_RESOLUTION" map="&#x01fb;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="EXIF_TAG_UNCOMPRESSED" map="&#x01fc;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_48_BIT_RGB" map="&#x01fd;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_32_BIT_GRAY_FLOAT" map="&#x01fe;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="EXIF_TAG_ALPHA_BYTE_COUNT" map="&#x01ff;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_32_BIT_GRAY_FIXED_POINT" map="&#x0200;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_128_BIT_8_CHANNELS" map="&#x0201;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_80_BIT_CMYK_ALPHA" map="&#x0202;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_64_BIT_PRGBA" map="&#x0203;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_16_BIT_BGR565" map="&#x0204;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_32_BIT_BGR101010" map="&#x0205;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="EXIF_TAG_IMAGE_DATA_DISCARD" map="&#x0206;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_128_BIT_7_CHANNELS_ALPHA" map="&#x0207;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_64_BIT_RGBA" map="&#x0208;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_128_BIT_PRGBA_FLOAT" map="&#x0209;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="EXIF_TAG_TRANSFOMATION" map="&#x020a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="EXIF_TAG_HEIGHT_RESOLUTION" map="&#x020b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_72_BIT_8_CHANNELS_ALPHA" map="&#x020c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_40_BIT_4_CHANNELS_ALPHA" map="&#x020d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_80_BIT_4_CHANNELS_ALPHA" map="&#x020e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_112_BIT_7_CHANNELS" map="&#x020f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="EXIF_TAG_IMAGE_OFFSET" map="&#x0210;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_32_BIT_RGBE" map="&#x0211;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_24_BIT_3_CHANNELS" map="&#x0212;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_64_BIT_7_CHANNELS_ALPHA" map="&#x0213;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_32_BIT_3_CHANNELS_ALPHA" map="&#x0214;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_48_BIT_6_CHANNELS" map="&#x0215;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_128_BIT_RGBA_FLOAT" map="&#x0216;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_96_BIT_6_CHANNELS" map="&#x0217;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_32_BIT_4_CHANNELS" map="&#x0250;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_16_BIT_BGR555" map="&#x0251;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_128_BIT_RGB_FLOAT" map="&#x0252;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_56_BIT_7_CHANNELS" map="&#x0253;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_40_BIT_5_CHANNELS" map="&#x0254;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_64_BIT_3_CHANNELS_ALPHA" map="&#x0255;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_24_BIT_BGR" map="&#x0256;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_56_BIT_6_CHANNELS_ALPHA" map="&#x0257;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_64_BIT_8_CHANNELS" map="&#x0258;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_48_BIT_RGB_FIXED_POINT" map="&#x0259;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_32_BIT_BGRA" map="&#x025a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_48_BIT_RGB_HALF" map="&#x025b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_96_BIT_5_CHANNELS_ALPHA" map="&#x025c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="EXIF_TAG_IMAGE_HEIGHT" map="&#x025d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_16_BIT_GRAY" map="&#x025e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_80_BIT_5_CHANNELS" map="&#x025f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="EXIF_TAG_PIXEL_FORMAT" map="&#x0260;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="EXIF_TAG_IMAGE_WIDTH" map="&#x0261;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_64_BIT_CMYK" map="&#x0262;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_128_BIT_RGBA_FIXED_POINT" map="&#x0263;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_8_BIT_GRAY" map="&#x0264;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_48_BIT_5_CHANNELS_ALPHA" map="&#x0265;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_64_BIT_4_CHANNELS" map="&#x0266;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_112_BIT_6_CHANNELS_ALPHA" map="&#x0267;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="ALL_MICROSOFT_HD_PHOTO_TAGS" map="&#x0268;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_48_BIT_3_CHANNELS" map="&#x0269;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_96_BIT_RGB_FIXED_POINT" map="&#x026a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="EXIF_TAG_PADDING" map="&#x026b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="EXIF_TAG_ALPHA_OFFSET" map="&#x026c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_16_BIT_GRAY_HALF" map="&#x026d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_144_BIT_8_CHANNELS_ALPHA" map="&#x026e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_64_BIT_RGBA_HALF" map="&#x026f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_32_BIT_PBGRA" map="&#x0270;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="EXIF_TAG_IMAGE_BYTE_COUNT" map="&#x0271;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_24_BIT_RGB" map="&#x0272;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_32_BIT_BGR" map="&#x0273;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_40_BIT_CMYK_ALPHA" map="&#x0274;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="PIXEL_FORMAT_VALUE_64_BIT_RGBA_FIXED_POINT" map="&#x0275;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.MicrosoftHdPhotoTagConstants" name="EXIF_TAG_ALPHA_DATA_DISCARD" map="&#x0276;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.Rfc2301TagConstants" map="Q"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Rfc2301TagConstants" name="TIFF_TAG_DECODE" map="&#x0285;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Rfc2301TagConstants" name="TIFF_TAG_FAX_PROFILE" map="&#x0286;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Rfc2301TagConstants" name="TIFF_TAG_STRIP_ROW_COUNTS" map="&#x0287;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Rfc2301TagConstants" name="TIFF_TAG_CODING_METHODS" map="&#x0288;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Rfc2301TagConstants" name="TIFF_TAG_GLOBAL_PARAMETERS_IFD" map="&#x0289;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Rfc2301TagConstants" name="TIFF_TAG_CLEAN_FAX_DATA" map="&#x028a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Rfc2301TagConstants" name="TIFF_TAG_BAD_FAX_LINES" map="&#x028b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Rfc2301TagConstants" name="ALL_RFC_2301_TAGS" map="&#x028c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Rfc2301TagConstants" name="TIFF_TAG_IMAGE_LAYER" map="&#x028d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Rfc2301TagConstants" name="TIFF_TAG_PROFILE_TYPE" map="&#x028e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Rfc2301TagConstants" name="TIFF_TAG_DEFAULT_IMAGE_COLOR" map="&#x028f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Rfc2301TagConstants" name="TIFF_TAG_VERSION_YEAR" map="&#x0290;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Rfc2301TagConstants" name="TIFF_TAG_CONSECUTIVE_BAD_FAX_LINES" map="&#x0291;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.Rfc2301TagConstants" name="TIFF_TAG_MODE_NUMBER" map="&#x0292;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" map="R"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_COLOR_SEQUENCE" map="&#x013a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_RASTER_PADDING" map="&#x013b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_IMAGE_NUMBER" map="&#x013c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_PROCESSING_SOFTWARE" map="&#x013d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_DATE_TIME_ORIGINAL" map="&#x013e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_DIGITAL_ZOOM_RATIO" map="&#x013f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_DEVICE_SETTING_DESCRIPTION" map="&#x0140;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_JPG_FROM_RAW_LENGTH_SUB_IFD" map="&#x0141;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_JPG_FROM_RAW_LENGTH_SUB_IFD2" map="&#x0142;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_PREVIEW_IMAGE_START_MAKER_NOTES" map="&#x0143;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_DATE_TIME_DIGITIZED" map="&#x0144;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_BRIGHTNESS_VALUE" map="&#x0145;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SCENE_TYPE" map="&#x0146;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_ISO" map="&#x0147;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_OFFSET_SCHEMA" map="&#x0148;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_LEAF_DATA" map="&#x0149;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SHUTTER_SPEED_VALUE" map="&#x014a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SPATIAL_FREQUENCY_RESPONSE_2" map="&#x014b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SUB_SEC_TIME_ORIGINAL" map="&#x014c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_IMAGE_COLOR_INDICATOR" map="&#x014d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_COLOR_CHARACTERIZATION" map="&#x014e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_FILE_SOURCE" map="&#x014f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_FOCAL_PLANE_RESOLUTION_UNIT_EXIF_IFD" map="&#x0150;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_EXPOSURE_TIME" map="&#x0151;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_PIXEL_INTENSITY_RANGE" map="&#x0152;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SUBJECT_DISTANCE_RANGE" map="&#x0153;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_HCUSAGE" map="&#x0154;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_IMAGE_UNIQUE_ID" map="&#x0155;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_EXIF_IMAGE_WIDTH" map="&#x0156;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SUB_SEC_TIME_DIGITIZED" map="&#x0157;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_INTEROPERABILITY_INDEX" map="&#x0158;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_IMAGE_COLOR_VALUE" map="&#x0159;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_APERTURE_VALUE" map="&#x015a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_LEAF_SUB_IFD" map="&#x015b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_METERING_MODE" map="&#x015c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_EXPOSURE_MODE" map="&#x015d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_AFCP_IPTC" map="&#x015e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_WHITE_BALANCE_2" map="&#x015f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_GPSINFO" map="&#x0160;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_OTHER_IMAGE_LENGTH" map="&#x0161;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_TRANSPARENCY_INDICATOR" map="&#x0162;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_WHITE_BALANCE_1" map="&#x0163;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SUBJECT_DISTANCE" map="&#x0164;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_FLASH" map="&#x0165;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_OWNER_NAME" map="&#x0166;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_INTEROPERABILITY_VERSION" map="&#x0167;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SHADOWS" map="&#x0168;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_FNUMBER" map="&#x0169;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_INTERGRAPH_PACKET_DATA" map="&#x016a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_JPG_FROM_RAW_START_IFD2" map="&#x016b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_NOISE_2" map="&#x016c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SENSING_METHOD_EXIF_IFD" map="&#x016d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_EXIF_VERSION" map="&#x016e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_EXPOSURE_PROGRAM" map="&#x016f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_FLASH_ENERGY_EXIF_IFD" map="&#x0170;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_GAMMA" map="&#x0171;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_EXPOSURE" map="&#x0172;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_LENS" map="&#x0173;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_STO_NITS" map="&#x0174;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_PHOTOSHOP_SETTINGS" map="&#x0175;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_ANNOTATIONS" map="&#x0176;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_FOCAL_PLANE_YRESOLUTION_EXIF_IFD" map="&#x0177;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_INTERGRAPH_FLAG_REGISTERS" map="&#x0178;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SEMINFO" map="&#x0179;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_COLOR_TABLE" map="&#x017a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_FOCAL_PLANE_XRESOLUTION_EXIF_IFD" map="&#x017b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_BACKGROUND_COLOR_VALUE" map="&#x017c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SATURATION_2" map="&#x017d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SATURATION_1" map="&#x017e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_CFAPATTERN" map="&#x017f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_IMAGE_DEPTH" map="&#x0180;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_COMPONENTS_CONFIGURATION" map="&#x0181;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SECURITY_CLASSIFICATION" map="&#x0182;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SITE" map="&#x0183;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_FLASHPIX_VERSION" map="&#x0184;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_EXPOSURE_INDEX_EXIF_IFD" map="&#x0185;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_PREVIEW_IMAGE_START_SUB_IFD1" map="&#x0186;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_MOIRE_FILTER" map="&#x0187;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_MATTEING" map="&#x0188;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SERIAL_NUMBER" map="&#x0189;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_DATA_TYPE" map="&#x018a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SUBJECT_LOCATION" map="&#x018b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SUB_SEC_TIME" map="&#x018c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_JPG_FROM_RAW_LENGTH_IFD2" map="&#x018d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_BITS_PER_RUN_LENGTH" map="&#x018e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_JPG_FROM_RAW_START_SUB_IFD2" map="&#x018f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_TILE_DEPTH" map="&#x0190;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_IMAGE_HISTORY" map="&#x0191;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_PREVIEW_IMAGE_LENGTH_SUB_IFD1" map="&#x0192;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_PREVIEW_IMAGE_START_IFD0" map="&#x0193;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_IT8HEADER" map="&#x0194;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_BITS_PER_EXTENDED_RUN_LENGTH" map="&#x0195;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_CUSTOM_RENDERED" map="&#x0196;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_RAW_FILE" map="&#x0197;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_BRIGHTNESS" map="&#x0198;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SPECTRAL_SENSITIVITY" map="&#x0199;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_PREVIEW_IMAGE_LENGTH_MAKER_NOTES" map="&#x019a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_CONVERTER" map="&#x019b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SUBJECT_AREA" map="&#x019c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_PREVIEW_IMAGE_LENGTH_IFD0" map="&#x019d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_EXPOSURE_COMPENSATION" map="&#x019e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_FOCAL_LENGTH_IN_35MM_FORMAT" map="&#x019f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_BACKGROUND_COLOR_INDICATOR" map="&#x01a0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_USER_COMMENT" map="&#x01a1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_JPG_FROM_RAW_START_SUB_IFD" map="&#x01a2;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_LIGHT_SOURCE" map="&#x01a3;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_EXIF_IMAGE_LENGTH" map="&#x01a4;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_MODEL_2" map="&#x01a5;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SHARPNESS_2" map="&#x01a6;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_COMPRESSED_BITS_PER_PIXEL" map="&#x01a7;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_MAX_APERTURE_VALUE" map="&#x01a8;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_FOCAL_LENGTH" map="&#x01a9;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SHARPNESS_1" map="&#x01aa;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_TIFF_EPSTANDARD_ID_2" map="&#x01ab;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SMOOTHNESS" map="&#x01ac;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_OTHER_IMAGE_START" map="&#x01ad;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_CONTRAST_2" map="&#x01ae;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SOFTWARE" map="&#x01af;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_CONTRAST_1" map="&#x01b0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_SCENE_CAPTURE_TYPE" map="&#x01b1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_RELATED_SOUND_FILE" map="&#x01b2;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_PRINT_IM" map="&#x01b3;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_APPLICATION_NOTES" map="&#x01b4;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_EXIF_OFFSET" map="&#x01b5;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_OPTO_ELECTRIC_CONV_FACTOR" map="&#x01b6;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_IPTC_NAA" map="&#x01b7;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="ALL_EXIF_TAGS" map="&#x01b8;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_INTEROP_OFFSET" map="&#x01b9;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_MAKER_NOTE" map="&#x01ba;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants" name="EXIF_TAG_GAIN_CONTROL" map="&#x01bb;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.DcfTagConstants" map="S"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DcfTagConstants" name="EXIF_TAG_RELATED_IMAGE_LENGTH" map="&#x00e4;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DcfTagConstants" name="EXIF_TAG_COLOR_SPACE" map="&#x00e5;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DcfTagConstants" name="ALL_DCF_TAGS" map="&#x00e6;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DcfTagConstants" name="EXIF_TAG_RELATED_IMAGE_WIDTH" map="&#x00e7;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DcfTagConstants" name="EXIF_TAG_RELATED_IMAGE_FILE_FORMAT" map="&#x00e8;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" map="T"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_LATITUDE_REF" map="&#x01c7;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_SATELLITES" map="&#x01c8;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_SPEED" map="&#x01c9;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_DEST_BEARING_REF" map="&#x01ca;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_LATITUDE" map="&#x01cb;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_SPEED_REF" map="&#x01cc;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_DEST_LONGITUDE" map="&#x01cd;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_MEASURE_MODE" map="&#x01ce;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_PROCESSING_METHOD" map="&#x01cf;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_DEST_DISTANCE" map="&#x01d0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_LONGITUDE" map="&#x01d1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_DEST_DISTANCE_REF" map="&#x01d2;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_DEST_LONGITUDE_REF" map="&#x01d3;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_STATUS" map="&#x01d4;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="ALL_GPS_TAGS" map="&#x01d5;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_VERSION_ID" map="&#x01d6;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_ALTITUDE" map="&#x01d7;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_DEST_LATITUDE_REF" map="&#x01d8;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_DATE_STAMP" map="&#x01d9;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_AREA_INFORMATION" map="&#x01da;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_DEST_LATITUDE" map="&#x01db;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_DOP" map="&#x01dc;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_ALTITUDE_REF" map="&#x01dd;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_DIFFERENTIAL" map="&#x01de;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_MAP_DATUM" map="&#x01df;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_DEST_BEARING" map="&#x01e0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_IMG_DIRECTION_REF" map="&#x01e1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_IMG_DIRECTION" map="&#x01e2;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_LONGITUDE_REF" map="&#x01e3;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_TRACK" map="&#x01e4;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_TIME_STAMP" map="&#x01e5;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GpsTagConstants" name="GPS_TAG_GPS_TRACK_REF" map="&#x01e6;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.TiffConstants" map="U"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.TiffConstants" name="DEFAULT_TIFF_BYTE_ORDER" map="&#x03c5;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.TiffDirectoryConstants" map="V"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" map="W"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_DNG_LENS_INFO" map="&#x00e9;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PROFILE_LOOK_TABLE_DIMS" map="&#x00ea;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_WHITE_LEVEL" map="&#x00eb;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_DNG_BACKWARD_VERSION" map="&#x00ec;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_CAMERA_CALIBRATION_SIGNATURE" map="&#x00ed;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_BLACK_LEVEL" map="&#x00ee;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_ACTIVE_AREA" map="&#x00ef;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_CURRENT_PRE_PROFILE_MATRIX" map="&#x00f0;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PREVIEW_SETTINGS_DIGEST" map="&#x00f1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_SUB_TILE_BLOCK_SIZE" map="&#x00f2;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_AS_SHOT_PRE_PROFILE_MATRIX" map="&#x00f3;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PROFILE_LOOK_TABLE_DATA" map="&#x00f4;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_ORIGINAL_RAW_FILE_NAME" map="&#x00f5;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_COLORIMETRIC_REFERENCE" map="&#x00f6;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PROFILE_COPYRIGHT" map="&#x00f8;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_COLOR_MATRIX_2" map="&#x00f9;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_LOCALIZED_CAMERA_MODEL" map="&#x00fa;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_COLOR_MATRIX_1" map="&#x00fb;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_FORWARD_MATRIX2" map="&#x00fc;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_NOISE_PROFILE" map="&#x00fd;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_FORWARD_MATRIX1" map="&#x00fe;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_BASELINE_EXPOSURE" map="&#x00ff;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_DEFAULT_CROP_ORIGIN" map="&#x0100;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_EXTRA_CAMERA_PROFILES" map="&#x0101;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_CAMERA_SERIAL_NUMBER" map="&#x0102;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PROFILE_NAME" map="&#x0103;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PROFILE_CALIBRATION_SIGNATURE" map="&#x0104;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_CFAPLANE_COLOR" map="&#x0105;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_ANTI_ALIAS_STRENGTH" map="&#x0106;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PREVIEW_APPLICATION_NAME" map="&#x0107;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PROFILE_HUE_SAT_MAP_DATA2" map="&#x0108;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PROFILE_HUE_SAT_MAP_DATA1" map="&#x0109;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PROFILE_TONE_CURVE" map="&#x010a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_OPCODE_LIST_3" map="&#x010b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_DEFAULT_SCALE" map="&#x010c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_OPCODE_LIST_2" map="&#x010d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_OPCODE_LIST_1" map="&#x010e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="ALL_DNG_TAGS" map="&#x010f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_BLACK_LEVEL_REPEAT_DIM" map="&#x0110;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_LINEAR_RESPONSE_LIMIT" map="&#x0111;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PREVIEW_COLORSPACE" map="&#x0112;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PROFILE_HUE_SAT_MAP_DIMS" map="&#x0113;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_DEFAULT_CROP_SIZE" map="&#x0114;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_REDUCTION_MATRIX_2" map="&#x0115;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_REDUCTION_MATRIX_1" map="&#x0116;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_ANALOG_BALANCE" map="&#x0117;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_CURRENT_ICCPROFILE" map="&#x0118;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PREVIEW_APPLICATION_VERSION" map="&#x0119;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_MASKED_AREAS" map="&#x011a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_LINEARIZATION_TABLE" map="&#x011b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_RAW_DATA_UNIQUE_ID" map="&#x011c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_ORIGINAL_RAW_FILE_DIGEST" map="&#x011d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_BASELINE_NOISE" map="&#x011e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PROFILE_EMBED_POLICY" map="&#x011f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_DNG_PRIVATE_DATA" map="&#x0120;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_AS_SHOT_PROFILE_NAME" map="&#x0121;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_BASELINE_SHARPNESS" map="&#x0122;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_AS_SHOT_ICCPROFILE" map="&#x0123;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_CHROMA_BLUR_RADIUS" map="&#x0124;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_UNIQUE_CAMERA_MODEL" map="&#x0125;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_CALIBRATION_ILLUMINANT_2" map="&#x0126;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_CALIBRATION_ILLUMINANT_1" map="&#x0127;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_AS_SHOT_NEUTRAL" map="&#x0128;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PREVIEW_SETTINGS_NAME" map="&#x0129;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_AS_SHOT_WHITE_XY" map="&#x012a;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_DNG_VERSION" map="&#x012b;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_RAW_IMAGE_DIGEST" map="&#x012c;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_CFALAYOUT" map="&#x012d;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_BLACK_LEVEL_DELTA_V" map="&#x012e;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_CAMERA_CALIBRATION_2" map="&#x012f;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_CAMERA_CALIBRATION_1" map="&#x0130;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_NOISE_REDUCTION_APPLIED" map="&#x0131;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_SHADOW_SCALE" map="&#x0132;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_ROW_INTERLEAVE_FACTOR" map="&#x0133;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_BEST_QUALITY_SCALE" map="&#x0134;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_BLACK_LEVEL_DELTA_H" map="&#x0135;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_MAKER_NOTE_SAFETY" map="&#x0136;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_ORIGINAL_RAW_FILE_DATA" map="&#x0137;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_PREVIEW_DATE_TIME" map="&#x0138;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.DngTagConstants" name="EXIF_TAG_BAYER_GREEN_SPLIT" map="&#x0139;"/>
  <class name="org.apache.commons.imaging.formats.tiff.constants.GdalLibraryTagConstants" map="X"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GdalLibraryTagConstants" name="ALL_GDAL_LIBRARY_TAGS" map="&#x01c4;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GdalLibraryTagConstants" name="EXIF_TAG_GDAL_METADATA" map="&#x01c5;"/>
  <field class="org.apache.commons.imaging.formats.tiff.constants.GdalLibraryTagConstants" name="EXIF_TAG_GDAL_NO_DATA" map="&#x01c6;"/>
  <package name="org.apache.commons.imaging.formats.tiff.write" map="D"/>
  <class name="org.apache.commons.imaging.formats.tiff.write.TiffImageWriterBase" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffImageWriterBase" name="byteOrder" map="&#x03e3;"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffImageWriterBase" name="int imageDataPaddingLength(int)" map="E"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffImageWriterBase" name="org.apache.commons.imaging.formats.tiff.write.TiffOutputSummary validateDirectories(org.apache.commons.imaging.formats.tiff.write.TiffOutputSet)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffImageWriterBase" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="D"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffImageWriterBase" name="void writeImageFileHeader(org.apache.commons.imaging.common.BinaryOutputStream)" map="B"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffImageWriterBase" name="void write(java.io.OutputStream, org.apache.commons.imaging.formats.tiff.write.TiffOutputSet)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffImageWriterBase" name="void combineUserExifIntoFinalExif(org.apache.commons.imaging.formats.tiff.write.TiffOutputSet, org.apache.commons.imaging.formats.tiff.write.TiffOutputSet)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffImageWriterBase" name="void writeImageFileHeader(org.apache.commons.imaging.common.BinaryOutputStream, long)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffImageWriterBase" name="byte[][] getStrips(java.awt.image.BufferedImage, int, int, int)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.write.TiffOutputItem$Value" map="_A"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputItem$Value" name="bytes" map="&#x03c3;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputItem$Value" name="name" map="&#x03c4;"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputItem$Value" name="void updateValue(byte[])" map="F"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputItem$Value" name="void writeItem(org.apache.commons.imaging.common.BinaryOutputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputItem$Value" name="int getItemLength()" map="S"/>
  <class name="org.apache.commons.imaging.formats.tiff.write.TiffOutputItem" map="B"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputItem" name="offset" map="&#x03c2;"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputItem" name="void writeItem(org.apache.commons.imaging.common.BinaryOutputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputItem" name="void setOffset(long)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputItem" name="int getItemLength()" map="S"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputItem" name="long getOffset()" map="T"/>
  <class name="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" map="C"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="tag" map="&#x03e4;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="separateValueItem" map="&#x03e5;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="bytes" map="&#x03e6;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="fieldType" map="&#x03e7;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="newline" map="&#x03e8;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="sortHint" map="&#x03e9;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="count" map="&#x03ea;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="tagInfo" map="&#x03eb;"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="org.apache.commons.imaging.formats.tiff.write.TiffOutputItem getSeperateValue()" map="V"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="void setData(byte[])" map="G"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="org.apache.commons.imaging.formats.tiff.write.TiffOutputField createOffsetField(org.apache.commons.imaging.formats.tiff.taginfos.TagInfo, org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="boolean isLocalValue()" map="W"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="void writeField(org.apache.commons.imaging.common.BinaryOutputStream)" map="C"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="int getSortHint()" map="X"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="java.lang.String toString(java.lang.String)" map="F"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputField" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.commons.imaging.formats.tiff.write.TiffOutputSummary$OffsetItem" map="_A"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSummary$OffsetItem" name="itemOffsetField" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSummary$OffsetItem" name="item" map="B"/>
  <class name="org.apache.commons.imaging.formats.tiff.write.TiffOutputSummary" map="D"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSummary" name="directoryTypeMap" map="&#x03ec;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSummary" name="offsetItems" map="&#x03ed;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSummary" name="byteOrder" map="&#x03ee;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSummary" name="imageDataItems" map="&#x03ef;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSummary" name="rootDirectory" map="&#x03f0;"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSummary" name="void addTiffImageData(org.apache.commons.imaging.formats.tiff.write.ImageDataOffsets)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSummary" name="void updateOffsets(org.apache.commons.imaging.common.ByteOrder)" map="B"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSummary" name="void add(org.apache.commons.imaging.formats.tiff.write.TiffOutputItem, org.apache.commons.imaging.formats.tiff.write.TiffOutputField)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory$2" map="2"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory$2" name="this$0" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory$2" name="int compare(org.apache.commons.imaging.formats.tiff.write.TiffOutputField, org.apache.commons.imaging.formats.tiff.write.TiffOutputField)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory$2" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory$1" map="1"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory$1" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory$1" name="int compare(org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory, org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" map="E"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="fields" map="&#x0403;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="nextDirectory" map="&#x0404;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="byteOrder" map="&#x0405;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="COMPARATOR" map="&#x0406;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="type" map="&#x0407;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="tiffImageData" map="&#x0408;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="jpegImageData" map="&#x0409;"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="java.lang.String description()" map="a"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="void add(org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShortOrLong, int[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="int getItemLength()" map="S"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="org.apache.commons.imaging.formats.tiff.write.TiffOutputField findField(org.apache.commons.imaging.formats.tiff.taginfos.TagInfo)" map="C"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="void sortFields()" map="b"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="void setNextDirectory(org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory)" map="B"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="void add(org.apache.commons.imaging.formats.tiff.taginfos.TagInfoByte, byte[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="void add(org.apache.commons.imaging.formats.tiff.taginfos.TagInfoLong, int[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="void setTiffImageData(org.apache.commons.imaging.formats.tiff.TiffImageData)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="void add(org.apache.commons.imaging.formats.tiff.taginfos.TagInfoRational, org.apache.commons.imaging.common.RationalNumber[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="java.util.List getFields()" map="c"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="void add(org.apache.commons.imaging.formats.tiff.write.TiffOutputField)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="void removeFieldIfPresent(org.apache.commons.imaging.formats.tiff.taginfos.TagInfo)" map="D"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="java.util.List getOutputItems(org.apache.commons.imaging.formats.tiff.write.TiffOutputSummary)" map="B"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="void add(org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShort, short[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="void writeItem(org.apache.commons.imaging.common.BinaryOutputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory" name="org.apache.commons.imaging.formats.tiff.write.TiffOutputField findField(int)" map="H"/>
  <class name="org.apache.commons.imaging.formats.tiff.write.ImageDataOffsets" map="F"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.ImageDataOffsets" name="imageDataOffsetsField" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.ImageDataOffsets" name="imageDataOffsets" map="B"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.ImageDataOffsets" name="outputItems" map="C"/>
  <class name="org.apache.commons.imaging.formats.tiff.write.TiffOutputSet" map="G"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSet" name="newline" map="&#x03f1;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSet" name="byteOrder" map="&#x03f2;"/>
  <field class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSet" name="directories" map="&#x03f3;"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSet" name="void addDirectory(org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSet" name="java.util.List getOutputItems(org.apache.commons.imaging.formats.tiff.write.TiffOutputSummary)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSet" name="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory addRootDirectory()" map="Y"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSet" name="java.util.List getDirectories()" map="Z"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSet" name="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory findDirectory(int)" map="F"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSet" name="java.lang.String toString(java.lang.String)" map="G"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSet" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffOutputSet" name="org.apache.commons.imaging.formats.tiff.write.TiffOutputDirectory addExifDirectory()" map="_"/>
  <class name="org.apache.commons.imaging.formats.tiff.write.TiffImageWriterLossy" map="H"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffImageWriterLossy" name="void updateOffsetsStep(java.util.List)" map="C"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffImageWriterLossy" name="void write(java.io.OutputStream, org.apache.commons.imaging.formats.tiff.write.TiffOutputSet)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.write.TiffImageWriterLossy" name="void writeStep(org.apache.commons.imaging.common.BinaryOutputStream, java.util.List)" map="A"/>
  <package name="org.apache.commons.imaging.formats.tiff.taginfos" map="E"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShortOrLongOrRational" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoSLong" map="B"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoUndefined" map="C"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoByteOrShort" map="D"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoFloat" map="E"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoAsciiOrByte" map="F"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoAsciiOrRational" map="G"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoGpsText$TextEncoding" map="_A"/>
  <field class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoGpsText$TextEncoding" name="encodingName" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoGpsText$TextEncoding" name="prefix" map="B"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoGpsText" map="H"/>
  <field class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoGpsText" name="TEXT_ENCODING_UNDEFINED" map="G"/>
  <field class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoGpsText" name="TEXT_ENCODINGS" map="H"/>
  <field class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoGpsText" name="TEXT_ENCODING_UNICODE_LE" map="I"/>
  <field class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoGpsText" name="TEXT_ENCODING_ASCII" map="J"/>
  <field class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoGpsText" name="TEXT_ENCODING_UNICODE_BE" map="K"/>
  <field class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoGpsText" name="TEXT_ENCODING_JIS" map="L"/>
  <method class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoGpsText" name="java.lang.Object getValue(org.apache.commons.imaging.formats.tiff.TiffField)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoGpsText" name="java.lang.String getValue(org.apache.commons.imaging.formats.tiff.TiffField)" map="B"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoLong" map="I"/>
  <method class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoLong" name="byte[] encodeValue(org.apache.commons.imaging.common.ByteOrder, int[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoLong" name="int[] getValue(org.apache.commons.imaging.common.ByteOrder, byte[])" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoDouble" map="J"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShortOrRational" map="K"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShort" map="L"/>
  <method class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShort" name="byte[] encodeValue(org.apache.commons.imaging.common.ByteOrder, short[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShort" name="short[] getValue(org.apache.commons.imaging.common.ByteOrder, byte[])" map="B"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoByte" map="M"/>
  <method class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoByte" name="byte[] encodeValue(org.apache.commons.imaging.common.ByteOrder, byte[])" map="C"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShortOrLong" map="N"/>
  <method class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShortOrLong" name="byte[] encodeValue(org.apache.commons.imaging.common.ByteOrder, int[])" map="B"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoAscii" map="O"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfo" map="P"/>
  <field class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfo" name="tag" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfo" name="name" map="B"/>
  <field class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfo" name="dataTypes" map="C"/>
  <field class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfo" name="isOffset" map="D"/>
  <field class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfo" name="length" map="E"/>
  <field class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfo" name="directoryType" map="F"/>
  <method class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfo" name="java.lang.String getDescription()" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfo" name="java.lang.Object getValue(org.apache.commons.imaging.formats.tiff.TiffField)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfo" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoAny" map="Q"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoSRational" map="R"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoRational" map="S"/>
  <method class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoRational" name="byte[] encodeValue(org.apache.commons.imaging.common.ByteOrder, org.apache.commons.imaging.common.RationalNumber[])" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoLongOrIFD" map="T"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoUnknown" map="U"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoXpString" map="V"/>
  <method class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoXpString" name="java.lang.Object getValue(org.apache.commons.imaging.formats.tiff.TiffField)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoXpString" name="java.lang.String getValue(org.apache.commons.imaging.formats.tiff.TiffField)" map="C"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoDirectory" map="W"/>
  <class name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfoSShort" map="X"/>
  <package name="org.apache.commons.imaging.formats.tiff.fieldtypes" map="F"/>
  <class name="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldTypeAscii" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldTypeAscii" name="java.lang.Object getValue(org.apache.commons.imaging.formats.tiff.TiffField)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldTypeShort" map="B"/>
  <method class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldTypeShort" name="java.lang.Object getValue(org.apache.commons.imaging.formats.tiff.TiffField)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" map="C"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="elementSize" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="LONG" map="B"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="SHORT_OR_LONG" map="C"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="BYTE" map="D"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="type" map="E"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="LONG_OR_SHORT" map="F"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="SLONG" map="G"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="BYTE_OR_SHORT" map="H"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="SRATIONAL" map="I"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="SHORT_OR_LONG_OR_RATIONAL" map="J"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="SBYTE" map="K"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="ASCII_OR_RATIONAL" map="L"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="FLOAT" map="M"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="LONG_OR_IFD" map="N"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="ANY" map="O"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="ASCII_OR_BYTE" map="P"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="SHORT" map="Q"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="IFD" map="R"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="SSHORT" map="S"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="ASCII" map="T"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="RATIONAL" map="U"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="SHORT_OR_RATIONAL" map="V"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="UNDEFINED" map="W"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="DOUBLE" map="X"/>
  <field class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="name" map="Y"/>
  <method class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="int getType()" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType getFieldType(int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="java.lang.Object getValue(org.apache.commons.imaging.formats.tiff.TiffField)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="int getSize()" map="B"/>
  <method class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType" name="java.lang.String getName()" map="C"/>
  <class name="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldTypeLong" map="D"/>
  <method class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldTypeLong" name="byte[] writeData(java.lang.Object, org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldTypeLong" name="java.lang.Object getValue(org.apache.commons.imaging.formats.tiff.TiffField)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldTypeDouble" map="E"/>
  <method class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldTypeDouble" name="java.lang.Object getValue(org.apache.commons.imaging.formats.tiff.TiffField)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldTypeByte" map="F"/>
  <method class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldTypeByte" name="java.lang.Object getValue(org.apache.commons.imaging.formats.tiff.TiffField)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldTypeFloat" map="G"/>
  <method class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldTypeFloat" name="java.lang.Object getValue(org.apache.commons.imaging.formats.tiff.TiffField)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldTypeRational" map="H"/>
  <method class="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldTypeRational" name="java.lang.Object getValue(org.apache.commons.imaging.formats.tiff.TiffField)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffDirectory$ImageDataElement" map="_A"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffDirectory" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="entries" map="D"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="type" map="E"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="tiffImageData" map="F"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="jpegImageData" map="G"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="nextDirectoryOffset" map="H"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="org.apache.commons.imaging.formats.tiff.TiffField findField(org.apache.commons.imaging.formats.tiff.taginfos.TagInfo, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="java.util.List getRawImageDataElements(org.apache.commons.imaging.formats.tiff.TiffField, org.apache.commons.imaging.formats.tiff.TiffField)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="short[] getFieldValue(org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShort, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="java.lang.String description()" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="int[] getFieldValue(org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShortOrLong, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="int getSingleFieldValue(org.apache.commons.imaging.formats.tiff.taginfos.TagInfoLong)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="short getSingleFieldValue(org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShort)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="java.awt.image.BufferedImage getTiffImage(org.apache.commons.imaging.common.ByteOrder, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="java.util.List getTiffRawImageDataElements()" map="B"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="org.apache.commons.imaging.formats.tiff.TiffDirectory$ImageDataElement getJpegRawImageDataElement()" map="C"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="int[] getFieldValue(org.apache.commons.imaging.formats.tiff.taginfos.TagInfoLong, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="int getSingleFieldValue(org.apache.commons.imaging.formats.tiff.taginfos.TagInfoShortOrLong)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="void setJpegImageData(org.apache.commons.imaging.formats.tiff.JpegImageData)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="void setTiffImageData(org.apache.commons.imaging.formats.tiff.TiffImageData)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="boolean hasTiffImageData()" map="D"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="boolean hasJpegImageData()" map="E"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="org.apache.commons.imaging.formats.tiff.JpegImageData getJpegImageData()" map="F"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="org.apache.commons.imaging.formats.tiff.TiffImageData getTiffImageData()" map="G"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="java.util.List getDirectoryEntries()" map="H"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="org.apache.commons.imaging.formats.tiff.TiffField findField(org.apache.commons.imaging.formats.tiff.taginfos.TagInfo)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="java.lang.String description(int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffDirectory" name="boolean imageDataInStrips()" map="I"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffElement$DataElement" map="_A"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffElement$DataElement" name="data" map="I"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffElement$DataElement" name="byte[] getData()" map="J"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffElement$1" map="1"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffElement$1" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffElement$1" name="int compare(org.apache.commons.imaging.formats.tiff.TiffElement, org.apache.commons.imaging.formats.tiff.TiffElement)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffElement" map="B"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffElement" name="COMPARATOR" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffElement" name="length" map="B"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffElement" name="offset" map="C"/>
  <class name="org.apache.commons.imaging.formats.tiff.JpegImageData" map="C"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffImageMetadata$Directory" map="_A"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffImageMetadata$Directory" name="directory" map="n"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffImageMetadata$Directory" name="byteOrder" map="o"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffImageMetadata$Directory" name="type" map="p"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageMetadata$Directory" name="org.apache.commons.imaging.formats.tiff.TiffImageData getTiffImageData()" map="J"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageMetadata$Directory" name="org.apache.commons.imaging.formats.tiff.JpegImageData getJpegImageData()" map="K"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageMetadata$Directory" name="org.apache.commons.imaging.formats.tiff.TiffField findField(org.apache.commons.imaging.formats.tiff.taginfos.TagInfo)" map="B"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageMetadata$Directory" name="void add(org.apache.commons.imaging.formats.tiff.TiffField)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageMetadata$Directory" name="java.lang.String toString(java.lang.String)" map="B"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffImageMetadata$Item" map="_B"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffImageMetadata$Item" name="entry" map="m"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffImageMetadata" map="D"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffImageMetadata" name="tagCounts" map="&#x0426;"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffImageMetadata" name="contents" map="&#x0427;"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageMetadata" name="org.apache.commons.imaging.formats.tiff.TiffField findField(org.apache.commons.imaging.formats.tiff.taginfos.TagInfo)" map="E"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageMetadata" name="java.util.List getDirectories()" map="d"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageMetadata" name="java.util.Map countTags(java.util.List)" map="D"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageMetadata" name="org.apache.commons.imaging.formats.tiff.TiffField findField(org.apache.commons.imaging.formats.tiff.taginfos.TagInfo, boolean)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffImageParser" map="E"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffImageParser" name="ACCEPTED_EXTENSIONS" map="&#x0401;"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageParser" name="org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter getPhotometricInterpreter(org.apache.commons.imaging.formats.tiff.TiffDirectory, int, int, int[], int, int, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.formats.tiff.TiffDirectory, org.apache.commons.imaging.common.ByteOrder, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageParser" name="java.awt.Rectangle checkForSubImage(java.util.Map)" map="D"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageParser" name="java.lang.Integer getIntegerParameter(java.lang.String, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageParser" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="B"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffHeader" map="F"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffHeader" name="byteOrder" map="K"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffHeader" name="offsetToFirstIFD" map="L"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffHeader" name="tiffVersion" map="M"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffImageData$ByteSourceData" map="_A"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffImageData$ByteSourceData" name="byteSourceFile" map="J"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageData$ByteSourceData" name="byte[] getData()" map="J"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffImageData$Data" map="_B"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffImageData$Strips" map="_C"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffImageData$Strips" name="rowsPerStrip" map="D"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffImageData$Strips" name="strips" map="E"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageData$Strips" name="org.apache.commons.imaging.formats.tiff.datareaders.DataReader getDataReader(org.apache.commons.imaging.formats.tiff.TiffDirectory, org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter, int, int[], int, int, int, int, int, org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageData$Strips" name="org.apache.commons.imaging.formats.tiff.TiffElement$DataElement[] getImageData()" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageData$Strips" name="boolean stripsNotTiles()" map="B"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffImageData$Tiles" map="_D"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffImageData$Tiles" name="tiles" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffImageData$Tiles" name="tileLength" map="B"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffImageData$Tiles" name="tileWidth" map="C"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageData$Tiles" name="org.apache.commons.imaging.formats.tiff.datareaders.DataReader getDataReader(org.apache.commons.imaging.formats.tiff.TiffDirectory, org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter, int, int[], int, int, int, int, int, org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageData$Tiles" name="org.apache.commons.imaging.formats.tiff.TiffElement$DataElement[] getImageData()" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageData$Tiles" name="boolean stripsNotTiles()" map="B"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffImageData" map="G"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageData" name="org.apache.commons.imaging.formats.tiff.datareaders.DataReader getDataReader(org.apache.commons.imaging.formats.tiff.TiffDirectory, org.apache.commons.imaging.formats.tiff.photometricinterpreters.PhotometricInterpreter, int, int[], int, int, int, int, int, org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageData" name="org.apache.commons.imaging.formats.tiff.TiffElement$DataElement[] getImageData()" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffImageData" name="boolean stripsNotTiles()" map="B"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffReader$Collector" map="_A"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffReader$Collector" name="fields" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffReader$Collector" name="tiffHeader" map="B"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffReader$Collector" name="directories" map="C"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffReader$Collector" name="readThumbnails" map="D"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader$Collector" name="boolean setTiffHeader(org.apache.commons.imaging.formats.tiff.TiffHeader)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader$Collector" name="boolean readOffsetDirectories()" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader$Collector" name="boolean addDirectory(org.apache.commons.imaging.formats.tiff.TiffDirectory)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader$Collector" name="boolean addField(org.apache.commons.imaging.formats.tiff.TiffField)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader$Collector" name="boolean readImageData()" map="B"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader$Collector" name="org.apache.commons.imaging.formats.tiff.TiffContents getContents()" map="C"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffReader$FirstDirectoryCollector" map="_B"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffReader$FirstDirectoryCollector" name="readImageData" map="E"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader$FirstDirectoryCollector" name="boolean addDirectory(org.apache.commons.imaging.formats.tiff.TiffDirectory)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader$FirstDirectoryCollector" name="boolean readImageData()" map="B"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffReader$Listener" map="_C"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader$Listener" name="boolean setTiffHeader(org.apache.commons.imaging.formats.tiff.TiffHeader)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader$Listener" name="boolean readOffsetDirectories()" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader$Listener" name="boolean addDirectory(org.apache.commons.imaging.formats.tiff.TiffDirectory)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader$Listener" name="boolean addField(org.apache.commons.imaging.formats.tiff.TiffField)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader$Listener" name="boolean readImageData()" map="B"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffReader" map="H"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffReader" name="strict" map="&#x0402;"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader" name="org.apache.commons.imaging.formats.tiff.TiffContents readFirstDirectory(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map, boolean, org.apache.commons.imaging.FormatCompliance)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader" name="org.apache.commons.imaging.formats.tiff.TiffContents readContents(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map, org.apache.commons.imaging.FormatCompliance)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader" name="org.apache.commons.imaging.formats.tiff.TiffHeader readTiffHeader(java.io.InputStream, org.apache.commons.imaging.FormatCompliance)" map="B"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader" name="org.apache.commons.imaging.common.ByteOrder getTiffByteOrder(int)" map="G"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader" name="void read(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map, org.apache.commons.imaging.FormatCompliance, org.apache.commons.imaging.formats.tiff.TiffReader$Listener)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader" name="org.apache.commons.imaging.formats.tiff.JpegImageData getJpegRawImageData(org.apache.commons.imaging.common.bytesource.ByteSource, org.apache.commons.imaging.formats.tiff.TiffDirectory)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader" name="boolean readDirectory(org.apache.commons.imaging.common.bytesource.ByteSource, long, int, org.apache.commons.imaging.FormatCompliance, org.apache.commons.imaging.formats.tiff.TiffReader$Listener, java.util.List)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader" name="org.apache.commons.imaging.formats.tiff.TiffImageData getTiffRawImageData(org.apache.commons.imaging.common.bytesource.ByteSource, org.apache.commons.imaging.formats.tiff.TiffDirectory)" map="B"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader" name="void readDirectories(org.apache.commons.imaging.common.bytesource.ByteSource, org.apache.commons.imaging.FormatCompliance, org.apache.commons.imaging.formats.tiff.TiffReader$Listener)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader" name="boolean readDirectory(org.apache.commons.imaging.common.bytesource.ByteSource, long, int, org.apache.commons.imaging.FormatCompliance, org.apache.commons.imaging.formats.tiff.TiffReader$Listener, boolean, java.util.List)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader" name="org.apache.commons.imaging.formats.tiff.TiffContents readDirectories(org.apache.commons.imaging.common.bytesource.ByteSource, boolean, org.apache.commons.imaging.FormatCompliance)" map="B"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffReader" name="org.apache.commons.imaging.formats.tiff.TiffHeader readTiffHeader(org.apache.commons.imaging.common.bytesource.ByteSource, org.apache.commons.imaging.FormatCompliance)" map="A"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffField" map="I"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffField" name="sortHint" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffField" name="ALL_TAG_MAP" map="B"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffField" name="tagInfo" map="C"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffField" name="offset" map="D"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffField" name="fieldType" map="E"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffField" name="count" map="F"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffField" name="directoryType" map="G"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffField" name="byteOrder" map="H"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffField" name="value" map="I"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffField" name="tag" map="J"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="int getIntValueOrArraySum()" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="int getBytesLength()" map="B"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="java.lang.Object getValue()" map="C"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="java.lang.String getTagName()" map="D"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="int getIntValue()" map="E"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="java.util.Map makeTagMap(java.util.List, boolean, java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="org.apache.commons.imaging.common.ByteOrder getByteOrder()" map="F"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="double getDoubleValue()" map="G"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="int getDirectoryType()" map="H"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="int[] getIntArrayValue()" map="I"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="double[] getDoubleArrayValue()" map="J"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfo getTagInfo()" map="K"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfo getTag(int, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="org.apache.commons.imaging.formats.tiff.fieldtypes.FieldType getFieldType()" map="L"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="java.lang.String getValueDescription(java.lang.Object)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="long getCount()" map="M"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="java.lang.String getDescriptionWithoutValue()" map="N"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="org.apache.commons.imaging.formats.tiff.taginfos.TagInfo getTag(int, int, java.util.List)" map="A"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="java.lang.String getValueDescription()" map="O"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="byte[] getByteArrayValue()" map="P"/>
  <method class="org.apache.commons.imaging.formats.tiff.TiffField" name="int getTag()" map="Q"/>
  <class name="org.apache.commons.imaging.formats.tiff.TiffContents" map="J"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffContents" name="directories" map="A"/>
  <field class="org.apache.commons.imaging.formats.tiff.TiffContents" name="header" map="B"/>
  <package name="org.apache.commons.imaging.formats.pcx" map="M"/>
  <class name="org.apache.commons.imaging.formats.pcx.PcxConstants" map="A"/>
  <class name="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" map="_A"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="hDpi" map="A"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="xMin" map="B"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="reserved" map="C"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="encoding" map="D"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="colormap" map="E"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="yMax" map="F"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="nPlanes" map="G"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="vDpi" map="H"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="xMax" map="I"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="bytesPerLine" map="J"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="paletteInfo" map="K"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="version" map="L"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="hScreenSize" map="M"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="manufacturer" map="N"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="yMin" map="O"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="bitsPerPixel" map="P"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader" name="vScreenSize" map="Q"/>
  <class name="org.apache.commons.imaging.formats.pcx.PcxImageParser" map="B"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxImageParser" name="ACCEPTED_EXTENSIONS" map="&#x040e;"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxImageParser" name="void readScanLine(org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader, java.io.InputStream, byte[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxImageParser" name="java.awt.image.BufferedImage readImage(org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader, java.io.InputStream, org.apache.commons.imaging.common.bytesource.ByteSource)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxImageParser" name="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader readPcxHeader(org.apache.commons.imaging.common.bytesource.ByteSource)" map="K"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxImageParser" name="org.apache.commons.imaging.formats.pcx.PcxImageParser$PcxHeader readPcxHeader(java.io.InputStream, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxImageParser" name="int[] read256ColorPalette(java.io.InputStream)" map="H"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxImageParser" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxImageParser" name="int[] read256ColorPaletteFromEndOfFile(org.apache.commons.imaging.common.bytesource.ByteSource)" map="L"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxImageParser" name="java.awt.Dimension getImageSize(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="F"/>
  <class name="org.apache.commons.imaging.formats.pcx.PcxWriter" map="C"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxWriter" name="encoding" map="&#x040a;"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxWriter" name="pixelDensity" map="&#x040b;"/>
  <field class="org.apache.commons.imaging.formats.pcx.PcxWriter" name="bitDepth" map="&#x040c;"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxWriter" name="void write256ColorPCX(java.awt.image.BufferedImage, org.apache.commons.imaging.palette.SimplePalette, org.apache.commons.imaging.common.BinaryOutputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxWriter" name="void writeBlackAndWhitePCX(java.awt.image.BufferedImage, org.apache.commons.imaging.palette.SimplePalette, org.apache.commons.imaging.common.BinaryOutputStream)" map="B"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxWriter" name="void write16ColorPCX(java.awt.image.BufferedImage, org.apache.commons.imaging.palette.SimplePalette, org.apache.commons.imaging.common.BinaryOutputStream)" map="C"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxWriter" name="void write32BppPCX(java.awt.image.BufferedImage, org.apache.commons.imaging.common.BinaryOutputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxWriter" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream)" map="A"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxWriter" name="void writeScanLine(org.apache.commons.imaging.common.BinaryOutputStream, byte[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.pcx.PcxWriter" name="void write24BppPCX(java.awt.image.BufferedImage, org.apache.commons.imaging.common.BinaryOutputStream)" map="B"/>
  <package name="org.apache.commons.imaging.formats.icns" map="N"/>
  <class name="org.apache.commons.imaging.formats.icns.IcnsType" map="A"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_512x512_32BIT_ARGB_IMAGE" map="A"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_32x32_8BIT_IMAGE" map="B"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_32x32_8BIT_MASK" map="C"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="allImageTypes" map="D"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_128x128_8BIT_MASK" map="E"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_16x12_1BIT_IMAGE_AND_MASK" map="F"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_48x48_1BIT_IMAGE_AND_MASK" map="G"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="type" map="H"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_16x12_8BIT_IMAGE" map="I"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_48x48_8BIT_IMAGE" map="J"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_16x16_8BIT_MASK" map="K"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_16x16_1BIT_IMAGE_AND_MASK" map="L"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_32x32_1BIT_IMAGE_AND_MASK" map="M"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="allMaskTypes" map="N"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_16x16_32BIT_IMAGE" map="O"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="hasMask" map="P"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="height" map="Q"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_256x256_32BIT_ARGB_IMAGE" map="R"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_128x128_32BIT_IMAGE" map="S"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="width" map="T"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_16x12_4BIT_IMAGE" map="U"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_48x48_4BIT_IMAGE" map="V"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="bitsPerPixel" map="W"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_16x16_4BIT_IMAGE" map="X"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_32x32_32BIT_IMAGE" map="Y"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_32x32_4BIT_IMAGE" map="Z"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_48x48_32BIT_IMAGE" map="_"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_48x48_8BIT_MASK" map="a"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsType" name="ICNS_16x16_8BIT_IMAGE" map="b"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsType" name="int getType()" map="A"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsType" name="int getBitsPerPixel()" map="B"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsType" name="boolean hasMask()" map="C"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsType" name="org.apache.commons.imaging.formats.icns.IcnsType find8BPPMaskType(org.apache.commons.imaging.formats.icns.IcnsType)" map="A"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsType" name="org.apache.commons.imaging.formats.icns.IcnsType findImageType(int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsType" name="org.apache.commons.imaging.formats.icns.IcnsType find1BPPMaskType(org.apache.commons.imaging.formats.icns.IcnsType)" map="B"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsType" name="int typeAsInt(java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsType" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsType" name="int getWidth()" map="D"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsType" name="int getHeight()" map="E"/>
  <class name="org.apache.commons.imaging.formats.icns.IcnsDecoder" map="B"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsDecoder" name="palette_4bpp" map="A"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsDecoder" name="palette_8bpp" map="B"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsDecoder" name="void decode4BPPImage(org.apache.commons.imaging.formats.icns.IcnsType, byte[], org.apache.commons.imaging.common.ImageBuilder)" map="A"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsDecoder" name="void apply1BPPMask(byte[], org.apache.commons.imaging.common.ImageBuilder)" map="A"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsDecoder" name="java.util.List decodeAllImages(org.apache.commons.imaging.formats.icns.IcnsImageParser$IcnsElement[])" map="A"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsDecoder" name="void decode32BPPImage(org.apache.commons.imaging.formats.icns.IcnsType, byte[], org.apache.commons.imaging.common.ImageBuilder)" map="B"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsDecoder" name="void apply8BPPMask(byte[], org.apache.commons.imaging.common.ImageBuilder)" map="B"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsDecoder" name="void decode8BPPImage(org.apache.commons.imaging.formats.icns.IcnsType, byte[], org.apache.commons.imaging.common.ImageBuilder)" map="C"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsDecoder" name="void decode1BPPImage(org.apache.commons.imaging.formats.icns.IcnsType, byte[], org.apache.commons.imaging.common.ImageBuilder)" map="D"/>
  <class name="org.apache.commons.imaging.formats.icns.IcnsImageParser$IcnsContents" map="_A"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsImageParser$IcnsContents" name="icnsElements" map="A"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsImageParser$IcnsContents" name="icnsHeader" map="B"/>
  <class name="org.apache.commons.imaging.formats.icns.IcnsImageParser$IcnsElement" map="_B"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsImageParser$IcnsElement" name="elementSize" map="A"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsImageParser$IcnsElement" name="type" map="B"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsImageParser$IcnsElement" name="data" map="C"/>
  <class name="org.apache.commons.imaging.formats.icns.IcnsImageParser$IcnsHeader" map="_C"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsImageParser$IcnsHeader" name="fileSize" map="A"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsImageParser$IcnsHeader" name="magic" map="B"/>
  <class name="org.apache.commons.imaging.formats.icns.IcnsImageParser" map="C"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsImageParser" name="ACCEPTED_EXTENSIONS" map="&#x040f;"/>
  <field class="org.apache.commons.imaging.formats.icns.IcnsImageParser" name="ICNS_MAGIC" map="&#x0410;"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsImageParser" name="org.apache.commons.imaging.formats.icns.IcnsImageParser$IcnsHeader readIcnsHeader(java.io.InputStream)" map="I"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsImageParser" name="org.apache.commons.imaging.formats.icns.IcnsImageParser$IcnsContents readImage(org.apache.commons.imaging.common.bytesource.ByteSource)" map="M"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsImageParser" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.icns.IcnsImageParser" name="org.apache.commons.imaging.formats.icns.IcnsImageParser$IcnsElement readIcnsElement(java.io.InputStream)" map="J"/>
  <class name="org.apache.commons.imaging.formats.icns.Rle24Compression" map="D"/>
  <method class="org.apache.commons.imaging.formats.icns.Rle24Compression" name="byte[] decompress(int, int, byte[])" map="A"/>
  <package name="org.apache.commons.imaging.formats.psd" map="O"/>
  <package name="org.apache.commons.imaging.formats.psd.datareaders" map="A"/>
  <class name="org.apache.commons.imaging.formats.psd.datareaders.CompressedDataReader" map="A"/>
  <method class="org.apache.commons.imaging.formats.psd.datareaders.CompressedDataReader" name="void readData(java.io.InputStream, java.awt.image.BufferedImage, org.apache.commons.imaging.formats.psd.ImageContents, org.apache.commons.imaging.common.BinaryFileParser)" map="A"/>
  <class name="org.apache.commons.imaging.formats.psd.datareaders.UncompressedDataReader" map="B"/>
  <method class="org.apache.commons.imaging.formats.psd.datareaders.UncompressedDataReader" name="void readData(java.io.InputStream, java.awt.image.BufferedImage, org.apache.commons.imaging.formats.psd.ImageContents, org.apache.commons.imaging.common.BinaryFileParser)" map="A"/>
  <class name="org.apache.commons.imaging.formats.psd.datareaders.DataReader" map="C"/>
  <field class="org.apache.commons.imaging.formats.psd.datareaders.DataReader" name="dataParser" map="A"/>
  <method class="org.apache.commons.imaging.formats.psd.datareaders.DataReader" name="void dump()" map="A"/>
  <method class="org.apache.commons.imaging.formats.psd.datareaders.DataReader" name="void readData(java.io.InputStream, java.awt.image.BufferedImage, org.apache.commons.imaging.formats.psd.ImageContents, org.apache.commons.imaging.common.BinaryFileParser)" map="A"/>
  <package name="org.apache.commons.imaging.formats.psd.dataparsers" map="B"/>
  <class name="org.apache.commons.imaging.formats.psd.dataparsers.DataParserCmyk" map="A"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParserCmyk" name="int getBasicChannelsCount()" map="B"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParserCmyk" name="int getRGB(int[][][], int, int, org.apache.commons.imaging.formats.psd.ImageContents)" map="A"/>
  <class name="org.apache.commons.imaging.formats.psd.dataparsers.DataParserBitmap" map="B"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParserBitmap" name="int getBasicChannelsCount()" map="B"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParserBitmap" name="int getRGB(int[][][], int, int, org.apache.commons.imaging.formats.psd.ImageContents)" map="A"/>
  <class name="org.apache.commons.imaging.formats.psd.dataparsers.DataParserGrayscale" map="C"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParserGrayscale" name="int getBasicChannelsCount()" map="B"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParserGrayscale" name="int getRGB(int[][][], int, int, org.apache.commons.imaging.formats.psd.ImageContents)" map="A"/>
  <class name="org.apache.commons.imaging.formats.psd.dataparsers.DataParserIndexed" map="D"/>
  <field class="org.apache.commons.imaging.formats.psd.dataparsers.DataParserIndexed" name="ColorTable" map="A"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParserIndexed" name="int getBasicChannelsCount()" map="B"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParserIndexed" name="int getRGB(int[][][], int, int, org.apache.commons.imaging.formats.psd.ImageContents)" map="A"/>
  <class name="org.apache.commons.imaging.formats.psd.dataparsers.DataParser" map="E"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParser" name="void dump()" map="A"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParser" name="int getBasicChannelsCount()" map="B"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParser" name="int getRGB(int[][][], int, int, org.apache.commons.imaging.formats.psd.ImageContents)" map="A"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParser" name="void parseData(int[][][], java.awt.image.BufferedImage, org.apache.commons.imaging.formats.psd.ImageContents)" map="A"/>
  <class name="org.apache.commons.imaging.formats.psd.dataparsers.DataParserRgb" map="F"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParserRgb" name="int getBasicChannelsCount()" map="B"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParserRgb" name="int getRGB(int[][][], int, int, org.apache.commons.imaging.formats.psd.ImageContents)" map="A"/>
  <class name="org.apache.commons.imaging.formats.psd.dataparsers.DataParserLab" map="G"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParserLab" name="void dump()" map="A"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParserLab" name="int getBasicChannelsCount()" map="B"/>
  <method class="org.apache.commons.imaging.formats.psd.dataparsers.DataParserLab" name="int getRGB(int[][][], int, int, org.apache.commons.imaging.formats.psd.ImageContents)" map="A"/>
  <class name="org.apache.commons.imaging.formats.psd.PsdHeaderInfo" map="A"/>
  <field class="org.apache.commons.imaging.formats.psd.PsdHeaderInfo" name="Channels" map="A"/>
  <field class="org.apache.commons.imaging.formats.psd.PsdHeaderInfo" name="Reserved" map="B"/>
  <field class="org.apache.commons.imaging.formats.psd.PsdHeaderInfo" name="Columns" map="C"/>
  <field class="org.apache.commons.imaging.formats.psd.PsdHeaderInfo" name="Depth" map="D"/>
  <field class="org.apache.commons.imaging.formats.psd.PsdHeaderInfo" name="Rows" map="E"/>
  <field class="org.apache.commons.imaging.formats.psd.PsdHeaderInfo" name="Mode" map="F"/>
  <field class="org.apache.commons.imaging.formats.psd.PsdHeaderInfo" name="Version" map="G"/>
  <class name="org.apache.commons.imaging.formats.psd.ImageResourceBlock" map="B"/>
  <field class="org.apache.commons.imaging.formats.psd.ImageResourceBlock" name="data" map="A"/>
  <field class="org.apache.commons.imaging.formats.psd.ImageResourceBlock" name="nameData" map="B"/>
  <field class="org.apache.commons.imaging.formats.psd.ImageResourceBlock" name="id" map="C"/>
  <class name="org.apache.commons.imaging.formats.psd.PsdImageParser" map="C"/>
  <field class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="ACCEPTED_EXTENSIONS" map="&#x0411;"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="org.apache.commons.imaging.formats.psd.ImageContents readImageContents(org.apache.commons.imaging.common.bytesource.ByteSource)" map="N"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="byte[] getData(org.apache.commons.imaging.common.bytesource.ByteSource, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="java.util.List readImageResourceBlocks(org.apache.commons.imaging.common.bytesource.ByteSource, int[], int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="java.util.List readImageResourceBlocks(byte[], int[], int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="java.util.List readImageResourceBlocks(java.io.InputStream, int[], int, int)" map="A"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="org.apache.commons.imaging.formats.psd.ImageContents readImageContents(java.io.InputStream)" map="K"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="java.io.InputStream getInputStream(org.apache.commons.imaging.common.bytesource.ByteSource, int)" map="B"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="org.apache.commons.imaging.formats.psd.PsdHeaderInfo readHeader(java.io.InputStream)" map="L"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="boolean keepImageResourceBlock(int, int[])" map="B"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <method class="org.apache.commons.imaging.formats.psd.PsdImageParser" name="int getChannelsPerMode(int)" map="I"/>
  <class name="org.apache.commons.imaging.formats.psd.ImageContents" map="D"/>
  <field class="org.apache.commons.imaging.formats.psd.ImageContents" name="Compression" map="A"/>
  <field class="org.apache.commons.imaging.formats.psd.ImageContents" name="ImageResourcesLength" map="B"/>
  <field class="org.apache.commons.imaging.formats.psd.ImageContents" name="ColorModeDataLength" map="C"/>
  <field class="org.apache.commons.imaging.formats.psd.ImageContents" name="LayerAndMaskDataLength" map="D"/>
  <field class="org.apache.commons.imaging.formats.psd.ImageContents" name="header" map="E"/>
  <package name="org.apache.commons.imaging.util" map="B"/>
  <class name="org.apache.commons.imaging.util.UnicodeUtils" map="A"/>
  <method class="org.apache.commons.imaging.util.UnicodeUtils" name="boolean isValidISO_8859_1(java.lang.String)" map="A"/>
  <class name="org.apache.commons.imaging.util.ParamMap" map="B"/>
  <method class="org.apache.commons.imaging.util.ParamMap" name="boolean getParamBoolean(java.util.Map, java.lang.Object, boolean)" map="A"/>
  <class name="org.apache.commons.imaging.util.Debug" map="C"/>
  <field class="org.apache.commons.imaging.util.Debug" name="counter" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug(java.lang.String, int)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="java.lang.String getDebug(java.lang.String, byte[])" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void newline()" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="java.lang.String getDebug(java.lang.String, byte[], int)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug(java.lang.String, char[])" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug(java.lang.String, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug(java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="java.lang.String getStackTrace(java.lang.Throwable, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="java.lang.String getDebug(java.lang.Throwable, int)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="java.lang.String getDebug(java.lang.Throwable)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug(java.lang.String, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug(java.lang.Throwable)" map="B"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug(java.lang.String, java.util.List)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug(java.lang.String, int[])" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug(java.lang.String, java.awt.color.ICC_Profile)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug(java.lang.String, java.io.File)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug(java.lang.String, java.util.Calendar)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug(java.lang.String, byte[])" map="B"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug()" map="B"/>
  <method class="org.apache.commons.imaging.util.Debug" name="java.lang.String byteQuadToString(int)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="java.lang.String getStackTrace(java.lang.Throwable, int)" map="B"/>
  <method class="org.apache.commons.imaging.util.Debug" name="java.lang.String getType(java.lang.Object)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="java.lang.String getDebug(java.lang.String, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug(java.lang.String, java.lang.Object)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="java.lang.String getDebug(java.lang.String, char[])" map="B"/>
  <method class="org.apache.commons.imaging.util.Debug" name="void debug(java.lang.String, java.util.Date)" map="A"/>
  <method class="org.apache.commons.imaging.util.Debug" name="java.lang.String getDebug(java.lang.String)" map="B"/>
  <method class="org.apache.commons.imaging.util.Debug" name="java.lang.String getDebug(java.lang.String, int[])" map="B"/>
  <package name="org.apache.commons.imaging.palette" map="C"/>
  <class name="org.apache.commons.imaging.palette.SimplePalette" map="A"/>
  <field class="org.apache.commons.imaging.palette.SimplePalette" name="palette" map="A"/>
  <method class="org.apache.commons.imaging.palette.SimplePalette" name="int getPaletteIndex(int)" map="A"/>
  <method class="org.apache.commons.imaging.palette.SimplePalette" name="int getEntry(int)" map="B"/>
  <method class="org.apache.commons.imaging.palette.SimplePalette" name="int length()" map="A"/>
  <method class="org.apache.commons.imaging.palette.SimplePalette" name="int getPaletteIndex(int[], int)" map="A"/>
  <class name="org.apache.commons.imaging.palette.ColorSpaceSubset$RgbComparator" map="_A"/>
  <method class="org.apache.commons.imaging.palette.ColorSpaceSubset$RgbComparator" name="int compare(org.apache.commons.imaging.palette.ColorSpaceSubset, org.apache.commons.imaging.palette.ColorSpaceSubset)" map="A"/>
  <method class="org.apache.commons.imaging.palette.ColorSpaceSubset$RgbComparator" name="int compare(java.lang.Object, java.lang.Object)" map="compare"/>
  <class name="org.apache.commons.imaging.palette.ColorSpaceSubset" map="B"/>
  <field class="org.apache.commons.imaging.palette.ColorSpaceSubset" name="precision" map="A"/>
  <field class="org.apache.commons.imaging.palette.ColorSpaceSubset" name="index" map="B"/>
  <field class="org.apache.commons.imaging.palette.ColorSpaceSubset" name="rgb" map="C"/>
  <field class="org.apache.commons.imaging.palette.ColorSpaceSubset" name="maxs" map="D"/>
  <field class="org.apache.commons.imaging.palette.ColorSpaceSubset" name="precision_mask" map="E"/>
  <field class="org.apache.commons.imaging.palette.ColorSpaceSubset" name="total" map="F"/>
  <field class="org.apache.commons.imaging.palette.ColorSpaceSubset" name="mins" map="G"/>
  <field class="org.apache.commons.imaging.palette.ColorSpaceSubset" name="rgbComparator" map="H"/>
  <method class="org.apache.commons.imaging.palette.ColorSpaceSubset" name="void setAverageRGB(int[])" map="A"/>
  <method class="org.apache.commons.imaging.palette.ColorSpaceSubset" name="void setIndex(int)" map="A"/>
  <method class="org.apache.commons.imaging.palette.ColorSpaceSubset" name="int getIndex()" map="A"/>
  <class name="org.apache.commons.imaging.palette.QuantizedPalette" map="C"/>
  <field class="org.apache.commons.imaging.palette.QuantizedPalette" name="subsets" map="B"/>
  <field class="org.apache.commons.imaging.palette.QuantizedPalette" name="precision" map="C"/>
  <field class="org.apache.commons.imaging.palette.QuantizedPalette" name="straight" map="D"/>
  <method class="org.apache.commons.imaging.palette.QuantizedPalette" name="int getPaletteIndex(int)" map="A"/>
  <method class="org.apache.commons.imaging.palette.QuantizedPalette" name="int getEntry(int)" map="B"/>
  <method class="org.apache.commons.imaging.palette.QuantizedPalette" name="int length()" map="A"/>
  <class name="org.apache.commons.imaging.palette.PaletteFactory$DivisionCandidate" map="_A"/>
  <field class="org.apache.commons.imaging.palette.PaletteFactory$DivisionCandidate" name="dst_b" map="A"/>
  <field class="org.apache.commons.imaging.palette.PaletteFactory$DivisionCandidate" name="dst_a" map="B"/>
  <method class="org.apache.commons.imaging.palette.PaletteFactory$DivisionCandidate" name="org.apache.commons.imaging.palette.ColorSpaceSubset access$000(org.apache.commons.imaging.palette.PaletteFactory$DivisionCandidate)" map="A"/>
  <method class="org.apache.commons.imaging.palette.PaletteFactory$DivisionCandidate" name="org.apache.commons.imaging.palette.ColorSpaceSubset access$100(org.apache.commons.imaging.palette.PaletteFactory$DivisionCandidate)" map="B"/>
  <class name="org.apache.commons.imaging.palette.PaletteFactory" map="D"/>
  <method class="org.apache.commons.imaging.palette.PaletteFactory" name="boolean hasTransparency(java.awt.image.BufferedImage)" map="A"/>
  <method class="org.apache.commons.imaging.palette.PaletteFactory" name="java.util.List divide(java.util.List, int, int[], int)" map="A"/>
  <method class="org.apache.commons.imaging.palette.PaletteFactory" name="int pixelToQuantizationTableIndex(int, int)" map="A"/>
  <method class="org.apache.commons.imaging.palette.PaletteFactory" name="boolean hasTransparency(java.awt.image.BufferedImage, int)" map="A"/>
  <method class="org.apache.commons.imaging.palette.PaletteFactory" name="org.apache.commons.imaging.palette.SimplePalette makeExactRgbPaletteSimple(java.awt.image.BufferedImage, int)" map="B"/>
  <method class="org.apache.commons.imaging.palette.PaletteFactory" name="boolean isGrayscale(java.awt.image.BufferedImage)" map="B"/>
  <method class="org.apache.commons.imaging.palette.PaletteFactory" name="org.apache.commons.imaging.palette.Palette makeQuantizedRgbPalette(java.awt.image.BufferedImage, int)" map="C"/>
  <method class="org.apache.commons.imaging.palette.PaletteFactory" name="org.apache.commons.imaging.palette.PaletteFactory$DivisionCandidate divideSubset2(int[], org.apache.commons.imaging.palette.ColorSpaceSubset, int)" map="A"/>
  <method class="org.apache.commons.imaging.palette.PaletteFactory" name="org.apache.commons.imaging.palette.PaletteFactory$DivisionCandidate finishDivision(int[], org.apache.commons.imaging.palette.ColorSpaceSubset, int, int, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.palette.PaletteFactory" name="java.util.List divideSubset2(int[], org.apache.commons.imaging.palette.ColorSpaceSubset, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.palette.PaletteFactory" name="int getFrequencyTotal(int[], int[], int[], int)" map="A"/>
  <class name="org.apache.commons.imaging.palette.Palette" map="E"/>
  <method class="org.apache.commons.imaging.palette.Palette" name="int getPaletteIndex(int)" map="A"/>
  <method class="org.apache.commons.imaging.palette.Palette" name="int getEntry(int)" map="B"/>
  <method class="org.apache.commons.imaging.palette.Palette" name="int length()" map="A"/>
  <package name="org.apache.commons.imaging.color" map="D"/>
  <class name="org.apache.commons.imaging.color.ColorConversions" map="A"/>
  <method class="org.apache.commons.imaging.color.ColorConversions" name="int convertRGBtoRGB(double, double, double)" map="A"/>
  <method class="org.apache.commons.imaging.color.ColorConversions" name="int convertCIELabtoARGBTest(int, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.color.ColorConversions" name="int convertCMYKtoRGB(int, int, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.color.ColorConversions" name="org.apache.commons.imaging.color.ColorCmy convertCMYKtoCMY(double, double, double, double)" map="A"/>
  <method class="org.apache.commons.imaging.color.ColorConversions" name="double cube(double)" map="A"/>
  <method class="org.apache.commons.imaging.color.ColorConversions" name="int convertCMYtoRGB(org.apache.commons.imaging.color.ColorCmy)" map="A"/>
  <class name="org.apache.commons.imaging.color.ColorCmy" map="B"/>
  <field class="org.apache.commons.imaging.color.ColorCmy" name="Y" map="A"/>
  <field class="org.apache.commons.imaging.color.ColorCmy" name="C" map="B"/>
  <field class="org.apache.commons.imaging.color.ColorCmy" name="M" map="C"/>
  <method class="org.apache.commons.imaging.color.ColorCmy" name="java.lang.String toString()" map="toString"/>
  <package name="org.apache.commons.imaging.common" map="E"/>
  <package name="org.apache.commons.imaging.common.bytesource" map="A"/>
  <class name="org.apache.commons.imaging.common.bytesource.ByteSourceFile" map="A"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSourceFile" name="byte[] getBlock(long, int)" map="A"/>
  <class name="org.apache.commons.imaging.common.bytesource.ByteSourceArray" map="B"/>
  <field class="org.apache.commons.imaging.common.bytesource.ByteSourceArray" name="bytes" map="B"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSourceArray" name="byte[] getBlock(long, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSourceArray" name="long getLength()" map="B"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSourceArray" name="java.io.InputStream getInputStream()" map="C"/>
  <class name="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$1" map="1"/>
  <class name="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheBlock" map="_A"/>
  <field class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheBlock" name="this$0" map="A"/>
  <field class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheBlock" name="bytes" map="B"/>
  <field class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheBlock" name="next" map="C"/>
  <field class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheBlock" name="triedNext" map="D"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheBlock" name="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheBlock getNext()" map="A"/>
  <class name="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheReadingInputStream" map="_B"/>
  <field class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheReadingInputStream" name="this$0" map="A"/>
  <field class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheReadingInputStream" name="blockIndex" map="B"/>
  <field class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheReadingInputStream" name="readFirst" map="C"/>
  <field class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheReadingInputStream" name="block" map="D"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheReadingInputStream" name="long skip(long)" map="skip"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheReadingInputStream" name="int read()" map="read"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheReadingInputStream" name="int read(byte[], int, int)" map="read"/>
  <class name="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream" map="C"/>
  <field class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream" name="streamLength" map="C"/>
  <field class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream" name="readBuffer" map="D"/>
  <field class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream" name="is" map="E"/>
  <field class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream" name="cacheHead" map="F"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream" name="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheBlock readBlock()" map="D"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream" name="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheBlock access$100(org.apache.commons.imaging.common.bytesource.ByteSourceInputStream)" map="A"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream" name="byte[] getBlock(long, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream" name="long getLength()" map="B"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream" name="java.io.InputStream getInputStream()" map="C"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream" name="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheBlock getFirstBlock()" map="E"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream" name="org.apache.commons.imaging.common.bytesource.ByteSourceInputStream$CacheBlock access$000(org.apache.commons.imaging.common.bytesource.ByteSourceInputStream)" map="B"/>
  <class name="org.apache.commons.imaging.common.bytesource.ByteSource" map="D"/>
  <field class="org.apache.commons.imaging.common.bytesource.ByteSource" name="filename" map="A"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSource" name="java.lang.String getFilename()" map="A"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSource" name="java.io.InputStream getInputStream(long)" map="A"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSource" name="byte[] getBlock(long, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSource" name="long getLength()" map="B"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSource" name="java.io.InputStream getInputStream()" map="C"/>
  <method class="org.apache.commons.imaging.common.bytesource.ByteSource" name="byte[] getBlock(int, int)" map="A"/>
  <package name="org.apache.commons.imaging.common.mylzw" map="B"/>
  <class name="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor$Listener" map="_A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor$Listener" name="void init(int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor$Listener" name="void code(int)" map="A"/>
  <class name="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" map="A"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="codes" map="A"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="listener" map="B"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="eoiCode" map="C"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="written" map="D"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="initialCodeSize" map="E"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="clearCode" map="F"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="tiffLZWMode" map="G"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="codeSize" map="H"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="byteOrder" map="I"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="table" map="J"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="boolean isInTable(int)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="void writeToResult(java.io.OutputStream, byte[])" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="byte[] stringFromCode(int)" map="B"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="void checkCodeSize()" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="byte firstChar(byte[])" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="int getNextCode(org.apache.commons.imaging.common.mylzw.MyBitInputStream)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="void InitializeTable()" map="B"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="void addStringToTable(byte[])" map="B"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="byte[] decompress(java.io.InputStream, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="void clearTable()" map="C"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="void setTiffLZWMode()" map="D"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="byte[] appendBytes(byte[], byte)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwDecompressor" name="void incrementCodeSize()" map="E"/>
  <class name="org.apache.commons.imaging.common.mylzw.MyLzwCompressor$Listener" map="_A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor$Listener" name="void init(int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor$Listener" name="void eoiCode(int)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor$Listener" name="void dataCode(int)" map="B"/>
  <class name="org.apache.commons.imaging.common.mylzw.MyLzwCompressor$ByteArray" map="_B"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor$ByteArray" name="bytes" map="A"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor$ByteArray" name="length" map="B"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor$ByteArray" name="hash" map="C"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor$ByteArray" name="start" map="D"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor$ByteArray" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor$ByteArray" name="int hashCode()" map="hashCode"/>
  <class name="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" map="B"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="codes" map="A"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="map" map="B"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="listener" map="C"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="eoiCode" map="D"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="initialCodeSize" map="E"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="clearCode" map="F"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="codeSize" map="G"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="byteOrder" map="H"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="earlyLimit" map="I"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="org.apache.commons.imaging.common.mylzw.MyLzwCompressor$ByteArray arrayToKey(byte[], int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="boolean addTableEntry(org.apache.commons.imaging.common.mylzw.MyBitOutputStream, byte[], int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="void writeClearCode(org.apache.commons.imaging.common.mylzw.MyBitOutputStream)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="int codeFromString(byte[], int, int)" map="B"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="void writeCode(org.apache.commons.imaging.common.mylzw.MyBitOutputStream, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="void writeDataCode(org.apache.commons.imaging.common.mylzw.MyBitOutputStream, int)" map="B"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="void writeEoiCode(org.apache.commons.imaging.common.mylzw.MyBitOutputStream)" map="B"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="byte[] compress(byte[])" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="void InitializeStringTable()" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="boolean addTableEntry(org.apache.commons.imaging.common.mylzw.MyBitOutputStream, org.apache.commons.imaging.common.mylzw.MyLzwCompressor$ByteArray)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="void clearTable()" map="B"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="org.apache.commons.imaging.common.mylzw.MyLzwCompressor$ByteArray arrayToKey(byte)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="boolean isInTable(byte[], int, int)" map="C"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyLzwCompressor" name="void incrementCodeSize()" map="C"/>
  <class name="org.apache.commons.imaging.common.mylzw.BitsToByteInputStream" map="C"/>
  <field class="org.apache.commons.imaging.common.mylzw.BitsToByteInputStream" name="desiredDepth" map="A"/>
  <field class="org.apache.commons.imaging.common.mylzw.BitsToByteInputStream" name="is" map="B"/>
  <method class="org.apache.commons.imaging.common.mylzw.BitsToByteInputStream" name="int read()" map="read"/>
  <method class="org.apache.commons.imaging.common.mylzw.BitsToByteInputStream" name="int[] readBitsArray(int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.BitsToByteInputStream" name="int readBits(int)" map="A"/>
  <class name="org.apache.commons.imaging.common.mylzw.MyBitOutputStream" map="D"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyBitOutputStream" name="bitCache" map="A"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyBitOutputStream" name="byteOrder" map="B"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyBitOutputStream" name="bytesWritten" map="C"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyBitOutputStream" name="os" map="D"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyBitOutputStream" name="bitsInCache" map="E"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyBitOutputStream" name="void flushCache()" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyBitOutputStream" name="void writeBits(int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyBitOutputStream" name="void write(int)" map="write"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyBitOutputStream" name="void actualWrite(int)" map="A"/>
  <class name="org.apache.commons.imaging.common.mylzw.MyBitInputStream" map="E"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyBitInputStream" name="bitCache" map="A"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyBitInputStream" name="byteOrder" map="B"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyBitInputStream" name="tiffLZWMode" map="C"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyBitInputStream" name="is" map="D"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyBitInputStream" name="bytesRead" map="E"/>
  <field class="org.apache.commons.imaging.common.mylzw.MyBitInputStream" name="bitsInCache" map="F"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyBitInputStream" name="int read()" map="read"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyBitInputStream" name="int readBits(int)" map="A"/>
  <method class="org.apache.commons.imaging.common.mylzw.MyBitInputStream" name="void setTiffLZWMode()" map="A"/>
  <package name="org.apache.commons.imaging.common.itu_t4" map="C"/>
  <class name="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" map="A"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="controlCodes" map="A"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="whiteRunLengths" map="B"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="blackRunLengths" map="C"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables$Entry lowerBound(org.apache.commons.imaging.common.itu_t4.T4_T6_Tables$Entry[], int)" map="A"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="void writeRunLength(org.apache.commons.imaging.common.BitArrayOutputStream, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="byte[] compressT4_1D(byte[], int, int, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="int readTotalRunLength(org.apache.commons.imaging.common.BitInputStreamFlexible, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="boolean isEOL(org.apache.commons.imaging.common.itu_t4.T4_T6_Tables$Entry, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="int nextChangingElement(int[], int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="byte[] decompressT4_2D(byte[], int, int, boolean)" map="B"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="void fillRange(org.apache.commons.imaging.common.BitArrayOutputStream, int[], int, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="int changingElementAt(int[], int)" map="A"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="byte[] decompressT6(byte[], int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="byte[] compressModifiedHuffman(byte[], int, int)" map="B"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="void compress1DLine(org.apache.commons.imaging.common.BitInputStreamFlexible, org.apache.commons.imaging.common.BitArrayOutputStream, int[], int)" map="A"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="byte[] compressT4_2D(byte[], int, int, boolean, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="byte[] decompressModifiedHuffman(byte[], int, int)" map="C"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="byte[] decompressT4_1D(byte[], int, int, boolean)" map="C"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4AndT6Compression" name="byte[] compressT6(byte[], int, int)" map="D"/>
  <class name="org.apache.commons.imaging.common.itu_t4.HuffmanTree$Node" map="_A"/>
  <field class="org.apache.commons.imaging.common.itu_t4.HuffmanTree$Node" name="value" map="A"/>
  <field class="org.apache.commons.imaging.common.itu_t4.HuffmanTree$Node" name="isEmpty" map="B"/>
  <class name="org.apache.commons.imaging.common.itu_t4.HuffmanTree$1" map="1"/>
  <class name="org.apache.commons.imaging.common.itu_t4.HuffmanTree" map="B"/>
  <field class="org.apache.commons.imaging.common.itu_t4.HuffmanTree" name="nodes" map="A"/>
  <method class="org.apache.commons.imaging.common.itu_t4.HuffmanTree" name="java.lang.Object decode(org.apache.commons.imaging.common.BitInputStreamFlexible)" map="A"/>
  <method class="org.apache.commons.imaging.common.itu_t4.HuffmanTree" name="void insert(java.lang.String, java.lang.Object)" map="A"/>
  <method class="org.apache.commons.imaging.common.itu_t4.HuffmanTree" name="org.apache.commons.imaging.common.itu_t4.HuffmanTree$Node growAndGetNode(int)" map="A"/>
  <class name="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables$Entry" map="_A"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables$Entry" name="bitString" map="A"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables$Entry" name="value" map="B"/>
  <method class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables$Entry" name="void writeBits(org.apache.commons.imaging.common.BitArrayOutputStream)" map="A"/>
  <class name="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" map="C"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="additionalMakeUpCodes" map="A"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="V0" map="B"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="P" map="C"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="VL3" map="D"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="VL2" map="E"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="VL1" map="F"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="VR3" map="G"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="VR2" map="H"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="blackMakeUpCodes" map="I"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="EOL" map="J"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="VR1" map="K"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="H" map="L"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="blackTerminatingCodes" map="M"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="whiteMakeUpCodes" map="N"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="EOL19" map="O"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="EOL18" map="P"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="EOL17" map="Q"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="whiteTerminatingCodes" map="R"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="EOL16" map="S"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="EOL15" map="T"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="EOL14" map="U"/>
  <field class="org.apache.commons.imaging.common.itu_t4.T4_T6_Tables" name="EOL13" map="V"/>
  <class name="org.apache.commons.imaging.common.itu_t4.HuffmanTreeException" map="D"/>
  <class name="org.apache.commons.imaging.common.ImageBuilder" map="A"/>
  <field class="org.apache.commons.imaging.common.ImageBuilder" name="height" map="A"/>
  <field class="org.apache.commons.imaging.common.ImageBuilder" name="hasAlpha" map="B"/>
  <field class="org.apache.commons.imaging.common.ImageBuilder" name="width" map="C"/>
  <field class="org.apache.commons.imaging.common.ImageBuilder" name="data" map="D"/>
  <method class="org.apache.commons.imaging.common.ImageBuilder" name="void setRGB(int, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.ImageBuilder" name="int getRGB(int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.ImageBuilder" name="java.awt.image.BufferedImage makeBufferedImage(int[], int, int, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.common.ImageBuilder" name="int getWidth()" map="A"/>
  <method class="org.apache.commons.imaging.common.ImageBuilder" name="java.awt.image.BufferedImage getSubimage(int, int, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.ImageBuilder" name="java.awt.image.BufferedImage getBufferedImage()" map="B"/>
  <method class="org.apache.commons.imaging.common.ImageBuilder" name="int getHeight()" map="C"/>
  <class name="org.apache.commons.imaging.common.ZLibUtils" map="B"/>
  <method class="org.apache.commons.imaging.common.ZLibUtils" name="byte[] deflate(byte[])" map="B"/>
  <method class="org.apache.commons.imaging.common.ZLibUtils" name="byte[] inflate(byte[])" map="C"/>
  <class name="org.apache.commons.imaging.common.BinaryOutputStream" map="C"/>
  <field class="org.apache.commons.imaging.common.BinaryOutputStream" name="debug" map="A"/>
  <field class="org.apache.commons.imaging.common.BinaryOutputStream" name="byteOrder" map="B"/>
  <field class="org.apache.commons.imaging.common.BinaryOutputStream" name="count" map="C"/>
  <field class="org.apache.commons.imaging.common.BinaryOutputStream" name="os" map="D"/>
  <method class="org.apache.commons.imaging.common.BinaryOutputStream" name="void flush()" map="flush"/>
  <method class="org.apache.commons.imaging.common.BinaryOutputStream" name="void write(byte[], int, int)" map="write"/>
  <method class="org.apache.commons.imaging.common.BinaryOutputStream" name="void write(byte[])" map="write"/>
  <method class="org.apache.commons.imaging.common.BinaryOutputStream" name="void write2Bytes(int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryOutputStream" name="void write(int)" map="write"/>
  <method class="org.apache.commons.imaging.common.BinaryOutputStream" name="void close()" map="close"/>
  <method class="org.apache.commons.imaging.common.BinaryOutputStream" name="void write4Bytes(int)" map="B"/>
  <class name="org.apache.commons.imaging.common.RationalNumber" map="D"/>
  <field class="org.apache.commons.imaging.common.RationalNumber" name="numerator" map="A"/>
  <field class="org.apache.commons.imaging.common.RationalNumber" name="nf" map="B"/>
  <field class="org.apache.commons.imaging.common.RationalNumber" name="divisor" map="C"/>
  <method class="org.apache.commons.imaging.common.RationalNumber" name="double doubleValue()" map="doubleValue"/>
  <method class="org.apache.commons.imaging.common.RationalNumber" name="org.apache.commons.imaging.common.RationalNumber negate()" map="A"/>
  <method class="org.apache.commons.imaging.common.RationalNumber" name="long gcd(long, long)" map="A"/>
  <method class="org.apache.commons.imaging.common.RationalNumber" name="int intValue()" map="intValue"/>
  <method class="org.apache.commons.imaging.common.RationalNumber" name="float floatValue()" map="floatValue"/>
  <method class="org.apache.commons.imaging.common.RationalNumber" name="long longValue()" map="longValue"/>
  <method class="org.apache.commons.imaging.common.RationalNumber" name="org.apache.commons.imaging.common.RationalNumber factoryMethod(long, long)" map="B"/>
  <method class="org.apache.commons.imaging.common.RationalNumber" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.commons.imaging.common.PackBits" map="E"/>
  <method class="org.apache.commons.imaging.common.PackBits" name="int findNextDuplicate(byte[], int)" map="A"/>
  <method class="org.apache.commons.imaging.common.PackBits" name="int findRunLength(byte[], int)" map="B"/>
  <method class="org.apache.commons.imaging.common.PackBits" name="byte[] compress(byte[])" map="A"/>
  <method class="org.apache.commons.imaging.common.PackBits" name="byte[] decompress(byte[], int)" map="C"/>
  <class name="org.apache.commons.imaging.common.BinaryFunctions" map="F"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="int findNull(byte[])" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="int read2Bytes(java.lang.String, java.io.InputStream, java.lang.String, org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="void printCharQuad(java.lang.String, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="boolean compareBytes(byte[], int, byte[], int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="byte[] readBytes(java.lang.String, java.io.InputStream, int, java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="byte readByte(java.lang.String, java.io.InputStream, java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="byte[] remainingBytes(java.lang.String, byte[], int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="void copyStreamToStream(java.io.InputStream, java.io.OutputStream)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="int findNull(byte[], int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="byte[] readBytes(java.io.InputStream, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="boolean startsWith(byte[], byte[])" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="void printByteBits(java.lang.String, byte)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="void skipBytes(java.io.InputStream, long)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="int read3Bytes(java.lang.String, java.io.InputStream, java.lang.String, org.apache.commons.imaging.common.ByteOrder)" map="B"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="byte[] head(byte[], int)" map="B"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="byte[] readBytes(java.lang.String, java.io.InputStream, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="void readAndVerifyBytes(java.io.InputStream, org.apache.commons.imaging.common.BinaryConstant, java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="void readAndVerifyBytes(java.io.InputStream, byte[], java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="byte[] getStreamBytes(java.io.InputStream)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="int charsToQuad(char, char, char, char)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="byte[] slice(byte[], int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="int read4Bytes(java.lang.String, java.io.InputStream, java.lang.String, org.apache.commons.imaging.common.ByteOrder)" map="C"/>
  <method class="org.apache.commons.imaging.common.BinaryFunctions" name="void skipBytes(java.io.InputStream, long, java.lang.String)" map="A"/>
  <class name="org.apache.commons.imaging.common.BitInputStreamFlexible" map="G"/>
  <field class="org.apache.commons.imaging.common.BitInputStreamFlexible" name="cache" map="A"/>
  <field class="org.apache.commons.imaging.common.BitInputStreamFlexible" name="cacheBitsRemaining" map="B"/>
  <field class="org.apache.commons.imaging.common.BitInputStreamFlexible" name="is" map="C"/>
  <field class="org.apache.commons.imaging.common.BitInputStreamFlexible" name="bytesRead" map="D"/>
  <method class="org.apache.commons.imaging.common.BitInputStreamFlexible" name="int read()" map="read"/>
  <method class="org.apache.commons.imaging.common.BitInputStreamFlexible" name="void flushCache()" map="A"/>
  <method class="org.apache.commons.imaging.common.BitInputStreamFlexible" name="int readBits(int)" map="A"/>
  <class name="org.apache.commons.imaging.common.BitInputStream" map="H"/>
  <field class="org.apache.commons.imaging.common.BitInputStream" name="cache" map="A"/>
  <field class="org.apache.commons.imaging.common.BitInputStream" name="byteOrder" map="B"/>
  <field class="org.apache.commons.imaging.common.BitInputStream" name="cacheBitsRemaining" map="C"/>
  <field class="org.apache.commons.imaging.common.BitInputStream" name="is" map="D"/>
  <field class="org.apache.commons.imaging.common.BitInputStream" name="bytes_read" map="E"/>
  <method class="org.apache.commons.imaging.common.BitInputStream" name="int read()" map="read"/>
  <method class="org.apache.commons.imaging.common.BitInputStream" name="void flushCache()" map="A"/>
  <method class="org.apache.commons.imaging.common.BitInputStream" name="int readBits(int)" map="A"/>
  <class name="org.apache.commons.imaging.common.FastByteArrayOutputStream" map="I"/>
  <field class="org.apache.commons.imaging.common.FastByteArrayOutputStream" name="bytes" map="A"/>
  <field class="org.apache.commons.imaging.common.FastByteArrayOutputStream" name="count" map="B"/>
  <method class="org.apache.commons.imaging.common.FastByteArrayOutputStream" name="void write(int)" map="write"/>
  <method class="org.apache.commons.imaging.common.FastByteArrayOutputStream" name="byte[] toByteArray()" map="A"/>
  <class name="org.apache.commons.imaging.common.SimpleBufferedImageFactory" map="J"/>
  <method class="org.apache.commons.imaging.common.SimpleBufferedImageFactory" name="java.awt.image.BufferedImage getGrayscaleBufferedImage(int, int, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.common.SimpleBufferedImageFactory" name="java.awt.image.BufferedImage getColorBufferedImage(int, int, boolean)" map="B"/>
  <class name="org.apache.commons.imaging.common.ByteOrder" map="K"/>
  <field class="org.apache.commons.imaging.common.ByteOrder" name="MOTOROLA" map="A"/>
  <field class="org.apache.commons.imaging.common.ByteOrder" name="NETWORK" map="B"/>
  <field class="org.apache.commons.imaging.common.ByteOrder" name="BIG_ENDIAN" map="C"/>
  <field class="org.apache.commons.imaging.common.ByteOrder" name="$VALUES" map="D"/>
  <field class="org.apache.commons.imaging.common.ByteOrder" name="INTEL" map="E"/>
  <field class="org.apache.commons.imaging.common.ByteOrder" name="LITTLE_ENDIAN" map="F"/>
  <method class="org.apache.commons.imaging.common.ByteOrder" name="org.apache.commons.imaging.common.ByteOrder[] values()" map="values"/>
  <method class="org.apache.commons.imaging.common.ByteOrder" name="org.apache.commons.imaging.common.ByteOrder valueOf(java.lang.String)" map="valueOf"/>
  <class name="org.apache.commons.imaging.common.ImageMetadata$Item" map="_A"/>
  <field class="org.apache.commons.imaging.common.ImageMetadata$Item" name="keyword" map="k"/>
  <field class="org.apache.commons.imaging.common.ImageMetadata$Item" name="text" map="l"/>
  <method class="org.apache.commons.imaging.common.ImageMetadata$Item" name="java.lang.String toString(java.lang.String)" map="B"/>
  <method class="org.apache.commons.imaging.common.ImageMetadata$Item" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.commons.imaging.common.ImageMetadata" map="L"/>
  <field class="org.apache.commons.imaging.common.ImageMetadata" name="newline" map="i"/>
  <field class="org.apache.commons.imaging.common.ImageMetadata" name="items" map="j"/>
  <method class="org.apache.commons.imaging.common.ImageMetadata" name="void add(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.common.ImageMetadata" name="void add(org.apache.commons.imaging.common.IImageMetadata$IImageMetadataItem)" map="A"/>
  <method class="org.apache.commons.imaging.common.ImageMetadata" name="java.lang.String toString(java.lang.String)" map="B"/>
  <method class="org.apache.commons.imaging.common.ImageMetadata" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.commons.imaging.common.ImageMetadata" name="java.util.List getItems()" map="I"/>
  <class name="org.apache.commons.imaging.common.IBufferedImageFactory" map="M"/>
  <method class="org.apache.commons.imaging.common.IBufferedImageFactory" name="java.awt.image.BufferedImage getGrayscaleBufferedImage(int, int, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.common.IBufferedImageFactory" name="java.awt.image.BufferedImage getColorBufferedImage(int, int, boolean)" map="B"/>
  <class name="org.apache.commons.imaging.common.RationalNumberUtilities$Option" map="_A"/>
  <field class="org.apache.commons.imaging.common.RationalNumberUtilities$Option" name="error" map="A"/>
  <field class="org.apache.commons.imaging.common.RationalNumberUtilities$Option" name="rationalNumber" map="B"/>
  <method class="org.apache.commons.imaging.common.RationalNumberUtilities$Option" name="org.apache.commons.imaging.common.RationalNumberUtilities$Option factory(org.apache.commons.imaging.common.RationalNumber, double)" map="A"/>
  <method class="org.apache.commons.imaging.common.RationalNumberUtilities$Option" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.commons.imaging.common.RationalNumberUtilities" map="N"/>
  <method class="org.apache.commons.imaging.common.RationalNumberUtilities" name="org.apache.commons.imaging.common.RationalNumber getRationalNumber(double)" map="A"/>
  <class name="org.apache.commons.imaging.common.IImageMetadata$IImageMetadataItem" map="_A"/>
  <method class="org.apache.commons.imaging.common.IImageMetadata$IImageMetadataItem" name="java.lang.String toString(java.lang.String)" map="B"/>
  <class name="org.apache.commons.imaging.common.IImageMetadata" map="O"/>
  <class name="org.apache.commons.imaging.common.BinaryInputStream" map="P"/>
  <field class="org.apache.commons.imaging.common.BinaryInputStream" name="debug" map="A"/>
  <field class="org.apache.commons.imaging.common.BinaryInputStream" name="byteOrder" map="B"/>
  <field class="org.apache.commons.imaging.common.BinaryInputStream" name="is" map="C"/>
  <method class="org.apache.commons.imaging.common.BinaryInputStream" name="void readAndVerifyBytes(byte[], java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryInputStream" name="int read4Bytes(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryInputStream" name="int read4Bytes(java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryInputStream" name="int read3Bytes(java.lang.String, java.lang.String)" map="B"/>
  <method class="org.apache.commons.imaging.common.BinaryInputStream" name="int read2Bytes(java.lang.String, java.lang.String)" map="C"/>
  <method class="org.apache.commons.imaging.common.BinaryInputStream" name="byte readByte(java.lang.String, java.lang.String)" map="D"/>
  <method class="org.apache.commons.imaging.common.BinaryInputStream" name="int read2Bytes(java.lang.String)" map="B"/>
  <method class="org.apache.commons.imaging.common.BinaryInputStream" name="int read()" map="read"/>
  <method class="org.apache.commons.imaging.common.BinaryInputStream" name="byte[] readBytes(java.lang.String, int, java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryInputStream" name="byte[] readBytes(int, java.lang.String)" map="A"/>
  <class name="org.apache.commons.imaging.common.BinaryConstant" map="Q"/>
  <field class="org.apache.commons.imaging.common.BinaryConstant" name="value" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryConstant" name="void writeTo(java.io.OutputStream)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryConstant" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.commons.imaging.common.BinaryConstant" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.commons.imaging.common.BinaryConstant" name="byte[] toByteArray()" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryConstant" name="org.apache.commons.imaging.common.BinaryConstant clone()" map="B"/>
  <method class="org.apache.commons.imaging.common.BinaryConstant" name="java.lang.Object clone()" map="clone"/>
  <method class="org.apache.commons.imaging.common.BinaryConstant" name="int size()" map="C"/>
  <method class="org.apache.commons.imaging.common.BinaryConstant" name="byte get(int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryConstant" name="boolean equals(byte[])" map="A"/>
  <class name="org.apache.commons.imaging.common.BinaryFileParser" map="R"/>
  <field class="org.apache.commons.imaging.common.BinaryFileParser" name="debug" map="A"/>
  <field class="org.apache.commons.imaging.common.BinaryFileParser" name="byteOrder" map="B"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="int findNull(byte[])" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="void setByteOrder(org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="int toInt(byte[])" map="B"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="int toUInt16(byte[], int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="void printCharQuad(java.lang.String, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="void skipBytes(java.io.InputStream, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="int toUInt16(byte[])" map="C"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="void setDebug(boolean)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="int read2Bytes(java.lang.String, java.io.InputStream, java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="void debugNumber(java.io.PrintWriter, java.lang.String, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="int read4Bytes(java.lang.String, java.io.InputStream, java.lang.String)" map="B"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="byte[] readBytes(java.lang.String, java.io.InputStream, int, java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="byte readByte(java.lang.String, java.io.InputStream, java.lang.String)" map="C"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="org.apache.commons.imaging.common.ByteOrder getByteOrder()" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="byte[] remainingBytes(java.lang.String, byte[], int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="int findNull(byte[], int)" map="B"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="boolean getDebug()" map="B"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="boolean startsWith(byte[], org.apache.commons.imaging.common.BinaryConstant)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="byte[] readBytes(java.io.InputStream, int)" map="B"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="boolean startsWith(byte[], byte[])" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="void printByteBits(java.lang.String, byte)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="void skipBytes(java.io.InputStream, long)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="byte[] readBytes(java.lang.String, java.io.InputStream, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="void readAndVerifyBytes(java.io.InputStream, org.apache.commons.imaging.common.BinaryConstant, java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="void debugNumber(java.lang.String, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="void readAndVerifyBytes(java.io.InputStream, byte[], java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="void debugNumber(java.lang.String, int)" map="B"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="byte[] getStreamBytes(java.io.InputStream)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="byte[] slice(byte[], int, int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BinaryFileParser" name="void skipBytes(java.io.InputStream, long, java.lang.String)" map="A"/>
  <class name="org.apache.commons.imaging.common.BitArrayOutputStream" map="S"/>
  <field class="org.apache.commons.imaging.common.BitArrayOutputStream" name="buffer" map="A"/>
  <field class="org.apache.commons.imaging.common.BitArrayOutputStream" name="cache" map="B"/>
  <field class="org.apache.commons.imaging.common.BitArrayOutputStream" name="cacheMask" map="C"/>
  <field class="org.apache.commons.imaging.common.BitArrayOutputStream" name="bytesWritten" map="D"/>
  <method class="org.apache.commons.imaging.common.BitArrayOutputStream" name="int getBitsAvailableInCurrentByte()" map="A"/>
  <method class="org.apache.commons.imaging.common.BitArrayOutputStream" name="void writeBit(int)" map="A"/>
  <method class="org.apache.commons.imaging.common.BitArrayOutputStream" name="void writeByte(int)" map="B"/>
  <method class="org.apache.commons.imaging.common.BitArrayOutputStream" name="void flush()" map="flush"/>
  <method class="org.apache.commons.imaging.common.BitArrayOutputStream" name="void write(int)" map="write"/>
  <method class="org.apache.commons.imaging.common.BitArrayOutputStream" name="void close()" map="close"/>
  <method class="org.apache.commons.imaging.common.BitArrayOutputStream" name="byte[] toByteArray()" map="B"/>
  <class name="org.apache.commons.imaging.common.BasicCParser" map="T"/>
  <field class="org.apache.commons.imaging.common.BasicCParser" name="is" map="A"/>
  <method class="org.apache.commons.imaging.common.BasicCParser" name="java.lang.String[] tokenizeRow(java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.common.BasicCParser" name="void unescapeString(java.lang.StringBuilder, java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.common.BasicCParser" name="java.io.ByteArrayOutputStream preprocess(java.io.InputStream, java.lang.StringBuilder, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.common.BasicCParser" name="java.lang.String nextToken()" map="A"/>
  <class name="org.apache.commons.imaging.common.ByteConversions" map="U"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="int[] toUInt16s(byte[], org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="void toBytes(short, org.apache.commons.imaging.common.ByteOrder, byte[], int)" map="A"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="void toBytes(org.apache.commons.imaging.common.RationalNumber, org.apache.commons.imaging.common.ByteOrder, byte[], int)" map="A"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="org.apache.commons.imaging.common.RationalNumber[] toRationals(byte[], org.apache.commons.imaging.common.ByteOrder)" map="B"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="org.apache.commons.imaging.common.RationalNumber toRational(byte[], org.apache.commons.imaging.common.ByteOrder)" map="C"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="byte[] toBytes(short[], org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="double[] toDoubles(byte[], int, int, org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="short[] toShorts(byte[], org.apache.commons.imaging.common.ByteOrder)" map="D"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="double toDouble(byte[], int, org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="int toInt(byte[], int, org.apache.commons.imaging.common.ByteOrder)" map="B"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="int toUInt16(byte[], int, org.apache.commons.imaging.common.ByteOrder)" map="C"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="float toFloat(byte[], org.apache.commons.imaging.common.ByteOrder)" map="E"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="void toBytes(int, org.apache.commons.imaging.common.ByteOrder, byte[], int)" map="A"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="org.apache.commons.imaging.common.RationalNumber toRational(byte[], int, org.apache.commons.imaging.common.ByteOrder)" map="D"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="byte[] toBytes(int, org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="float[] toFloats(byte[], org.apache.commons.imaging.common.ByteOrder)" map="F"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="short toShort(byte[], org.apache.commons.imaging.common.ByteOrder)" map="G"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="int toUInt16(byte[], org.apache.commons.imaging.common.ByteOrder)" map="H"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="byte[] toBytes(short[], int, int, org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="double[] toDoubles(byte[], org.apache.commons.imaging.common.ByteOrder)" map="I"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="float toFloat(byte[], int, org.apache.commons.imaging.common.ByteOrder)" map="E"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="int toInt(byte[], org.apache.commons.imaging.common.ByteOrder)" map="J"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="int[] toInts(byte[], int, int, org.apache.commons.imaging.common.ByteOrder)" map="B"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="int[] toInts(byte[], org.apache.commons.imaging.common.ByteOrder)" map="K"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="byte[] toBytes(int[], org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="short[] toShorts(byte[], int, int, org.apache.commons.imaging.common.ByteOrder)" map="C"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="byte[] toBytes(int[], int, int, org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="byte[] toBytes(org.apache.commons.imaging.common.RationalNumber[], int, int, org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="int[] toUInt16s(byte[], int, int, org.apache.commons.imaging.common.ByteOrder)" map="D"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="float[] toFloats(byte[], int, int, org.apache.commons.imaging.common.ByteOrder)" map="E"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="short toShort(byte[], int, org.apache.commons.imaging.common.ByteOrder)" map="F"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="byte[] toBytes(short, org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="byte[] toBytes(org.apache.commons.imaging.common.RationalNumber[], org.apache.commons.imaging.common.ByteOrder)" map="A"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="org.apache.commons.imaging.common.RationalNumber[] toRationals(byte[], int, int, org.apache.commons.imaging.common.ByteOrder)" map="F"/>
  <method class="org.apache.commons.imaging.common.ByteConversions" name="double toDouble(byte[], org.apache.commons.imaging.common.ByteOrder)" map="L"/>
  <package name="org.apache.commons.imaging.icc" map="F"/>
  <class name="org.apache.commons.imaging.icc.IccConstants" map="A"/>
  <class name="org.apache.commons.imaging.icc.IccProfileParser" map="B"/>
  <method class="org.apache.commons.imaging.icc.IccProfileParser" name="java.lang.Boolean issRGB(java.awt.color.ICC_Profile)" map="A"/>
  <method class="org.apache.commons.imaging.icc.IccProfileParser" name="java.lang.Boolean issRGB(org.apache.commons.imaging.common.bytesource.ByteSource)" map="R"/>
  <class name="org.apache.commons.imaging.ImagingConstants" map="A"/>
  <class name="org.apache.commons.imaging.ImageParser" map="B"/>
  <method class="org.apache.commons.imaging.ImageParser" name="boolean canAcceptExtension(java.lang.String)" map="C"/>
  <method class="org.apache.commons.imaging.ImageParser" name="org.apache.commons.imaging.ImageFormat[] getAcceptedTypes()" map="L"/>
  <method class="org.apache.commons.imaging.ImageParser" name="boolean isStrict(java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.ImageParser" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.ImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.ImageParser" name="org.apache.commons.imaging.common.IImageMetadata getMetadata(byte[], java.util.Map)" map="B"/>
  <method class="org.apache.commons.imaging.ImageParser" name="org.apache.commons.imaging.ImageParser[] getAllImageParsers()" map="M"/>
  <method class="org.apache.commons.imaging.ImageParser" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.ImageParser" name="java.lang.String getName()" map="N"/>
  <method class="org.apache.commons.imaging.ImageParser" name="org.apache.commons.imaging.common.IBufferedImageFactory getBufferedImageFactory(java.util.Map)" map="C"/>
  <method class="org.apache.commons.imaging.ImageParser" name="java.lang.String[] getAcceptedExtensions()" map="O"/>
  <method class="org.apache.commons.imaging.ImageParser" name="boolean canAcceptType(org.apache.commons.imaging.ImageFormat)" map="A"/>
  <method class="org.apache.commons.imaging.ImageParser" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, java.util.Map)" map="B"/>
  <class name="org.apache.commons.imaging.ImagingException" map="C"/>
  <class name="org.apache.commons.imaging.PixelDensity" map="D"/>
  <field class="org.apache.commons.imaging.PixelDensity" name="horizontalDensity" map="A"/>
  <field class="org.apache.commons.imaging.PixelDensity" name="unitLength" map="B"/>
  <field class="org.apache.commons.imaging.PixelDensity" name="verticalDensity" map="C"/>
  <method class="org.apache.commons.imaging.PixelDensity" name="double horizontalDensityCentimetres()" map="A"/>
  <method class="org.apache.commons.imaging.PixelDensity" name="double horizontalDensityInches()" map="B"/>
  <method class="org.apache.commons.imaging.PixelDensity" name="double verticalDensityMetres()" map="C"/>
  <method class="org.apache.commons.imaging.PixelDensity" name="boolean isInMetres()" map="D"/>
  <method class="org.apache.commons.imaging.PixelDensity" name="double verticalDensityInches()" map="E"/>
  <method class="org.apache.commons.imaging.PixelDensity" name="double verticalDensityCentimetres()" map="F"/>
  <method class="org.apache.commons.imaging.PixelDensity" name="boolean isInInches()" map="G"/>
  <method class="org.apache.commons.imaging.PixelDensity" name="boolean isInCentimetres()" map="H"/>
  <method class="org.apache.commons.imaging.PixelDensity" name="double getRawVerticalDensity()" map="I"/>
  <method class="org.apache.commons.imaging.PixelDensity" name="double getRawHorizontalDensity()" map="J"/>
  <method class="org.apache.commons.imaging.PixelDensity" name="org.apache.commons.imaging.PixelDensity createFromPixelsPerInch(double, double)" map="A"/>
  <method class="org.apache.commons.imaging.PixelDensity" name="double horizontalDensityMetres()" map="K"/>
  <method class="org.apache.commons.imaging.PixelDensity" name="boolean isUnitless()" map="L"/>
  <class name="org.apache.commons.imaging.ColorTools" map="E"/>
  <method class="org.apache.commons.imaging.ColorTools" name="java.awt.image.ColorModel deriveColorModel(java.awt.image.BufferedImage, java.awt.color.ColorSpace)" map="A"/>
  <method class="org.apache.commons.imaging.ColorTools" name="java.awt.image.BufferedImage relabelColorSpace(java.awt.image.BufferedImage, java.awt.color.ColorSpace)" map="B"/>
  <method class="org.apache.commons.imaging.ColorTools" name="java.awt.image.BufferedImage convertBetweenColorSpaces(java.awt.image.BufferedImage, java.awt.color.ColorSpace, java.awt.color.ColorSpace)" map="A"/>
  <method class="org.apache.commons.imaging.ColorTools" name="java.awt.image.BufferedImage relabelColorSpace(java.awt.image.BufferedImage, java.awt.image.ColorModel)" map="A"/>
  <method class="org.apache.commons.imaging.ColorTools" name="int count_bits_in_mask(int)" map="A"/>
  <method class="org.apache.commons.imaging.ColorTools" name="java.awt.image.ColorModel deriveColorModel(java.awt.image.ColorModel, java.awt.color.ColorSpace, boolean)" map="A"/>
  <method class="org.apache.commons.imaging.ColorTools" name="java.awt.image.ColorModel deriveColorModel(java.awt.image.BufferedImage, java.awt.color.ColorSpace, boolean)" map="A"/>
  <class name="org.apache.commons.imaging.FormatCompliance" map="F"/>
  <field class="org.apache.commons.imaging.FormatCompliance" name="failOnError" map="A"/>
  <field class="org.apache.commons.imaging.FormatCompliance" name="description" map="B"/>
  <field class="org.apache.commons.imaging.FormatCompliance" name="comments" map="C"/>
  <method class="org.apache.commons.imaging.FormatCompliance" name="void dump(java.io.PrintWriter)" map="A"/>
  <method class="org.apache.commons.imaging.FormatCompliance" name="void addComment(java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.FormatCompliance" name="java.lang.String getValueDescription(int)" map="A"/>
  <method class="org.apache.commons.imaging.FormatCompliance" name="org.apache.commons.imaging.FormatCompliance getDefault()" map="A"/>
  <method class="org.apache.commons.imaging.FormatCompliance" name="boolean compare(java.lang.String, int[], int)" map="A"/>
  <method class="org.apache.commons.imaging.FormatCompliance" name="boolean checkBounds(java.lang.String, int, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.FormatCompliance" name="void addComment(java.lang.String, int)" map="A"/>
  <method class="org.apache.commons.imaging.FormatCompliance" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.commons.imaging.FormatCompliance" name="boolean compare(java.lang.String, int, int)" map="A"/>
  <method class="org.apache.commons.imaging.FormatCompliance" name="boolean compare_bytes(java.lang.String, byte[], byte[])" map="A"/>
  <class name="org.apache.commons.imaging.Imaging" map="G"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_RGBE" map="&#x0413;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_PBM_B" map="&#x0414;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_PBM_A" map="&#x0415;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_PNG" map="&#x0416;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_PPM_B" map="&#x0417;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_TIFF_INTEL" map="&#x0418;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_PPM_A" map="&#x0419;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_ICNS" map="&#x041a;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_DCX" map="&#x041b;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_GIF" map="&#x041c;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_PAM" map="&#x041d;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_JBIG2_2" map="&#x041e;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_JBIG2_1" map="&#x041f;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_PGM_B" map="&#x0420;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_JPEG" map="&#x0421;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_PGM_A" map="&#x0422;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_BMP" map="&#x0423;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_PSD" map="&#x0424;"/>
  <field class="org.apache.commons.imaging.Imaging" name="MAGIC_NUMBERS_TIFF_MOTOROLA" map="&#x0425;"/>
  <method class="org.apache.commons.imaging.Imaging" name="byte[] writeImageToBytes(java.awt.image.BufferedImage, org.apache.commons.imaging.ImageFormat, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.Imaging" name="boolean compareBytePair(int[], int[])" map="A"/>
  <method class="org.apache.commons.imaging.Imaging" name="java.awt.image.BufferedImage getBufferedImage(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="G"/>
  <method class="org.apache.commons.imaging.Imaging" name="org.apache.commons.imaging.ImageInfo getImageInfo(byte[])" map="H"/>
  <method class="org.apache.commons.imaging.Imaging" name="org.apache.commons.imaging.ImageParser getImageParser(org.apache.commons.imaging.common.bytesource.ByteSource)" map="O"/>
  <method class="org.apache.commons.imaging.Imaging" name="void writeImage(java.awt.image.BufferedImage, java.io.OutputStream, org.apache.commons.imaging.ImageFormat, java.util.Map)" map="A"/>
  <method class="org.apache.commons.imaging.Imaging" name="org.apache.commons.imaging.ImageInfo getImageInfo(org.apache.commons.imaging.common.bytesource.ByteSource, java.util.Map)" map="H"/>
  <method class="org.apache.commons.imaging.Imaging" name="org.apache.commons.imaging.ImageFormat guessFormat(org.apache.commons.imaging.common.bytesource.ByteSource)" map="P"/>
  <method class="org.apache.commons.imaging.Imaging" name="java.awt.image.BufferedImage getBufferedImage(byte[])" map="I"/>
  <method class="org.apache.commons.imaging.Imaging" name="org.apache.commons.imaging.ImageFormat guessFormat(byte[])" map="J"/>
  <class name="org.apache.commons.imaging.ImageWriteException" map="H"/>
  <class name="org.apache.commons.imaging.ImageFormat" map="I"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_XBM" map="A"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_ICO" map="B"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_DCX" map="C"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_WBMP" map="D"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_GIF" map="E"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="extension" map="F"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_PAM" map="G"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_PGM" map="H"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_TIFF" map="I"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_PPM" map="J"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_JPEG" map="K"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_UNKNOWN" map="L"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_JBIG2" map="M"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="actual" map="N"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_BMP" map="O"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_PSD" map="P"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_PBM" map="Q"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_RGBE" map="R"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_PNM" map="S"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_PCX" map="T"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_TGA" map="U"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_XPM" map="V"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_PNG" map="W"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="IMAGE_FORMAT_ICNS" map="X"/>
  <field class="org.apache.commons.imaging.ImageFormat" name="name" map="Y"/>
  <method class="org.apache.commons.imaging.ImageFormat" name="java.lang.String getExtension()" map="A"/>
  <method class="org.apache.commons.imaging.ImageFormat" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.commons.imaging.ImageFormat" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.commons.imaging.ImageFormat" name="java.lang.String getName()" map="B"/>
  <method class="org.apache.commons.imaging.ImageFormat" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.commons.imaging.ImageReadException" map="J"/>
  <class name="org.apache.commons.imaging.ImageInfo" map="K"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="isProgressive" map="A"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="physicalHeightDpi" map="B"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="mimeType" map="C"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="usesPalette" map="D"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="comments" map="E"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="isTransparent" map="F"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="numberOfImages" map="G"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="formatDetails" map="H"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="physicalHeightInch" map="I"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="height" map="J"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="formatName" map="K"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="width" map="L"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="physicalWidthDpi" map="M"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="physicalWidthInch" map="N"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="bitsPerPixel" map="O"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="format" map="P"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="compressionAlgorithm" map="Q"/>
  <field class="org.apache.commons.imaging.ImageInfo" name="colorType" map="R"/>
  <method class="org.apache.commons.imaging.ImageInfo" name="java.lang.String getColorTypeDescription()" map="A"/>
  <method class="org.apache.commons.imaging.ImageInfo" name="void toString(java.io.PrintWriter, java.lang.String)" map="A"/>
  <method class="org.apache.commons.imaging.ImageInfo" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.commons.imaging.ImageInfo" name="org.apache.commons.imaging.ImageFormat getFormat()" map="B"/>
  <package name="org.apache.commons.lang3" map="C"/>
  <package name="org.apache.commons.lang3.text" map="A"/>
  <package name="org.apache.commons.lang3.text.translate" map="A"/>
  <class name="org.apache.commons.lang3.text.translate.CodePointTranslator" map="A"/>
  <method class="org.apache.commons.lang3.text.translate.CodePointTranslator" name="boolean translate(int, java.io.Writer)" map="A"/>
  <method class="org.apache.commons.lang3.text.translate.CodePointTranslator" name="int translate(java.lang.CharSequence, int, java.io.Writer)" map="A"/>
  <class name="org.apache.commons.lang3.text.translate.CharSequenceTranslator" map="B"/>
  <field class="org.apache.commons.lang3.text.translate.CharSequenceTranslator" name="HEX_DIGITS" map="A"/>
  <method class="org.apache.commons.lang3.text.translate.CharSequenceTranslator" name="java.lang.String hex(int)" map="A"/>
  <method class="org.apache.commons.lang3.text.translate.CharSequenceTranslator" name="org.apache.commons.lang3.text.translate.CharSequenceTranslator with(org.apache.commons.lang3.text.translate.CharSequenceTranslator[])" map="A"/>
  <method class="org.apache.commons.lang3.text.translate.CharSequenceTranslator" name="void translate(java.lang.CharSequence, java.io.Writer)" map="A"/>
  <method class="org.apache.commons.lang3.text.translate.CharSequenceTranslator" name="int translate(java.lang.CharSequence, int, java.io.Writer)" map="A"/>
  <method class="org.apache.commons.lang3.text.translate.CharSequenceTranslator" name="java.lang.String translate(java.lang.CharSequence)" map="A"/>
  <class name="org.apache.commons.lang3.text.translate.NumericEntityEscaper" map="C"/>
  <field class="org.apache.commons.lang3.text.translate.NumericEntityEscaper" name="above" map="L"/>
  <field class="org.apache.commons.lang3.text.translate.NumericEntityEscaper" name="between" map="M"/>
  <field class="org.apache.commons.lang3.text.translate.NumericEntityEscaper" name="below" map="N"/>
  <method class="org.apache.commons.lang3.text.translate.NumericEntityEscaper" name="boolean translate(int, java.io.Writer)" map="A"/>
  <method class="org.apache.commons.lang3.text.translate.NumericEntityEscaper" name="org.apache.commons.lang3.text.translate.NumericEntityEscaper between(int, int)" map="A"/>
  <class name="org.apache.commons.lang3.text.translate.UnicodeUnpairedSurrogateRemover" map="D"/>
  <method class="org.apache.commons.lang3.text.translate.UnicodeUnpairedSurrogateRemover" name="boolean translate(int, java.io.Writer)" map="A"/>
  <class name="org.apache.commons.lang3.text.translate.AggregateTranslator" map="E"/>
  <field class="org.apache.commons.lang3.text.translate.AggregateTranslator" name="translators" map="B"/>
  <method class="org.apache.commons.lang3.text.translate.AggregateTranslator" name="int translate(java.lang.CharSequence, int, java.io.Writer)" map="A"/>
  <class name="org.apache.commons.lang3.text.translate.NumericEntityUnescaper$OPTION" map="_A"/>
  <field class="org.apache.commons.lang3.text.translate.NumericEntityUnescaper$OPTION" name="errorIfNoSemiColon" map="A"/>
  <field class="org.apache.commons.lang3.text.translate.NumericEntityUnescaper$OPTION" name="semiColonOptional" map="B"/>
  <field class="org.apache.commons.lang3.text.translate.NumericEntityUnescaper$OPTION" name="$VALUES" map="C"/>
  <field class="org.apache.commons.lang3.text.translate.NumericEntityUnescaper$OPTION" name="semiColonRequired" map="D"/>
  <method class="org.apache.commons.lang3.text.translate.NumericEntityUnescaper$OPTION" name="org.apache.commons.lang3.text.translate.NumericEntityUnescaper$OPTION valueOf(java.lang.String)" map="valueOf"/>
  <method class="org.apache.commons.lang3.text.translate.NumericEntityUnescaper$OPTION" name="org.apache.commons.lang3.text.translate.NumericEntityUnescaper$OPTION[] values()" map="values"/>
  <class name="org.apache.commons.lang3.text.translate.NumericEntityUnescaper" map="F"/>
  <field class="org.apache.commons.lang3.text.translate.NumericEntityUnescaper" name="options" map="C"/>
  <method class="org.apache.commons.lang3.text.translate.NumericEntityUnescaper" name="int translate(java.lang.CharSequence, int, java.io.Writer)" map="A"/>
  <method class="org.apache.commons.lang3.text.translate.NumericEntityUnescaper" name="boolean isSet(org.apache.commons.lang3.text.translate.NumericEntityUnescaper$OPTION)" map="A"/>
  <class name="org.apache.commons.lang3.text.translate.JavaUnicodeEscaper" map="G"/>
  <method class="org.apache.commons.lang3.text.translate.JavaUnicodeEscaper" name="java.lang.String toUtf16Escape(int)" map="B"/>
  <method class="org.apache.commons.lang3.text.translate.JavaUnicodeEscaper" name="org.apache.commons.lang3.text.translate.JavaUnicodeEscaper outsideOf(int, int)" map="B"/>
  <class name="org.apache.commons.lang3.text.translate.EntityArrays" map="H"/>
  <field class="org.apache.commons.lang3.text.translate.EntityArrays" name="ISO8859_1_ESCAPE" map="A"/>
  <field class="org.apache.commons.lang3.text.translate.EntityArrays" name="BASIC_UNESCAPE" map="B"/>
  <field class="org.apache.commons.lang3.text.translate.EntityArrays" name="APOS_ESCAPE" map="C"/>
  <field class="org.apache.commons.lang3.text.translate.EntityArrays" name="HTML40_EXTENDED_ESCAPE" map="D"/>
  <field class="org.apache.commons.lang3.text.translate.EntityArrays" name="BASIC_ESCAPE" map="E"/>
  <field class="org.apache.commons.lang3.text.translate.EntityArrays" name="HTML40_EXTENDED_UNESCAPE" map="F"/>
  <field class="org.apache.commons.lang3.text.translate.EntityArrays" name="ISO8859_1_UNESCAPE" map="G"/>
  <field class="org.apache.commons.lang3.text.translate.EntityArrays" name="JAVA_CTRL_CHARS_UNESCAPE" map="H"/>
  <field class="org.apache.commons.lang3.text.translate.EntityArrays" name="APOS_UNESCAPE" map="I"/>
  <field class="org.apache.commons.lang3.text.translate.EntityArrays" name="JAVA_CTRL_CHARS_ESCAPE" map="J"/>
  <method class="org.apache.commons.lang3.text.translate.EntityArrays" name="java.lang.String[][] ISO8859_1_UNESCAPE()" map="A"/>
  <method class="org.apache.commons.lang3.text.translate.EntityArrays" name="java.lang.String[][] HTML40_EXTENDED_UNESCAPE()" map="B"/>
  <method class="org.apache.commons.lang3.text.translate.EntityArrays" name="java.lang.String[][] JAVA_CTRL_CHARS_UNESCAPE()" map="C"/>
  <method class="org.apache.commons.lang3.text.translate.EntityArrays" name="java.lang.String[][] APOS_UNESCAPE()" map="D"/>
  <method class="org.apache.commons.lang3.text.translate.EntityArrays" name="java.lang.String[][] BASIC_ESCAPE()" map="E"/>
  <method class="org.apache.commons.lang3.text.translate.EntityArrays" name="java.lang.String[][] HTML40_EXTENDED_ESCAPE()" map="F"/>
  <method class="org.apache.commons.lang3.text.translate.EntityArrays" name="java.lang.String[][] ISO8859_1_ESCAPE()" map="G"/>
  <method class="org.apache.commons.lang3.text.translate.EntityArrays" name="java.lang.String[][] APOS_ESCAPE()" map="H"/>
  <method class="org.apache.commons.lang3.text.translate.EntityArrays" name="java.lang.String[][] invert(java.lang.String[][])" map="A"/>
  <method class="org.apache.commons.lang3.text.translate.EntityArrays" name="java.lang.String[][] BASIC_UNESCAPE()" map="I"/>
  <method class="org.apache.commons.lang3.text.translate.EntityArrays" name="java.lang.String[][] JAVA_CTRL_CHARS_ESCAPE()" map="J"/>
  <class name="org.apache.commons.lang3.text.translate.UnicodeUnescaper" map="I"/>
  <method class="org.apache.commons.lang3.text.translate.UnicodeUnescaper" name="int translate(java.lang.CharSequence, int, java.io.Writer)" map="A"/>
  <class name="org.apache.commons.lang3.text.translate.OctalUnescaper" map="J"/>
  <method class="org.apache.commons.lang3.text.translate.OctalUnescaper" name="int translate(java.lang.CharSequence, int, java.io.Writer)" map="A"/>
  <method class="org.apache.commons.lang3.text.translate.OctalUnescaper" name="boolean isZeroToThree(char)" map="A"/>
  <method class="org.apache.commons.lang3.text.translate.OctalUnescaper" name="boolean isOctalDigit(char)" map="B"/>
  <class name="org.apache.commons.lang3.text.translate.LookupTranslator" map="K"/>
  <field class="org.apache.commons.lang3.text.translate.LookupTranslator" name="prefixSet" map="D"/>
  <field class="org.apache.commons.lang3.text.translate.LookupTranslator" name="lookupMap" map="E"/>
  <field class="org.apache.commons.lang3.text.translate.LookupTranslator" name="longest" map="F"/>
  <field class="org.apache.commons.lang3.text.translate.LookupTranslator" name="shortest" map="G"/>
  <method class="org.apache.commons.lang3.text.translate.LookupTranslator" name="int translate(java.lang.CharSequence, int, java.io.Writer)" map="A"/>
  <class name="org.apache.commons.lang3.text.translate.UnicodeEscaper" map="L"/>
  <field class="org.apache.commons.lang3.text.translate.UnicodeEscaper" name="above" map="O"/>
  <field class="org.apache.commons.lang3.text.translate.UnicodeEscaper" name="between" map="P"/>
  <field class="org.apache.commons.lang3.text.translate.UnicodeEscaper" name="below" map="Q"/>
  <method class="org.apache.commons.lang3.text.translate.UnicodeEscaper" name="java.lang.String toUtf16Escape(int)" map="B"/>
  <method class="org.apache.commons.lang3.text.translate.UnicodeEscaper" name="boolean translate(int, java.io.Writer)" map="A"/>
  <class name="org.apache.commons.lang3.ArrayUtils" map="A"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_FLOAT_ARRAY" map="A"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_INTEGER_OBJECT_ARRAY" map="B"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_FLOAT_OBJECT_ARRAY" map="C"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_BOOLEAN_OBJECT_ARRAY" map="D"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_SHORT_ARRAY" map="E"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_STRING_ARRAY" map="F"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_CHARACTER_OBJECT_ARRAY" map="G"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_BOOLEAN_ARRAY" map="H"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_LONG_OBJECT_ARRAY" map="I"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_DOUBLE_OBJECT_ARRAY" map="J"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_INT_ARRAY" map="K"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_LONG_ARRAY" map="L"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_BYTE_OBJECT_ARRAY" map="M"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_CLASS_ARRAY" map="N"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_OBJECT_ARRAY" map="O"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_CHAR_ARRAY" map="P"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_DOUBLE_ARRAY" map="Q"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_SHORT_OBJECT_ARRAY" map="R"/>
  <field class="org.apache.commons.lang3.ArrayUtils" name="EMPTY_BYTE_ARRAY" map="S"/>
  <method class="org.apache.commons.lang3.ArrayUtils" name="boolean isEmpty(char[])" map="A"/>
  <method class="org.apache.commons.lang3.ArrayUtils" name="java.lang.Object[] clone(java.lang.Object[])" map="A"/>
  <class name="org.apache.commons.lang3.StringUtils" map="B"/>
  <method class="org.apache.commons.lang3.StringUtils" name="java.lang.String replace(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.commons.lang3.StringUtils" name="boolean containsAny(java.lang.CharSequence, char[])" map="A"/>
  <method class="org.apache.commons.lang3.StringUtils" name="java.lang.String replace(java.lang.String, java.lang.String, java.lang.String, int)" map="A"/>
  <method class="org.apache.commons.lang3.StringUtils" name="boolean isEmpty(java.lang.CharSequence)" map="A"/>
  <method class="org.apache.commons.lang3.StringUtils" name="boolean containsNone(java.lang.CharSequence, char[])" map="B"/>
  <class name="org.apache.commons.lang3.StringEscapeUtils$CsvUnescaper" map="_A"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils$CsvUnescaper" name="CSV_SEARCH_CHARS" map="H"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils$CsvUnescaper" name="CSV_QUOTE_STR" map="I"/>
  <method class="org.apache.commons.lang3.StringEscapeUtils$CsvUnescaper" name="int translate(java.lang.CharSequence, int, java.io.Writer)" map="A"/>
  <class name="org.apache.commons.lang3.StringEscapeUtils$CsvEscaper" map="_B"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils$CsvEscaper" name="CSV_SEARCH_CHARS" map="J"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils$CsvEscaper" name="CSV_QUOTE_STR" map="K"/>
  <method class="org.apache.commons.lang3.StringEscapeUtils$CsvEscaper" name="int translate(java.lang.CharSequence, int, java.io.Writer)" map="A"/>
  <class name="org.apache.commons.lang3.StringEscapeUtils" map="C"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="ESCAPE_HTML4" map="A"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="ESCAPE_HTML3" map="B"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="UNESCAPE_CSV" map="C"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="UNESCAPE_XML" map="D"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="UNESCAPE_JSON" map="E"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="ESCAPE_CSV" map="F"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="ESCAPE_XML" map="G"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="UNESCAPE_ECMASCRIPT" map="H"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="UNESCAPE_JAVA" map="I"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="ESCAPE_JSON" map="J"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="ESCAPE_ECMASCRIPT" map="K"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="UNESCAPE_HTML4" map="L"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="ESCAPE_XML11" map="M"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="UNESCAPE_HTML3" map="N"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="ESCAPE_JAVA" map="O"/>
  <field class="org.apache.commons.lang3.StringEscapeUtils" name="ESCAPE_XML10" map="P"/>
  <method class="org.apache.commons.lang3.StringEscapeUtils" name="java.lang.String escapeHtml4(java.lang.String)" map="A"/>
  <method class="org.apache.commons.lang3.StringEscapeUtils" name="java.lang.String escapeHtml3(java.lang.String)" map="B"/>
  <package name="org.apache.commons.net" map="D"/>
  <package name="org.apache.commons.net.util" map="A"/>
  <class name="org.apache.commons.net.util.ListenerList" map="A"/>
  <field class="org.apache.commons.net.util.ListenerList" name="__listeners" map="A"/>
  <method class="org.apache.commons.net.util.ListenerList" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="org.apache.commons.net.util.ListenerList" name="int getListenerCount()" map="A"/>
  <package name="org.apache.commons.net.ftp" map="B"/>
  <package name="org.apache.commons.net.ftp.parser" map="A"/>
  <class name="org.apache.commons.net.ftp.parser.FTPFileEntryParserFactory" map="A"/>
  <class name="org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory" map="B"/>
  <field class="org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory" name="JAVA_QUALIFIED_NAME_PATTERN" map="A"/>
  <class name="org.apache.commons.net.ftp.FTPReply" map="A"/>
  <method class="org.apache.commons.net.ftp.FTPReply" name="boolean isPositiveCompletion(int)" map="A"/>
  <method class="org.apache.commons.net.ftp.FTPReply" name="boolean isPositivePreliminary(int)" map="B"/>
  <method class="org.apache.commons.net.ftp.FTPReply" name="boolean isPositiveIntermediate(int)" map="C"/>
  <class name="org.apache.commons.net.ftp.FTPFileEntryParser" map="B"/>
  <class name="org.apache.commons.net.ftp.FTPConnectionClosedException" map="C"/>
  <class name="org.apache.commons.net.ftp.FTPClient$HostnameResolver" map="_A"/>
  <class name="org.apache.commons.net.ftp.FTPClient$NatServerResolverImpl" map="_B"/>
  <field class="org.apache.commons.net.ftp.FTPClient$NatServerResolverImpl" name="client" map="A"/>
  <class name="org.apache.commons.net.ftp.FTPClient" map="D"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__fileStructure" map="Z"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__autodetectEncoding" map="_"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__passiveLocalHost" map="a"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__remoteVerificationEnabled" map="b"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__passiveNatWorkaroundStrategy" map="c"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__fileFormat" map="d"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__entryParser" map="e"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__useEPSVwithIPv4" map="f"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__fileType" map="g"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__activeMinPort" map="h"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__systemName" map="i"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__entryParserKey" map="j"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__controlKeepAliveReplyTimeout" map="k"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__passivePort" map="l"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__activeMaxPort" map="m"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__featuresMap" map="n"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__passiveHost" map="o"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__parserFactory" map="p"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__reportActiveExternalHost" map="q"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__PARMS_PAT" map="r"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__restartOffset" map="s"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__dataConnectionMode" map="t"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__configuration" map="u"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__activeExternalHost" map="v"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__random" map="w"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__listHiddenFiles" map="x"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__fileTransferMode" map="y"/>
  <field class="org.apache.commons.net.ftp.FTPClient" name="__dataTimeout" map="z"/>
  <method class="org.apache.commons.net.ftp.FTPClient" name="boolean login(java.lang.String, java.lang.String)" map="E"/>
  <method class="org.apache.commons.net.ftp.FTPClient" name="void _connectAction_(java.io.Reader)" map="A"/>
  <method class="org.apache.commons.net.ftp.FTPClient" name="void __initDefaults()" map="L"/>
  <method class="org.apache.commons.net.ftp.FTPClient" name="boolean hasFeature(java.lang.String)" map="G"/>
  <method class="org.apache.commons.net.ftp.FTPClient" name="boolean initFeatureMap()" map="M"/>
  <method class="org.apache.commons.net.ftp.FTPClient" name="void _connectAction_()" map="A"/>
  <class name="org.apache.commons.net.ftp.Configurable" map="E"/>
  <class name="org.apache.commons.net.ftp.FTP" map="F"/>
  <field class="org.apache.commons.net.ftp.FTP" name="_replyLines" map="P"/>
  <field class="org.apache.commons.net.ftp.FTP" name="_replyString" map="Q"/>
  <field class="org.apache.commons.net.ftp.FTP" name="_replyCode" map="R"/>
  <field class="org.apache.commons.net.ftp.FTP" name="_controlOutput_" map="S"/>
  <field class="org.apache.commons.net.ftp.FTP" name="_commandSupport_" map="T"/>
  <field class="org.apache.commons.net.ftp.FTP" name="_newReplyString" map="U"/>
  <field class="org.apache.commons.net.ftp.FTP" name="strictMultilineParsing" map="V"/>
  <field class="org.apache.commons.net.ftp.FTP" name="strictReplyParsing" map="W"/>
  <field class="org.apache.commons.net.ftp.FTP" name="_controlInput_" map="X"/>
  <field class="org.apache.commons.net.ftp.FTP" name="_controlEncoding" map="Y"/>
  <method class="org.apache.commons.net.ftp.FTP" name="boolean isStrictMultilineParsing()" map="D"/>
  <method class="org.apache.commons.net.ftp.FTP" name="java.lang.String getReplyString()" map="E"/>
  <method class="org.apache.commons.net.ftp.FTP" name="boolean __lenientCheck(java.lang.String)" map="B"/>
  <method class="org.apache.commons.net.ftp.FTP" name="java.lang.String __buildMessage(java.lang.String, java.lang.String)" map="B"/>
  <method class="org.apache.commons.net.ftp.FTP" name="void __getReply()" map="F"/>
  <method class="org.apache.commons.net.ftp.FTP" name="org.apache.commons.net.ProtocolCommandSupport getCommandSupport()" map="C"/>
  <method class="org.apache.commons.net.ftp.FTP" name="java.lang.String[] getReplyStrings()" map="G"/>
  <method class="org.apache.commons.net.ftp.FTP" name="int feat()" map="H"/>
  <method class="org.apache.commons.net.ftp.FTP" name="boolean isStrictReplyParsing()" map="I"/>
  <method class="org.apache.commons.net.ftp.FTP" name="int user(java.lang.String)" map="C"/>
  <method class="org.apache.commons.net.ftp.FTP" name="void __getReply(boolean)" map="A"/>
  <method class="org.apache.commons.net.ftp.FTP" name="int sendCommand(java.lang.String, java.lang.String)" map="C"/>
  <method class="org.apache.commons.net.ftp.FTP" name="int sendCommand(org.apache.commons.net.ftp.FTPCmd)" map="A"/>
  <method class="org.apache.commons.net.ftp.FTP" name="int getReplyCode()" map="J"/>
  <method class="org.apache.commons.net.ftp.FTP" name="void __send(java.lang.String)" map="D"/>
  <method class="org.apache.commons.net.ftp.FTP" name="int pass(java.lang.String)" map="E"/>
  <method class="org.apache.commons.net.ftp.FTP" name="void _connectAction_(java.io.Reader)" map="A"/>
  <method class="org.apache.commons.net.ftp.FTP" name="java.lang.String getControlEncoding()" map="K"/>
  <method class="org.apache.commons.net.ftp.FTP" name="boolean __strictCheck(java.lang.String, java.lang.String)" map="D"/>
  <method class="org.apache.commons.net.ftp.FTP" name="void setControlEncoding(java.lang.String)" map="F"/>
  <method class="org.apache.commons.net.ftp.FTP" name="int sendCommand(org.apache.commons.net.ftp.FTPCmd, java.lang.String)" map="A"/>
  <class name="org.apache.commons.net.ftp.FTPClientConfig" map="G"/>
  <field class="org.apache.commons.net.ftp.FTPClientConfig" name="LANGUAGE_CODE_MAP" map="A"/>
  <class name="org.apache.commons.net.ftp.FTPCmd" map="H"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="RETRIEVE" map="A"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="PWD" map="B"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="REINITIALIZE" map="C"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="APPEND" map="D"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="STRUCTURE_MOUNT" map="E"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="MKD" map="F"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="TYPE" map="G"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="REST" map="H"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="LOGOUT" map="I"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="SYSTEM" map="J"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="RENAME_TO" map="K"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="REMOVE_DIRECTORY" map="L"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="MAKE_DIRECTORY" map="M"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="PASV" map="N"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="MODE" map="O"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="PASS" map="P"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="QUIT" map="Q"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="REPRESENTATION_TYPE" map="R"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="PASSWORD" map="S"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="PRINT_WORKING_DIRECTORY" map="T"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="ABORT" map="U"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="STOU" map="V"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="STOR" map="W"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="ACCT" map="X"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="DATA_PORT" map="Y"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="USERNAME" map="Z"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="STORE_UNIQUE" map="_"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="CHANGE_WORKING_DIRECTORY" map="a"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="NOOP" map="b"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="EPSV" map="c"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="ABOR" map="d"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="FILE_STRUCTURE" map="e"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="$VALUES" map="f"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="STORE" map="g"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="CDUP" map="h"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="CWD" map="i"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="ALLOCATE" map="j"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="SYST" map="k"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="DELETE" map="l"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="CHANGE_TO_PARENT_DIRECTORY" map="m"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="EPRT" map="n"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="STAT" map="o"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="MOD_TIME" map="p"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="TRANSFER_MODE" map="q"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="ALLO" map="r"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="RMD" map="s"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="ACCOUNT" map="t"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="RNTO" map="u"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="SMNT" map="v"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="SET_MOD_TIME" map="w"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="FEATURES" map="x"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="FEAT" map="y"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="MLST" map="z"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="REIN" map="&#x00a2;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="NLST" map="&#x00a3;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="STRU" map="&#x00a4;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="LIST" map="&#x00a5;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="MLSD" map="&#x00aa;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="GET_MOD_TIME" map="&#x00b5;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="APPE" map="&#x00ba;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="MDTM" map="&#x00c0;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="PASSIVE" map="&#x00c1;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="NAME_LIST" map="&#x00c2;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="PORT" map="&#x00c3;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="MFMT" map="&#x00c4;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="SITE" map="&#x00c5;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="RNFR" map="&#x00c6;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="RETR" map="&#x00c7;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="DELE" map="&#x00c8;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="STATUS" map="&#x00c9;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="RESTART" map="&#x00ca;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="HELP" map="&#x00cb;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="RENAME_FROM" map="&#x00cc;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="USER" map="&#x00cd;"/>
  <field class="org.apache.commons.net.ftp.FTPCmd" name="SITE_PARAMETERS" map="&#x00ce;"/>
  <method class="org.apache.commons.net.ftp.FTPCmd" name="org.apache.commons.net.ftp.FTPCmd[] values()" map="values"/>
  <method class="org.apache.commons.net.ftp.FTPCmd" name="java.lang.String getCommand()" map="A"/>
  <method class="org.apache.commons.net.ftp.FTPCmd" name="org.apache.commons.net.ftp.FTPCmd valueOf(java.lang.String)" map="valueOf"/>
  <package name="org.apache.commons.net.io" map="C"/>
  <class name="org.apache.commons.net.io.CRLFLineReader" map="A"/>
  <method class="org.apache.commons.net.io.CRLFLineReader" name="java.lang.String readLine()" map="readLine"/>
  <class name="org.apache.commons.net.ProtocolCommandSupport" map="A"/>
  <field class="org.apache.commons.net.ProtocolCommandSupport" name="__listeners" map="A"/>
  <field class="org.apache.commons.net.ProtocolCommandSupport" name="__source" map="B"/>
  <method class="org.apache.commons.net.ProtocolCommandSupport" name="void fireReplyReceived(int, java.lang.String)" map="A"/>
  <method class="org.apache.commons.net.ProtocolCommandSupport" name="void fireCommandSent(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.commons.net.ProtocolCommandSupport" name="int getListenerCount()" map="A"/>
  <class name="org.apache.commons.net.MalformedServerReplyException" map="B"/>
  <class name="org.apache.commons.net.SocketClient" map="C"/>
  <field class="org.apache.commons.net.SocketClient" name="_serverSocketFactory_" map="A"/>
  <field class="org.apache.commons.net.SocketClient" name="charset" map="B"/>
  <field class="org.apache.commons.net.SocketClient" name="_socketFactory_" map="C"/>
  <field class="org.apache.commons.net.SocketClient" name="_socket_" map="D"/>
  <field class="org.apache.commons.net.SocketClient" name="receiveBufferSize" map="E"/>
  <field class="org.apache.commons.net.SocketClient" name="_hostname_" map="F"/>
  <field class="org.apache.commons.net.SocketClient" name="_defaultPort_" map="G"/>
  <field class="org.apache.commons.net.SocketClient" name="__DEFAULT_SERVER_SOCKET_FACTORY" map="H"/>
  <field class="org.apache.commons.net.SocketClient" name="_output_" map="I"/>
  <field class="org.apache.commons.net.SocketClient" name="__commandSupport" map="J"/>
  <field class="org.apache.commons.net.SocketClient" name="__DEFAULT_SOCKET_FACTORY" map="K"/>
  <field class="org.apache.commons.net.SocketClient" name="connectTimeout" map="L"/>
  <field class="org.apache.commons.net.SocketClient" name="_input_" map="M"/>
  <field class="org.apache.commons.net.SocketClient" name="sendBufferSize" map="N"/>
  <field class="org.apache.commons.net.SocketClient" name="_timeout_" map="O"/>
  <method class="org.apache.commons.net.SocketClient" name="void _connect(java.net.InetAddress, int, java.net.InetAddress, int)" map="A"/>
  <method class="org.apache.commons.net.SocketClient" name="void fireReplyReceived(int, java.lang.String)" map="A"/>
  <method class="org.apache.commons.net.SocketClient" name="void fireCommandSent(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.apache.commons.net.SocketClient" name="void _connectAction_()" map="A"/>
  <method class="org.apache.commons.net.SocketClient" name="boolean isConnected()" map="B"/>
  <method class="org.apache.commons.net.SocketClient" name="void setDefaultPort(int)" map="A"/>
  <method class="org.apache.commons.net.SocketClient" name="void connect(java.lang.String, int)" map="A"/>
  <method class="org.apache.commons.net.SocketClient" name="void connect(java.lang.String)" map="A"/>
  <method class="org.apache.commons.net.SocketClient" name="org.apache.commons.net.ProtocolCommandSupport getCommandSupport()" map="C"/>
  <class name="org.apache.commons.net.ProtocolCommandListener" map="D"/>
  <method class="org.apache.commons.net.ProtocolCommandListener" name="void protocolReplyReceived(org.apache.commons.net.ProtocolCommandEvent)" map="A"/>
  <method class="org.apache.commons.net.ProtocolCommandListener" name="void protocolCommandSent(org.apache.commons.net.ProtocolCommandEvent)" map="B"/>
  <class name="org.apache.commons.net.ProtocolCommandEvent" map="E"/>
  <field class="org.apache.commons.net.ProtocolCommandEvent" name="__message" map="A"/>
  <field class="org.apache.commons.net.ProtocolCommandEvent" name="__command" map="B"/>
  <field class="org.apache.commons.net.ProtocolCommandEvent" name="__replyCode" map="C"/>
  <field class="org.apache.commons.net.ProtocolCommandEvent" name="__isCommand" map="D"/>
  <package name="org.apache.wml" map="F"/>
  <package name="org.apache.wml.dom" map="A"/>
  <class name="org.apache.wml.dom.WMLSetvarElementImpl" map="A"/>
  <class name="org.apache.wml.dom.WMLOneventElementImpl" map="B"/>
  <class name="org.apache.wml.dom.WMLIElementImpl" map="C"/>
  <class name="org.apache.wml.dom.WMLWmlElementImpl" map="D"/>
  <class name="org.apache.wml.dom.WMLSelectElementImpl" map="E"/>
  <class name="org.apache.wml.dom.WMLMetaElementImpl" map="F"/>
  <class name="org.apache.wml.dom.WMLBElementImpl" map="G"/>
  <class name="org.apache.wml.dom.WMLAccessElementImpl" map="H"/>
  <class name="org.apache.wml.dom.WMLImgElementImpl" map="I"/>
  <class name="org.apache.wml.dom.WMLEmElementImpl" map="J"/>
  <class name="org.apache.wml.dom.WMLStrongElementImpl" map="K"/>
  <class name="org.apache.wml.dom.WMLPrevElementImpl" map="L"/>
  <class name="org.apache.wml.dom.WMLBigElementImpl" map="M"/>
  <class name="org.apache.wml.dom.WMLCardElementImpl" map="N"/>
  <class name="org.apache.wml.dom.WMLTemplateElementImpl" map="O"/>
  <class name="org.apache.wml.dom.WMLElementImpl" map="P"/>
  <class name="org.apache.wml.dom.WMLHeadElementImpl" map="Q"/>
  <class name="org.apache.wml.dom.WMLTrElementImpl" map="R"/>
  <class name="org.apache.wml.dom.WMLUElementImpl" map="S"/>
  <class name="org.apache.wml.dom.WMLInputElementImpl" map="T"/>
  <class name="org.apache.wml.dom.WMLTableElementImpl" map="U"/>
  <class name="org.apache.wml.dom.WMLTimerElementImpl" map="V"/>
  <class name="org.apache.wml.dom.WMLOptionElementImpl" map="W"/>
  <class name="org.apache.wml.dom.WMLDocumentImpl" map="X"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLEmElementImpl" map="class$F$C$F$A$J"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLSelectElementImpl" map="class$F$C$F$A$E"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLPrevElementImpl" map="class$F$C$F$A$L"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLIElementImpl" map="class$F$C$F$A$C"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLTemplateElementImpl" map="class$F$C$F$A$O"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="_elemClassSigWML" map="&#x00ef;"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLRefreshElementImpl" map="class$F$C$F$A$f"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLAccessElementImpl" map="class$F$C$F$A$H"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLCardElementImpl" map="class$F$C$F$A$N"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLStrongElementImpl" map="class$F$C$F$A$K"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLHeadElementImpl" map="class$F$C$F$A$Q"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLTrElementImpl" map="class$F$C$F$A$R"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLBElementImpl" map="class$F$C$F$A$G"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLOneventElementImpl" map="class$F$C$F$A$B"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLOptgroupElementImpl" map="class$F$C$F$A$_"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLNoopElementImpl" map="class$F$C$F$A$a"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLDoElementImpl" map="class$F$C$F$A$Y"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLFieldsetElementImpl" map="class$F$C$F$A$c"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLOptionElementImpl" map="class$F$C$F$A$W"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLInputElementImpl" map="class$F$C$F$A$T"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLTimerElementImpl" map="class$F$C$F$A$V"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLTableElementImpl" map="class$F$C$F$A$U"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLUElementImpl" map="class$F$C$F$A$S"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLGoElementImpl" map="class$F$C$F$A$d"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLAnchorElementImpl" map="class$F$C$F$A$Z"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLBrElementImpl" map="class$F$C$F$A$g"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLDocumentImpl" map="class$F$C$F$A$X"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLTdElementImpl" map="class$F$C$F$A$h"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLPostfieldElementImpl" map="class$F$C$F$A$j"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLWmlElementImpl" map="class$F$C$F$A$D"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLAElementImpl" map="class$F$C$F$A$b"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLPElementImpl" map="class$F$C$F$A$e"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLImgElementImpl" map="class$F$C$F$A$I"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLSetvarElementImpl" map="class$F$C$F$A$A"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLBigElementImpl" map="class$F$C$F$A$M"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLMetaElementImpl" map="class$F$C$F$A$F"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$org$apache$wml$dom$WMLSmallElementImpl" map="class$F$C$F$A$i"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="class$java$lang$String" map="class$java$lang$String"/>
  <field class="org.apache.wml.dom.WMLDocumentImpl" name="_elementTypesWML" map="&#x00f0;"/>
  <method class="org.apache.wml.dom.WMLDocumentImpl" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.apache.wml.dom.WMLDocumentImpl" name="org.w3c.dom.Element createElement(java.lang.String)" map="K"/>
  <class name="org.apache.wml.dom.WMLDoElementImpl" map="Y"/>
  <class name="org.apache.wml.dom.WMLAnchorElementImpl" map="Z"/>
  <class name="org.apache.wml.dom.WMLOptgroupElementImpl" map="_"/>
  <class name="org.apache.wml.dom.WMLNoopElementImpl" map="a"/>
  <class name="org.apache.wml.dom.WMLAElementImpl" map="b"/>
  <class name="org.apache.wml.dom.WMLFieldsetElementImpl" map="c"/>
  <class name="org.apache.wml.dom.WMLGoElementImpl" map="d"/>
  <class name="org.apache.wml.dom.WMLPElementImpl" map="e"/>
  <class name="org.apache.wml.dom.WMLRefreshElementImpl" map="f"/>
  <class name="org.apache.wml.dom.WMLBrElementImpl" map="g"/>
  <class name="org.apache.wml.dom.WMLTdElementImpl" map="h"/>
  <class name="org.apache.wml.dom.WMLSmallElementImpl" map="i"/>
  <class name="org.apache.wml.dom.WMLPostfieldElementImpl" map="j"/>
  <class name="org.apache.wml.WMLElement" map="A"/>
  <class name="org.apache.wml.WMLFieldsetElement" map="B"/>
  <class name="org.apache.wml.WMLTdElement" map="C"/>
  <class name="org.apache.wml.WMLDoElement" map="D"/>
  <class name="org.apache.wml.WMLHeadElement" map="E"/>
  <class name="org.apache.wml.WMLMetaElement" map="F"/>
  <class name="org.apache.wml.WMLTrElement" map="G"/>
  <class name="org.apache.wml.WMLAnchorElement" map="H"/>
  <class name="org.apache.wml.WMLUElement" map="I"/>
  <class name="org.apache.wml.WMLIElement" map="J"/>
  <class name="org.apache.wml.WMLOptgroupElement" map="K"/>
  <class name="org.apache.wml.WMLSelectElement" map="L"/>
  <class name="org.apache.wml.WMLSetvarElement" map="M"/>
  <class name="org.apache.wml.WMLBigElement" map="N"/>
  <class name="org.apache.wml.WMLCardElement" map="O"/>
  <class name="org.apache.wml.WMLOptionElement" map="P"/>
  <class name="org.apache.wml.WMLInputElement" map="Q"/>
  <class name="org.apache.wml.WMLEmElement" map="R"/>
  <class name="org.apache.wml.WMLGoElement" map="S"/>
  <class name="org.apache.wml.WMLPrevElement" map="T"/>
  <class name="org.apache.wml.WMLAccessElement" map="U"/>
  <class name="org.apache.wml.WMLTemplateElement" map="V"/>
  <class name="org.apache.wml.WMLBrElement" map="W"/>
  <class name="org.apache.wml.WMLImgElement" map="X"/>
  <class name="org.apache.wml.WMLTimerElement" map="Y"/>
  <class name="org.apache.wml.WMLPostfieldElement" map="Z"/>
  <class name="org.apache.wml.WMLAElement" map="_"/>
  <class name="org.apache.wml.WMLRefreshElement" map="a"/>
  <class name="org.apache.wml.WMLBElement" map="b"/>
  <class name="org.apache.wml.WMLTableElement" map="c"/>
  <class name="org.apache.wml.WMLNoopElement" map="d"/>
  <class name="org.apache.wml.WMLStrongElement" map="e"/>
  <class name="org.apache.wml.WMLSmallElement" map="f"/>
  <class name="org.apache.wml.WMLWmlElement" map="g"/>
  <class name="org.apache.wml.WMLOneventElement" map="h"/>
  <class name="org.apache.wml.WMLPElement" map="i"/>
  <class name="org.apache.wml.WMLDocument" map="j"/>
  <package name="org.apache.poi" map="G"/>
  <package name="org.apache.poi.sl" map="A"/>
  <package name="org.apache.poi.sl.draw" map="A"/>
  <package name="org.apache.poi.sl.draw.binding" map="A"/>
  <class name="org.apache.poi.sl.draw.binding.package-info" map="package-info"/>
  <package name="org.apache.poi.util" map="B"/>
  <class name="org.apache.poi.util.BitFieldFactory" map="A"/>
  <field class="org.apache.poi.util.BitFieldFactory" name="instances" map="A"/>
  <method class="org.apache.poi.util.BitFieldFactory" name="org.apache.poi.util.BitField getInstance(int)" map="A"/>
  <class name="org.apache.poi.util.POILogger" map="B"/>
  <field class="org.apache.poi.util.POILogger" name="LEVEL_STRINGS" map="A"/>
  <field class="org.apache.poi.util.POILogger" name="LEVEL_STRINGS_SHORT" map="B"/>
  <method class="org.apache.poi.util.POILogger" name="void log(int, java.lang.Object[])" map="A"/>
  <method class="org.apache.poi.util.POILogger" name="void initialize(java.lang.String)" map="A"/>
  <class name="org.apache.poi.util.ShortField" map="C"/>
  <field class="org.apache.poi.util.ShortField" name="_offset" map="G"/>
  <field class="org.apache.poi.util.ShortField" name="_value" map="H"/>
  <method class="org.apache.poi.util.ShortField" name="void writeToBytes(byte[])" map="F"/>
  <method class="org.apache.poi.util.ShortField" name="void readFromBytes(byte[])" map="G"/>
  <method class="org.apache.poi.util.ShortField" name="void set(short, byte[])" map="A"/>
  <method class="org.apache.poi.util.ShortField" name="short get()" map="B"/>
  <method class="org.apache.poi.util.ShortField" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.poi.util.BitField" map="D"/>
  <field class="org.apache.poi.util.BitField" name="_shift_count" map="A"/>
  <field class="org.apache.poi.util.BitField" name="_mask" map="B"/>
  <method class="org.apache.poi.util.BitField" name="boolean isSet(int)" map="A"/>
  <class name="org.apache.poi.util.HexDump" map="E"/>
  <field class="org.apache.poi.util.HexDump" name="EOL" map="A"/>
  <field class="org.apache.poi.util.HexDump" name="UTF8" map="B"/>
  <method class="org.apache.poi.util.HexDump" name="java.lang.String toHex(byte)" map="A"/>
  <method class="org.apache.poi.util.HexDump" name="java.lang.String longToHex(long)" map="A"/>
  <method class="org.apache.poi.util.HexDump" name="void writeHex(java.lang.StringBuilder, long, int, java.lang.String)" map="A"/>
  <class name="org.apache.poi.util.LittleEndianInput" map="F"/>
  <method class="org.apache.poi.util.LittleEndianInput" name="int readInt()" map="A"/>
  <method class="org.apache.poi.util.LittleEndianInput" name="int readUShort()" map="B"/>
  <class name="org.apache.poi.util.LittleEndian" map="G"/>
  <method class="org.apache.poi.util.LittleEndian" name="void putShort(byte[], int, short)" map="A"/>
  <method class="org.apache.poi.util.LittleEndian" name="short getShort(byte[], int)" map="A"/>
  <method class="org.apache.poi.util.LittleEndian" name="int getUShort(byte[], int)" map="B"/>
  <method class="org.apache.poi.util.LittleEndian" name="void putInt(byte[], int, int)" map="A"/>
  <method class="org.apache.poi.util.LittleEndian" name="long getLong(byte[], int)" map="C"/>
  <method class="org.apache.poi.util.LittleEndian" name="int getInt(byte[])" map="A"/>
  <method class="org.apache.poi.util.LittleEndian" name="int getInt(byte[], int)" map="D"/>
  <method class="org.apache.poi.util.LittleEndian" name="int getUShort(byte[])" map="B"/>
  <method class="org.apache.poi.util.LittleEndian" name="void putLong(byte[], int, long)" map="A"/>
  <class name="org.apache.poi.util.SuppressForbidden" map="H"/>
  <method class="org.apache.poi.util.SuppressForbidden" name="java.lang.String value()" map="A"/>
  <class name="org.apache.poi.util.Internal" map="I"/>
  <method class="org.apache.poi.util.Internal" name="java.lang.String since()" map="A"/>
  <class name="org.apache.poi.util.LocaleUtil" map="J"/>
  <field class="org.apache.poi.util.LocaleUtil" name="TIMEZONE_UTC" map="A"/>
  <field class="org.apache.poi.util.LocaleUtil" name="userLocale" map="B"/>
  <field class="org.apache.poi.util.LocaleUtil" name="CHARSET_1252" map="C"/>
  <field class="org.apache.poi.util.LocaleUtil" name="userTimeZone" map="D"/>
  <class name="org.apache.poi.util.LittleEndianConsts" map="K"/>
  <class name="org.apache.poi.util.IntegerField" map="L"/>
  <field class="org.apache.poi.util.IntegerField" name="_offset" map="A"/>
  <field class="org.apache.poi.util.IntegerField" name="_value" map="B"/>
  <method class="org.apache.poi.util.IntegerField" name="void writeToBytes(byte[])" map="A"/>
  <method class="org.apache.poi.util.IntegerField" name="void set(int, byte[])" map="A"/>
  <method class="org.apache.poi.util.IntegerField" name="void readFromBytes(byte[])" map="B"/>
  <method class="org.apache.poi.util.IntegerField" name="int get()" map="A"/>
  <method class="org.apache.poi.util.IntegerField" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.poi.util.NullLogger" map="M"/>
  <method class="org.apache.poi.util.NullLogger" name="void log(int, java.lang.Object[])" map="A"/>
  <method class="org.apache.poi.util.NullLogger" name="void initialize(java.lang.String)" map="A"/>
  <class name="org.apache.poi.util.FixedField" map="N"/>
  <class name="org.apache.poi.util.LongField" map="O"/>
  <field class="org.apache.poi.util.LongField" name="_offset" map="C"/>
  <field class="org.apache.poi.util.LongField" name="_value" map="D"/>
  <method class="org.apache.poi.util.LongField" name="void writeToBytes(byte[])" map="C"/>
  <method class="org.apache.poi.util.LongField" name="void set(long, byte[])" map="A"/>
  <method class="org.apache.poi.util.LongField" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.poi.util.ByteField" map="P"/>
  <field class="org.apache.poi.util.ByteField" name="_offset" map="E"/>
  <field class="org.apache.poi.util.ByteField" name="_value" map="F"/>
  <method class="org.apache.poi.util.ByteField" name="void writeToBytes(byte[])" map="D"/>
  <method class="org.apache.poi.util.ByteField" name="void readFromBytes(byte[])" map="E"/>
  <method class="org.apache.poi.util.ByteField" name="void set(byte, byte[])" map="A"/>
  <method class="org.apache.poi.util.ByteField" name="void set(byte)" map="A"/>
  <method class="org.apache.poi.util.ByteField" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.poi.util.RecordFormatException" map="Q"/>
  <class name="org.apache.poi.util.IOUtils" map="R"/>
  <field class="org.apache.poi.util.IOUtils" name="BYTE_ARRAY_MAX_OVERRIDE" map="A"/>
  <field class="org.apache.poi.util.IOUtils" name="logger" map="B"/>
  <method class="org.apache.poi.util.IOUtils" name="int readFully(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)" map="A"/>
  <method class="org.apache.poi.util.IOUtils" name="byte[] toByteArray(java.nio.ByteBuffer, int)" map="A"/>
  <method class="org.apache.poi.util.IOUtils" name="void checkLength(long, int)" map="A"/>
  <method class="org.apache.poi.util.IOUtils" name="void throwRFE(long, int)" map="B"/>
  <method class="org.apache.poi.util.IOUtils" name="byte[] safelyAllocate(long, int)" map="C"/>
  <method class="org.apache.poi.util.IOUtils" name="void closeQuietly(java.io.Closeable)" map="A"/>
  <class name="org.apache.poi.util.POILogFactory" map="S"/>
  <field class="org.apache.poi.util.POILogFactory" name="_loggers" map="A"/>
  <field class="org.apache.poi.util.POILogFactory" name="_loggerClassName" map="B"/>
  <field class="org.apache.poi.util.POILogFactory" name="_nullLogger" map="C"/>
  <method class="org.apache.poi.util.POILogFactory" name="org.apache.poi.util.POILogger getLogger(java.lang.Class)" map="A"/>
  <method class="org.apache.poi.util.POILogFactory" name="org.apache.poi.util.POILogger getLogger(java.lang.String)" map="A"/>
  <package name="org.apache.poi.ss" map="C"/>
  <package name="org.apache.poi.ss.usermodel" map="A"/>
  <class name="org.apache.poi.ss.usermodel.Workbook" map="A"/>
  <method class="org.apache.poi.ss.usermodel.Workbook" name="org.apache.poi.ss.usermodel.Sheet getSheet(java.lang.String)" map="A"/>
  <method class="org.apache.poi.ss.usermodel.Workbook" name="int getNumberOfSheets()" map="A"/>
  <class name="org.apache.poi.ss.usermodel.WorkbookFactory" map="B"/>
  <method class="org.apache.poi.ss.usermodel.WorkbookFactory" name="org.apache.poi.ss.usermodel.Workbook createHSSFWorkbook(java.lang.Object[])" map="A"/>
  <method class="org.apache.poi.ss.usermodel.WorkbookFactory" name="org.apache.poi.ss.usermodel.Workbook create(org.apache.poi.poifs.filesystem.DirectoryNode, java.lang.String)" map="A"/>
  <method class="org.apache.poi.ss.usermodel.WorkbookFactory" name="org.apache.poi.ss.usermodel.Workbook create(java.io.File, java.lang.String, boolean)" map="A"/>
  <method class="org.apache.poi.ss.usermodel.WorkbookFactory" name="org.apache.poi.ss.usermodel.Workbook createWorkbook(java.lang.String, java.lang.Object[])" map="A"/>
  <method class="org.apache.poi.ss.usermodel.WorkbookFactory" name="org.apache.poi.ss.usermodel.Workbook create(java.io.File, java.lang.String)" map="A"/>
  <method class="org.apache.poi.ss.usermodel.WorkbookFactory" name="org.apache.poi.ss.usermodel.Workbook create(org.apache.poi.poifs.filesystem.POIFSFileSystem, java.lang.String)" map="A"/>
  <method class="org.apache.poi.ss.usermodel.WorkbookFactory" name="org.apache.poi.ss.usermodel.Workbook create(java.io.File)" map="A"/>
  <method class="org.apache.poi.ss.usermodel.WorkbookFactory" name="org.apache.poi.ss.usermodel.Workbook createXSSFWorkbook(java.lang.Object[])" map="B"/>
  <package name="org.apache.poi.hssf" map="D"/>
  <package name="org.apache.poi.hssf.record" map="A"/>
  <package name="org.apache.poi.hssf.record.crypto" map="A"/>
  <class name="org.apache.poi.hssf.record.crypto.Biff8EncryptionKey" map="A"/>
  <field class="org.apache.poi.hssf.record.crypto.Biff8EncryptionKey" name="_userPasswordTLS" map="A"/>
  <method class="org.apache.poi.hssf.record.crypto.Biff8EncryptionKey" name="void setCurrentUserPassword(java.lang.String)" map="A"/>
  <class name="org.apache.poi.hssf.OldExcelFormatException" map="A"/>
  <package name="org.apache.poi.hpsf" map="E"/>
  <class name="org.apache.poi.hpsf.ClassID" map="A"/>
  <field class="org.apache.poi.hpsf.ClassID" name="EXCEL2007_MACRO" map="A"/>
  <field class="org.apache.poi.hpsf.ClassID" name="XLS_WORKBOOK" map="B"/>
  <field class="org.apache.poi.hpsf.ClassID" name="EXCEL2010_CHART" map="C"/>
  <field class="org.apache.poi.hpsf.ClassID" name="EXCEL97" map="D"/>
  <field class="org.apache.poi.hpsf.ClassID" name="OLE10_PACKAGE" map="E"/>
  <field class="org.apache.poi.hpsf.ClassID" name="EXCEL2010" map="F"/>
  <field class="org.apache.poi.hpsf.ClassID" name="EXCEL95" map="G"/>
  <field class="org.apache.poi.hpsf.ClassID" name="EXCEL2007_XLSB" map="H"/>
  <field class="org.apache.poi.hpsf.ClassID" name="EXCEL_V3_CHART" map="I"/>
  <field class="org.apache.poi.hpsf.ClassID" name="POWERPOINT97" map="J"/>
  <field class="org.apache.poi.hpsf.ClassID" name="EXCEL95_CHART" map="K"/>
  <field class="org.apache.poi.hpsf.ClassID" name="POWERPOINT2007_MACRO" map="L"/>
  <field class="org.apache.poi.hpsf.ClassID" name="POWERPOINT95" map="M"/>
  <field class="org.apache.poi.hpsf.ClassID" name="WORD2007_MACRO" map="N"/>
  <field class="org.apache.poi.hpsf.ClassID" name="WORD97" map="O"/>
  <field class="org.apache.poi.hpsf.ClassID" name="WORD2007" map="P"/>
  <field class="org.apache.poi.hpsf.ClassID" name="WORD95" map="Q"/>
  <field class="org.apache.poi.hpsf.ClassID" name="EQUATION30" map="R"/>
  <field class="org.apache.poi.hpsf.ClassID" name="EXCEL2010_ODS" map="S"/>
  <field class="org.apache.poi.hpsf.ClassID" name="EXCEL_V3_MACRO" map="T"/>
  <field class="org.apache.poi.hpsf.ClassID" name="bytes" map="U"/>
  <field class="org.apache.poi.hpsf.ClassID" name="EXCEL97_CHART" map="V"/>
  <field class="org.apache.poi.hpsf.ClassID" name="EXCEL2007" map="W"/>
  <field class="org.apache.poi.hpsf.ClassID" name="EXCEL2003" map="X"/>
  <field class="org.apache.poi.hpsf.ClassID" name="PPT_SHOW" map="Y"/>
  <field class="org.apache.poi.hpsf.ClassID" name="EXCEL_V3" map="Z"/>
  <field class="org.apache.poi.hpsf.ClassID" name="TXT_ONLY" map="_"/>
  <field class="org.apache.poi.hpsf.ClassID" name="POWERPOINT2007" map="a"/>
  <method class="org.apache.poi.hpsf.ClassID" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.poi.hpsf.ClassID" name="byte[] read(byte[], int)" map="A"/>
  <method class="org.apache.poi.hpsf.ClassID" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.poi.hpsf.ClassID" name="java.lang.String toString()" map="toString"/>
  <class name="org.apache.poi.hpsf.ClassIDPredefined" map="B"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="POWERPOINT_V12_MACRO" map="A"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V14_CHART" map="B"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="VISIO_V10" map="C"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="externalForm" map="D"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V14_ODS" map="E"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="POWERPOINT_V8_TPL" map="F"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="WORD_V12" map="G"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="WORD_V12_MACRO" map="H"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V12_MACRO" map="I"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="contentType" map="J"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V7_WORKBOOK" map="K"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V14_WORKBOOK" map="L"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V7_CHART" map="M"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V3_CHART" map="N"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V8_CHART" map="O"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="classId" map="P"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="OLE_V1_PACKAGE" map="Q"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="POWERPOINT_V8" map="R"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="POWERPOINT_V7" map="S"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V3_MACRO" map="T"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="$VALUES" map="U"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V12_XLSB" map="V"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V14" map="W"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V12" map="X"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V11" map="Y"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="LOOKUP" map="Z"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="TXT_ONLY" map="_"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="PDF" map="a"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="WORD_V8" map="b"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="WORD_V7" map="c"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="POWERPOINT_V7_SLIDE" map="d"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V8" map="e"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V7" map="f"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EXCEL_V3" map="g"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="EQUATION_V3" map="h"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="PUBLISHER_V12" map="i"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="fileExtension" map="j"/>
  <field class="org.apache.poi.hpsf.ClassIDPredefined" name="POWERPOINT_V12" map="k"/>
  <method class="org.apache.poi.hpsf.ClassIDPredefined" name="org.apache.poi.hpsf.ClassIDPredefined[] values()" map="values"/>
  <method class="org.apache.poi.hpsf.ClassIDPredefined" name="org.apache.poi.hpsf.ClassIDPredefined valueOf(java.lang.String)" map="valueOf"/>
  <method class="org.apache.poi.hpsf.ClassIDPredefined" name="org.apache.poi.hpsf.ClassID getClassID()" map="A"/>
  <package name="org.apache.poi.poifs" map="F"/>
  <package name="org.apache.poi.poifs.dev" map="A"/>
  <class name="org.apache.poi.poifs.dev.package-info" map="package-info"/>
  <class name="org.apache.poi.poifs.dev.POIFSViewable" map="A"/>
  <package name="org.apache.poi.poifs.common" map="B"/>
  <class name="org.apache.poi.poifs.common.POIFSConstants" map="A"/>
  <field class="org.apache.poi.poifs.common.POIFSConstants" name="RAW_XML_FILE_HEADER" map="A"/>
  <field class="org.apache.poi.poifs.common.POIFSConstants" name="SMALLER_BIG_BLOCK_SIZE_DETAILS" map="B"/>
  <field class="org.apache.poi.poifs.common.POIFSConstants" name="LARGER_BIG_BLOCK_SIZE_DETAILS" map="C"/>
  <field class="org.apache.poi.poifs.common.POIFSConstants" name="OOXML_FILE_HEADER" map="D"/>
  <class name="org.apache.poi.poifs.common.POIFSBigBlockSize" map="B"/>
  <field class="org.apache.poi.poifs.common.POIFSBigBlockSize" name="bigBlockSize" map="A"/>
  <field class="org.apache.poi.poifs.common.POIFSBigBlockSize" name="headerValue" map="B"/>
  <method class="org.apache.poi.poifs.common.POIFSBigBlockSize" name="int getXBATEntriesPerBlock()" map="A"/>
  <method class="org.apache.poi.poifs.common.POIFSBigBlockSize" name="int getBATEntriesPerBlock()" map="B"/>
  <method class="org.apache.poi.poifs.common.POIFSBigBlockSize" name="int getBigBlockSize()" map="C"/>
  <method class="org.apache.poi.poifs.common.POIFSBigBlockSize" name="short getHeaderValue()" map="D"/>
  <class name="org.apache.poi.poifs.common.package-info" map="package-info"/>
  <package name="org.apache.poi.poifs.property" map="C"/>
  <class name="org.apache.poi.poifs.property.Parent" map="A"/>
  <class name="org.apache.poi.poifs.property.PropertyTable" map="B"/>
  <field class="org.apache.poi.poifs.property.PropertyTable" name="_bigBigBlockSize" map="A"/>
  <field class="org.apache.poi.poifs.property.PropertyTable" name="_properties" map="B"/>
  <field class="org.apache.poi.poifs.property.PropertyTable" name="_logger" map="C"/>
  <field class="org.apache.poi.poifs.property.PropertyTable" name="_header_block" map="D"/>
  <method class="org.apache.poi.poifs.property.PropertyTable" name="boolean isValidIndex(int)" map="A"/>
  <method class="org.apache.poi.poifs.property.PropertyTable" name="void populatePropertyTree(org.apache.poi.poifs.property.DirectoryProperty)" map="A"/>
  <method class="org.apache.poi.poifs.property.PropertyTable" name="org.apache.poi.poifs.property.RootProperty getRoot()" map="A"/>
  <method class="org.apache.poi.poifs.property.PropertyTable" name="void addProperty(org.apache.poi.poifs.property.Property)" map="A"/>
  <class name="org.apache.poi.poifs.property.DirectoryProperty" map="C"/>
  <field class="org.apache.poi.poifs.property.DirectoryProperty" name="_children" map="U"/>
  <field class="org.apache.poi.poifs.property.DirectoryProperty" name="_children_names" map="V"/>
  <method class="org.apache.poi.poifs.property.DirectoryProperty" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="org.apache.poi.poifs.property.DirectoryProperty" name="java.util.Iterator getChildren()" map="J"/>
  <method class="org.apache.poi.poifs.property.DirectoryProperty" name="boolean isDirectory()" map="B"/>
  <method class="org.apache.poi.poifs.property.DirectoryProperty" name="void addChild(org.apache.poi.poifs.property.Property)" map="A"/>
  <class name="org.apache.poi.poifs.property.package-info" map="package-info"/>
  <class name="org.apache.poi.poifs.property.DocumentProperty" map="D"/>
  <field class="org.apache.poi.poifs.property.DocumentProperty" name="_document" map="T"/>
  <method class="org.apache.poi.poifs.property.DocumentProperty" name="boolean isDirectory()" map="B"/>
  <method class="org.apache.poi.poifs.property.DocumentProperty" name="org.apache.poi.poifs.filesystem.POIFSDocument getDocument()" map="I"/>
  <class name="org.apache.poi.poifs.property.Property" map="E"/>
  <field class="org.apache.poi.poifs.property.Property" name="_seconds_2" map="A"/>
  <field class="org.apache.poi.poifs.property.Property" name="_seconds_1" map="B"/>
  <field class="org.apache.poi.poifs.property.Property" name="_size" map="C"/>
  <field class="org.apache.poi.poifs.property.Property" name="_name_size" map="D"/>
  <field class="org.apache.poi.poifs.property.Property" name="_days_2" map="E"/>
  <field class="org.apache.poi.poifs.property.Property" name="_days_1" map="F"/>
  <field class="org.apache.poi.poifs.property.Property" name="_property_type" map="G"/>
  <field class="org.apache.poi.poifs.property.Property" name="_node_color" map="H"/>
  <field class="org.apache.poi.poifs.property.Property" name="_previous_property" map="I"/>
  <field class="org.apache.poi.poifs.property.Property" name="_raw_data" map="J"/>
  <field class="org.apache.poi.poifs.property.Property" name="_name" map="K"/>
  <field class="org.apache.poi.poifs.property.Property" name="_previous_child" map="L"/>
  <field class="org.apache.poi.poifs.property.Property" name="_next_child" map="M"/>
  <field class="org.apache.poi.poifs.property.Property" name="_index" map="N"/>
  <field class="org.apache.poi.poifs.property.Property" name="_child_property" map="O"/>
  <field class="org.apache.poi.poifs.property.Property" name="_start_block" map="P"/>
  <field class="org.apache.poi.poifs.property.Property" name="_next_property" map="Q"/>
  <field class="org.apache.poi.poifs.property.Property" name="_storage_clsid" map="R"/>
  <field class="org.apache.poi.poifs.property.Property" name="_user_flags" map="S"/>
  <method class="org.apache.poi.poifs.property.Property" name="int getChildIndex()" map="A"/>
  <method class="org.apache.poi.poifs.property.Property" name="boolean isDirectory()" map="B"/>
  <method class="org.apache.poi.poifs.property.Property" name="void setName(java.lang.String)" map="A"/>
  <method class="org.apache.poi.poifs.property.Property" name="int getIndex()" map="C"/>
  <method class="org.apache.poi.poifs.property.Property" name="void setPropertyType(byte)" map="A"/>
  <method class="org.apache.poi.poifs.property.Property" name="boolean isValidIndex(int)" map="A"/>
  <method class="org.apache.poi.poifs.property.Property" name="void setNextChild(org.apache.poi.poifs.property.Child)" map="A"/>
  <method class="org.apache.poi.poifs.property.Property" name="int getStartBlock()" map="D"/>
  <method class="org.apache.poi.poifs.property.Property" name="void setNodeColor(byte)" map="B"/>
  <method class="org.apache.poi.poifs.property.Property" name="int getNextChildIndex()" map="E"/>
  <method class="org.apache.poi.poifs.property.Property" name="java.lang.String getName()" map="F"/>
  <method class="org.apache.poi.poifs.property.Property" name="int getSize()" map="G"/>
  <method class="org.apache.poi.poifs.property.Property" name="void setSize(int)" map="B"/>
  <method class="org.apache.poi.poifs.property.Property" name="void setPreviousChild(org.apache.poi.poifs.property.Child)" map="B"/>
  <method class="org.apache.poi.poifs.property.Property" name="void setStartBlock(int)" map="C"/>
  <method class="org.apache.poi.poifs.property.Property" name="int getPreviousChildIndex()" map="H"/>
  <class name="org.apache.poi.poifs.property.RootProperty" map="F"/>
  <method class="org.apache.poi.poifs.property.RootProperty" name="java.lang.String getName()" map="F"/>
  <method class="org.apache.poi.poifs.property.RootProperty" name="void setSize(int)" map="B"/>
  <class name="org.apache.poi.poifs.property.PropertyFactory" map="G"/>
  <method class="org.apache.poi.poifs.property.PropertyFactory" name="void convertToProperties(byte[], java.util.List)" map="A"/>
  <class name="org.apache.poi.poifs.property.Child" map="H"/>
  <package name="org.apache.poi.poifs.crypt" map="D"/>
  <class name="org.apache.poi.poifs.crypt.EncryptionMode" map="A"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionMode" name="versionMajor" map="A"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionMode" name="$VALUES" map="B"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionMode" name="cryptoAPI" map="C"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionMode" name="standard" map="D"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionMode" name="builder" map="E"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionMode" name="xor" map="F"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionMode" name="agile" map="G"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionMode" name="encryptionFlags" map="H"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionMode" name="binaryRC4" map="I"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionMode" name="versionMinor" map="J"/>
  <method class="org.apache.poi.poifs.crypt.EncryptionMode" name="org.apache.poi.poifs.crypt.EncryptionMode valueOf(java.lang.String)" map="valueOf"/>
  <method class="org.apache.poi.poifs.crypt.EncryptionMode" name="org.apache.poi.poifs.crypt.EncryptionMode[] values()" map="values"/>
  <class name="org.apache.poi.poifs.crypt.HashAlgorithm" map="B"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="ripemd160" map="A"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="ecmaId" map="B"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="ecmaString" map="C"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="none" map="D"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="whirlpool" map="E"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="ripemd256" map="F"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="needsBouncyCastle" map="G"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="md5" map="H"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="md4" map="I"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="jceHmacId" map="J"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="md2" map="K"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="hashSize" map="L"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="sha256" map="M"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="sha224" map="N"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="ripemd128" map="O"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="sha1" map="P"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="sha512" map="Q"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="rsaOid" map="R"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="jceId" map="S"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="$VALUES" map="T"/>
  <field class="org.apache.poi.poifs.crypt.HashAlgorithm" name="sha384" map="U"/>
  <method class="org.apache.poi.poifs.crypt.HashAlgorithm" name="org.apache.poi.poifs.crypt.HashAlgorithm valueOf(java.lang.String)" map="valueOf"/>
  <method class="org.apache.poi.poifs.crypt.HashAlgorithm" name="org.apache.poi.poifs.crypt.HashAlgorithm[] values()" map="values"/>
  <class name="org.apache.poi.poifs.crypt.ChainingMode" map="C"/>
  <field class="org.apache.poi.poifs.crypt.ChainingMode" name="ecmaId" map="A"/>
  <field class="org.apache.poi.poifs.crypt.ChainingMode" name="jceId" map="B"/>
  <field class="org.apache.poi.poifs.crypt.ChainingMode" name="ecb" map="C"/>
  <field class="org.apache.poi.poifs.crypt.ChainingMode" name="$VALUES" map="D"/>
  <field class="org.apache.poi.poifs.crypt.ChainingMode" name="cfb" map="E"/>
  <field class="org.apache.poi.poifs.crypt.ChainingMode" name="cbc" map="F"/>
  <method class="org.apache.poi.poifs.crypt.ChainingMode" name="org.apache.poi.poifs.crypt.ChainingMode valueOf(java.lang.String)" map="valueOf"/>
  <method class="org.apache.poi.poifs.crypt.ChainingMode" name="org.apache.poi.poifs.crypt.ChainingMode[] values()" map="values"/>
  <class name="org.apache.poi.poifs.crypt.EncryptionHeader" map="D"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionHeader" name="PROVIDER_RC4" map="A"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionHeader" name="ALGORITHM_AES_192" map="B"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionHeader" name="ALGORITHM_AES_128" map="C"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionHeader" name="PROVIDER_AES" map="D"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionHeader" name="MODE_CFB" map="E"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionHeader" name="ALGORITHM_RC4" map="F"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionHeader" name="HASH_SHA1" map="G"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionHeader" name="HASH_SHA256" map="H"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionHeader" name="ALGORITHM_AES_256" map="I"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionHeader" name="HASH_SHA512" map="J"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionHeader" name="MODE_CBC" map="K"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionHeader" name="HASH_SHA384" map="L"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionHeader" name="MODE_ECB" map="M"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionHeader" name="HASH_NONE" map="N"/>
  <method class="org.apache.poi.poifs.crypt.EncryptionHeader" name="org.apache.poi.poifs.crypt.EncryptionHeader clone()" map="A"/>
  <class name="org.apache.poi.poifs.crypt.EncryptionInfoBuilder" map="E"/>
  <method class="org.apache.poi.poifs.crypt.EncryptionInfoBuilder" name="void initialize(org.apache.poi.poifs.crypt.EncryptionInfo, org.apache.poi.util.LittleEndianInput)" map="A"/>
  <class name="org.apache.poi.poifs.crypt.CipherAlgorithm" map="F"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="ecmaId" map="A"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="rsa" map="B"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="needsBouncyCastle" map="C"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="aes128" map="D"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="des" map="E"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="blockSize" map="F"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="allowedKeySize" map="G"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="des3_112" map="H"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="encryptedVerifierHashLength" map="I"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="defaultKeySize" map="J"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="rc4" map="K"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="rc2" map="L"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="aes192" map="M"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="xmlId" map="N"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="jceId" map="O"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="$VALUES" map="P"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="des3" map="Q"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="aes256" map="R"/>
  <field class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="provider" map="S"/>
  <method class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="org.apache.poi.poifs.crypt.CipherAlgorithm valueOf(java.lang.String)" map="valueOf"/>
  <method class="org.apache.poi.poifs.crypt.CipherAlgorithm" name="org.apache.poi.poifs.crypt.CipherAlgorithm[] values()" map="values"/>
  <class name="org.apache.poi.poifs.crypt.package-info" map="package-info"/>
  <class name="org.apache.poi.poifs.crypt.Encryptor" map="G"/>
  <method class="org.apache.poi.poifs.crypt.Encryptor" name="org.apache.poi.poifs.crypt.Encryptor clone()" map="A"/>
  <method class="org.apache.poi.poifs.crypt.Encryptor" name="void setEncryptionInfo(org.apache.poi.poifs.crypt.EncryptionInfo)" map="A"/>
  <class name="org.apache.poi.poifs.crypt.EncryptionInfo" map="H"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionInfo" name="versionMajor" map="A"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionInfo" name="flagDocProps" map="B"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionInfo" name="flagCryptoAPI" map="C"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionInfo" name="header" map="D"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionInfo" name="encryptor" map="E"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionInfo" name="flagAES" map="F"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionInfo" name="encryptionFlags" map="G"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionInfo" name="verifier" map="H"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionInfo" name="flagExternal" map="I"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionInfo" name="decryptor" map="J"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionInfo" name="versionMinor" map="K"/>
  <field class="org.apache.poi.poifs.crypt.EncryptionInfo" name="encryptionMode" map="L"/>
  <method class="org.apache.poi.poifs.crypt.EncryptionInfo" name="java.lang.Object clone()" map="clone"/>
  <method class="org.apache.poi.poifs.crypt.EncryptionInfo" name="org.apache.poi.poifs.crypt.EncryptionInfo clone()" map="A"/>
  <method class="org.apache.poi.poifs.crypt.EncryptionInfo" name="org.apache.poi.poifs.crypt.EncryptionInfoBuilder getBuilder(org.apache.poi.poifs.crypt.EncryptionMode)" map="A"/>
  <method class="org.apache.poi.poifs.crypt.EncryptionInfo" name="org.apache.poi.poifs.crypt.Decryptor getDecryptor()" map="B"/>
  <class name="org.apache.poi.poifs.crypt.Decryptor" map="I"/>
  <method class="org.apache.poi.poifs.crypt.Decryptor" name="void setEncryptionInfo(org.apache.poi.poifs.crypt.EncryptionInfo)" map="A"/>
  <method class="org.apache.poi.poifs.crypt.Decryptor" name="java.io.InputStream getDataStream(org.apache.poi.poifs.filesystem.DirectoryNode)" map="A"/>
  <method class="org.apache.poi.poifs.crypt.Decryptor" name="org.apache.poi.poifs.crypt.Decryptor clone()" map="A"/>
  <method class="org.apache.poi.poifs.crypt.Decryptor" name="boolean verifyPassword(java.lang.String)" map="A"/>
  <method class="org.apache.poi.poifs.crypt.Decryptor" name="org.apache.poi.poifs.crypt.Decryptor getInstance(org.apache.poi.poifs.crypt.EncryptionInfo)" map="B"/>
  <class name="org.apache.poi.poifs.crypt.CipherProvider" map="J"/>
  <field class="org.apache.poi.poifs.crypt.CipherProvider" name="cipherProviderName" map="A"/>
  <field class="org.apache.poi.poifs.crypt.CipherProvider" name="ecmaId" map="B"/>
  <field class="org.apache.poi.poifs.crypt.CipherProvider" name="jceId" map="C"/>
  <field class="org.apache.poi.poifs.crypt.CipherProvider" name="$VALUES" map="D"/>
  <field class="org.apache.poi.poifs.crypt.CipherProvider" name="aes" map="E"/>
  <field class="org.apache.poi.poifs.crypt.CipherProvider" name="rc4" map="F"/>
  <method class="org.apache.poi.poifs.crypt.CipherProvider" name="org.apache.poi.poifs.crypt.CipherProvider valueOf(java.lang.String)" map="valueOf"/>
  <method class="org.apache.poi.poifs.crypt.CipherProvider" name="org.apache.poi.poifs.crypt.CipherProvider[] values()" map="values"/>
  <class name="org.apache.poi.poifs.crypt.EncryptionVerifier" map="K"/>
  <method class="org.apache.poi.poifs.crypt.EncryptionVerifier" name="org.apache.poi.poifs.crypt.EncryptionVerifier clone()" map="A"/>
  <package name="org.apache.poi.poifs.storage" map="E"/>
  <class name="org.apache.poi.poifs.storage.HeaderBlock$1" map="1"/>
  <field class="org.apache.poi.poifs.storage.HeaderBlock$1" name="$SwitchMap$org$apache$poi$poifs$filesystem$FileMagic" map="A"/>
  <class name="org.apache.poi.poifs.storage.HeaderBlock" map="A"/>
  <field class="org.apache.poi.poifs.storage.HeaderBlock" name="_sbat_start" map="A"/>
  <field class="org.apache.poi.poifs.storage.HeaderBlock" name="_xbat_count" map="B"/>
  <field class="org.apache.poi.poifs.storage.HeaderBlock" name="_property_start" map="C"/>
  <field class="org.apache.poi.poifs.storage.HeaderBlock" name="bigBlockSize" map="D"/>
  <field class="org.apache.poi.poifs.storage.HeaderBlock" name="_data" map="E"/>
  <field class="org.apache.poi.poifs.storage.HeaderBlock" name="_bat_count" map="F"/>
  <field class="org.apache.poi.poifs.storage.HeaderBlock" name="_xbat_start" map="G"/>
  <field class="org.apache.poi.poifs.storage.HeaderBlock" name="_sbat_count" map="H"/>
  <method class="org.apache.poi.poifs.storage.HeaderBlock" name="org.apache.poi.poifs.common.POIFSBigBlockSize getBigBlockSize()" map="A"/>
  <method class="org.apache.poi.poifs.storage.HeaderBlock" name="int[] getBATArray()" map="B"/>
  <method class="org.apache.poi.poifs.storage.HeaderBlock" name="int getBATCount()" map="C"/>
  <method class="org.apache.poi.poifs.storage.HeaderBlock" name="int getSBATStart()" map="D"/>
  <method class="org.apache.poi.poifs.storage.HeaderBlock" name="int getXBATCount()" map="E"/>
  <method class="org.apache.poi.poifs.storage.HeaderBlock" name="int getPropertyStart()" map="F"/>
  <method class="org.apache.poi.poifs.storage.HeaderBlock" name="int getXBATIndex()" map="G"/>
  <method class="org.apache.poi.poifs.storage.HeaderBlock" name="int getSBATCount()" map="H"/>
  <class name="org.apache.poi.poifs.storage.HeaderBlockConstants" map="B"/>
  <class name="org.apache.poi.poifs.storage.BATBlock$BATBlockAndIndex" map="_A"/>
  <field class="org.apache.poi.poifs.storage.BATBlock$BATBlockAndIndex" name="index" map="A"/>
  <field class="org.apache.poi.poifs.storage.BATBlock$BATBlockAndIndex" name="block" map="B"/>
  <method class="org.apache.poi.poifs.storage.BATBlock$BATBlockAndIndex" name="org.apache.poi.poifs.storage.BATBlock getBlock()" map="A"/>
  <method class="org.apache.poi.poifs.storage.BATBlock$BATBlockAndIndex" name="int getIndex()" map="B"/>
  <class name="org.apache.poi.poifs.storage.BATBlock$1" map="1"/>
  <class name="org.apache.poi.poifs.storage.BATBlock" map="C"/>
  <field class="org.apache.poi.poifs.storage.BATBlock" name="ourBlockIndex" map="A"/>
  <field class="org.apache.poi.poifs.storage.BATBlock" name="bigBlockSize" map="B"/>
  <field class="org.apache.poi.poifs.storage.BATBlock" name="_values" map="C"/>
  <field class="org.apache.poi.poifs.storage.BATBlock" name="_has_free_sectors" map="D"/>
  <method class="org.apache.poi.poifs.storage.BATBlock" name="org.apache.poi.poifs.storage.BATBlock$BATBlockAndIndex getBATBlockAndIndex(int, org.apache.poi.poifs.storage.HeaderBlock, java.util.List)" map="A"/>
  <method class="org.apache.poi.poifs.storage.BATBlock" name="org.apache.poi.poifs.storage.BATBlock$BATBlockAndIndex getSBATBlockAndIndex(int, org.apache.poi.poifs.storage.HeaderBlock, java.util.List)" map="B"/>
  <method class="org.apache.poi.poifs.storage.BATBlock" name="void recomputeFree()" map="A"/>
  <method class="org.apache.poi.poifs.storage.BATBlock" name="void setOurBlockIndex(int)" map="A"/>
  <method class="org.apache.poi.poifs.storage.BATBlock" name="org.apache.poi.poifs.storage.BATBlock createBATBlock(org.apache.poi.poifs.common.POIFSBigBlockSize, java.nio.ByteBuffer)" map="A"/>
  <method class="org.apache.poi.poifs.storage.BATBlock" name="int getValueAt(int)" map="B"/>
  <class name="org.apache.poi.poifs.storage.package-info" map="package-info"/>
  <class name="org.apache.poi.poifs.storage.BlockWritable" map="D"/>
  <package name="org.apache.poi.poifs.nio" map="F"/>
  <class name="org.apache.poi.poifs.nio.ByteArrayBackedDataSource" map="A"/>
  <field class="org.apache.poi.poifs.nio.ByteArrayBackedDataSource" name="buffer" map="F"/>
  <field class="org.apache.poi.poifs.nio.ByteArrayBackedDataSource" name="size" map="G"/>
  <method class="org.apache.poi.poifs.nio.ByteArrayBackedDataSource" name="long size()" map="A"/>
  <method class="org.apache.poi.poifs.nio.ByteArrayBackedDataSource" name="void close()" map="B"/>
  <method class="org.apache.poi.poifs.nio.ByteArrayBackedDataSource" name="java.nio.ByteBuffer read(int, long)" map="A"/>
  <class name="org.apache.poi.poifs.nio.DataSource" map="B"/>
  <method class="org.apache.poi.poifs.nio.DataSource" name="long size()" map="A"/>
  <method class="org.apache.poi.poifs.nio.DataSource" name="void close()" map="B"/>
  <method class="org.apache.poi.poifs.nio.DataSource" name="java.nio.ByteBuffer read(int, long)" map="A"/>
  <class name="org.apache.poi.poifs.nio.FileBackedDataSource$1" map="1"/>
  <field class="org.apache.poi.poifs.nio.FileBackedDataSource$1" name="val$buffer" map="A"/>
  <method class="org.apache.poi.poifs.nio.FileBackedDataSource$1" name="java.lang.Object run()" map="run"/>
  <method class="org.apache.poi.poifs.nio.FileBackedDataSource$1" name="java.lang.Void run()" map="A"/>
  <class name="org.apache.poi.poifs.nio.FileBackedDataSource" map="C"/>
  <field class="org.apache.poi.poifs.nio.FileBackedDataSource" name="logger" map="A"/>
  <field class="org.apache.poi.poifs.nio.FileBackedDataSource" name="writable" map="B"/>
  <field class="org.apache.poi.poifs.nio.FileBackedDataSource" name="buffersToClean" map="C"/>
  <field class="org.apache.poi.poifs.nio.FileBackedDataSource" name="srcFile" map="D"/>
  <field class="org.apache.poi.poifs.nio.FileBackedDataSource" name="channel" map="E"/>
  <method class="org.apache.poi.poifs.nio.FileBackedDataSource" name="long size()" map="A"/>
  <method class="org.apache.poi.poifs.nio.FileBackedDataSource" name="void unmap(java.nio.ByteBuffer)" map="A"/>
  <method class="org.apache.poi.poifs.nio.FileBackedDataSource" name="org.apache.poi.util.POILogger access$000()" map="C"/>
  <method class="org.apache.poi.poifs.nio.FileBackedDataSource" name="java.io.RandomAccessFile newSrcFile(java.io.File, java.lang.String)" map="A"/>
  <method class="org.apache.poi.poifs.nio.FileBackedDataSource" name="void close()" map="B"/>
  <method class="org.apache.poi.poifs.nio.FileBackedDataSource" name="java.nio.ByteBuffer read(int, long)" map="A"/>
  <method class="org.apache.poi.poifs.nio.FileBackedDataSource" name="java.nio.channels.FileChannel getChannel()" map="D"/>
  <package name="org.apache.poi.poifs.filesystem" map="G"/>
  <class name="org.apache.poi.poifs.filesystem.FileMagic" map="A"/>
  <field class="org.apache.poi.poifs.filesystem.FileMagic" name="XML" map="A"/>
  <field class="org.apache.poi.poifs.filesystem.FileMagic" name="$VALUES" map="B"/>
  <field class="org.apache.poi.poifs.filesystem.FileMagic" name="HTML" map="C"/>
  <field class="org.apache.poi.poifs.filesystem.FileMagic" name="OOXML" map="D"/>
  <field class="org.apache.poi.poifs.filesystem.FileMagic" name="RTF" map="E"/>
  <field class="org.apache.poi.poifs.filesystem.FileMagic" name="PDF" map="F"/>
  <field class="org.apache.poi.poifs.filesystem.FileMagic" name="UNKNOWN" map="G"/>
  <field class="org.apache.poi.poifs.filesystem.FileMagic" name="OLE2" map="H"/>
  <field class="org.apache.poi.poifs.filesystem.FileMagic" name="magic" map="I"/>
  <field class="org.apache.poi.poifs.filesystem.FileMagic" name="MSWRITE" map="J"/>
  <field class="org.apache.poi.poifs.filesystem.FileMagic" name="WORD2" map="K"/>
  <field class="org.apache.poi.poifs.filesystem.FileMagic" name="BIFF4" map="L"/>
  <field class="org.apache.poi.poifs.filesystem.FileMagic" name="BIFF3" map="M"/>
  <field class="org.apache.poi.poifs.filesystem.FileMagic" name="BIFF2" map="N"/>
  <method class="org.apache.poi.poifs.filesystem.FileMagic" name="org.apache.poi.poifs.filesystem.FileMagic valueOf(byte[])" map="A"/>
  <method class="org.apache.poi.poifs.filesystem.FileMagic" name="org.apache.poi.poifs.filesystem.FileMagic valueOf(java.lang.String)" map="valueOf"/>
  <method class="org.apache.poi.poifs.filesystem.FileMagic" name="org.apache.poi.poifs.filesystem.FileMagic[] values()" map="values"/>
  <class name="org.apache.poi.poifs.filesystem.BlockStore$ChainLoopDetector" map="_A"/>
  <field class="org.apache.poi.poifs.filesystem.BlockStore$ChainLoopDetector" name="this$0" map="A"/>
  <field class="org.apache.poi.poifs.filesystem.BlockStore$ChainLoopDetector" name="used_blocks" map="B"/>
  <method class="org.apache.poi.poifs.filesystem.BlockStore$ChainLoopDetector" name="void claim(int)" map="A"/>
  <class name="org.apache.poi.poifs.filesystem.BlockStore" map="B"/>
  <method class="org.apache.poi.poifs.filesystem.BlockStore" name="int getNextBlock(int)" map="D"/>
  <method class="org.apache.poi.poifs.filesystem.BlockStore" name="org.apache.poi.poifs.filesystem.BlockStore$ChainLoopDetector getChainLoopDetector()" map="K"/>
  <method class="org.apache.poi.poifs.filesystem.BlockStore" name="java.nio.ByteBuffer getBlockAt(int)" map="E"/>
  <method class="org.apache.poi.poifs.filesystem.BlockStore" name="int getBlockStoreBlockSize()" map="L"/>
  <class name="org.apache.poi.poifs.filesystem.EntryNode" map="C"/>
  <field class="org.apache.poi.poifs.filesystem.EntryNode" name="_property" map="j"/>
  <field class="org.apache.poi.poifs.filesystem.EntryNode" name="_parent" map="k"/>
  <method class="org.apache.poi.poifs.filesystem.EntryNode" name="org.apache.poi.poifs.filesystem.DirectoryEntry getParent()" map="S"/>
  <method class="org.apache.poi.poifs.filesystem.EntryNode" name="java.lang.String getName()" map="Q"/>
  <method class="org.apache.poi.poifs.filesystem.EntryNode" name="boolean isDocumentEntry()" map="R"/>
  <method class="org.apache.poi.poifs.filesystem.EntryNode" name="org.apache.poi.poifs.property.Property getProperty()" map="T"/>
  <class name="org.apache.poi.poifs.filesystem.POIFSFileSystem" map="D"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="_bat_blocks" map="a"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="_data" map="b"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="bigBlockSize" map="c"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="_root" map="d"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="_mini_store" map="e"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="_xbat_blocks" map="f"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="_property_table" map="g"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="_header" map="h"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="LOG" map="i"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="int getBigBlockSize()" map="M"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="void readBAT(int, org.apache.poi.poifs.filesystem.BlockStore$ChainLoopDetector)" map="A"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="void close()" map="close"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="org.apache.poi.poifs.storage.BATBlock$BATBlockAndIndex getBATBlockAndIndex(int)" map="G"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="int getNextBlock(int)" map="D"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="org.apache.poi.poifs.filesystem.POIFSMiniStore getMiniStore()" map="N"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="org.apache.poi.poifs.filesystem.DirectoryNode getRoot()" map="O"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="int getBlockStoreBlockSize()" map="L"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="org.apache.poi.poifs.filesystem.BlockStore$ChainLoopDetector getChainLoopDetector()" map="K"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="java.nio.ByteBuffer getBlockAt(int)" map="E"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSFileSystem" name="void readCoreContents()" map="P"/>
  <class name="org.apache.poi.poifs.filesystem.NotOLE2FileException" map="E"/>
  <class name="org.apache.poi.poifs.filesystem.DirectoryEntry" map="F"/>
  <class name="org.apache.poi.poifs.filesystem.Entry" map="G"/>
  <method class="org.apache.poi.poifs.filesystem.Entry" name="java.lang.String getName()" map="Q"/>
  <method class="org.apache.poi.poifs.filesystem.Entry" name="boolean isDocumentEntry()" map="R"/>
  <class name="org.apache.poi.poifs.filesystem.DocumentEntry" map="H"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentEntry" name="int getSize()" map="U"/>
  <class name="org.apache.poi.poifs.filesystem.POIFSDocumentPath" map="I"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSDocumentPath" name="hashcode" map="A"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSDocumentPath" name="log" map="B"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSDocumentPath" name="components" map="C"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSDocumentPath" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSDocumentPath" name="int hashCode()" map="hashCode"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSDocumentPath" name="int computeHashCode()" map="A"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSDocumentPath" name="java.lang.String toString()" map="toString"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSDocumentPath" name="java.lang.String getComponent(int)" map="A"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSDocumentPath" name="int length()" map="B"/>
  <class name="org.apache.poi.poifs.filesystem.package-info" map="package-info"/>
  <class name="org.apache.poi.poifs.filesystem.BATManaged" map="J"/>
  <class name="org.apache.poi.poifs.filesystem.OfficeXmlFileException" map="K"/>
  <class name="org.apache.poi.poifs.filesystem.DirectoryNode" map="L"/>
  <field class="org.apache.poi.poifs.filesystem.DirectoryNode" name="_path" map="m"/>
  <field class="org.apache.poi.poifs.filesystem.DirectoryNode" name="_nfilesystem" map="n"/>
  <field class="org.apache.poi.poifs.filesystem.DirectoryNode" name="_entries" map="o"/>
  <field class="org.apache.poi.poifs.filesystem.DirectoryNode" name="_byname" map="p"/>
  <method class="org.apache.poi.poifs.filesystem.DirectoryNode" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="org.apache.poi.poifs.filesystem.DirectoryNode" name="org.apache.poi.poifs.filesystem.DocumentInputStream createDocumentInputStream(org.apache.poi.poifs.filesystem.Entry)" map="A"/>
  <method class="org.apache.poi.poifs.filesystem.DirectoryNode" name="java.util.Iterator getEntries()" map="V"/>
  <method class="org.apache.poi.poifs.filesystem.DirectoryNode" name="org.apache.poi.poifs.filesystem.POIFSFileSystem getFileSystem()" map="W"/>
  <method class="org.apache.poi.poifs.filesystem.DirectoryNode" name="boolean hasEntry(java.lang.String)" map="B"/>
  <method class="org.apache.poi.poifs.filesystem.DirectoryNode" name="org.apache.poi.poifs.filesystem.Entry getEntry(java.lang.String)" map="C"/>
  <method class="org.apache.poi.poifs.filesystem.DirectoryNode" name="org.apache.poi.poifs.filesystem.POIFSFileSystem getNFileSystem()" map="X"/>
  <method class="org.apache.poi.poifs.filesystem.DirectoryNode" name="org.apache.poi.poifs.filesystem.DocumentInputStream createDocumentInputStream(java.lang.String)" map="D"/>
  <class name="org.apache.poi.poifs.filesystem.DocumentInputStream" map="M"/>
  <field class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="_closed" map="A"/>
  <field class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="_data" map="B"/>
  <field class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="_current_offset" map="C"/>
  <field class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="_document_size" map="D"/>
  <field class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="_marked_offset" map="E"/>
  <field class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="_current_block_count" map="F"/>
  <field class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="_document" map="G"/>
  <field class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="_buffer" map="H"/>
  <field class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="_marked_offset_count" map="I"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="int readInt()" map="A"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="void reset()" map="reset"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="int read(byte[])" map="read"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="void close()" map="close"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="boolean markSupported()" map="markSupported"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="void mark(int)" map="mark"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="void checkAvaliable(int)" map="A"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="void readFully(byte[], int, int)" map="A"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="void readFully(byte[])" map="A"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="boolean atEOD()" map="C"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="int read()" map="read"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="int remainingBytes()" map="D"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="void dieIfClosed()" map="E"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="int read(byte[], int, int)" map="read"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="long skip(long)" map="skip"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="int available()" map="available"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentInputStream" name="int readUShort()" map="B"/>
  <class name="org.apache.poi.poifs.filesystem.DocumentNode" map="N"/>
  <field class="org.apache.poi.poifs.filesystem.DocumentNode" name="_document" map="l"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentNode" name="int getSize()" map="U"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentNode" name="boolean isDocumentEntry()" map="R"/>
  <class name="org.apache.poi.poifs.filesystem.POIFSStream$StreamBlockByteBufferIterator" map="_A"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSStream$StreamBlockByteBufferIterator" name="this$0" map="A"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSStream$StreamBlockByteBufferIterator" name="loopDetector" map="B"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSStream$StreamBlockByteBufferIterator" name="nextBlock" map="C"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSStream$StreamBlockByteBufferIterator" name="java.nio.ByteBuffer next()" map="A"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSStream$StreamBlockByteBufferIterator" name="boolean hasNext()" map="hasNext"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSStream$StreamBlockByteBufferIterator" name="void remove()" map="remove"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSStream$StreamBlockByteBufferIterator" name="java.lang.Object next()" map="next"/>
  <class name="org.apache.poi.poifs.filesystem.POIFSStream" map="O"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSStream" name="startBlock" map="A"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSStream" name="blockStore" map="B"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSStream" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSStream" name="java.util.Iterator getBlockIterator()" map="A"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSStream" name="org.apache.poi.poifs.filesystem.BlockStore access$000(org.apache.poi.poifs.filesystem.POIFSStream)" map="A"/>
  <class name="org.apache.poi.poifs.filesystem.POIFSMiniStore" map="P"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSMiniStore" name="_mini_stream" map="W"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSMiniStore" name="_header" map="X"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSMiniStore" name="_filesystem" map="Y"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSMiniStore" name="_sbat_blocks" map="Z"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSMiniStore" name="_root" map="_"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSMiniStore" name="int getNextBlock(int)" map="D"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSMiniStore" name="org.apache.poi.poifs.filesystem.BlockStore$ChainLoopDetector getChainLoopDetector()" map="K"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSMiniStore" name="java.nio.ByteBuffer getBlockAt(int)" map="E"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSMiniStore" name="int getBlockStoreBlockSize()" map="L"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSMiniStore" name="org.apache.poi.poifs.storage.BATBlock$BATBlockAndIndex getBATBlockAndIndex(int)" map="F"/>
  <class name="org.apache.poi.poifs.filesystem.DocumentFactoryHelper" map="Q"/>
  <method class="org.apache.poi.poifs.filesystem.DocumentFactoryHelper" name="java.io.InputStream getDecryptedStream(org.apache.poi.poifs.filesystem.DirectoryNode, java.lang.String)" map="A"/>
  <class name="org.apache.poi.poifs.filesystem.POIFSDocument" map="R"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSDocument" name="_stream" map="q"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSDocument" name="_filesystem" map="r"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSDocument" name="_block_size" map="s"/>
  <field class="org.apache.poi.poifs.filesystem.POIFSDocument" name="_property" map="t"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSDocument" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSDocument" name="java.util.Iterator getBlockIterator()" map="Y"/>
  <method class="org.apache.poi.poifs.filesystem.POIFSDocument" name="int getSize()" map="Z"/>
  <package name="org.apache.poi.poifs.eventfilesystem" map="H"/>
  <class name="org.apache.poi.poifs.eventfilesystem.package-info" map="package-info"/>
  <class name="org.apache.poi.poifs.package-info" map="package-info"/>
  <class name="org.apache.poi.EmptyFileException" map="A"/>
  <class name="org.apache.poi.EncryptedDocumentException" map="B"/>
  <class name="org.apache.poi.OldFileFormatException" map="C"/>
  <class name="org.apache.poi.UnsupportedFileFormatException" map="D"/>
  <package name="org.bouncycastle" map="D"/>
  <package name="org.bouncycastle.x509" map="A"/>
  <package name="org.bouncycastle.x509.util" map="A"/>
  <class name="org.bouncycastle.x509.util.StreamParsingException" map="A"/>
  <field class="org.bouncycastle.x509.util.StreamParsingException" name="_e" map="A"/>
  <method class="org.bouncycastle.x509.util.StreamParsingException" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="org.bouncycastle.x509.X509StreamParserSpi" map="A"/>
  <package name="org.bouncycastle.crypto" map="B"/>
  <package name="org.bouncycastle.crypto.util" map="A"/>
  <class name="org.bouncycastle.crypto.util.DigestFactory" map="A"/>
  <method class="org.bouncycastle.crypto.util.DigestFactory" name="org.bouncycastle.crypto.Digest createSHA384()" map="A"/>
  <method class="org.bouncycastle.crypto.util.DigestFactory" name="org.bouncycastle.crypto.Digest createSHA1()" map="B"/>
  <method class="org.bouncycastle.crypto.util.DigestFactory" name="org.bouncycastle.crypto.Digest createSHA512()" map="C"/>
  <method class="org.bouncycastle.crypto.util.DigestFactory" name="org.bouncycastle.crypto.Digest createSHA256()" map="D"/>
  <method class="org.bouncycastle.crypto.util.DigestFactory" name="org.bouncycastle.crypto.Digest createSHA224()" map="E"/>
  <package name="org.bouncycastle.crypto.paddings" map="B"/>
  <class name="org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher" map="A"/>
  <field class="org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher" name="padding" map="E"/>
  <method class="org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher" name="int processBytes(byte[], int, int, byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher" name="int getUpdateOutputSize(int)" map="A"/>
  <method class="org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher" name="int getOutputSize(int)" map="B"/>
  <method class="org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher" name="void init(boolean, org.bouncycastle.crypto.CipherParameters)" map="A"/>
  <class name="org.bouncycastle.crypto.paddings.PKCS7Padding" map="B"/>
  <method class="org.bouncycastle.crypto.paddings.PKCS7Padding" name="int addPadding(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.paddings.PKCS7Padding" name="void init(java.security.SecureRandom)" map="A"/>
  <method class="org.bouncycastle.crypto.paddings.PKCS7Padding" name="int padCount(byte[])" map="A"/>
  <class name="org.bouncycastle.crypto.paddings.BlockCipherPadding" map="C"/>
  <method class="org.bouncycastle.crypto.paddings.BlockCipherPadding" name="int addPadding(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.paddings.BlockCipherPadding" name="void init(java.security.SecureRandom)" map="A"/>
  <method class="org.bouncycastle.crypto.paddings.BlockCipherPadding" name="int padCount(byte[])" map="A"/>
  <package name="org.bouncycastle.crypto.engines" map="C"/>
  <class name="org.bouncycastle.crypto.engines.AESFastEngine" map="A"/>
  <field class="org.bouncycastle.crypto.engines.AESFastEngine" name="forEncryption" map="T"/>
  <field class="org.bouncycastle.crypto.engines.AESFastEngine" name="T" map="U"/>
  <field class="org.bouncycastle.crypto.engines.AESFastEngine" name="S" map="V"/>
  <field class="org.bouncycastle.crypto.engines.AESFastEngine" name="rcon" map="W"/>
  <field class="org.bouncycastle.crypto.engines.AESFastEngine" name="C3" map="X"/>
  <field class="org.bouncycastle.crypto.engines.AESFastEngine" name="C2" map="Y"/>
  <field class="org.bouncycastle.crypto.engines.AESFastEngine" name="Tinv" map="Z"/>
  <field class="org.bouncycastle.crypto.engines.AESFastEngine" name="C1" map="_"/>
  <field class="org.bouncycastle.crypto.engines.AESFastEngine" name="Si" map="a"/>
  <field class="org.bouncycastle.crypto.engines.AESFastEngine" name="C0" map="b"/>
  <field class="org.bouncycastle.crypto.engines.AESFastEngine" name="ROUNDS" map="c"/>
  <field class="org.bouncycastle.crypto.engines.AESFastEngine" name="WorkingKey" map="d"/>
  <method class="org.bouncycastle.crypto.engines.AESFastEngine" name="int shift(int, int)" map="B"/>
  <method class="org.bouncycastle.crypto.engines.AESFastEngine" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.engines.AESFastEngine" name="int subWord(int)" map="A"/>
  <method class="org.bouncycastle.crypto.engines.AESFastEngine" name="void init(boolean, org.bouncycastle.crypto.CipherParameters)" map="A"/>
  <method class="org.bouncycastle.crypto.engines.AESFastEngine" name="int FFmulX(int)" map="B"/>
  <method class="org.bouncycastle.crypto.engines.AESFastEngine" name="void unpackBlock(byte[], int)" map="B"/>
  <method class="org.bouncycastle.crypto.engines.AESFastEngine" name="int[][] generateWorkingKey(byte[], boolean)" map="A"/>
  <method class="org.bouncycastle.crypto.engines.AESFastEngine" name="int inv_mcol(int)" map="C"/>
  <method class="org.bouncycastle.crypto.engines.AESFastEngine" name="void encryptBlock(int[][])" map="A"/>
  <method class="org.bouncycastle.crypto.engines.AESFastEngine" name="void decryptBlock(int[][])" map="B"/>
  <method class="org.bouncycastle.crypto.engines.AESFastEngine" name="void packBlock(byte[], int)" map="C"/>
  <method class="org.bouncycastle.crypto.engines.AESFastEngine" name="int getBlockSize()" map="B"/>
  <method class="org.bouncycastle.crypto.engines.AESFastEngine" name="int FFmulX2(int)" map="D"/>
  <method class="org.bouncycastle.crypto.engines.AESFastEngine" name="int processBlock(byte[], int, byte[], int)" map="A"/>
  <class name="org.bouncycastle.crypto.engines.GOST28147Engine" map="B"/>
  <field class="org.bouncycastle.crypto.engines.GOST28147Engine" name="workingKey" map="A"/>
  <field class="org.bouncycastle.crypto.engines.GOST28147Engine" name="DSbox_A" map="B"/>
  <field class="org.bouncycastle.crypto.engines.GOST28147Engine" name="forEncryption" map="C"/>
  <field class="org.bouncycastle.crypto.engines.GOST28147Engine" name="ESbox_Test" map="D"/>
  <field class="org.bouncycastle.crypto.engines.GOST28147Engine" name="S" map="E"/>
  <field class="org.bouncycastle.crypto.engines.GOST28147Engine" name="ESbox_D" map="F"/>
  <field class="org.bouncycastle.crypto.engines.GOST28147Engine" name="ESbox_C" map="G"/>
  <field class="org.bouncycastle.crypto.engines.GOST28147Engine" name="sBoxes" map="H"/>
  <field class="org.bouncycastle.crypto.engines.GOST28147Engine" name="ESbox_B" map="I"/>
  <field class="org.bouncycastle.crypto.engines.GOST28147Engine" name="ESbox_A" map="J"/>
  <field class="org.bouncycastle.crypto.engines.GOST28147Engine" name="Param_Z" map="K"/>
  <field class="org.bouncycastle.crypto.engines.GOST28147Engine" name="Sbox_Default" map="L"/>
  <field class="org.bouncycastle.crypto.engines.GOST28147Engine" name="DSbox_Test" map="M"/>
  <method class="org.bouncycastle.crypto.engines.GOST28147Engine" name="void addSBox(java.lang.String, byte[])" map="A"/>
  <method class="org.bouncycastle.crypto.engines.GOST28147Engine" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.engines.GOST28147Engine" name="void init(boolean, org.bouncycastle.crypto.CipherParameters)" map="A"/>
  <method class="org.bouncycastle.crypto.engines.GOST28147Engine" name="void GOST28147Func(int[], byte[], int, byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.engines.GOST28147Engine" name="byte[] getSBox(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.crypto.engines.GOST28147Engine" name="int bytesToint(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.engines.GOST28147Engine" name="int getBlockSize()" map="B"/>
  <method class="org.bouncycastle.crypto.engines.GOST28147Engine" name="void intTobytes(int, byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.engines.GOST28147Engine" name="int processBlock(byte[], int, byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.engines.GOST28147Engine" name="int[] generateWorkingKey(boolean, byte[])" map="A"/>
  <method class="org.bouncycastle.crypto.engines.GOST28147Engine" name="int GOST28147_mainStep(int, int)" map="A"/>
  <package name="org.bouncycastle.crypto.modes" map="D"/>
  <class name="org.bouncycastle.crypto.modes.CBCBlockCipher" map="A"/>
  <field class="org.bouncycastle.crypto.modes.CBCBlockCipher" name="cipher" map="N"/>
  <field class="org.bouncycastle.crypto.modes.CBCBlockCipher" name="blockSize" map="O"/>
  <field class="org.bouncycastle.crypto.modes.CBCBlockCipher" name="IV" map="P"/>
  <field class="org.bouncycastle.crypto.modes.CBCBlockCipher" name="cbcV" map="Q"/>
  <field class="org.bouncycastle.crypto.modes.CBCBlockCipher" name="cbcNextV" map="R"/>
  <field class="org.bouncycastle.crypto.modes.CBCBlockCipher" name="encrypting" map="S"/>
  <method class="org.bouncycastle.crypto.modes.CBCBlockCipher" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.modes.CBCBlockCipher" name="int decryptBlock(byte[], int, byte[], int)" map="B"/>
  <method class="org.bouncycastle.crypto.modes.CBCBlockCipher" name="int encryptBlock(byte[], int, byte[], int)" map="C"/>
  <method class="org.bouncycastle.crypto.modes.CBCBlockCipher" name="int processBlock(byte[], int, byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.modes.CBCBlockCipher" name="int getBlockSize()" map="B"/>
  <method class="org.bouncycastle.crypto.modes.CBCBlockCipher" name="void init(boolean, org.bouncycastle.crypto.CipherParameters)" map="A"/>
  <package name="org.bouncycastle.crypto.digests" map="E"/>
  <class name="org.bouncycastle.crypto.digests.SHA384Digest" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA384Digest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA384Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.SHA384Digest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA384Digest" name="int getDigestSize()" map="C"/>
  <class name="org.bouncycastle.crypto.digests.GOST3411_2012_512Digest" map="B"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411_2012_512Digest" name="IV" map="e"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012_512Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012_512Digest" name="int getDigestSize()" map="C"/>
  <class name="org.bouncycastle.crypto.digests.SHA224Digest" map="C"/>
  <field class="org.bouncycastle.crypto.digests.SHA224Digest" name="X" map="&#x00cf;"/>
  <field class="org.bouncycastle.crypto.digests.SHA224Digest" name="H8" map="&#x00d0;"/>
  <field class="org.bouncycastle.crypto.digests.SHA224Digest" name="H7" map="&#x00d1;"/>
  <field class="org.bouncycastle.crypto.digests.SHA224Digest" name="H6" map="&#x00d2;"/>
  <field class="org.bouncycastle.crypto.digests.SHA224Digest" name="H5" map="&#x00d3;"/>
  <field class="org.bouncycastle.crypto.digests.SHA224Digest" name="H4" map="&#x00d4;"/>
  <field class="org.bouncycastle.crypto.digests.SHA224Digest" name="K" map="&#x00d5;"/>
  <field class="org.bouncycastle.crypto.digests.SHA224Digest" name="H3" map="&#x00d6;"/>
  <field class="org.bouncycastle.crypto.digests.SHA224Digest" name="H2" map="&#x00d8;"/>
  <field class="org.bouncycastle.crypto.digests.SHA224Digest" name="H1" map="&#x00d9;"/>
  <field class="org.bouncycastle.crypto.digests.SHA224Digest" name="xOff" map="&#x00da;"/>
  <method class="org.bouncycastle.crypto.digests.SHA224Digest" name="void processLength(long)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA224Digest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA224Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.SHA224Digest" name="void processWord(byte[], int)" map="D"/>
  <method class="org.bouncycastle.crypto.digests.SHA224Digest" name="void doCopy(org.bouncycastle.crypto.digests.SHA224Digest)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA224Digest" name="int Ch(int, int, int)" map="J"/>
  <method class="org.bouncycastle.crypto.digests.SHA224Digest" name="void processBlock()" map="F"/>
  <method class="org.bouncycastle.crypto.digests.SHA224Digest" name="int Maj(int, int, int)" map="K"/>
  <method class="org.bouncycastle.crypto.digests.SHA224Digest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA224Digest" name="int getDigestSize()" map="C"/>
  <method class="org.bouncycastle.crypto.digests.SHA224Digest" name="int Sum1(int)" map="E"/>
  <method class="org.bouncycastle.crypto.digests.SHA224Digest" name="int Theta1(int)" map="F"/>
  <method class="org.bouncycastle.crypto.digests.SHA224Digest" name="int Sum0(int)" map="G"/>
  <method class="org.bouncycastle.crypto.digests.SHA224Digest" name="int Theta0(int)" map="H"/>
  <class name="org.bouncycastle.crypto.digests.MD2Digest" map="D"/>
  <field class="org.bouncycastle.crypto.digests.MD2Digest" name="COff" map="&#x00f9;"/>
  <field class="org.bouncycastle.crypto.digests.MD2Digest" name="S" map="&#x00fa;"/>
  <field class="org.bouncycastle.crypto.digests.MD2Digest" name="mOff" map="&#x00fb;"/>
  <field class="org.bouncycastle.crypto.digests.MD2Digest" name="xOff" map="&#x00fc;"/>
  <field class="org.bouncycastle.crypto.digests.MD2Digest" name="C" map="&#x00fd;"/>
  <field class="org.bouncycastle.crypto.digests.MD2Digest" name="M" map="&#x00fe;"/>
  <field class="org.bouncycastle.crypto.digests.MD2Digest" name="X" map="&#x00ff;"/>
  <method class="org.bouncycastle.crypto.digests.MD2Digest" name="void copyIn(org.bouncycastle.crypto.digests.MD2Digest)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.MD2Digest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.MD2Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.MD2Digest" name="void processBlock(byte[])" map="F"/>
  <method class="org.bouncycastle.crypto.digests.MD2Digest" name="void update(byte[], int, int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.MD2Digest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.MD2Digest" name="void processCheckSum(byte[])" map="G"/>
  <method class="org.bouncycastle.crypto.digests.MD2Digest" name="int getDigestSize()" map="C"/>
  <method class="org.bouncycastle.crypto.digests.MD2Digest" name="void update(byte)" map="A"/>
  <class name="org.bouncycastle.crypto.digests.SHA512Digest" map="E"/>
  <method class="org.bouncycastle.crypto.digests.SHA512Digest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA512Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.SHA512Digest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA512Digest" name="int getDigestSize()" map="C"/>
  <class name="org.bouncycastle.crypto.digests.SHAKEDigest" map="F"/>
  <method class="org.bouncycastle.crypto.digests.SHAKEDigest" name="int checkBitLength(int)" map="K"/>
  <method class="org.bouncycastle.crypto.digests.SHAKEDigest" name="int doOutput(byte[], int, int)" map="D"/>
  <method class="org.bouncycastle.crypto.digests.SHAKEDigest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.SHAKEDigest" name="int doFinal(byte[], int, int)" map="C"/>
  <method class="org.bouncycastle.crypto.digests.SHAKEDigest" name="int doFinal(byte[], int)" map="A"/>
  <class name="org.bouncycastle.crypto.digests.SHA1Digest" map="G"/>
  <field class="org.bouncycastle.crypto.digests.SHA1Digest" name="H5" map="j"/>
  <field class="org.bouncycastle.crypto.digests.SHA1Digest" name="H4" map="k"/>
  <field class="org.bouncycastle.crypto.digests.SHA1Digest" name="H3" map="l"/>
  <field class="org.bouncycastle.crypto.digests.SHA1Digest" name="H2" map="m"/>
  <field class="org.bouncycastle.crypto.digests.SHA1Digest" name="H1" map="n"/>
  <field class="org.bouncycastle.crypto.digests.SHA1Digest" name="xOff" map="o"/>
  <field class="org.bouncycastle.crypto.digests.SHA1Digest" name="X" map="p"/>
  <method class="org.bouncycastle.crypto.digests.SHA1Digest" name="void processLength(long)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA1Digest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA1Digest" name="int g(int, int, int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA1Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.SHA1Digest" name="void processWord(byte[], int)" map="D"/>
  <method class="org.bouncycastle.crypto.digests.SHA1Digest" name="void processBlock()" map="F"/>
  <method class="org.bouncycastle.crypto.digests.SHA1Digest" name="int f(int, int, int)" map="B"/>
  <method class="org.bouncycastle.crypto.digests.SHA1Digest" name="int h(int, int, int)" map="C"/>
  <method class="org.bouncycastle.crypto.digests.SHA1Digest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA1Digest" name="int getDigestSize()" map="C"/>
  <method class="org.bouncycastle.crypto.digests.SHA1Digest" name="void copyIn(org.bouncycastle.crypto.digests.SHA1Digest)" map="A"/>
  <class name="org.bouncycastle.crypto.digests.RIPEMD128Digest" map="H"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="H3" map="&#x00db;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="H2" map="&#x00dc;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="H1" map="&#x00dd;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="H0" map="&#x00de;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="xOff" map="&#x00df;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="X" map="&#x00e0;"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="int F4(int, int, int, int, int, int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="int f1(int, int, int)" map="L"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="void processBlock()" map="F"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="int F2(int, int, int, int, int, int)" map="B"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="void processLength(long)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="int FF3(int, int, int, int, int, int)" map="C"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="void processWord(byte[], int)" map="D"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="int f4(int, int, int)" map="M"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="int f3(int, int, int)" map="N"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="void copyIn(org.bouncycastle.crypto.digests.RIPEMD128Digest)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="int f2(int, int, int)" map="O"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="int FF1(int, int, int, int, int, int)" map="D"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="int F3(int, int, int, int, int, int)" map="E"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="int FF4(int, int, int, int, int, int)" map="F"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="int RL(int, int)" map="B"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="int F1(int, int, int, int, int, int)" map="G"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="void unpackWord(int, byte[], int)" map="B"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="int FF2(int, int, int, int, int, int)" map="H"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD128Digest" name="int getDigestSize()" map="C"/>
  <class name="org.bouncycastle.crypto.digests.GOST3411Digest" map="I"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="xBuf" map="A"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="cipher" map="B"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="W" map="C"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="V" map="D"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="U" map="E"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="S" map="F"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="xBufOff" map="G"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="M" map="H"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="L" map="I"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="K" map="J"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="w_S" map="K"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="Sum" map="L"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="H" map="M"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="byteCount" map="N"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="C" map="O"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="C2" map="P"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="wS" map="Q"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="sBox" map="R"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411Digest" name="a" map="S"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="void processBlock(byte[], int)" map="B"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="void update(byte[], int, int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="void sumByteArray(byte[])" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="void cpyBytesToShort(byte[], short[])" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="int getDigestSize()" map="C"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="byte[] A(byte[])" map="B"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="void finish()" map="D"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="void update(byte)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="byte[] P(byte[])" map="C"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="void cpyShortToBytes(short[], byte[])" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="void fw(byte[])" map="D"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="void reset(org.bouncycastle.util.Memoable)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411Digest" name="void E(byte[], byte[], int, byte[], int)" map="A"/>
  <class name="org.bouncycastle.crypto.digests.MD4Digest" map="J"/>
  <field class="org.bouncycastle.crypto.digests.MD4Digest" name="H4" map="&#x00e1;"/>
  <field class="org.bouncycastle.crypto.digests.MD4Digest" name="H3" map="&#x00e2;"/>
  <field class="org.bouncycastle.crypto.digests.MD4Digest" name="H2" map="&#x00e3;"/>
  <field class="org.bouncycastle.crypto.digests.MD4Digest" name="H1" map="&#x00e4;"/>
  <field class="org.bouncycastle.crypto.digests.MD4Digest" name="xOff" map="&#x00e5;"/>
  <field class="org.bouncycastle.crypto.digests.MD4Digest" name="X" map="&#x00e6;"/>
  <method class="org.bouncycastle.crypto.digests.MD4Digest" name="void processLength(long)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.MD4Digest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.MD4Digest" name="int F(int, int, int)" map="P"/>
  <method class="org.bouncycastle.crypto.digests.MD4Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.MD4Digest" name="void unpackWord(int, byte[], int)" map="C"/>
  <method class="org.bouncycastle.crypto.digests.MD4Digest" name="int H(int, int, int)" map="Q"/>
  <method class="org.bouncycastle.crypto.digests.MD4Digest" name="void processWord(byte[], int)" map="D"/>
  <method class="org.bouncycastle.crypto.digests.MD4Digest" name="void processBlock()" map="F"/>
  <method class="org.bouncycastle.crypto.digests.MD4Digest" name="int G(int, int, int)" map="R"/>
  <method class="org.bouncycastle.crypto.digests.MD4Digest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.MD4Digest" name="int getDigestSize()" map="C"/>
  <method class="org.bouncycastle.crypto.digests.MD4Digest" name="int rotateLeft(int, int)" map="C"/>
  <class name="org.bouncycastle.crypto.digests.GOST3411_2012Digest" map="K"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="C" map="T"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="m" map="U"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="T" map="V"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="block" map="W"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="Ki" map="X"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="tmp" map="Y"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="h" map="Z"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="N" map="_"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="Sigma" map="a"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="bOff" map="b"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="IV" map="c"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="Zero" map="d"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="void xor512(byte[], byte[])" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="void addMod512(byte[], byte[])" map="B"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="void addMod512(byte[], int)" map="C"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="void update(byte[], int, int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="void F(byte[])" map="E"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="int getDigestSize()" map="C"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="void update(byte)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="void reverse(byte[], byte[])" map="C"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="void g_N(byte[], byte[], byte[])" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012Digest" name="void E(byte[], byte[])" map="D"/>
  <class name="org.bouncycastle.crypto.digests.SHA256Digest" map="L"/>
  <field class="org.bouncycastle.crypto.digests.SHA256Digest" name="X" map="q"/>
  <field class="org.bouncycastle.crypto.digests.SHA256Digest" name="H8" map="r"/>
  <field class="org.bouncycastle.crypto.digests.SHA256Digest" name="H7" map="s"/>
  <field class="org.bouncycastle.crypto.digests.SHA256Digest" name="H6" map="t"/>
  <field class="org.bouncycastle.crypto.digests.SHA256Digest" name="H5" map="u"/>
  <field class="org.bouncycastle.crypto.digests.SHA256Digest" name="H4" map="v"/>
  <field class="org.bouncycastle.crypto.digests.SHA256Digest" name="K" map="w"/>
  <field class="org.bouncycastle.crypto.digests.SHA256Digest" name="H3" map="x"/>
  <field class="org.bouncycastle.crypto.digests.SHA256Digest" name="H2" map="y"/>
  <field class="org.bouncycastle.crypto.digests.SHA256Digest" name="H1" map="z"/>
  <field class="org.bouncycastle.crypto.digests.SHA256Digest" name="xOff" map="&#x00a2;"/>
  <method class="org.bouncycastle.crypto.digests.SHA256Digest" name="void processLength(long)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA256Digest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA256Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.SHA256Digest" name="void processWord(byte[], int)" map="D"/>
  <method class="org.bouncycastle.crypto.digests.SHA256Digest" name="int Ch(int, int, int)" map="D"/>
  <method class="org.bouncycastle.crypto.digests.SHA256Digest" name="void processBlock()" map="F"/>
  <method class="org.bouncycastle.crypto.digests.SHA256Digest" name="int Maj(int, int, int)" map="E"/>
  <method class="org.bouncycastle.crypto.digests.SHA256Digest" name="void copyIn(org.bouncycastle.crypto.digests.SHA256Digest)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA256Digest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA256Digest" name="int getDigestSize()" map="C"/>
  <method class="org.bouncycastle.crypto.digests.SHA256Digest" name="int Sum1(int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.SHA256Digest" name="int Theta1(int)" map="B"/>
  <method class="org.bouncycastle.crypto.digests.SHA256Digest" name="int Sum0(int)" map="C"/>
  <method class="org.bouncycastle.crypto.digests.SHA256Digest" name="int Theta0(int)" map="D"/>
  <class name="org.bouncycastle.crypto.digests.GeneralDigest" map="M"/>
  <field class="org.bouncycastle.crypto.digests.GeneralDigest" name="xBuf" map="g"/>
  <field class="org.bouncycastle.crypto.digests.GeneralDigest" name="xBufOff" map="h"/>
  <field class="org.bouncycastle.crypto.digests.GeneralDigest" name="byteCount" map="i"/>
  <method class="org.bouncycastle.crypto.digests.GeneralDigest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GeneralDigest" name="void processLength(long)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GeneralDigest" name="void copyIn(org.bouncycastle.crypto.digests.GeneralDigest)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GeneralDigest" name="void finish()" map="E"/>
  <method class="org.bouncycastle.crypto.digests.GeneralDigest" name="void processWord(byte[], int)" map="D"/>
  <method class="org.bouncycastle.crypto.digests.GeneralDigest" name="void update(byte[], int, int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GeneralDigest" name="void update(byte)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GeneralDigest" name="void processBlock()" map="F"/>
  <class name="org.bouncycastle.crypto.digests.SHA3Digest" map="N"/>
  <method class="org.bouncycastle.crypto.digests.SHA3Digest" name="int checkBitLength(int)" map="L"/>
  <method class="org.bouncycastle.crypto.digests.SHA3Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.SHA3Digest" name="int doFinal(byte[], int)" map="A"/>
  <class name="org.bouncycastle.crypto.digests.LongDigest" map="O"/>
  <field class="org.bouncycastle.crypto.digests.LongDigest" name="wOff" map="&#x00a3;"/>
  <field class="org.bouncycastle.crypto.digests.LongDigest" name="W" map="&#x00a4;"/>
  <field class="org.bouncycastle.crypto.digests.LongDigest" name="byteCount2" map="&#x00a5;"/>
  <field class="org.bouncycastle.crypto.digests.LongDigest" name="byteCount1" map="&#x00aa;"/>
  <field class="org.bouncycastle.crypto.digests.LongDigest" name="H8" map="&#x00b5;"/>
  <field class="org.bouncycastle.crypto.digests.LongDigest" name="H7" map="&#x00ba;"/>
  <field class="org.bouncycastle.crypto.digests.LongDigest" name="H6" map="&#x00c0;"/>
  <field class="org.bouncycastle.crypto.digests.LongDigest" name="H5" map="&#x00c1;"/>
  <field class="org.bouncycastle.crypto.digests.LongDigest" name="H4" map="&#x00c2;"/>
  <field class="org.bouncycastle.crypto.digests.LongDigest" name="K" map="&#x00c3;"/>
  <field class="org.bouncycastle.crypto.digests.LongDigest" name="H3" map="&#x00c4;"/>
  <field class="org.bouncycastle.crypto.digests.LongDigest" name="H2" map="&#x00c5;"/>
  <field class="org.bouncycastle.crypto.digests.LongDigest" name="xBufOff" map="&#x00c6;"/>
  <field class="org.bouncycastle.crypto.digests.LongDigest" name="H1" map="&#x00c7;"/>
  <field class="org.bouncycastle.crypto.digests.LongDigest" name="xBuf" map="&#x00c8;"/>
  <method class="org.bouncycastle.crypto.digests.LongDigest" name="long Sum0(long)" map="B"/>
  <method class="org.bouncycastle.crypto.digests.LongDigest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.LongDigest" name="long Ch(long, long, long)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.LongDigest" name="void adjustByteCounts()" map="G"/>
  <method class="org.bouncycastle.crypto.digests.LongDigest" name="void update(byte[], int, int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.LongDigest" name="void processWord(byte[], int)" map="E"/>
  <method class="org.bouncycastle.crypto.digests.LongDigest" name="long Maj(long, long, long)" map="B"/>
  <method class="org.bouncycastle.crypto.digests.LongDigest" name="void processBlock()" map="H"/>
  <method class="org.bouncycastle.crypto.digests.LongDigest" name="long Sigma1(long)" map="C"/>
  <method class="org.bouncycastle.crypto.digests.LongDigest" name="void copyIn(org.bouncycastle.crypto.digests.LongDigest)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.LongDigest" name="long Sigma0(long)" map="D"/>
  <method class="org.bouncycastle.crypto.digests.LongDigest" name="void finish()" map="I"/>
  <method class="org.bouncycastle.crypto.digests.LongDigest" name="void update(byte)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.LongDigest" name="void processLength(long, long)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.LongDigest" name="long Sum1(long)" map="E"/>
  <class name="org.bouncycastle.crypto.digests.EncodableDigest" map="P"/>
  <class name="org.bouncycastle.crypto.digests.RIPEMD160Digest" map="Q"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="H4" map="&#x00e7;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="H3" map="&#x00e8;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="H2" map="&#x00e9;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="H1" map="&#x00ea;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="H0" map="&#x00eb;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="xOff" map="&#x00ec;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="X" map="&#x00ed;"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="int f4(int, int, int)" map="S"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="void processLength(long)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="int f2(int, int, int)" map="T"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="void unpackWord(int, byte[], int)" map="D"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="void processWord(byte[], int)" map="D"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="int f1(int, int, int)" map="U"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="void processBlock()" map="F"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="int RL(int, int)" map="D"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="int f3(int, int, int)" map="V"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="int f5(int, int, int)" map="W"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="void copyIn(org.bouncycastle.crypto.digests.RIPEMD160Digest)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD160Digest" name="int getDigestSize()" map="C"/>
  <class name="org.bouncycastle.crypto.digests.GOST3411_2012_256Digest" map="R"/>
  <field class="org.bouncycastle.crypto.digests.GOST3411_2012_256Digest" name="IV" map="f"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012_256Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012_256Digest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.GOST3411_2012_256Digest" name="int getDigestSize()" map="C"/>
  <class name="org.bouncycastle.crypto.digests.MD5Digest" map="S"/>
  <field class="org.bouncycastle.crypto.digests.MD5Digest" name="H4" map="&#x00c9;"/>
  <field class="org.bouncycastle.crypto.digests.MD5Digest" name="H3" map="&#x00ca;"/>
  <field class="org.bouncycastle.crypto.digests.MD5Digest" name="H2" map="&#x00cb;"/>
  <field class="org.bouncycastle.crypto.digests.MD5Digest" name="H1" map="&#x00cc;"/>
  <field class="org.bouncycastle.crypto.digests.MD5Digest" name="xOff" map="&#x00cd;"/>
  <field class="org.bouncycastle.crypto.digests.MD5Digest" name="X" map="&#x00ce;"/>
  <method class="org.bouncycastle.crypto.digests.MD5Digest" name="void processLength(long)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.MD5Digest" name="void copyIn(org.bouncycastle.crypto.digests.MD5Digest)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.MD5Digest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.MD5Digest" name="int F(int, int, int)" map="F"/>
  <method class="org.bouncycastle.crypto.digests.MD5Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.MD5Digest" name="void unpackWord(int, byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.MD5Digest" name="int H(int, int, int)" map="G"/>
  <method class="org.bouncycastle.crypto.digests.MD5Digest" name="void processWord(byte[], int)" map="D"/>
  <method class="org.bouncycastle.crypto.digests.MD5Digest" name="void processBlock()" map="F"/>
  <method class="org.bouncycastle.crypto.digests.MD5Digest" name="int G(int, int, int)" map="H"/>
  <method class="org.bouncycastle.crypto.digests.MD5Digest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.MD5Digest" name="int rotateLeft(int, int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.MD5Digest" name="int getDigestSize()" map="C"/>
  <method class="org.bouncycastle.crypto.digests.MD5Digest" name="int K(int, int, int)" map="I"/>
  <class name="org.bouncycastle.crypto.digests.RIPEMD256Digest" map="T"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="X" map="&#x00ee;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="H7" map="&#x00ef;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="H6" map="&#x00f0;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="H5" map="&#x00f1;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="H4" map="&#x00f2;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="H3" map="&#x00f3;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="H2" map="&#x00f4;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="H1" map="&#x00f5;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="H0" map="&#x00f6;"/>
  <field class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="xOff" map="&#x00f8;"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="int F4(int, int, int, int, int, int)" map="I"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="int f1(int, int, int)" map="X"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="void processBlock()" map="F"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="int F2(int, int, int, int, int, int)" map="J"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="void processLength(long)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="int FF3(int, int, int, int, int, int)" map="K"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="void processWord(byte[], int)" map="D"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="void copyIn(org.bouncycastle.crypto.digests.RIPEMD256Digest)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="int f4(int, int, int)" map="Y"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="int f3(int, int, int)" map="Z"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="int f2(int, int, int)" map="_"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="int FF1(int, int, int, int, int, int)" map="L"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="int F3(int, int, int, int, int, int)" map="M"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="int FF4(int, int, int, int, int, int)" map="N"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="int RL(int, int)" map="E"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="int F1(int, int, int, int, int, int)" map="O"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="void unpackWord(int, byte[], int)" map="E"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="int FF2(int, int, int, int, int, int)" map="P"/>
  <method class="org.bouncycastle.crypto.digests.RIPEMD256Digest" name="int getDigestSize()" map="C"/>
  <class name="org.bouncycastle.crypto.digests.KeccakDigest" map="U"/>
  <field class="org.bouncycastle.crypto.digests.KeccakDigest" name="dataQueue" map="&#x0100;"/>
  <field class="org.bouncycastle.crypto.digests.KeccakDigest" name="squeezing" map="&#x0101;"/>
  <field class="org.bouncycastle.crypto.digests.KeccakDigest" name="fixedOutputLength" map="&#x0102;"/>
  <field class="org.bouncycastle.crypto.digests.KeccakDigest" name="KeccakRoundConstants" map="&#x0103;"/>
  <field class="org.bouncycastle.crypto.digests.KeccakDigest" name="rate" map="&#x0104;"/>
  <field class="org.bouncycastle.crypto.digests.KeccakDigest" name="state" map="&#x0105;"/>
  <field class="org.bouncycastle.crypto.digests.KeccakDigest" name="bitsInQueue" map="&#x0106;"/>
  <method class="org.bouncycastle.crypto.digests.KeccakDigest" name="void KeccakExtract()" map="J"/>
  <method class="org.bouncycastle.crypto.digests.KeccakDigest" name="void squeeze(byte[], int, long)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.KeccakDigest" name="void absorbBits(int, int)" map="F"/>
  <method class="org.bouncycastle.crypto.digests.KeccakDigest" name="void padAndSwitchToSqueezingPhase()" map="K"/>
  <method class="org.bouncycastle.crypto.digests.KeccakDigest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.digests.KeccakDigest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.digests.KeccakDigest" name="void update(byte[], int, int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.KeccakDigest" name="void KeccakAbsorb(byte[], int)" map="F"/>
  <method class="org.bouncycastle.crypto.digests.KeccakDigest" name="void init(int)" map="I"/>
  <method class="org.bouncycastle.crypto.digests.KeccakDigest" name="void initSponge(int)" map="J"/>
  <method class="org.bouncycastle.crypto.digests.KeccakDigest" name="void KeccakPermutation()" map="L"/>
  <method class="org.bouncycastle.crypto.digests.KeccakDigest" name="void absorb(byte[], int, int)" map="B"/>
  <method class="org.bouncycastle.crypto.digests.KeccakDigest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.digests.KeccakDigest" name="int getDigestSize()" map="C"/>
  <method class="org.bouncycastle.crypto.digests.KeccakDigest" name="void update(byte)" map="A"/>
  <package name="org.bouncycastle.crypto.params" map="F"/>
  <class name="org.bouncycastle.crypto.params.ParametersWithRandom" map="A"/>
  <method class="org.bouncycastle.crypto.params.ParametersWithRandom" name="org.bouncycastle.crypto.CipherParameters getParameters()" map="y"/>
  <method class="org.bouncycastle.crypto.params.ParametersWithRandom" name="java.security.SecureRandom getRandom()" map="z"/>
  <class name="org.bouncycastle.crypto.params.KeyParameter" map="B"/>
  <field class="org.bouncycastle.crypto.params.KeyParameter" name="key" map="A"/>
  <method class="org.bouncycastle.crypto.params.KeyParameter" name="byte[] getKey()" map="A"/>
  <class name="org.bouncycastle.crypto.params.ParametersWithIV" map="C"/>
  <field class="org.bouncycastle.crypto.params.ParametersWithIV" name="iv" map="B"/>
  <field class="org.bouncycastle.crypto.params.ParametersWithIV" name="parameters" map="C"/>
  <method class="org.bouncycastle.crypto.params.ParametersWithIV" name="byte[] getIV()" map="B"/>
  <method class="org.bouncycastle.crypto.params.ParametersWithIV" name="org.bouncycastle.crypto.CipherParameters getParameters()" map="C"/>
  <class name="org.bouncycastle.crypto.params.ParametersWithSBox" map="D"/>
  <field class="org.bouncycastle.crypto.params.ParametersWithSBox" name="parameters" map="D"/>
  <field class="org.bouncycastle.crypto.params.ParametersWithSBox" name="sBox" map="E"/>
  <method class="org.bouncycastle.crypto.params.ParametersWithSBox" name="org.bouncycastle.crypto.CipherParameters getParameters()" map="D"/>
  <method class="org.bouncycastle.crypto.params.ParametersWithSBox" name="byte[] getSBox()" map="E"/>
  <class name="org.bouncycastle.crypto.params.AsymmetricKeyParameter" map="E"/>
  <field class="org.bouncycastle.crypto.params.AsymmetricKeyParameter" name="privateKey" map="F"/>
  <package name="org.bouncycastle.crypto.io" map="G"/>
  <class name="org.bouncycastle.crypto.io.CipherIOException" map="A"/>
  <field class="org.bouncycastle.crypto.io.CipherIOException" name="cause" map="A"/>
  <method class="org.bouncycastle.crypto.io.CipherIOException" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="org.bouncycastle.crypto.io.InvalidCipherTextIOException" map="B"/>
  <class name="org.bouncycastle.crypto.Xof" map="A"/>
  <method class="org.bouncycastle.crypto.Xof" name="int doFinal(byte[], int, int)" map="C"/>
  <class name="org.bouncycastle.crypto.CipherParameters" map="B"/>
  <class name="org.bouncycastle.crypto.ExtendedDigest" map="C"/>
  <class name="org.bouncycastle.crypto.OutputLengthException" map="D"/>
  <class name="org.bouncycastle.crypto.CryptoException" map="E"/>
  <field class="org.bouncycastle.crypto.CryptoException" name="cause" map="A"/>
  <method class="org.bouncycastle.crypto.CryptoException" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="org.bouncycastle.crypto.Digest" map="F"/>
  <method class="org.bouncycastle.crypto.Digest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.Digest" name="java.lang.String getAlgorithmName()" map="B"/>
  <method class="org.bouncycastle.crypto.Digest" name="int doFinal(byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.Digest" name="void update(byte[], int, int)" map="A"/>
  <method class="org.bouncycastle.crypto.Digest" name="void update(byte)" map="A"/>
  <method class="org.bouncycastle.crypto.Digest" name="int getDigestSize()" map="C"/>
  <class name="org.bouncycastle.crypto.DataLengthException" map="G"/>
  <class name="org.bouncycastle.crypto.BufferedBlockCipher" map="H"/>
  <field class="org.bouncycastle.crypto.BufferedBlockCipher" name="cipher" map="A"/>
  <field class="org.bouncycastle.crypto.BufferedBlockCipher" name="forEncryption" map="B"/>
  <field class="org.bouncycastle.crypto.BufferedBlockCipher" name="buf" map="C"/>
  <field class="org.bouncycastle.crypto.BufferedBlockCipher" name="bufOff" map="D"/>
  <method class="org.bouncycastle.crypto.BufferedBlockCipher" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.BufferedBlockCipher" name="int getBlockSize()" map="B"/>
  <class name="org.bouncycastle.crypto.RuntimeCryptoException" map="I"/>
  <class name="org.bouncycastle.crypto.BlockCipher" map="J"/>
  <method class="org.bouncycastle.crypto.BlockCipher" name="void reset()" map="A"/>
  <method class="org.bouncycastle.crypto.BlockCipher" name="int processBlock(byte[], int, byte[], int)" map="A"/>
  <method class="org.bouncycastle.crypto.BlockCipher" name="int getBlockSize()" map="B"/>
  <method class="org.bouncycastle.crypto.BlockCipher" name="void init(boolean, org.bouncycastle.crypto.CipherParameters)" map="A"/>
  <class name="org.bouncycastle.crypto.InvalidCipherTextException" map="K"/>
  <package name="org.bouncycastle.operator" map="C"/>
  <package name="org.bouncycastle.operator.jcajce" map="A"/>
  <class name="org.bouncycastle.operator.jcajce.JceGenericKey" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JceGenericKey" name="java.lang.Object getRepresentation(java.security.Key)" map="A"/>
  <class name="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$DigestOutputStream" map="_A"/>
  <field class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$DigestOutputStream" name="this$0" map="A"/>
  <field class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$DigestOutputStream" name="dig" map="B"/>
  <method class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$DigestOutputStream" name="void write(byte[])" map="write"/>
  <method class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$DigestOutputStream" name="void write(byte[], int, int)" map="write"/>
  <method class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$DigestOutputStream" name="byte[] getDigest()" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$DigestOutputStream" name="void write(int)" map="write"/>
  <class name="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$1$1" map="1"/>
  <field class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$1$1" name="val$algorithm" map="D"/>
  <field class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$1$1" name="val$stream" map="E"/>
  <field class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$1$1" name="this$1" map="F"/>
  <method class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$1$1" name="byte[] getDigest()" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$1$1" name="java.io.OutputStream getOutputStream()" map="B"/>
  <method class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$1$1" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmIdentifier()" map="C"/>
  <class name="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$1" map="1"/>
  <field class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$1" name="this$0" map="B"/>
  <method class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder$1" name="org.bouncycastle.operator.DigestCalculator get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder" map="B"/>
  <field class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder" name="helper" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder" name="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder setProvider(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder" name="org.bouncycastle.operator.DigestCalculatorProvider build()" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder" name="org.bouncycastle.operator.jcajce.OperatorHelper access$000(org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder)" map="A"/>
  <class name="org.bouncycastle.operator.jcajce.OperatorHelper" map="C"/>
  <field class="org.bouncycastle.operator.jcajce.OperatorHelper" name="symmetricKeyAlgNames" map="A"/>
  <field class="org.bouncycastle.operator.jcajce.OperatorHelper" name="asymmetricWrapperAlgNames" map="B"/>
  <field class="org.bouncycastle.operator.jcajce.OperatorHelper" name="oids" map="C"/>
  <field class="org.bouncycastle.operator.jcajce.OperatorHelper" name="symmetricWrapperKeySizes" map="D"/>
  <field class="org.bouncycastle.operator.jcajce.OperatorHelper" name="symmetricWrapperAlgNames" map="E"/>
  <field class="org.bouncycastle.operator.jcajce.OperatorHelper" name="helper" map="F"/>
  <method class="org.bouncycastle.operator.jcajce.OperatorHelper" name="java.lang.String getSignatureName(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.OperatorHelper" name="java.security.MessageDigest createDigest(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="B"/>
  <method class="org.bouncycastle.operator.jcajce.OperatorHelper" name="boolean notDefaultPSSParams(org.bouncycastle.asn1.ASN1Sequence)" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.OperatorHelper" name="javax.crypto.Cipher createAsymmetricWrapper(org.bouncycastle.asn1.ASN1ObjectIdentifier, java.util.Map)" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.OperatorHelper" name="java.security.Signature createSignature(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="C"/>
  <method class="org.bouncycastle.operator.jcajce.OperatorHelper" name="java.lang.String getKeyAlgorithmName(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.OperatorHelper" name="java.security.Signature createRawSignature(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="D"/>
  <method class="org.bouncycastle.operator.jcajce.OperatorHelper" name="java.lang.String getDigestName(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="B"/>
  <method class="org.bouncycastle.operator.jcajce.OperatorHelper" name="java.security.AlgorithmParameters createAlgorithmParameters(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="E"/>
  <class name="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper" map="D"/>
  <field class="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper" name="extraMappings" map="B"/>
  <field class="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper" name="unwrappedKeyMustBeEncodable" map="C"/>
  <field class="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper" name="helper" map="D"/>
  <field class="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper" name="privKey" map="E"/>
  <method class="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper" name="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper setProvider(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper" name="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper setMustProduceEncodableUnwrappedKey(boolean)" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper" name="org.bouncycastle.operator.GenericKey generateUnwrappedKey(org.bouncycastle.asn1.x509.AlgorithmIdentifier, byte[])" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper" name="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper setAlgorithmMapping(org.bouncycastle.asn1.ASN1ObjectIdentifier, java.lang.String)" map="A"/>
  <class name="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$SignatureOutputStream" map="_A"/>
  <field class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$SignatureOutputStream" name="this$0" map="A"/>
  <field class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$SignatureOutputStream" name="sig" map="B"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$SignatureOutputStream" name="boolean verify(byte[])" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$SignatureOutputStream" name="void write(byte[])" map="write"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$SignatureOutputStream" name="void write(byte[], int, int)" map="write"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$SignatureOutputStream" name="void write(int)" map="write"/>
  <class name="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$2" map="2"/>
  <field class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$2" name="this$0" map="E"/>
  <field class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$2" name="val$publicKey" map="F"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$2" name="org.bouncycastle.operator.ContentVerifier get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$2" name="boolean hasAssociatedCertificate()" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$2" name="org.bouncycastle.cert.X509CertificateHolder getAssociatedCertificate()" map="B"/>
  <class name="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$1" map="1"/>
  <field class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$1" name="this$0" map="A"/>
  <field class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$1" name="val$certHolder" map="B"/>
  <field class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$1" name="stream" map="C"/>
  <field class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$1" name="val$certificate" map="D"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$1" name="org.bouncycastle.operator.ContentVerifier get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$1" name="boolean hasAssociatedCertificate()" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$1" name="org.bouncycastle.cert.X509CertificateHolder getAssociatedCertificate()" map="B"/>
  <class name="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$SigVerifier" map="_B"/>
  <field class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$SigVerifier" name="this$0" map="A"/>
  <field class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$SigVerifier" name="algorithm" map="B"/>
  <field class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$SigVerifier" name="stream" map="C"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$SigVerifier" name="boolean verify(byte[])" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$SigVerifier" name="java.io.OutputStream getOutputStream()" map="A"/>
  <class name="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$RawSigVerifier" map="_C"/>
  <field class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$RawSigVerifier" name="this$0" map="A"/>
  <field class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$RawSigVerifier" name="rawSignature" map="D"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$RawSigVerifier" name="boolean verify(byte[])" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$RawSigVerifier" name="boolean verify(byte[], byte[])" map="A"/>
  <class name="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder" map="E"/>
  <field class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder" name="helper" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder" name="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder setProvider(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder" name="org.bouncycastle.operator.jcajce.OperatorHelper access$000(org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder)" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder" name="org.bouncycastle.operator.ContentVerifierProvider build(java.security.PublicKey)" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder" name="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$SignatureOutputStream access$200(org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder, org.bouncycastle.asn1.x509.AlgorithmIdentifier, java.security.PublicKey)" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder" name="java.security.Signature access$100(org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder, org.bouncycastle.asn1.x509.AlgorithmIdentifier, java.security.PublicKey)" map="B"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder" name="java.security.Signature createRawSig(org.bouncycastle.asn1.x509.AlgorithmIdentifier, java.security.PublicKey)" map="A"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder" name="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder$SignatureOutputStream createSignatureStream(org.bouncycastle.asn1.x509.AlgorithmIdentifier, java.security.PublicKey)" map="B"/>
  <method class="org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder" name="org.bouncycastle.operator.ContentVerifierProvider build(java.security.cert.X509Certificate)" map="A"/>
  <package name="org.bouncycastle.operator.bc" map="B"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$18" map="18"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$18" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$17" map="17"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$17" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$16" map="16"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$16" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$15" map="15"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$15" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$14" map="14"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$14" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$13" map="13"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$13" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$12" map="12"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$12" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$11" map="11"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$11" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$10" map="10"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$10" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$9" map="9"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$9" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$8" map="8"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$8" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$7" map="7"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$7" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$6" map="6"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$6" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$5" map="5"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$5" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$4" map="4"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$4" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$3" map="3"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$3" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$2" map="2"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$2" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider$1" map="1"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider$1" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDefaultDigestProvider" map="A"/>
  <field class="org.bouncycastle.operator.bc.BcDefaultDigestProvider" name="INSTANCE" map="A"/>
  <field class="org.bouncycastle.operator.bc.BcDefaultDigestProvider" name="lookup" map="B"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <method class="org.bouncycastle.operator.bc.BcDefaultDigestProvider" name="java.util.Map createTable()" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDigestProvider" map="B"/>
  <method class="org.bouncycastle.operator.bc.BcDigestProvider" name="org.bouncycastle.crypto.ExtendedDigest get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.bc.BcDigestCalculatorProvider$DigestOutputStream" map="_A"/>
  <field class="org.bouncycastle.operator.bc.BcDigestCalculatorProvider$DigestOutputStream" name="this$0" map="A"/>
  <field class="org.bouncycastle.operator.bc.BcDigestCalculatorProvider$DigestOutputStream" name="dig" map="B"/>
  <method class="org.bouncycastle.operator.bc.BcDigestCalculatorProvider$DigestOutputStream" name="void write(byte[])" map="write"/>
  <method class="org.bouncycastle.operator.bc.BcDigestCalculatorProvider$DigestOutputStream" name="void write(byte[], int, int)" map="write"/>
  <method class="org.bouncycastle.operator.bc.BcDigestCalculatorProvider$DigestOutputStream" name="byte[] getDigest()" map="A"/>
  <method class="org.bouncycastle.operator.bc.BcDigestCalculatorProvider$DigestOutputStream" name="void write(int)" map="write"/>
  <class name="org.bouncycastle.operator.bc.BcDigestCalculatorProvider$1" map="1"/>
  <field class="org.bouncycastle.operator.bc.BcDigestCalculatorProvider$1" name="this$0" map="A"/>
  <field class="org.bouncycastle.operator.bc.BcDigestCalculatorProvider$1" name="val$algorithm" map="B"/>
  <field class="org.bouncycastle.operator.bc.BcDigestCalculatorProvider$1" name="val$stream" map="C"/>
  <method class="org.bouncycastle.operator.bc.BcDigestCalculatorProvider$1" name="byte[] getDigest()" map="A"/>
  <method class="org.bouncycastle.operator.bc.BcDigestCalculatorProvider$1" name="java.io.OutputStream getOutputStream()" map="B"/>
  <method class="org.bouncycastle.operator.bc.BcDigestCalculatorProvider$1" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmIdentifier()" map="C"/>
  <class name="org.bouncycastle.operator.bc.BcDigestCalculatorProvider" map="C"/>
  <field class="org.bouncycastle.operator.bc.BcDigestCalculatorProvider" name="digestProvider" map="A"/>
  <method class="org.bouncycastle.operator.bc.BcDigestCalculatorProvider" name="org.bouncycastle.operator.DigestCalculator get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.KeyUnwrapper" map="A"/>
  <class name="org.bouncycastle.operator.MacCalculator" map="B"/>
  <method class="org.bouncycastle.operator.MacCalculator" name="java.io.OutputStream getOutputStream()" map="A"/>
  <class name="org.bouncycastle.operator.SecretKeySizeProvider" map="C"/>
  <method class="org.bouncycastle.operator.SecretKeySizeProvider" name="int getKeySize(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.OperatorCreationException" map="D"/>
  <class name="org.bouncycastle.operator.ContentVerifier" map="E"/>
  <method class="org.bouncycastle.operator.ContentVerifier" name="boolean verify(byte[])" map="A"/>
  <method class="org.bouncycastle.operator.ContentVerifier" name="java.io.OutputStream getOutputStream()" map="A"/>
  <class name="org.bouncycastle.operator.DefaultSecretKeySizeProvider" map="F"/>
  <field class="org.bouncycastle.operator.DefaultSecretKeySizeProvider" name="INSTANCE" map="A"/>
  <field class="org.bouncycastle.operator.DefaultSecretKeySizeProvider" name="KEY_SIZES" map="B"/>
  <method class="org.bouncycastle.operator.DefaultSecretKeySizeProvider" name="int getKeySize(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="A"/>
  <method class="org.bouncycastle.operator.DefaultSecretKeySizeProvider" name="int getKeySize(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.InputDecryptor" map="G"/>
  <method class="org.bouncycastle.operator.InputDecryptor" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmIdentifier()" map="A"/>
  <method class="org.bouncycastle.operator.InputDecryptor" name="java.io.InputStream getInputStream(java.io.InputStream)" map="A"/>
  <class name="org.bouncycastle.operator.GenericKey" map="H"/>
  <field class="org.bouncycastle.operator.GenericKey" name="algorithmIdentifier" map="A"/>
  <field class="org.bouncycastle.operator.GenericKey" name="representation" map="B"/>
  <method class="org.bouncycastle.operator.GenericKey" name="java.lang.Object getRepresentation()" map="A"/>
  <class name="org.bouncycastle.operator.OperatorException" map="I"/>
  <field class="org.bouncycastle.operator.OperatorException" name="cause" map="A"/>
  <method class="org.bouncycastle.operator.OperatorException" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="org.bouncycastle.operator.RuntimeOperatorException" map="J"/>
  <field class="org.bouncycastle.operator.RuntimeOperatorException" name="cause" map="A"/>
  <method class="org.bouncycastle.operator.RuntimeOperatorException" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" map="K"/>
  <field class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="ENCRYPTION_ECGOST3410_2012_512" map="A"/>
  <field class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="noParams" map="B"/>
  <field class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="ENCRYPTION_ECDSA" map="C"/>
  <field class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="params" map="D"/>
  <field class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="ENCRYPTION_RSA_PSS" map="E"/>
  <field class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="digestOids" map="F"/>
  <field class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="ENCRYPTION_DSA" map="G"/>
  <field class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="ENCRYPTION_RSA" map="H"/>
  <field class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="pkcs15RsaEncryption" map="I"/>
  <field class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="algorithms" map="J"/>
  <field class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="ENCRYPTION_ECGOST3410_2012_256" map="K"/>
  <field class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="ENCRYPTION_GOST3410" map="L"/>
  <field class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="ENCRYPTION_ECGOST3410" map="M"/>
  <method class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier find(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="org.bouncycastle.asn1.pkcs.RSASSAPSSparams createPSSParams(org.bouncycastle.asn1.x509.AlgorithmIdentifier, int)" map="A"/>
  <method class="org.bouncycastle.operator.DefaultSignatureAlgorithmIdentifierFinder" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier generate(java.lang.String)" map="B"/>
  <class name="org.bouncycastle.operator.AsymmetricKeyUnwrapper" map="L"/>
  <field class="org.bouncycastle.operator.AsymmetricKeyUnwrapper" name="algorithmId" map="A"/>
  <method class="org.bouncycastle.operator.AsymmetricKeyUnwrapper" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmIdentifier()" map="A"/>
  <class name="org.bouncycastle.operator.SignatureAlgorithmIdentifierFinder" map="M"/>
  <method class="org.bouncycastle.operator.SignatureAlgorithmIdentifierFinder" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier find(java.lang.String)" map="A"/>
  <class name="org.bouncycastle.operator.DigestCalculatorProvider" map="N"/>
  <method class="org.bouncycastle.operator.DigestCalculatorProvider" name="org.bouncycastle.operator.DigestCalculator get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.operator.OperatorStreamException" map="O"/>
  <field class="org.bouncycastle.operator.OperatorStreamException" name="cause" map="A"/>
  <method class="org.bouncycastle.operator.OperatorStreamException" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="org.bouncycastle.operator.RawContentVerifier" map="P"/>
  <method class="org.bouncycastle.operator.RawContentVerifier" name="boolean verify(byte[], byte[])" map="A"/>
  <class name="org.bouncycastle.operator.DigestCalculator" map="Q"/>
  <method class="org.bouncycastle.operator.DigestCalculator" name="byte[] getDigest()" map="A"/>
  <method class="org.bouncycastle.operator.DigestCalculator" name="java.io.OutputStream getOutputStream()" map="B"/>
  <method class="org.bouncycastle.operator.DigestCalculator" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmIdentifier()" map="C"/>
  <class name="org.bouncycastle.operator.ContentSigner" map="R"/>
  <method class="org.bouncycastle.operator.ContentSigner" name="byte[] getSignature()" map="A"/>
  <method class="org.bouncycastle.operator.ContentSigner" name="java.io.OutputStream getOutputStream()" map="B"/>
  <method class="org.bouncycastle.operator.ContentSigner" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmIdentifier()" map="C"/>
  <class name="org.bouncycastle.operator.ContentVerifierProvider" map="S"/>
  <method class="org.bouncycastle.operator.ContentVerifierProvider" name="org.bouncycastle.operator.ContentVerifier get(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <method class="org.bouncycastle.operator.ContentVerifierProvider" name="boolean hasAssociatedCertificate()" map="A"/>
  <method class="org.bouncycastle.operator.ContentVerifierProvider" name="org.bouncycastle.cert.X509CertificateHolder getAssociatedCertificate()" map="B"/>
  <package name="org.bouncycastle.jce" map="D"/>
  <package name="org.bouncycastle.jce.provider" map="A"/>
  <class name="org.bouncycastle.jce.provider.X509SignatureUtil" map="A"/>
  <field class="org.bouncycastle.jce.provider.X509SignatureUtil" name="derNull" map="A"/>
  <method class="org.bouncycastle.jce.provider.X509SignatureUtil" name="void setSignatureParameters(java.security.Signature, org.bouncycastle.asn1.ASN1Encodable)" map="A"/>
  <method class="org.bouncycastle.jce.provider.X509SignatureUtil" name="java.lang.String getSignatureName(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <method class="org.bouncycastle.jce.provider.X509SignatureUtil" name="java.lang.String getDigestAlgName(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="A"/>
  <class name="org.bouncycastle.jce.provider.X509CertificateObject" map="B"/>
  <field class="org.bouncycastle.jce.provider.X509CertificateObject" name="attrCarrier" map="C"/>
  <field class="org.bouncycastle.jce.provider.X509CertificateObject" name="hashValueSet" map="D"/>
  <field class="org.bouncycastle.jce.provider.X509CertificateObject" name="hashValue" map="E"/>
  <field class="org.bouncycastle.jce.provider.X509CertificateObject" name="keyUsage" map="F"/>
  <field class="org.bouncycastle.jce.provider.X509CertificateObject" name="basicConstraints" map="G"/>
  <field class="org.bouncycastle.jce.provider.X509CertificateObject" name="c" map="H"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="java.security.PublicKey getPublicKey()" map="getPublicKey"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="byte[] getExtensionValue(java.lang.String)" map="getExtensionValue"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="byte[] getSignature()" map="getSignature"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="java.util.Date getNotAfter()" map="getNotAfter"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="byte[] getSigAlgParams()" map="getSigAlgParams"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="int getBasicConstraints()" map="getBasicConstraints"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="boolean[] getSubjectUniqueID()" map="getSubjectUniqueID"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="void verify(java.security.PublicKey, java.lang.String)" map="verify"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="java.util.Set getNonCriticalExtensionOIDs()" map="getNonCriticalExtensionOIDs"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="java.util.Date getNotBefore()" map="getNotBefore"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="byte[] getExtensionBytes(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="byte[] getTBSCertificate()" map="getTBSCertificate"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="javax.security.auth.x500.X500Principal getSubjectX500Principal()" map="getSubjectX500Principal"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="java.lang.String getSigAlgName()" map="getSigAlgName"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="java.util.Set getCriticalExtensionOIDs()" map="getCriticalExtensionOIDs"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="boolean isAlgIdEqual(org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="javax.security.auth.x500.X500Principal getIssuerX500Principal()" map="getIssuerX500Principal"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="java.util.Collection getSubjectAlternativeNames()" map="getSubjectAlternativeNames"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="void checkValidity(java.util.Date)" map="checkValidity"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="byte[] getEncoded()" map="getEncoded"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="void verify(java.security.PublicKey, java.security.Provider)" map="verify"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="int getVersion()" map="getVersion"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="java.util.Collection getIssuerAlternativeNames()" map="getIssuerAlternativeNames"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="boolean[] getKeyUsage()" map="getKeyUsage"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="java.util.Collection getAlternativeNames(byte[])" map="A"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="void checkSignature(java.security.PublicKey, java.security.Signature)" map="A"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="void verify(java.security.PublicKey)" map="verify"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="int calculateHashCode()" map="A"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="java.security.Principal getSubjectDN()" map="getSubjectDN"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="java.security.Principal getIssuerDN()" map="getIssuerDN"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="java.math.BigInteger getSerialNumber()" map="getSerialNumber"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="void checkValidity()" map="checkValidity"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="java.util.List getExtendedKeyUsage()" map="getExtendedKeyUsage"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="java.lang.String getSigAlgOID()" map="getSigAlgOID"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="boolean hasUnsupportedCriticalExtension()" map="hasUnsupportedCriticalExtension"/>
  <method class="org.bouncycastle.jce.provider.X509CertificateObject" name="boolean[] getIssuerUniqueID()" map="getIssuerUniqueID"/>
  <class name="org.bouncycastle.jce.provider.X509CertParser" map="C"/>
  <field class="org.bouncycastle.jce.provider.X509CertParser" name="sData" map="A"/>
  <field class="org.bouncycastle.jce.provider.X509CertParser" name="PEM_PARSER" map="B"/>
  <field class="org.bouncycastle.jce.provider.X509CertParser" name="sDataObjectCount" map="C"/>
  <field class="org.bouncycastle.jce.provider.X509CertParser" name="currentStream" map="D"/>
  <method class="org.bouncycastle.jce.provider.X509CertParser" name="java.security.cert.Certificate getCertificate()" map="A"/>
  <method class="org.bouncycastle.jce.provider.X509CertParser" name="java.lang.Object engineRead()" map="B"/>
  <method class="org.bouncycastle.jce.provider.X509CertParser" name="java.security.cert.Certificate readPEMCertificate(java.io.InputStream)" map="A"/>
  <method class="org.bouncycastle.jce.provider.X509CertParser" name="void engineInit(java.io.InputStream)" map="B"/>
  <method class="org.bouncycastle.jce.provider.X509CertParser" name="java.util.Collection engineReadAll()" map="C"/>
  <method class="org.bouncycastle.jce.provider.X509CertParser" name="java.security.cert.Certificate readDERCertificate(java.io.InputStream)" map="C"/>
  <class name="org.bouncycastle.jce.provider.PKIXCRLUtil" map="D"/>
  <class name="org.bouncycastle.jce.provider.PEMUtil" map="E"/>
  <field class="org.bouncycastle.jce.provider.PEMUtil" name="_footer2" map="A"/>
  <field class="org.bouncycastle.jce.provider.PEMUtil" name="_footer1" map="B"/>
  <field class="org.bouncycastle.jce.provider.PEMUtil" name="_header2" map="C"/>
  <field class="org.bouncycastle.jce.provider.PEMUtil" name="_header1" map="D"/>
  <method class="org.bouncycastle.jce.provider.PEMUtil" name="org.bouncycastle.asn1.ASN1Sequence readPEMObject(java.io.InputStream)" map="A"/>
  <method class="org.bouncycastle.jce.provider.PEMUtil" name="java.lang.String readLine(java.io.InputStream)" map="B"/>
  <class name="org.bouncycastle.jce.provider.BouncyCastleProvider$1" map="1"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProvider$1" name="this$0" map="A"/>
  <method class="org.bouncycastle.jce.provider.BouncyCastleProvider$1" name="java.lang.Object run()" map="run"/>
  <class name="org.bouncycastle.jce.provider.BouncyCastleProvider" map="F"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="info" map="A"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="SYMMETRIC_CIPHERS" map="B"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="SYMMETRIC_MACS" map="C"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="DIGESTS" map="D"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="CONFIGURATION" map="E"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="keyInfoConverters" map="F"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="ASYMMETRIC_GENERIC" map="G"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="SECURE_RANDOMS" map="H"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="SYMMETRIC_GENERIC" map="I"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="ASYMMETRIC_CIPHERS" map="J"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="KEYSTORES" map="K"/>
  <method class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="org.bouncycastle.jcajce.provider.util.AsymmetricKeyInfoConverter getAsymmetricKeyInfoConverter(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="A"/>
  <method class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="void loadAlgorithms(java.lang.String, java.lang.String[])" map="A"/>
  <method class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="java.security.PublicKey getPublicKey(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)" map="A"/>
  <method class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="void loadPQCKeys()" map="A"/>
  <method class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="void access$000(org.bouncycastle.jce.provider.BouncyCastleProvider)" map="A"/>
  <method class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="void addKeyInfoConverter(org.bouncycastle.asn1.ASN1ObjectIdentifier, org.bouncycastle.jcajce.provider.util.AsymmetricKeyInfoConverter)" map="A"/>
  <method class="org.bouncycastle.jce.provider.BouncyCastleProvider" name="void setup()" map="B"/>
  <class name="org.bouncycastle.jce.provider.BouncyCastleProviderConfiguration" map="G"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProviderConfiguration" name="BC_ADDITIONAL_EC_CURVE_PERMISSION" map="A"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProviderConfiguration" name="BC_DH_LOCAL_PERMISSION" map="B"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProviderConfiguration" name="BC_DH_PERMISSION" map="C"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProviderConfiguration" name="BC_EC_PERMISSION" map="D"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProviderConfiguration" name="acceptableNamedCurves" map="E"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProviderConfiguration" name="dhThreadSpec" map="F"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProviderConfiguration" name="additionalECParameters" map="G"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProviderConfiguration" name="BC_EC_LOCAL_PERMISSION" map="H"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProviderConfiguration" name="ecThreadSpec" map="I"/>
  <field class="org.bouncycastle.jce.provider.BouncyCastleProviderConfiguration" name="BC_EC_CURVE_PERMISSION" map="J"/>
  <class name="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" map="H"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="ISSUING_DISTRIBUTION_POINT" map="A"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="CERTIFICATE_POLICIES" map="B"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="AUTHORITY_KEY_IDENTIFIER" map="C"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="POLICY_CONSTRAINTS" map="D"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="FRESHEST_CRL" map="E"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="crlReasons" map="F"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="POLICY_MAPPINGS" map="G"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="BASIC_CONSTRAINTS" map="H"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="DELTA_CRL_INDICATOR" map="I"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="NAME_CONSTRAINTS" map="J"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="CRL_DISTRIBUTION_POINTS" map="K"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="KEY_USAGE" map="L"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="CRL_UTIL" map="M"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="SUBJECT_ALTERNATIVE_NAME" map="N"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="CRL_NUMBER" map="O"/>
  <field class="org.bouncycastle.jce.provider.RFC3280CertPathUtilities" name="INHIBIT_ANY_POLICY" map="P"/>
  <package name="org.bouncycastle.jce.interfaces" map="B"/>
  <class name="org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier" map="A"/>
  <class name="org.bouncycastle.jce.X509Principal" map="A"/>
  <method class="org.bouncycastle.jce.X509Principal" name="org.bouncycastle.asn1.ASN1Sequence readSequence(org.bouncycastle.asn1.ASN1InputStream)" map="A"/>
  <method class="org.bouncycastle.jce.X509Principal" name="java.lang.String getName()" map="getName"/>
  <method class="org.bouncycastle.jce.X509Principal" name="byte[] getEncoded()" map="P"/>
  <package name="org.bouncycastle.asn1" map="E"/>
  <package name="org.bouncycastle.asn1.util" map="A"/>
  <class name="org.bouncycastle.asn1.util.ASN1Dump" map="A"/>
  <method class="org.bouncycastle.asn1.util.ASN1Dump" name="void _dumpAsString(java.lang.String, boolean, org.bouncycastle.asn1.ASN1Primitive, java.lang.StringBuffer)" map="A"/>
  <method class="org.bouncycastle.asn1.util.ASN1Dump" name="java.lang.String calculateAscString(byte[], int, int)" map="A"/>
  <method class="org.bouncycastle.asn1.util.ASN1Dump" name="java.lang.String dumpAsString(java.lang.Object, boolean)" map="A"/>
  <method class="org.bouncycastle.asn1.util.ASN1Dump" name="java.lang.String dumpBinaryDataAsString(java.lang.String, byte[])" map="A"/>
  <method class="org.bouncycastle.asn1.util.ASN1Dump" name="java.lang.String outputApplicationSpecific(java.lang.String, java.lang.String, boolean, org.bouncycastle.asn1.ASN1Primitive, java.lang.String)" map="A"/>
  <method class="org.bouncycastle.asn1.util.ASN1Dump" name="java.lang.String dumpAsString(java.lang.Object)" map="A"/>
  <package name="org.bouncycastle.asn1.ocsp" map="B"/>
  <class name="org.bouncycastle.asn1.ocsp.RevokedInfo" map="A"/>
  <field class="org.bouncycastle.asn1.ocsp.RevokedInfo" name="revocationReason" map="T"/>
  <field class="org.bouncycastle.asn1.ocsp.RevokedInfo" name="revocationTime" map="U"/>
  <method class="org.bouncycastle.asn1.ocsp.RevokedInfo" name="org.bouncycastle.asn1.ocsp.RevokedInfo getInstance(java.lang.Object)" map="A"/>
  <method class="org.bouncycastle.asn1.ocsp.RevokedInfo" name="org.bouncycastle.asn1.ocsp.RevokedInfo getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="A"/>
  <method class="org.bouncycastle.asn1.ocsp.RevokedInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers" map="B"/>
  <field class="org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers" name="id_pkix_ocsp_basic" map="A"/>
  <field class="org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers" name="id_pkix_ocsp_response" map="B"/>
  <field class="org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers" name="id_pkix_ocsp_crl" map="C"/>
  <field class="org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers" name="id_pkix_ocsp" map="D"/>
  <field class="org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers" name="id_pkix_ocsp_nonce" map="E"/>
  <field class="org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers" name="id_pkix_ocsp_archive_cutoff" map="F"/>
  <field class="org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers" name="id_pkix_ocsp_extended_revoke" map="G"/>
  <field class="org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers" name="id_pkix_ocsp_service_locator" map="H"/>
  <field class="org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers" name="id_pkix_ocsp_pref_sig_algs" map="I"/>
  <field class="org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers" name="id_pkix_ocsp_nocheck" map="J"/>
  <class name="org.bouncycastle.asn1.ocsp.Request" map="C"/>
  <field class="org.bouncycastle.asn1.ocsp.Request" name="reqCert" map="V"/>
  <field class="org.bouncycastle.asn1.ocsp.Request" name="singleRequestExtensions" map="W"/>
  <method class="org.bouncycastle.asn1.ocsp.Request" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.ocsp.ResponseBytes" map="D"/>
  <field class="org.bouncycastle.asn1.ocsp.ResponseBytes" name="response" map="X"/>
  <field class="org.bouncycastle.asn1.ocsp.ResponseBytes" name="responseType" map="Y"/>
  <method class="org.bouncycastle.asn1.ocsp.ResponseBytes" name="org.bouncycastle.asn1.ocsp.ResponseBytes getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="B"/>
  <method class="org.bouncycastle.asn1.ocsp.ResponseBytes" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getResponseType()" map="Q"/>
  <method class="org.bouncycastle.asn1.ocsp.ResponseBytes" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.ocsp.ResponseBytes" name="org.bouncycastle.asn1.ASN1OctetString getResponse()" map="R"/>
  <method class="org.bouncycastle.asn1.ocsp.ResponseBytes" name="org.bouncycastle.asn1.ocsp.ResponseBytes getInstance(java.lang.Object)" map="B"/>
  <class name="org.bouncycastle.asn1.ocsp.TBSRequest" map="E"/>
  <field class="org.bouncycastle.asn1.ocsp.TBSRequest" name="version" map="Z"/>
  <field class="org.bouncycastle.asn1.ocsp.TBSRequest" name="V1" map="_"/>
  <field class="org.bouncycastle.asn1.ocsp.TBSRequest" name="requestList" map="a"/>
  <field class="org.bouncycastle.asn1.ocsp.TBSRequest" name="requestExtensions" map="b"/>
  <field class="org.bouncycastle.asn1.ocsp.TBSRequest" name="requestorName" map="c"/>
  <field class="org.bouncycastle.asn1.ocsp.TBSRequest" name="versionSet" map="d"/>
  <method class="org.bouncycastle.asn1.ocsp.TBSRequest" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.ocsp.TBSRequest" name="org.bouncycastle.asn1.x509.Extensions getRequestExtensions()" map="S"/>
  <class name="org.bouncycastle.asn1.ocsp.CertStatus" map="F"/>
  <field class="org.bouncycastle.asn1.ocsp.CertStatus" name="tagNo" map="w"/>
  <field class="org.bouncycastle.asn1.ocsp.CertStatus" name="value" map="x"/>
  <method class="org.bouncycastle.asn1.ocsp.CertStatus" name="org.bouncycastle.asn1.ASN1Encodable getStatus()" map="l"/>
  <method class="org.bouncycastle.asn1.ocsp.CertStatus" name="int getTagNo()" map="m"/>
  <method class="org.bouncycastle.asn1.ocsp.CertStatus" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.ocsp.CertStatus" name="org.bouncycastle.asn1.ocsp.CertStatus getInstance(java.lang.Object)" map="N"/>
  <class name="org.bouncycastle.asn1.ocsp.OCSPResponse" map="G"/>
  <field class="org.bouncycastle.asn1.ocsp.OCSPResponse" name="responseBytes" map="y"/>
  <field class="org.bouncycastle.asn1.ocsp.OCSPResponse" name="responseStatus" map="z"/>
  <method class="org.bouncycastle.asn1.ocsp.OCSPResponse" name="org.bouncycastle.asn1.ocsp.OCSPResponseStatus getResponseStatus()" map="n"/>
  <method class="org.bouncycastle.asn1.ocsp.OCSPResponse" name="org.bouncycastle.asn1.ocsp.ResponseBytes getResponseBytes()" map="o"/>
  <method class="org.bouncycastle.asn1.ocsp.OCSPResponse" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.ocsp.OCSPResponse" name="org.bouncycastle.asn1.ocsp.OCSPResponse getInstance(java.lang.Object)" map="O"/>
  <class name="org.bouncycastle.asn1.ocsp.Signature" map="H"/>
  <field class="org.bouncycastle.asn1.ocsp.Signature" name="signature" map="&#x00a2;"/>
  <field class="org.bouncycastle.asn1.ocsp.Signature" name="certs" map="&#x00a3;"/>
  <field class="org.bouncycastle.asn1.ocsp.Signature" name="signatureAlgorithm" map="&#x00a4;"/>
  <method class="org.bouncycastle.asn1.ocsp.Signature" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.ocsp.BasicOCSPResponse" map="I"/>
  <field class="org.bouncycastle.asn1.ocsp.BasicOCSPResponse" name="signature" map="&#x00a5;"/>
  <field class="org.bouncycastle.asn1.ocsp.BasicOCSPResponse" name="certs" map="&#x00aa;"/>
  <field class="org.bouncycastle.asn1.ocsp.BasicOCSPResponse" name="signatureAlgorithm" map="&#x00b5;"/>
  <field class="org.bouncycastle.asn1.ocsp.BasicOCSPResponse" name="tbsResponseData" map="&#x00ba;"/>
  <method class="org.bouncycastle.asn1.ocsp.BasicOCSPResponse" name="org.bouncycastle.asn1.ASN1Sequence getCerts()" map="p"/>
  <method class="org.bouncycastle.asn1.ocsp.BasicOCSPResponse" name="org.bouncycastle.asn1.DERBitString getSignature()" map="q"/>
  <method class="org.bouncycastle.asn1.ocsp.BasicOCSPResponse" name="org.bouncycastle.asn1.ocsp.ResponseData getTbsResponseData()" map="r"/>
  <method class="org.bouncycastle.asn1.ocsp.BasicOCSPResponse" name="org.bouncycastle.asn1.ocsp.BasicOCSPResponse getInstance(java.lang.Object)" map="P"/>
  <method class="org.bouncycastle.asn1.ocsp.BasicOCSPResponse" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getSignatureAlgorithm()" map="s"/>
  <method class="org.bouncycastle.asn1.ocsp.BasicOCSPResponse" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.ocsp.OCSPRequest" map="J"/>
  <field class="org.bouncycastle.asn1.ocsp.OCSPRequest" name="optionalSignature" map="&#x00c0;"/>
  <field class="org.bouncycastle.asn1.ocsp.OCSPRequest" name="tbsRequest" map="&#x00c1;"/>
  <method class="org.bouncycastle.asn1.ocsp.OCSPRequest" name="org.bouncycastle.asn1.ocsp.TBSRequest getTbsRequest()" map="t"/>
  <method class="org.bouncycastle.asn1.ocsp.OCSPRequest" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.ocsp.OCSPResponseStatus" map="K"/>
  <field class="org.bouncycastle.asn1.ocsp.OCSPResponseStatus" name="value" map="&#x00c2;"/>
  <method class="org.bouncycastle.asn1.ocsp.OCSPResponseStatus" name="java.math.BigInteger getValue()" map="u"/>
  <method class="org.bouncycastle.asn1.ocsp.OCSPResponseStatus" name="org.bouncycastle.asn1.ocsp.OCSPResponseStatus getInstance(java.lang.Object)" map="Q"/>
  <method class="org.bouncycastle.asn1.ocsp.OCSPResponseStatus" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.ocsp.CertID" map="L"/>
  <field class="org.bouncycastle.asn1.ocsp.CertID" name="issuerKeyHash" map="&#x00c3;"/>
  <field class="org.bouncycastle.asn1.ocsp.CertID" name="serialNumber" map="&#x00c4;"/>
  <field class="org.bouncycastle.asn1.ocsp.CertID" name="hashAlgorithm" map="&#x00c5;"/>
  <field class="org.bouncycastle.asn1.ocsp.CertID" name="issuerNameHash" map="&#x00c6;"/>
  <method class="org.bouncycastle.asn1.ocsp.CertID" name="org.bouncycastle.asn1.ASN1Integer getSerialNumber()" map="v"/>
  <method class="org.bouncycastle.asn1.ocsp.CertID" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getHashAlgorithm()" map="w"/>
  <method class="org.bouncycastle.asn1.ocsp.CertID" name="org.bouncycastle.asn1.ocsp.CertID getInstance(java.lang.Object)" map="R"/>
  <method class="org.bouncycastle.asn1.ocsp.CertID" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.ocsp.ResponseData" map="M"/>
  <field class="org.bouncycastle.asn1.ocsp.ResponseData" name="versionPresent" map="&#x00c7;"/>
  <field class="org.bouncycastle.asn1.ocsp.ResponseData" name="version" map="&#x00c8;"/>
  <field class="org.bouncycastle.asn1.ocsp.ResponseData" name="V1" map="&#x00c9;"/>
  <field class="org.bouncycastle.asn1.ocsp.ResponseData" name="responderID" map="&#x00ca;"/>
  <field class="org.bouncycastle.asn1.ocsp.ResponseData" name="responseExtensions" map="&#x00cb;"/>
  <field class="org.bouncycastle.asn1.ocsp.ResponseData" name="responses" map="&#x00cc;"/>
  <field class="org.bouncycastle.asn1.ocsp.ResponseData" name="producedAt" map="&#x00cd;"/>
  <method class="org.bouncycastle.asn1.ocsp.ResponseData" name="org.bouncycastle.asn1.x509.Extensions getResponseExtensions()" map="x"/>
  <method class="org.bouncycastle.asn1.ocsp.ResponseData" name="org.bouncycastle.asn1.ASN1Sequence getResponses()" map="y"/>
  <method class="org.bouncycastle.asn1.ocsp.ResponseData" name="org.bouncycastle.asn1.ocsp.ResponseData getInstance(java.lang.Object)" map="S"/>
  <method class="org.bouncycastle.asn1.ocsp.ResponseData" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.ocsp.SingleResponse" map="N"/>
  <field class="org.bouncycastle.asn1.ocsp.SingleResponse" name="certID" map="&#x00ce;"/>
  <field class="org.bouncycastle.asn1.ocsp.SingleResponse" name="nextUpdate" map="&#x00cf;"/>
  <field class="org.bouncycastle.asn1.ocsp.SingleResponse" name="singleExtensions" map="&#x00d0;"/>
  <field class="org.bouncycastle.asn1.ocsp.SingleResponse" name="thisUpdate" map="&#x00d1;"/>
  <field class="org.bouncycastle.asn1.ocsp.SingleResponse" name="certStatus" map="&#x00d2;"/>
  <method class="org.bouncycastle.asn1.ocsp.SingleResponse" name="org.bouncycastle.asn1.x509.Extensions getSingleExtensions()" map="z"/>
  <method class="org.bouncycastle.asn1.ocsp.SingleResponse" name="org.bouncycastle.asn1.ASN1GeneralizedTime getThisUpdate()" map="&#x00a2;"/>
  <method class="org.bouncycastle.asn1.ocsp.SingleResponse" name="org.bouncycastle.asn1.ocsp.SingleResponse getInstance(java.lang.Object)" map="T"/>
  <method class="org.bouncycastle.asn1.ocsp.SingleResponse" name="org.bouncycastle.asn1.ocsp.CertStatus getCertStatus()" map="&#x00a3;"/>
  <method class="org.bouncycastle.asn1.ocsp.SingleResponse" name="org.bouncycastle.asn1.ASN1GeneralizedTime getNextUpdate()" map="&#x00a4;"/>
  <method class="org.bouncycastle.asn1.ocsp.SingleResponse" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.ocsp.SingleResponse" name="org.bouncycastle.asn1.ocsp.CertID getCertID()" map="&#x00a5;"/>
  <class name="org.bouncycastle.asn1.ocsp.ResponderID" map="O"/>
  <field class="org.bouncycastle.asn1.ocsp.ResponderID" name="value" map="e"/>
  <method class="org.bouncycastle.asn1.ocsp.ResponderID" name="org.bouncycastle.asn1.ocsp.ResponderID getInstance(java.lang.Object)" map="C"/>
  <method class="org.bouncycastle.asn1.ocsp.ResponderID" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <package name="org.bouncycastle.asn1.kisa" map="C"/>
  <class name="org.bouncycastle.asn1.kisa.KISAObjectIdentifiers" map="A"/>
  <field class="org.bouncycastle.asn1.kisa.KISAObjectIdentifiers" name="pbeWithSHA1AndSEED_CBC" map="A"/>
  <field class="org.bouncycastle.asn1.kisa.KISAObjectIdentifiers" name="id_seedCBC" map="B"/>
  <field class="org.bouncycastle.asn1.kisa.KISAObjectIdentifiers" name="id_seedMAC" map="C"/>
  <field class="org.bouncycastle.asn1.kisa.KISAObjectIdentifiers" name="id_mod_cms_seed" map="D"/>
  <field class="org.bouncycastle.asn1.kisa.KISAObjectIdentifiers" name="id_npki_app_cmsSeed_wrap" map="E"/>
  <package name="org.bouncycastle.asn1.bsi" map="D"/>
  <class name="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" map="A"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="id_aes256_CBC_CMAC" map="A"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecka_eg_SessionKDF" map="B"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecka_eg_X963kdf_RIPEMD160" map="C"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="id_ecc" map="D"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecka_eg_X963kdf_SHA256" map="E"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecka_eg_X963kdf_SHA224" map="F"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecdsa_plain_SHA384" map="G"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecka_eg_SessionKDF_AES192" map="H"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecdsa_plain_RIPEMD160" map="I"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecka_eg_SessionKDF_AES256" map="J"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecka_eg_X963kdf" map="K"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="id_aes192_CBC_CMAC" map="L"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecka_eg_X963kdf_SHA512" map="M"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecdsa_plain_SHA1" map="N"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecdsa_plain_signatures" map="O"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecka_eg_SessionKDF_3DES" map="P"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecdsa_plain_SHA256" map="Q"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecdsa_plain_SHA224" map="R"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="aes_cbc_cmac" map="S"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="id_aes128_CBC_CMAC" map="T"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecka_eg_SessionKDF_AES128" map="U"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecka_eg" map="V"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="algorithm" map="W"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecka_eg_X963kdf_SHA384" map="X"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecka_eg_X963kdf_SHA1" map="Y"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="ecdsa_plain_SHA512" map="Z"/>
  <field class="org.bouncycastle.asn1.bsi.BSIObjectIdentifiers" name="bsi_de" map="_"/>
  <package name="org.bouncycastle.asn1.pkcs" map="E"/>
  <class name="org.bouncycastle.asn1.pkcs.SignedData" map="A"/>
  <field class="org.bouncycastle.asn1.pkcs.SignedData" name="version" map="&#x0189;"/>
  <field class="org.bouncycastle.asn1.pkcs.SignedData" name="contentInfo" map="&#x018a;"/>
  <field class="org.bouncycastle.asn1.pkcs.SignedData" name="certificates" map="&#x018b;"/>
  <field class="org.bouncycastle.asn1.pkcs.SignedData" name="signerInfos" map="&#x018c;"/>
  <field class="org.bouncycastle.asn1.pkcs.SignedData" name="crls" map="&#x018d;"/>
  <field class="org.bouncycastle.asn1.pkcs.SignedData" name="digestAlgorithms" map="&#x018e;"/>
  <method class="org.bouncycastle.asn1.pkcs.SignedData" name="org.bouncycastle.asn1.ASN1Set getCertificates()" map="&#x00c0;"/>
  <method class="org.bouncycastle.asn1.pkcs.SignedData" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" map="B"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="safeContentsBag" map="&#x00d3;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_ets_sigPolicyId" map="&#x00d4;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="sha512_224WithRSAEncryption" map="&#x00d5;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="crlBag" map="&#x00d6;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_asymmDecryptKeyID" map="&#x00d8;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_alg" map="&#x00d9;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="certBag" map="&#x00da;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_9_at_signingTime" map="&#x00db;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_communityIdentifiers" map="&#x00dc;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_ets_signerAttr" map="&#x00dd;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pbeWithSHAAnd128BitRC2_CBC" map="&#x00de;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pbeWithSHA1AndDES_CBC" map="&#x00df;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="crlTypes" map="&#x00e0;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="sha384WithRSAEncryption" map="&#x00e1;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="envelopedData" map="&#x00e2;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_encrypKeyPref" map="&#x00e3;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_hmacWithSHA1" map="&#x00e4;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_ct_authEnvelopedData" map="&#x00e5;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="x509Crl" map="&#x00e6;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="md2WithRSAEncryption" map="&#x00e7;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="preferSignedData" map="&#x00e8;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_ets_contentTimestamp" map="&#x00e9;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_signingCertificate" map="&#x00ea;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_ets_certificateRefs" map="&#x00eb;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pbeWithMD2AndDES_CBC" map="&#x00ec;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_alg_CMS3DESwrap" map="&#x00ed;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_9_at_signingDescription" map="&#x00ee;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_hmacWithSHA224" map="&#x00ef;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_hmacWithSHA384" map="&#x00f0;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="sMIMECapabilitiesVersions" map="&#x00f1;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_cti_ets_proofOfDelivery" map="&#x00f2;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_ct_authData" map="&#x00f3;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_cti_ets_proofOfSender" map="&#x00f4;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_9_at_counterSignature" map="&#x00f5;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_ct_TSTInfo" map="&#x00f6;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs8ShroudedKeyBag" map="&#x00f8;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pbeWithSHAAnd2_KeyTripleDES_CBC" map="&#x00f9;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="md5" map="&#x00fa;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="md4" map="&#x00fb;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="md2" map="&#x00fc;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_ets_escTimeStamp" map="&#x00fd;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_receiptRequest" map="&#x00fe;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_ets_certValues" map="&#x00ff;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_signatureTimeStampToken" map="&#x0100;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="RC2_CBC" map="&#x0101;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="sdsiCertificate" map="&#x0102;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="sha512WithRSAEncryption" map="&#x0103;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="canNotDecryptAny" map="&#x0104;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="x509Certificate" map="&#x0105;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_9_at_extensionRequest" map="&#x0106;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="srsaOAEPEncryptionSET" map="&#x0107;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_spq_ets_uri" map="&#x0108;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_cti" map="&#x0109;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_ct" map="&#x010a;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="dhKeyAgreement" map="&#x010b;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="md4WithRSAEncryption" map="&#x010c;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pbeWithSHAAnd3_KeyTripleDES_CBC" map="&#x010d;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="des_EDE3_CBC" map="&#x010e;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="encryptedData" map="&#x010f;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="sha224WithRSAEncryption" map="&#x0110;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_mgf1" map="&#x0111;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="digestAlgorithm" map="&#x0112;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="digestedData" map="&#x0113;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="x509certType" map="&#x0114;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pbeWithMD5AndDES_CBC" map="&#x0115;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_12PbeIds" map="&#x0116;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_9_at_unstructuredAddress" map="&#x0117;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_sigPolicyId" map="&#x0118;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_smime" map="&#x0119;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_ct_timestampedData" map="&#x011a;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pbeWithSHAAnd40BitRC4" map="&#x011b;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_spq_ets_unotice" map="&#x011c;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_alg_ESDH" map="&#x011d;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="sha512_256WithRSAEncryption" map="&#x011e;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_alg_PWRI_KEK" map="&#x011f;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_9_at_extendedCertificateAttributes" map="&#x0120;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="md5WithRSAEncryption" map="&#x0121;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_9_at_contentType" map="&#x0122;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_alg_SSDH" map="&#x0123;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="signedAndEnvelopedData" map="&#x0124;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_9_at_challengePassword" map="&#x0125;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_msgSigDigest" map="&#x0126;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa" map="&#x0127;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="keyBag" map="&#x0128;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_12" map="&#x0129;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_cti_ets_proofOfOrigin" map="&#x012a;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_PBES2" map="&#x012b;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_ets_revocationRefs" map="&#x012c;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_pSpecified" map="&#x012d;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_cmsAlgorithmProtect" map="&#x012e;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pbeWithSHA1AndRC2_CBC" map="&#x012f;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_ets_archiveTimestamp" map="&#x0130;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="data" map="&#x0131;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_ct_compressedData" map="&#x0132;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pbeWithMD2AndRC2_CBC" map="&#x0133;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_alg_CMSRC2wrap" map="&#x0134;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_commitmentType" map="&#x0135;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="signedData" map="&#x0136;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_9_at_messageDigest" map="&#x0137;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_9_at_friendlyName" map="&#x0138;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_9_at_smimeCapabilities" map="&#x0139;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="rsaEncryption" map="&#x013a;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_cti_ets_proofOfReceipt" map="&#x013b;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_9_at_emailAddress" map="&#x013c;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_cti_ets_proofOfApproval" map="&#x013d;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_ets_commitmentType" map="&#x013e;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_9" map="&#x013f;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_7" map="&#x0140;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_5" map="&#x0141;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_hmacWithSHA512" map="&#x0142;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_3" map="&#x0143;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_1" map="&#x0144;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_contentReference" map="&#x0145;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_implCryptoAlgs" map="&#x0146;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="rc4" map="&#x0147;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="bagtypes" map="&#x0148;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_ets_certCRLTimestamp" map="&#x0149;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_9_at_unstructuredName" map="&#x014a;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_cti_ets_proofOfCreation" map="&#x014b;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_contentHint" map="&#x014c;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_ets_revocationValues" map="&#x014d;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_rsa_KEM" map="&#x014e;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_RSASSA_PSS" map="&#x014f;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pkcs_9_at_localKeyId" map="&#x0150;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_signerLocation" map="&#x0151;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_otherSigCert" map="&#x0152;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="sha256WithRSAEncryption" map="&#x0153;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="sha1WithRSAEncryption" map="&#x0154;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pbeWithMD5AndRC2_CBC" map="&#x0155;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_implCompressAlgs" map="&#x0156;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="secretBag" map="&#x0157;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_decryptKeyID" map="&#x0158;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_signingCertificateV2" map="&#x0159;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="encryptionAlgorithm" map="&#x015a;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_ets_signerLocation" map="&#x015b;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_hmacWithSHA256" map="&#x015c;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_ets_otherSigCert" map="&#x015d;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pbewithSHAAnd40BitRC2_CBC" map="&#x015e;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_aa_contentIdentifier" map="&#x015f;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_PBKDF2" map="&#x0160;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="id_RSAES_OAEP" map="&#x0161;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pbeWithSHAAnd128BitRC4" map="&#x0162;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="pbeWithSHAAnd40BitRC2_CBC" map="&#x0163;"/>
  <field class="org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers" name="certTypes" map="&#x0164;"/>
  <class name="org.bouncycastle.asn1.pkcs.ContentInfo" map="C"/>
  <field class="org.bouncycastle.asn1.pkcs.ContentInfo" name="content" map="&#x0165;"/>
  <field class="org.bouncycastle.asn1.pkcs.ContentInfo" name="isBer" map="&#x0166;"/>
  <field class="org.bouncycastle.asn1.pkcs.ContentInfo" name="contentType" map="&#x0167;"/>
  <method class="org.bouncycastle.asn1.pkcs.ContentInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.pkcs.ContentInfo" name="org.bouncycastle.asn1.pkcs.ContentInfo getInstance(java.lang.Object)" map="U"/>
  <class name="org.bouncycastle.asn1.pkcs.PrivateKeyInfo" map="D"/>
  <field class="org.bouncycastle.asn1.pkcs.PrivateKeyInfo" name="algId" map="&#x018f;"/>
  <field class="org.bouncycastle.asn1.pkcs.PrivateKeyInfo" name="attributes" map="&#x0190;"/>
  <field class="org.bouncycastle.asn1.pkcs.PrivateKeyInfo" name="privKey" map="&#x0191;"/>
  <method class="org.bouncycastle.asn1.pkcs.PrivateKeyInfo" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getPrivateKeyAlgorithm()" map="&#x00c1;"/>
  <method class="org.bouncycastle.asn1.pkcs.PrivateKeyInfo" name="org.bouncycastle.asn1.pkcs.PrivateKeyInfo getInstance(java.lang.Object)" map="W"/>
  <method class="org.bouncycastle.asn1.pkcs.PrivateKeyInfo" name="org.bouncycastle.asn1.ASN1Encodable parsePrivateKey()" map="&#x00c2;"/>
  <method class="org.bouncycastle.asn1.pkcs.PrivateKeyInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.pkcs.RSASSAPSSparams" map="E"/>
  <field class="org.bouncycastle.asn1.pkcs.RSASSAPSSparams" name="DEFAULT_MASK_GEN_FUNCTION" map="&#x0192;"/>
  <field class="org.bouncycastle.asn1.pkcs.RSASSAPSSparams" name="trailerField" map="&#x0193;"/>
  <field class="org.bouncycastle.asn1.pkcs.RSASSAPSSparams" name="saltLength" map="&#x0194;"/>
  <field class="org.bouncycastle.asn1.pkcs.RSASSAPSSparams" name="DEFAULT_HASH_ALGORITHM" map="&#x0195;"/>
  <field class="org.bouncycastle.asn1.pkcs.RSASSAPSSparams" name="DEFAULT_SALT_LENGTH" map="&#x0196;"/>
  <field class="org.bouncycastle.asn1.pkcs.RSASSAPSSparams" name="hashAlgorithm" map="&#x0197;"/>
  <field class="org.bouncycastle.asn1.pkcs.RSASSAPSSparams" name="maskGenAlgorithm" map="&#x0198;"/>
  <field class="org.bouncycastle.asn1.pkcs.RSASSAPSSparams" name="DEFAULT_TRAILER_FIELD" map="&#x0199;"/>
  <method class="org.bouncycastle.asn1.pkcs.RSASSAPSSparams" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getHashAlgorithm()" map="&#x00c3;"/>
  <method class="org.bouncycastle.asn1.pkcs.RSASSAPSSparams" name="java.math.BigInteger getSaltLength()" map="&#x00c4;"/>
  <method class="org.bouncycastle.asn1.pkcs.RSASSAPSSparams" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getMaskGenAlgorithm()" map="&#x00c5;"/>
  <method class="org.bouncycastle.asn1.pkcs.RSASSAPSSparams" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.pkcs.RSASSAPSSparams" name="org.bouncycastle.asn1.pkcs.RSASSAPSSparams getInstance(java.lang.Object)" map="X"/>
  <package name="org.bouncycastle.asn1.nist" map="F"/>
  <class name="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" map="A"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_shake128" map="A"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_dsa_with_sha3_512" map="B"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_dsa_with_sha3_256" map="C"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_dsa_with_sha3_224" map="D"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes128_OFB" map="E"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="nistAlgorithm" map="F"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes192_GCM" map="G"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes256_OFB" map="H"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes128_ECB" map="I"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_ecdsa_with_sha3_384" map="J"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes192_wrap_pad" map="K"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_ecdsa_with_sha3_512" map="L"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_ecdsa_with_sha3_256" map="M"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_ecdsa_with_sha3_224" map="N"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes256_ECB" map="O"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes192_OFB" map="P"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes128_CCM" map="Q"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_dsa_with_sha2" map="R"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_rsassa_pkcs1_v1_5_with_sha3_384" map="S"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes128_wrap_pad" map="T"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes256_CCM" map="U"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes192_ECB" map="V"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes128_CFB" map="W"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_rsassa_pkcs1_v1_5_with_sha3_512" map="X"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_rsassa_pkcs1_v1_5_with_sha3_256" map="Y"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_rsassa_pkcs1_v1_5_with_sha3_224" map="Z"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes256_CFB" map="_"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes192_CCM" map="a"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="aes" map="b"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="sigAlgs" map="c"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="hashAlgs" map="d"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_hmacWithSHA3_384" map="e"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes192_CFB" map="f"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes128_CBC" map="g"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_sha3_384" map="h"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_hmacWithSHA3_512" map="i"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_hmacWithSHA3_224" map="j"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_hmacWithSHA3_256" map="k"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_sha384" map="l"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="dsa_with_sha384" map="m"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_sha3_512" map="n"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_sha3_224" map="o"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_sha3_256" map="p"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes192_wrap" map="q"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_sha512_224" map="r"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_sha512_256" map="s"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes256_wrap_pad" map="t"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes128_GCM" map="u"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes256_CBC" map="v"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_sha512" map="w"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_sha224" map="x"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_sha256" map="y"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="dsa_with_sha512" map="z"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="dsa_with_sha256" map="&#x00a2;"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="dsa_with_sha224" map="&#x00a3;"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes128_wrap" map="&#x00a4;"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes256_wrap" map="&#x00a5;"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_shake256" map="&#x00aa;"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_dsa_with_sha3_384" map="&#x00b5;"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes256_GCM" map="&#x00ba;"/>
  <field class="org.bouncycastle.asn1.nist.NISTObjectIdentifiers" name="id_aes192_CBC" map="&#x00c0;"/>
  <package name="org.bouncycastle.asn1.bc" map="G"/>
  <class name="org.bouncycastle.asn1.bc.BCObjectIdentifiers" map="A"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe_sha1_pkcs12_aes128_cbc" map="A"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe_sha256_pkcs12" map="B"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="xmss_with_SHA256" map="C"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe_sha1_pkcs12_aes256_cbc" map="D"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe_sha512" map="E"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc" map="F"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe_sha1_pkcs12_aes192_cbc" map="G"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe_sha1_pkcs12" map="H"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="newHope" map="I"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="xmss_mt_with_SHA512" map="J"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_exch" map="K"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="xmss_mt_with_SHAKE128" map="L"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="sphincs256_with_BLAKE512" map="M"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_sig" map="N"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe" map="O"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe_sha256_pkcs12_aes128_cbc" map="P"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe_sha384" map="Q"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe_sha256_pkcs12_aes256_cbc" map="R"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="xmss_with_SHAKE256" map="S"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="xmss_with_SHA512" map="T"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="sphincs256_with_SHA512" map="U"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe_sha256_pkcs12_aes192_cbc" map="V"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="sphincs256_with_SHA3_512" map="W"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe_sha256_pkcs5" map="X"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe_sha1_pkcs5" map="Y"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="sphincs256" map="Z"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe_sha1" map="_"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe_sha256" map="a"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="bc_pbe_sha224" map="b"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="xmss_mt" map="c"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="xmss" map="d"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="xmss_mt_with_SHA256" map="e"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="xmss_with_SHAKE128" map="f"/>
  <field class="org.bouncycastle.asn1.bc.BCObjectIdentifiers" name="xmss_mt_with_SHAKE256" map="g"/>
  <package name="org.bouncycastle.asn1.x509" map="H"/>
  <class name="org.bouncycastle.asn1.x509.CRLReason" map="A"/>
  <field class="org.bouncycastle.asn1.x509.CRLReason" name="table" map="&#x019a;"/>
  <field class="org.bouncycastle.asn1.x509.CRLReason" name="value" map="&#x019b;"/>
  <field class="org.bouncycastle.asn1.x509.CRLReason" name="reasonString" map="&#x019c;"/>
  <method class="org.bouncycastle.asn1.x509.CRLReason" name="org.bouncycastle.asn1.x509.CRLReason getInstance(java.lang.Object)" map="Y"/>
  <method class="org.bouncycastle.asn1.x509.CRLReason" name="java.math.BigInteger getValue()" map="&#x00c6;"/>
  <method class="org.bouncycastle.asn1.x509.CRLReason" name="org.bouncycastle.asn1.x509.CRLReason lookup(int)" map="A"/>
  <method class="org.bouncycastle.asn1.x509.CRLReason" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.x509.CRLReason" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.x509.X509Extension" map="B"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="authorityKeyIdentifier" map="A"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="invalidityDate" map="B"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="freshestCRL" map="C"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="certificatePolicies" map="D"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="noRevAvail" map="E"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="certificateIssuer" map="F"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="cRLNumber" map="G"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="nameConstraints" map="H"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="inhibitAnyPolicy" map="I"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="policyConstraints" map="J"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="subjectAlternativeName" map="K"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="issuerAlternativeName" map="L"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="auditIdentity" map="M"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="qCStatements" map="N"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="basicConstraints" map="O"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="targetInformation" map="P"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="issuingDistributionPoint" map="Q"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="subjectKeyIdentifier" map="R"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="reasonCode" map="S"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="authorityInfoAccess" map="T"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="extendedKeyUsage" map="U"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="critical" map="V"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="subjectInfoAccess" map="W"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="value" map="X"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="subjectDirectoryAttributes" map="Y"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="logoType" map="Z"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="instructionCode" map="_"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="privateKeyUsagePeriod" map="a"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="keyUsage" map="b"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="cRLDistributionPoints" map="c"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="policyMappings" map="d"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="deltaCRLIndicator" map="e"/>
  <field class="org.bouncycastle.asn1.x509.X509Extension" name="biometricInfo" map="f"/>
  <method class="org.bouncycastle.asn1.x509.X509Extension" name="org.bouncycastle.asn1.ASN1Primitive convertValueToObject(org.bouncycastle.asn1.x509.X509Extension)" map="A"/>
  <method class="org.bouncycastle.asn1.x509.X509Extension" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.asn1.x509.X509Extension" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.x509.X509Extension" name="boolean isCritical()" map="A"/>
  <method class="org.bouncycastle.asn1.x509.X509Extension" name="org.bouncycastle.asn1.ASN1OctetString getValue()" map="B"/>
  <class name="org.bouncycastle.asn1.x509.Certificate" map="C"/>
  <field class="org.bouncycastle.asn1.x509.Certificate" name="seq" map="&#x019d;"/>
  <field class="org.bouncycastle.asn1.x509.Certificate" name="sigAlgId" map="&#x019e;"/>
  <field class="org.bouncycastle.asn1.x509.Certificate" name="sig" map="&#x019f;"/>
  <field class="org.bouncycastle.asn1.x509.Certificate" name="tbsCert" map="&#x01a0;"/>
  <method class="org.bouncycastle.asn1.x509.Certificate" name="org.bouncycastle.asn1.x500.X500Name getIssuer()" map="&#x00c7;"/>
  <method class="org.bouncycastle.asn1.x509.Certificate" name="org.bouncycastle.asn1.x509.Time getStartDate()" map="&#x00c8;"/>
  <method class="org.bouncycastle.asn1.x509.Certificate" name="org.bouncycastle.asn1.x500.X500Name getSubject()" map="&#x00c9;"/>
  <method class="org.bouncycastle.asn1.x509.Certificate" name="int getVersionNumber()" map="&#x00ca;"/>
  <method class="org.bouncycastle.asn1.x509.Certificate" name="org.bouncycastle.asn1.x509.Certificate getInstance(java.lang.Object)" map="Z"/>
  <method class="org.bouncycastle.asn1.x509.Certificate" name="org.bouncycastle.asn1.x509.TBSCertificate getTBSCertificate()" map="&#x00cb;"/>
  <method class="org.bouncycastle.asn1.x509.Certificate" name="org.bouncycastle.asn1.DERBitString getSignature()" map="&#x00cc;"/>
  <method class="org.bouncycastle.asn1.x509.Certificate" name="org.bouncycastle.asn1.x509.Time getEndDate()" map="&#x00cd;"/>
  <method class="org.bouncycastle.asn1.x509.Certificate" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.x509.Certificate" name="org.bouncycastle.asn1.ASN1Integer getSerialNumber()" map="&#x00ce;"/>
  <method class="org.bouncycastle.asn1.x509.Certificate" name="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getSubjectPublicKeyInfo()" map="&#x00cf;"/>
  <method class="org.bouncycastle.asn1.x509.Certificate" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getSignatureAlgorithm()" map="&#x00d0;"/>
  <class name="org.bouncycastle.asn1.x509.GeneralNames" map="D"/>
  <field class="org.bouncycastle.asn1.x509.GeneralNames" name="names" map="&#x01a1;"/>
  <method class="org.bouncycastle.asn1.x509.GeneralNames" name="org.bouncycastle.asn1.x509.GeneralNames getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="G"/>
  <method class="org.bouncycastle.asn1.x509.GeneralNames" name="org.bouncycastle.asn1.x509.GeneralNames getInstance(java.lang.Object)" map="_"/>
  <method class="org.bouncycastle.asn1.x509.GeneralNames" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.x509.GeneralNames" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.x509.GeneralNames" name="org.bouncycastle.asn1.x509.GeneralName[] getNames()" map="&#x00d1;"/>
  <class name="org.bouncycastle.asn1.x509.X509NameEntryConverter" map="E"/>
  <method class="org.bouncycastle.asn1.x509.X509NameEntryConverter" name="org.bouncycastle.asn1.ASN1Primitive getConvertedValue(org.bouncycastle.asn1.ASN1ObjectIdentifier, java.lang.String)" map="A"/>
  <class name="org.bouncycastle.asn1.x509.AlgorithmIdentifier" map="F"/>
  <field class="org.bouncycastle.asn1.x509.AlgorithmIdentifier" name="algorithm" map="&#x01a2;"/>
  <field class="org.bouncycastle.asn1.x509.AlgorithmIdentifier" name="parameters" map="&#x01a3;"/>
  <method class="org.bouncycastle.asn1.x509.AlgorithmIdentifier" name="org.bouncycastle.asn1.ASN1Encodable getParameters()" map="&#x00d2;"/>
  <method class="org.bouncycastle.asn1.x509.AlgorithmIdentifier" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getAlgorithm()" map="&#x00d3;"/>
  <method class="org.bouncycastle.asn1.x509.AlgorithmIdentifier" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getInstance(java.lang.Object)" map="a"/>
  <method class="org.bouncycastle.asn1.x509.AlgorithmIdentifier" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="H"/>
  <method class="org.bouncycastle.asn1.x509.AlgorithmIdentifier" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.x509.ReasonFlags" map="G"/>
  <class name="org.bouncycastle.asn1.x509.IssuerSerial" map="H"/>
  <field class="org.bouncycastle.asn1.x509.IssuerSerial" name="serial" map="&#x01a4;"/>
  <field class="org.bouncycastle.asn1.x509.IssuerSerial" name="issuer" map="&#x01a5;"/>
  <field class="org.bouncycastle.asn1.x509.IssuerSerial" name="issuerUID" map="&#x01a6;"/>
  <method class="org.bouncycastle.asn1.x509.IssuerSerial" name="org.bouncycastle.asn1.x509.IssuerSerial getInstance(java.lang.Object)" map="b"/>
  <method class="org.bouncycastle.asn1.x509.IssuerSerial" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.x509.Extensions" map="I"/>
  <field class="org.bouncycastle.asn1.x509.Extensions" name="extensions" map="&#x01a7;"/>
  <field class="org.bouncycastle.asn1.x509.Extensions" name="ordering" map="&#x01a8;"/>
  <method class="org.bouncycastle.asn1.x509.Extensions" name="java.util.Enumeration oids()" map="&#x00d4;"/>
  <method class="org.bouncycastle.asn1.x509.Extensions" name="org.bouncycastle.asn1.x509.Extensions getInstance(java.lang.Object)" map="c"/>
  <method class="org.bouncycastle.asn1.x509.Extensions" name="org.bouncycastle.asn1.x509.Extension getExtension(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="B"/>
  <method class="org.bouncycastle.asn1.x509.Extensions" name="org.bouncycastle.asn1.x509.Extensions getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="I"/>
  <method class="org.bouncycastle.asn1.x509.Extensions" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.x509.X509Extensions" map="J"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="QCStatements" map="&#x01a9;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="AuditIdentity" map="&#x01aa;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="SubjectAlternativeName" map="&#x01ab;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="CertificateIssuer" map="&#x01ac;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="InhibitAnyPolicy" map="&#x01ad;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="SubjectDirectoryAttributes" map="&#x01ae;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="CRLNumber" map="&#x01af;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="NameConstraints" map="&#x01b0;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="TargetInformation" map="&#x01b1;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="PolicyMappings" map="&#x01b2;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="InvalidityDate" map="&#x01b3;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="NoRevAvail" map="&#x01b4;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="PrivateKeyUsagePeriod" map="&#x01b5;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="CRLDistributionPoints" map="&#x01b6;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="SubjectKeyIdentifier" map="&#x01b7;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="SubjectInfoAccess" map="&#x01b8;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="AuthorityInfoAccess" map="&#x01b9;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="ExtendedKeyUsage" map="&#x01ba;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="CertificatePolicies" map="&#x01bb;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="FreshestCRL" map="&#x01bc;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="PolicyConstraints" map="&#x01bd;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="BiometricInfo" map="&#x01be;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="IssuingDistributionPoint" map="&#x01bf;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="LogoType" map="&#x01c0;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="IssuerAlternativeName" map="&#x01c1;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="ReasonCode" map="&#x01c2;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="extensions" map="&#x01c3;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="AuthorityKeyIdentifier" map="&#x01c4;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="ordering" map="&#x01c5;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="DeltaCRLIndicator" map="&#x01c6;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="KeyUsage" map="&#x01c7;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="BasicConstraints" map="&#x01c8;"/>
  <field class="org.bouncycastle.asn1.x509.X509Extensions" name="InstructionCode" map="&#x01c9;"/>
  <method class="org.bouncycastle.asn1.x509.X509Extensions" name="org.bouncycastle.asn1.x509.X509Extensions getInstance(java.lang.Object)" map="d"/>
  <method class="org.bouncycastle.asn1.x509.X509Extensions" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.x509.TBSCertificateStructure" map="K"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="subjectPublicKeyInfo" map="&#x017d;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="issuerUniqueId" map="&#x017e;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="startDate" map="&#x017f;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="signature" map="&#x0180;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="serialNumber" map="&#x0181;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="subjectUniqueId" map="&#x0182;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="endDate" map="&#x0183;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="issuer" map="&#x0184;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="version" map="&#x0185;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="extensions" map="&#x0186;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="subject" map="&#x0187;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="seq" map="&#x0188;"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="org.bouncycastle.asn1.ASN1Integer getSerialNumber()" map="&#x00aa;"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getSubjectPublicKeyInfo()" map="&#x00b5;"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="org.bouncycastle.asn1.x500.X500Name getIssuer()" map="&#x00ba;"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="org.bouncycastle.asn1.x509.TBSCertificateStructure getInstance(java.lang.Object)" map="V"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificateStructure" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.x509.DigestInfo" map="L"/>
  <field class="org.bouncycastle.asn1.x509.DigestInfo" name="algId" map="&#x01ca;"/>
  <field class="org.bouncycastle.asn1.x509.DigestInfo" name="digest" map="&#x01cb;"/>
  <method class="org.bouncycastle.asn1.x509.DigestInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.x509.Extension" map="M"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="authorityKeyIdentifier" map="&#x01cc;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="invalidityDate" map="&#x01cd;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="freshestCRL" map="&#x01ce;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="certificatePolicies" map="&#x01cf;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="noRevAvail" map="&#x01d0;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="expiredCertsOnCRL" map="&#x01d1;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="certificateIssuer" map="&#x01d2;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="cRLNumber" map="&#x01d3;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="nameConstraints" map="&#x01d4;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="extnId" map="&#x01d5;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="inhibitAnyPolicy" map="&#x01d6;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="policyConstraints" map="&#x01d7;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="subjectAlternativeName" map="&#x01d8;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="issuerAlternativeName" map="&#x01d9;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="auditIdentity" map="&#x01da;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="qCStatements" map="&#x01db;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="basicConstraints" map="&#x01dc;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="targetInformation" map="&#x01dd;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="issuingDistributionPoint" map="&#x01de;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="subjectKeyIdentifier" map="&#x01df;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="reasonCode" map="&#x01e0;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="authorityInfoAccess" map="&#x01e1;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="extendedKeyUsage" map="&#x01e2;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="critical" map="&#x01e3;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="subjectInfoAccess" map="&#x01e4;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="value" map="&#x01e5;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="subjectDirectoryAttributes" map="&#x01e6;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="logoType" map="&#x01e7;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="instructionCode" map="&#x01e8;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="privateKeyUsagePeriod" map="&#x01e9;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="keyUsage" map="&#x01ea;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="cRLDistributionPoints" map="&#x01eb;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="policyMappings" map="&#x01ec;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="deltaCRLIndicator" map="&#x01ed;"/>
  <field class="org.bouncycastle.asn1.x509.Extension" name="biometricInfo" map="&#x01ee;"/>
  <method class="org.bouncycastle.asn1.x509.Extension" name="org.bouncycastle.asn1.ASN1OctetString getExtnValue()" map="&#x00d5;"/>
  <method class="org.bouncycastle.asn1.x509.Extension" name="org.bouncycastle.asn1.ASN1Primitive convertValueToObject(org.bouncycastle.asn1.x509.Extension)" map="A"/>
  <method class="org.bouncycastle.asn1.x509.Extension" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.x509.Extension" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.asn1.x509.Extension" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getExtnId()" map="&#x00d6;"/>
  <method class="org.bouncycastle.asn1.x509.Extension" name="boolean isCritical()" map="&#x00d8;"/>
  <method class="org.bouncycastle.asn1.x509.Extension" name="org.bouncycastle.asn1.x509.Extension getInstance(java.lang.Object)" map="e"/>
  <method class="org.bouncycastle.asn1.x509.Extension" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.x509.Extension" name="org.bouncycastle.asn1.ASN1Encodable getParsedValue()" map="&#x00d9;"/>
  <class name="org.bouncycastle.asn1.x509.ExtensionsGenerator" map="N"/>
  <field class="org.bouncycastle.asn1.x509.ExtensionsGenerator" name="extOrdering" map="A"/>
  <field class="org.bouncycastle.asn1.x509.ExtensionsGenerator" name="extensions" map="B"/>
  <method class="org.bouncycastle.asn1.x509.ExtensionsGenerator" name="org.bouncycastle.asn1.x509.Extensions generate()" map="A"/>
  <method class="org.bouncycastle.asn1.x509.ExtensionsGenerator" name="boolean isEmpty()" map="B"/>
  <class name="org.bouncycastle.asn1.x509.Time" map="O"/>
  <field class="org.bouncycastle.asn1.x509.Time" name="time" map="f"/>
  <method class="org.bouncycastle.asn1.x509.Time" name="org.bouncycastle.asn1.x509.Time getInstance(java.lang.Object)" map="D"/>
  <method class="org.bouncycastle.asn1.x509.Time" name="java.util.Date getDate()" map="T"/>
  <method class="org.bouncycastle.asn1.x509.Time" name="java.lang.String getTime()" map="U"/>
  <method class="org.bouncycastle.asn1.x509.Time" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.x509.Time" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.x509.X509Name" map="P"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="SymbolLookUp" map="&#x01ef;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="ST" map="&#x01f0;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="GIVENNAME" map="&#x01f1;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="SN" map="&#x01f2;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="DC" map="&#x01f3;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="POSTAL_CODE" map="&#x01f4;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="T" map="&#x01f5;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="hashCodeValue" map="&#x01fa;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="STREET" map="&#x01fb;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="TELEPHONE_NUMBER" map="&#x01fc;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="O" map="&#x01fd;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="L" map="&#x01fe;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="DMD_NAME" map="&#x01ff;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="SURNAME" map="&#x0200;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="E" map="&#x0201;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="C" map="&#x0202;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="CN" map="&#x0203;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="PLACE_OF_BIRTH" map="&#x0204;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="OU" map="&#x0205;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="INITIALS" map="&#x0206;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="GENERATION" map="&#x0207;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="COUNTRY_OF_RESIDENCE" map="&#x0208;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="DefaultLookUp" map="&#x0209;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="RFC1779Symbols" map="&#x020a;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="GENDER" map="&#x020b;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="RFC2253Symbols" map="&#x020c;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="TRUE" map="&#x020d;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="seq" map="&#x020e;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="PSEUDONYM" map="&#x020f;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="ordering" map="&#x0210;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="converter" map="&#x0211;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="isHashCodeCalculated" map="&#x0212;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="UID" map="&#x0213;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="OIDLookUp" map="&#x0214;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="NAME" map="&#x0215;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="NAME_AT_BIRTH" map="&#x0216;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="UnstructuredAddress" map="&#x0217;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="BUSINESS_CATEGORY" map="&#x0250;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="DefaultReverse" map="&#x0251;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="DATE_OF_BIRTH" map="&#x0252;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="COUNTRY_OF_CITIZENSHIP" map="&#x0253;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="POSTAL_ADDRESS" map="&#x0254;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="SERIALNUMBER" map="&#x0255;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="DefaultSymbols" map="&#x0256;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="EmailAddress" map="&#x0257;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="DN_QUALIFIER" map="&#x0258;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="added" map="&#x0259;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="FALSE" map="&#x025a;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="UNIQUE_IDENTIFIER" map="&#x025b;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="values" map="&#x025c;"/>
  <field class="org.bouncycastle.asn1.x509.X509Name" name="UnstructuredName" map="&#x025d;"/>
  <method class="org.bouncycastle.asn1.x509.X509Name" name="java.lang.String stripInternalSpaces(java.lang.String)" map="B"/>
  <method class="org.bouncycastle.asn1.x509.X509Name" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.x509.X509Name" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.asn1.x509.X509Name" name="boolean equivalentStrings(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.bouncycastle.asn1.x509.X509Name" name="java.lang.String bytesToString(byte[])" map="B"/>
  <method class="org.bouncycastle.asn1.x509.X509Name" name="java.lang.String toString(boolean, java.util.Hashtable)" map="A"/>
  <method class="org.bouncycastle.asn1.x509.X509Name" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.x509.X509Name" name="java.lang.String canonicalize(java.lang.String)" map="C"/>
  <method class="org.bouncycastle.asn1.x509.X509Name" name="void appendValue(java.lang.StringBuffer, java.util.Hashtable, org.bouncycastle.asn1.ASN1ObjectIdentifier, java.lang.String)" map="A"/>
  <method class="org.bouncycastle.asn1.x509.X509Name" name="org.bouncycastle.asn1.x509.X509Name getInstance(java.lang.Object)" map="f"/>
  <method class="org.bouncycastle.asn1.x509.X509Name" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.x509.X509Name" name="org.bouncycastle.asn1.ASN1Primitive decodeObject(java.lang.String)" map="D"/>
  <class name="org.bouncycastle.asn1.x509.SubjectKeyIdentifier" map="Q"/>
  <field class="org.bouncycastle.asn1.x509.SubjectKeyIdentifier" name="keyidentifier" map="&#x025e;"/>
  <method class="org.bouncycastle.asn1.x509.SubjectKeyIdentifier" name="byte[] getKeyIdentifier()" map="&#x00da;"/>
  <method class="org.bouncycastle.asn1.x509.SubjectKeyIdentifier" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.x509.SubjectKeyIdentifier" name="org.bouncycastle.asn1.x509.SubjectKeyIdentifier getInstance(java.lang.Object)" map="g"/>
  <method class="org.bouncycastle.asn1.x509.SubjectKeyIdentifier" name="org.bouncycastle.asn1.x509.SubjectKeyIdentifier getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="J"/>
  <class name="org.bouncycastle.asn1.x509.DistributionPoint" map="R"/>
  <field class="org.bouncycastle.asn1.x509.DistributionPoint" name="distributionPoint" map="&#x025f;"/>
  <field class="org.bouncycastle.asn1.x509.DistributionPoint" name="cRLIssuer" map="&#x0260;"/>
  <field class="org.bouncycastle.asn1.x509.DistributionPoint" name="reasons" map="&#x0261;"/>
  <method class="org.bouncycastle.asn1.x509.DistributionPoint" name="org.bouncycastle.asn1.x509.DistributionPoint getInstance(java.lang.Object)" map="h"/>
  <method class="org.bouncycastle.asn1.x509.DistributionPoint" name="org.bouncycastle.asn1.x509.DistributionPointName getDistributionPoint()" map="&#x00db;"/>
  <method class="org.bouncycastle.asn1.x509.DistributionPoint" name="void appendObject(java.lang.StringBuffer, java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="org.bouncycastle.asn1.x509.DistributionPoint" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.x509.DistributionPoint" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.x509.CRLDistPoint" map="S"/>
  <field class="org.bouncycastle.asn1.x509.CRLDistPoint" name="seq" map="&#x0262;"/>
  <method class="org.bouncycastle.asn1.x509.CRLDistPoint" name="org.bouncycastle.asn1.x509.CRLDistPoint getInstance(java.lang.Object)" map="i"/>
  <method class="org.bouncycastle.asn1.x509.CRLDistPoint" name="org.bouncycastle.asn1.x509.DistributionPoint[] getDistributionPoints()" map="&#x00dc;"/>
  <method class="org.bouncycastle.asn1.x509.CRLDistPoint" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.x509.CRLDistPoint" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo" map="T"/>
  <field class="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo" name="algId" map="&#x0263;"/>
  <field class="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo" name="keyData" map="&#x0264;"/>
  <method class="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo" name="org.bouncycastle.asn1.DERBitString getPublicKeyData()" map="&#x00dd;"/>
  <method class="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo" name="org.bouncycastle.asn1.ASN1Primitive parsePublicKey()" map="&#x00de;"/>
  <method class="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo" name="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getInstance(java.lang.Object)" map="j"/>
  <method class="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo" name="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="K"/>
  <method class="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithm()" map="&#x00df;"/>
  <class name="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" map="U"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="ripemd160" map="&#x0168;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="countryName" map="&#x0169;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="id_ad_caIssuers" map="&#x016a;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="id_ad" map="&#x016b;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="id_ad_ocsp" map="&#x016c;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="id_pe" map="&#x016d;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="id_ea_rsa" map="&#x016e;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="organizationalUnitName" map="&#x016f;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="id_at_organizationIdentifier" map="&#x0170;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="stateOrProvinceName" map="&#x0171;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="commonName" map="&#x0172;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="id_at_name" map="&#x0173;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="id_pkix" map="&#x0174;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="id_ce" map="&#x0175;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="localityName" map="&#x0176;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="crlAccessMethod" map="&#x0177;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="id_SHA1" map="&#x0178;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="id_at_telephoneNumber" map="&#x0179;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="ocspAccessMethod" map="&#x017a;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="ripemd160WithRSAEncryption" map="&#x017b;"/>
  <field class="org.bouncycastle.asn1.x509.X509ObjectIdentifiers" name="organization" map="&#x017c;"/>
  <class name="org.bouncycastle.asn1.x509.TBSCertificate" map="V"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificate" name="subjectPublicKeyInfo" map="&#x0265;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificate" name="issuerUniqueId" map="&#x0266;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificate" name="startDate" map="&#x0267;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificate" name="signature" map="&#x0268;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificate" name="serialNumber" map="&#x0269;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificate" name="subjectUniqueId" map="&#x026a;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificate" name="endDate" map="&#x026b;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificate" name="issuer" map="&#x026c;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificate" name="version" map="&#x026d;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificate" name="extensions" map="&#x026e;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificate" name="subject" map="&#x026f;"/>
  <field class="org.bouncycastle.asn1.x509.TBSCertificate" name="seq" map="&#x0270;"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificate" name="org.bouncycastle.asn1.x500.X500Name getIssuer()" map="&#x00e0;"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificate" name="org.bouncycastle.asn1.x509.Time getStartDate()" map="&#x00e1;"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificate" name="org.bouncycastle.asn1.x500.X500Name getSubject()" map="&#x00e2;"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificate" name="int getVersionNumber()" map="&#x00e3;"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificate" name="org.bouncycastle.asn1.DERBitString getSubjectUniqueId()" map="&#x00e4;"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificate" name="org.bouncycastle.asn1.x509.Time getEndDate()" map="&#x00e5;"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificate" name="org.bouncycastle.asn1.DERBitString getIssuerUniqueId()" map="&#x00e6;"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificate" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificate" name="org.bouncycastle.asn1.ASN1Integer getSerialNumber()" map="&#x00e7;"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificate" name="org.bouncycastle.asn1.x509.Extensions getExtensions()" map="&#x00e8;"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificate" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getSignature()" map="&#x00e9;"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificate" name="org.bouncycastle.asn1.x509.TBSCertificate getInstance(java.lang.Object)" map="k"/>
  <method class="org.bouncycastle.asn1.x509.TBSCertificate" name="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getSubjectPublicKeyInfo()" map="&#x00ea;"/>
  <class name="org.bouncycastle.asn1.x509.DistributionPointName" map="W"/>
  <field class="org.bouncycastle.asn1.x509.DistributionPointName" name="name" map="g"/>
  <field class="org.bouncycastle.asn1.x509.DistributionPointName" name="type" map="h"/>
  <method class="org.bouncycastle.asn1.x509.DistributionPointName" name="int getType()" map="V"/>
  <method class="org.bouncycastle.asn1.x509.DistributionPointName" name="org.bouncycastle.asn1.x509.DistributionPointName getInstance(java.lang.Object)" map="E"/>
  <method class="org.bouncycastle.asn1.x509.DistributionPointName" name="void appendObject(java.lang.StringBuffer, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.bouncycastle.asn1.x509.DistributionPointName" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.x509.DistributionPointName" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.x509.DistributionPointName" name="org.bouncycastle.asn1.ASN1Encodable getName()" map="W"/>
  <method class="org.bouncycastle.asn1.x509.DistributionPointName" name="org.bouncycastle.asn1.x509.DistributionPointName getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="C"/>
  <class name="org.bouncycastle.asn1.x509.KeyUsage" map="X"/>
  <field class="org.bouncycastle.asn1.x509.KeyUsage" name="bitString" map="&#x0271;"/>
  <method class="org.bouncycastle.asn1.x509.KeyUsage" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.x509.KeyUsage" name="org.bouncycastle.asn1.x509.KeyUsage getInstance(java.lang.Object)" map="l"/>
  <method class="org.bouncycastle.asn1.x509.KeyUsage" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.x509.BasicConstraints" map="Y"/>
  <field class="org.bouncycastle.asn1.x509.BasicConstraints" name="cA" map="&#x0272;"/>
  <field class="org.bouncycastle.asn1.x509.BasicConstraints" name="pathLenConstraint" map="&#x0273;"/>
  <method class="org.bouncycastle.asn1.x509.BasicConstraints" name="boolean isCA()" map="&#x00eb;"/>
  <method class="org.bouncycastle.asn1.x509.BasicConstraints" name="java.math.BigInteger getPathLenConstraint()" map="&#x00ec;"/>
  <method class="org.bouncycastle.asn1.x509.BasicConstraints" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.x509.BasicConstraints" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.x509.BasicConstraints" name="org.bouncycastle.asn1.x509.BasicConstraints getInstance(java.lang.Object)" map="m"/>
  <class name="org.bouncycastle.asn1.x509.GeneralName" map="Z"/>
  <field class="org.bouncycastle.asn1.x509.GeneralName" name="tag" map="i"/>
  <field class="org.bouncycastle.asn1.x509.GeneralName" name="obj" map="j"/>
  <method class="org.bouncycastle.asn1.x509.GeneralName" name="org.bouncycastle.asn1.x509.GeneralName getInstance(java.lang.Object)" map="F"/>
  <method class="org.bouncycastle.asn1.x509.GeneralName" name="org.bouncycastle.asn1.x509.GeneralName getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="D"/>
  <method class="org.bouncycastle.asn1.x509.GeneralName" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.x509.GeneralName" name="int getTagNo()" map="X"/>
  <method class="org.bouncycastle.asn1.x509.GeneralName" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.x509.GeneralName" name="org.bouncycastle.asn1.ASN1Encodable getName()" map="Y"/>
  <package name="org.bouncycastle.asn1.misc" map="I"/>
  <class name="org.bouncycastle.asn1.misc.NetscapeRevocationURL" map="A"/>
  <method class="org.bouncycastle.asn1.misc.NetscapeRevocationURL" name="java.lang.String toString()" map="toString"/>
  <class name="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" map="B"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="id_blake2s160" map="A"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="netscapeBaseURL" map="B"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="as_sys_sec_alg_ideaCBC" map="C"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="netscape" map="D"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="id_blake2b160" map="E"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="id_scrypt" map="F"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="netscapeCertType" map="G"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="cryptlib_algorithm_blowfish_CBC" map="H"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="cryptlib_algorithm" map="I"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="id_blake2b384" map="J"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="netscapeRevocationURL" map="K"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="verisignIssStrongCrypto" map="L"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="id_blake2s256" map="M"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="id_blake2s224" map="N"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="id_blake2b512" map="O"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="id_blake2b256" map="P"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="entrustVersionExtension" map="Q"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="id_blake2s128" map="R"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="netscapeCertComment" map="S"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="verisignDnbDunsNumber" map="T"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="cast5CBC" map="U"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="cryptlib_algorithm_blowfish_OFB" map="V"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="verisignCzagExtension" map="W"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="novellSecurityAttribs" map="X"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="cryptlib_algorithm_blowfish_ECB" map="Y"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="verisignPrivate_6_9" map="Z"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="cryptlib" map="_"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="netscapeCApolicyURL" map="a"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="verisignOnSiteJurisdictionHash" map="b"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="netscapeSSLServerName" map="c"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="novell" map="d"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="entrust" map="e"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="cryptlib_algorithm_blowfish_CFB" map="f"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="verisign" map="g"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="netscapeCARevocationURL" map="h"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="blake2" map="i"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="verisignBitString_6_13" map="j"/>
  <field class="org.bouncycastle.asn1.misc.MiscObjectIdentifiers" name="netscapeRenewalURL" map="k"/>
  <class name="org.bouncycastle.asn1.misc.NetscapeCertType" map="C"/>
  <method class="org.bouncycastle.asn1.misc.NetscapeCertType" name="java.lang.String toString()" map="toString"/>
  <class name="org.bouncycastle.asn1.misc.VerisignCzagExtension" map="D"/>
  <method class="org.bouncycastle.asn1.misc.VerisignCzagExtension" name="java.lang.String toString()" map="toString"/>
  <package name="org.bouncycastle.asn1.cms" map="J"/>
  <class name="org.bouncycastle.asn1.cms.SignerInfo" map="A"/>
  <field class="org.bouncycastle.asn1.cms.SignerInfo" name="encryptedDigest" map="&#x0274;"/>
  <field class="org.bouncycastle.asn1.cms.SignerInfo" name="sid" map="&#x0275;"/>
  <field class="org.bouncycastle.asn1.cms.SignerInfo" name="version" map="&#x0276;"/>
  <field class="org.bouncycastle.asn1.cms.SignerInfo" name="unauthenticatedAttributes" map="&#x0277;"/>
  <field class="org.bouncycastle.asn1.cms.SignerInfo" name="digEncryptionAlgorithm" map="&#x0278;"/>
  <field class="org.bouncycastle.asn1.cms.SignerInfo" name="authenticatedAttributes" map="&#x0279;"/>
  <field class="org.bouncycastle.asn1.cms.SignerInfo" name="digAlgorithm" map="&#x027a;"/>
  <method class="org.bouncycastle.asn1.cms.SignerInfo" name="org.bouncycastle.asn1.ASN1OctetString getEncryptedDigest()" map="&#x00ed;"/>
  <method class="org.bouncycastle.asn1.cms.SignerInfo" name="org.bouncycastle.asn1.ASN1Set getAuthenticatedAttributes()" map="&#x00ee;"/>
  <method class="org.bouncycastle.asn1.cms.SignerInfo" name="org.bouncycastle.asn1.cms.SignerIdentifier getSID()" map="&#x00ef;"/>
  <method class="org.bouncycastle.asn1.cms.SignerInfo" name="org.bouncycastle.asn1.ASN1Set getUnauthenticatedAttributes()" map="&#x00f0;"/>
  <method class="org.bouncycastle.asn1.cms.SignerInfo" name="org.bouncycastle.asn1.cms.SignerInfo getInstance(java.lang.Object)" map="n"/>
  <method class="org.bouncycastle.asn1.cms.SignerInfo" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigestAlgorithm()" map="&#x00f1;"/>
  <method class="org.bouncycastle.asn1.cms.SignerInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cms.SignerInfo" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigestEncryptionAlgorithm()" map="&#x00f2;"/>
  <class name="org.bouncycastle.asn1.cms.CMSAlgorithmProtection" map="B"/>
  <field class="org.bouncycastle.asn1.cms.CMSAlgorithmProtection" name="digestAlgorithm" map="&#x027b;"/>
  <field class="org.bouncycastle.asn1.cms.CMSAlgorithmProtection" name="signatureAlgorithm" map="&#x027c;"/>
  <field class="org.bouncycastle.asn1.cms.CMSAlgorithmProtection" name="macAlgorithm" map="&#x027d;"/>
  <method class="org.bouncycastle.asn1.cms.CMSAlgorithmProtection" name="org.bouncycastle.asn1.cms.CMSAlgorithmProtection getInstance(java.lang.Object)" map="o"/>
  <method class="org.bouncycastle.asn1.cms.CMSAlgorithmProtection" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigestAlgorithm()" map="&#x00f3;"/>
  <method class="org.bouncycastle.asn1.cms.CMSAlgorithmProtection" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getSignatureAlgorithm()" map="&#x00f4;"/>
  <method class="org.bouncycastle.asn1.cms.CMSAlgorithmProtection" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.cms.CMSObjectIdentifiers" map="C"/>
  <field class="org.bouncycastle.asn1.cms.CMSObjectIdentifiers" name="encryptedData" map="&#x0283;"/>
  <field class="org.bouncycastle.asn1.cms.CMSObjectIdentifiers" name="compressedData" map="&#x0284;"/>
  <field class="org.bouncycastle.asn1.cms.CMSObjectIdentifiers" name="id_ri" map="&#x0285;"/>
  <field class="org.bouncycastle.asn1.cms.CMSObjectIdentifiers" name="envelopedData" map="&#x0286;"/>
  <field class="org.bouncycastle.asn1.cms.CMSObjectIdentifiers" name="authEnvelopedData" map="&#x0287;"/>
  <field class="org.bouncycastle.asn1.cms.CMSObjectIdentifiers" name="data" map="&#x0288;"/>
  <field class="org.bouncycastle.asn1.cms.CMSObjectIdentifiers" name="digestedData" map="&#x0289;"/>
  <field class="org.bouncycastle.asn1.cms.CMSObjectIdentifiers" name="id_ri_ocsp_response" map="&#x028a;"/>
  <field class="org.bouncycastle.asn1.cms.CMSObjectIdentifiers" name="authenticatedData" map="&#x028b;"/>
  <field class="org.bouncycastle.asn1.cms.CMSObjectIdentifiers" name="timestampedData" map="&#x028c;"/>
  <field class="org.bouncycastle.asn1.cms.CMSObjectIdentifiers" name="signedAndEnvelopedData" map="&#x028d;"/>
  <field class="org.bouncycastle.asn1.cms.CMSObjectIdentifiers" name="id_ri_scvp" map="&#x028e;"/>
  <field class="org.bouncycastle.asn1.cms.CMSObjectIdentifiers" name="signedData" map="&#x028f;"/>
  <class name="org.bouncycastle.asn1.cms.KEKIdentifier" map="D"/>
  <field class="org.bouncycastle.asn1.cms.KEKIdentifier" name="other" map="&#x027e;"/>
  <field class="org.bouncycastle.asn1.cms.KEKIdentifier" name="date" map="&#x027f;"/>
  <field class="org.bouncycastle.asn1.cms.KEKIdentifier" name="keyIdentifier" map="&#x0280;"/>
  <method class="org.bouncycastle.asn1.cms.KEKIdentifier" name="org.bouncycastle.asn1.ASN1OctetString getKeyIdentifier()" map="&#x00f5;"/>
  <method class="org.bouncycastle.asn1.cms.KEKIdentifier" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cms.KEKIdentifier" name="org.bouncycastle.asn1.cms.KEKIdentifier getInstance(java.lang.Object)" map="p"/>
  <class name="org.bouncycastle.asn1.cms.OtherKeyAttribute" map="E"/>
  <field class="org.bouncycastle.asn1.cms.OtherKeyAttribute" name="keyAttr" map="&#x0281;"/>
  <field class="org.bouncycastle.asn1.cms.OtherKeyAttribute" name="keyAttrId" map="&#x0282;"/>
  <method class="org.bouncycastle.asn1.cms.OtherKeyAttribute" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cms.OtherKeyAttribute" name="org.bouncycastle.asn1.cms.OtherKeyAttribute getInstance(java.lang.Object)" map="q"/>
  <class name="org.bouncycastle.asn1.cms.ContentInfo" map="F"/>
  <field class="org.bouncycastle.asn1.cms.ContentInfo" name="content" map="&#x0290;"/>
  <field class="org.bouncycastle.asn1.cms.ContentInfo" name="contentType" map="&#x0291;"/>
  <method class="org.bouncycastle.asn1.cms.ContentInfo" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getContentType()" map="&#x00f6;"/>
  <method class="org.bouncycastle.asn1.cms.ContentInfo" name="org.bouncycastle.asn1.cms.ContentInfo getInstance(java.lang.Object)" map="r"/>
  <method class="org.bouncycastle.asn1.cms.ContentInfo" name="org.bouncycastle.asn1.ASN1Encodable getContent()" map="&#x00f8;"/>
  <method class="org.bouncycastle.asn1.cms.ContentInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.cms.OriginatorInfo" map="G"/>
  <field class="org.bouncycastle.asn1.cms.OriginatorInfo" name="certs" map="&#x0292;"/>
  <field class="org.bouncycastle.asn1.cms.OriginatorInfo" name="crls" map="&#x0293;"/>
  <method class="org.bouncycastle.asn1.cms.OriginatorInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cms.OriginatorInfo" name="org.bouncycastle.asn1.cms.OriginatorInfo getInstance(java.lang.Object)" map="s"/>
  <method class="org.bouncycastle.asn1.cms.OriginatorInfo" name="org.bouncycastle.asn1.cms.OriginatorInfo getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="L"/>
  <class name="org.bouncycastle.asn1.cms.Attribute" map="H"/>
  <field class="org.bouncycastle.asn1.cms.Attribute" name="attrValues" map="&#x0294;"/>
  <field class="org.bouncycastle.asn1.cms.Attribute" name="attrType" map="&#x0295;"/>
  <method class="org.bouncycastle.asn1.cms.Attribute" name="org.bouncycastle.asn1.ASN1Encodable[] getAttributeValues()" map="&#x00f9;"/>
  <method class="org.bouncycastle.asn1.cms.Attribute" name="org.bouncycastle.asn1.cms.Attribute getInstance(java.lang.Object)" map="t"/>
  <method class="org.bouncycastle.asn1.cms.Attribute" name="org.bouncycastle.asn1.ASN1Set getAttrValues()" map="&#x00fa;"/>
  <method class="org.bouncycastle.asn1.cms.Attribute" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getAttrType()" map="&#x00fb;"/>
  <method class="org.bouncycastle.asn1.cms.Attribute" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.cms.CMSAttributes" map="I"/>
  <field class="org.bouncycastle.asn1.cms.CMSAttributes" name="signingTime" map="A"/>
  <field class="org.bouncycastle.asn1.cms.CMSAttributes" name="contentHint" map="B"/>
  <field class="org.bouncycastle.asn1.cms.CMSAttributes" name="counterSignature" map="C"/>
  <field class="org.bouncycastle.asn1.cms.CMSAttributes" name="cmsAlgorithmProtect" map="D"/>
  <field class="org.bouncycastle.asn1.cms.CMSAttributes" name="messageDigest" map="E"/>
  <field class="org.bouncycastle.asn1.cms.CMSAttributes" name="contentType" map="F"/>
  <class name="org.bouncycastle.asn1.cms.KeyTransRecipientInfo" map="J"/>
  <field class="org.bouncycastle.asn1.cms.KeyTransRecipientInfo" name="version" map="&#x0296;"/>
  <field class="org.bouncycastle.asn1.cms.KeyTransRecipientInfo" name="rid" map="&#x0297;"/>
  <field class="org.bouncycastle.asn1.cms.KeyTransRecipientInfo" name="encryptedKey" map="&#x0298;"/>
  <field class="org.bouncycastle.asn1.cms.KeyTransRecipientInfo" name="keyEncryptionAlgorithm" map="&#x0299;"/>
  <method class="org.bouncycastle.asn1.cms.KeyTransRecipientInfo" name="org.bouncycastle.asn1.cms.KeyTransRecipientInfo getInstance(java.lang.Object)" map="u"/>
  <method class="org.bouncycastle.asn1.cms.KeyTransRecipientInfo" name="org.bouncycastle.asn1.ASN1Integer getVersion()" map="&#x00fc;"/>
  <method class="org.bouncycastle.asn1.cms.KeyTransRecipientInfo" name="org.bouncycastle.asn1.cms.RecipientIdentifier getRecipientIdentifier()" map="&#x00fd;"/>
  <method class="org.bouncycastle.asn1.cms.KeyTransRecipientInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cms.KeyTransRecipientInfo" name="org.bouncycastle.asn1.ASN1OctetString getEncryptedKey()" map="&#x00fe;"/>
  <method class="org.bouncycastle.asn1.cms.KeyTransRecipientInfo" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyEncryptionAlgorithm()" map="&#x00ff;"/>
  <class name="org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey" map="K"/>
  <field class="org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey" name="id" map="k"/>
  <method class="org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey" name="org.bouncycastle.asn1.cms.IssuerAndSerialNumber getIssuerAndSerialNumber()" map="Z"/>
  <method class="org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey" name="org.bouncycastle.asn1.x509.SubjectKeyIdentifier getSubjectKeyIdentifier()" map="_"/>
  <method class="org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey" name="org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey getInstance(java.lang.Object)" map="G"/>
  <method class="org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey" name="org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="E"/>
  <method class="org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey" name="org.bouncycastle.asn1.cms.OriginatorPublicKey getOriginatorKey()" map="a"/>
  <class name="org.bouncycastle.asn1.cms.RecipientIdentifier" map="L"/>
  <field class="org.bouncycastle.asn1.cms.RecipientIdentifier" name="id" map="l"/>
  <method class="org.bouncycastle.asn1.cms.RecipientIdentifier" name="org.bouncycastle.asn1.cms.RecipientIdentifier getInstance(java.lang.Object)" map="H"/>
  <method class="org.bouncycastle.asn1.cms.RecipientIdentifier" name="org.bouncycastle.asn1.ASN1Encodable getId()" map="b"/>
  <method class="org.bouncycastle.asn1.cms.RecipientIdentifier" name="boolean isTagged()" map="c"/>
  <method class="org.bouncycastle.asn1.cms.RecipientIdentifier" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.cms.SignerIdentifier" map="M"/>
  <field class="org.bouncycastle.asn1.cms.SignerIdentifier" name="id" map="m"/>
  <method class="org.bouncycastle.asn1.cms.SignerIdentifier" name="org.bouncycastle.asn1.ASN1Encodable getId()" map="d"/>
  <method class="org.bouncycastle.asn1.cms.SignerIdentifier" name="boolean isTagged()" map="e"/>
  <method class="org.bouncycastle.asn1.cms.SignerIdentifier" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cms.SignerIdentifier" name="org.bouncycastle.asn1.cms.SignerIdentifier getInstance(java.lang.Object)" map="I"/>
  <class name="org.bouncycastle.asn1.cms.IssuerAndSerialNumber" map="N"/>
  <field class="org.bouncycastle.asn1.cms.IssuerAndSerialNumber" name="name" map="&#x029a;"/>
  <field class="org.bouncycastle.asn1.cms.IssuerAndSerialNumber" name="serialNumber" map="&#x029b;"/>
  <method class="org.bouncycastle.asn1.cms.IssuerAndSerialNumber" name="org.bouncycastle.asn1.ASN1Integer getSerialNumber()" map="&#x0100;"/>
  <method class="org.bouncycastle.asn1.cms.IssuerAndSerialNumber" name="org.bouncycastle.asn1.cms.IssuerAndSerialNumber getInstance(java.lang.Object)" map="v"/>
  <method class="org.bouncycastle.asn1.cms.IssuerAndSerialNumber" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cms.IssuerAndSerialNumber" name="org.bouncycastle.asn1.x500.X500Name getName()" map="&#x0101;"/>
  <class name="org.bouncycastle.asn1.cms.RecipientKeyIdentifier" map="O"/>
  <field class="org.bouncycastle.asn1.cms.RecipientKeyIdentifier" name="other" map="&#x029c;"/>
  <field class="org.bouncycastle.asn1.cms.RecipientKeyIdentifier" name="date" map="&#x029d;"/>
  <field class="org.bouncycastle.asn1.cms.RecipientKeyIdentifier" name="subjectKeyIdentifier" map="&#x029e;"/>
  <method class="org.bouncycastle.asn1.cms.RecipientKeyIdentifier" name="org.bouncycastle.asn1.ASN1OctetString getSubjectKeyIdentifier()" map="&#x0102;"/>
  <method class="org.bouncycastle.asn1.cms.RecipientKeyIdentifier" name="org.bouncycastle.asn1.cms.RecipientKeyIdentifier getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="M"/>
  <method class="org.bouncycastle.asn1.cms.RecipientKeyIdentifier" name="org.bouncycastle.asn1.cms.RecipientKeyIdentifier getInstance(java.lang.Object)" map="w"/>
  <method class="org.bouncycastle.asn1.cms.RecipientKeyIdentifier" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.cms.RecipientEncryptedKey" map="P"/>
  <field class="org.bouncycastle.asn1.cms.RecipientEncryptedKey" name="identifier" map="&#x029f;"/>
  <field class="org.bouncycastle.asn1.cms.RecipientEncryptedKey" name="encryptedKey" map="&#x02a0;"/>
  <method class="org.bouncycastle.asn1.cms.RecipientEncryptedKey" name="org.bouncycastle.asn1.cms.RecipientEncryptedKey getInstance(java.lang.Object)" map="x"/>
  <method class="org.bouncycastle.asn1.cms.RecipientEncryptedKey" name="org.bouncycastle.asn1.cms.KeyAgreeRecipientIdentifier getIdentifier()" map="&#x0103;"/>
  <method class="org.bouncycastle.asn1.cms.RecipientEncryptedKey" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cms.RecipientEncryptedKey" name="org.bouncycastle.asn1.ASN1OctetString getEncryptedKey()" map="&#x0104;"/>
  <class name="org.bouncycastle.asn1.cms.Time" map="Q"/>
  <field class="org.bouncycastle.asn1.cms.Time" name="time" map="n"/>
  <method class="org.bouncycastle.asn1.cms.Time" name="java.util.Date getDate()" map="f"/>
  <method class="org.bouncycastle.asn1.cms.Time" name="org.bouncycastle.asn1.cms.Time getInstance(java.lang.Object)" map="J"/>
  <method class="org.bouncycastle.asn1.cms.Time" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.cms.SignedData" map="R"/>
  <field class="org.bouncycastle.asn1.cms.SignedData" name="digestAlgorithms" map="&#x02a1;"/>
  <field class="org.bouncycastle.asn1.cms.SignedData" name="certsBer" map="&#x02a2;"/>
  <field class="org.bouncycastle.asn1.cms.SignedData" name="certificates" map="&#x02a3;"/>
  <field class="org.bouncycastle.asn1.cms.SignedData" name="signerInfos" map="&#x02a4;"/>
  <field class="org.bouncycastle.asn1.cms.SignedData" name="VERSION_5" map="&#x02a5;"/>
  <field class="org.bouncycastle.asn1.cms.SignedData" name="crls" map="&#x02a6;"/>
  <field class="org.bouncycastle.asn1.cms.SignedData" name="VERSION_4" map="&#x02a7;"/>
  <field class="org.bouncycastle.asn1.cms.SignedData" name="contentInfo" map="&#x02a8;"/>
  <field class="org.bouncycastle.asn1.cms.SignedData" name="VERSION_3" map="&#x02b0;"/>
  <field class="org.bouncycastle.asn1.cms.SignedData" name="VERSION_1" map="&#x02b1;"/>
  <field class="org.bouncycastle.asn1.cms.SignedData" name="crlsBer" map="&#x02b2;"/>
  <field class="org.bouncycastle.asn1.cms.SignedData" name="version" map="&#x02b3;"/>
  <method class="org.bouncycastle.asn1.cms.SignedData" name="org.bouncycastle.asn1.cms.SignedData getInstance(java.lang.Object)" map="y"/>
  <method class="org.bouncycastle.asn1.cms.SignedData" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cms.SignedData" name="org.bouncycastle.asn1.cms.ContentInfo getEncapContentInfo()" map="&#x0105;"/>
  <method class="org.bouncycastle.asn1.cms.SignedData" name="org.bouncycastle.asn1.ASN1Set getSignerInfos()" map="&#x0106;"/>
  <class name="org.bouncycastle.asn1.cms.KeyAgreeRecipientIdentifier" map="S"/>
  <field class="org.bouncycastle.asn1.cms.KeyAgreeRecipientIdentifier" name="rKeyID" map="o"/>
  <field class="org.bouncycastle.asn1.cms.KeyAgreeRecipientIdentifier" name="issuerSerial" map="p"/>
  <method class="org.bouncycastle.asn1.cms.KeyAgreeRecipientIdentifier" name="org.bouncycastle.asn1.cms.IssuerAndSerialNumber getIssuerAndSerialNumber()" map="g"/>
  <method class="org.bouncycastle.asn1.cms.KeyAgreeRecipientIdentifier" name="org.bouncycastle.asn1.cms.KeyAgreeRecipientIdentifier getInstance(java.lang.Object)" map="K"/>
  <method class="org.bouncycastle.asn1.cms.KeyAgreeRecipientIdentifier" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cms.KeyAgreeRecipientIdentifier" name="org.bouncycastle.asn1.cms.RecipientKeyIdentifier getRKeyID()" map="h"/>
  <class name="org.bouncycastle.asn1.cms.EncryptedContentInfo" map="T"/>
  <field class="org.bouncycastle.asn1.cms.EncryptedContentInfo" name="contentEncryptionAlgorithm" map="&#x02b4;"/>
  <field class="org.bouncycastle.asn1.cms.EncryptedContentInfo" name="encryptedContent" map="&#x02b5;"/>
  <field class="org.bouncycastle.asn1.cms.EncryptedContentInfo" name="contentType" map="&#x02b6;"/>
  <method class="org.bouncycastle.asn1.cms.EncryptedContentInfo" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getContentEncryptionAlgorithm()" map="&#x0107;"/>
  <method class="org.bouncycastle.asn1.cms.EncryptedContentInfo" name="org.bouncycastle.asn1.ASN1OctetString getEncryptedContent()" map="&#x0108;"/>
  <method class="org.bouncycastle.asn1.cms.EncryptedContentInfo" name="org.bouncycastle.asn1.cms.EncryptedContentInfo getInstance(java.lang.Object)" map="z"/>
  <method class="org.bouncycastle.asn1.cms.EncryptedContentInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.cms.OriginatorPublicKey" map="U"/>
  <field class="org.bouncycastle.asn1.cms.OriginatorPublicKey" name="algorithm" map="&#x02b7;"/>
  <field class="org.bouncycastle.asn1.cms.OriginatorPublicKey" name="publicKey" map="&#x02b8;"/>
  <method class="org.bouncycastle.asn1.cms.OriginatorPublicKey" name="org.bouncycastle.asn1.cms.OriginatorPublicKey getInstance(java.lang.Object)" map="&#x00a2;"/>
  <method class="org.bouncycastle.asn1.cms.OriginatorPublicKey" name="org.bouncycastle.asn1.DERBitString getPublicKey()" map="&#x0109;"/>
  <method class="org.bouncycastle.asn1.cms.OriginatorPublicKey" name="org.bouncycastle.asn1.cms.OriginatorPublicKey getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="N"/>
  <method class="org.bouncycastle.asn1.cms.OriginatorPublicKey" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.cms.OtherRecipientInfo" map="V"/>
  <field class="org.bouncycastle.asn1.cms.OtherRecipientInfo" name="oriValue" map="&#x02bb;"/>
  <field class="org.bouncycastle.asn1.cms.OtherRecipientInfo" name="oriType" map="&#x02bc;"/>
  <method class="org.bouncycastle.asn1.cms.OtherRecipientInfo" name="org.bouncycastle.asn1.cms.OtherRecipientInfo getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="O"/>
  <method class="org.bouncycastle.asn1.cms.OtherRecipientInfo" name="org.bouncycastle.asn1.cms.OtherRecipientInfo getInstance(java.lang.Object)" map="&#x00a3;"/>
  <method class="org.bouncycastle.asn1.cms.OtherRecipientInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo" map="W"/>
  <field class="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo" name="version" map="&#x02bd;"/>
  <field class="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo" name="recipientEncryptedKeys" map="&#x02be;"/>
  <field class="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo" name="originator" map="&#x02bf;"/>
  <field class="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo" name="keyEncryptionAlgorithm" map="&#x02c0;"/>
  <field class="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo" name="ukm" map="&#x02c1;"/>
  <method class="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo" name="org.bouncycastle.asn1.ASN1Sequence getRecipientEncryptedKeys()" map="&#x010a;"/>
  <method class="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo" name="org.bouncycastle.asn1.ASN1Integer getVersion()" map="&#x010b;"/>
  <method class="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo" name="org.bouncycastle.asn1.ASN1OctetString getUserKeyingMaterial()" map="&#x010c;"/>
  <method class="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo" name="org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey getOriginator()" map="&#x010d;"/>
  <method class="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyEncryptionAlgorithm()" map="&#x010e;"/>
  <method class="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo" name="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo getInstance(java.lang.Object)" map="&#x00a4;"/>
  <method class="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo" name="org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="P"/>
  <class name="org.bouncycastle.asn1.cms.KEKRecipientInfo" map="X"/>
  <field class="org.bouncycastle.asn1.cms.KEKRecipientInfo" name="version" map="&#x02d0;"/>
  <field class="org.bouncycastle.asn1.cms.KEKRecipientInfo" name="encryptedKey" map="&#x02d1;"/>
  <field class="org.bouncycastle.asn1.cms.KEKRecipientInfo" name="kekid" map="&#x02e0;"/>
  <field class="org.bouncycastle.asn1.cms.KEKRecipientInfo" name="keyEncryptionAlgorithm" map="&#x02e1;"/>
  <method class="org.bouncycastle.asn1.cms.KEKRecipientInfo" name="org.bouncycastle.asn1.ASN1Integer getVersion()" map="&#x010f;"/>
  <method class="org.bouncycastle.asn1.cms.KEKRecipientInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cms.KEKRecipientInfo" name="org.bouncycastle.asn1.ASN1OctetString getEncryptedKey()" map="&#x0110;"/>
  <method class="org.bouncycastle.asn1.cms.KEKRecipientInfo" name="org.bouncycastle.asn1.cms.KEKIdentifier getKekid()" map="&#x0111;"/>
  <method class="org.bouncycastle.asn1.cms.KEKRecipientInfo" name="org.bouncycastle.asn1.cms.KEKRecipientInfo getInstance(java.lang.Object)" map="&#x00a5;"/>
  <method class="org.bouncycastle.asn1.cms.KEKRecipientInfo" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyEncryptionAlgorithm()" map="&#x0112;"/>
  <method class="org.bouncycastle.asn1.cms.KEKRecipientInfo" name="org.bouncycastle.asn1.cms.KEKRecipientInfo getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="Q"/>
  <class name="org.bouncycastle.asn1.cms.EnvelopedData" map="Y"/>
  <field class="org.bouncycastle.asn1.cms.EnvelopedData" name="unprotectedAttrs" map="&#x02e2;"/>
  <field class="org.bouncycastle.asn1.cms.EnvelopedData" name="version" map="&#x02e3;"/>
  <field class="org.bouncycastle.asn1.cms.EnvelopedData" name="recipientInfos" map="&#x02e4;"/>
  <field class="org.bouncycastle.asn1.cms.EnvelopedData" name="encryptedContentInfo" map="&#x037a;"/>
  <field class="org.bouncycastle.asn1.cms.EnvelopedData" name="originatorInfo" map="&#x0386;"/>
  <method class="org.bouncycastle.asn1.cms.EnvelopedData" name="org.bouncycastle.asn1.cms.OriginatorInfo getOriginatorInfo()" map="&#x0113;"/>
  <method class="org.bouncycastle.asn1.cms.EnvelopedData" name="org.bouncycastle.asn1.ASN1Set getUnprotectedAttrs()" map="&#x0114;"/>
  <method class="org.bouncycastle.asn1.cms.EnvelopedData" name="org.bouncycastle.asn1.cms.EncryptedContentInfo getEncryptedContentInfo()" map="&#x0115;"/>
  <method class="org.bouncycastle.asn1.cms.EnvelopedData" name="org.bouncycastle.asn1.cms.EnvelopedData getInstance(java.lang.Object)" map="&#x00aa;"/>
  <method class="org.bouncycastle.asn1.cms.EnvelopedData" name="int calculateVersion(org.bouncycastle.asn1.cms.OriginatorInfo, org.bouncycastle.asn1.ASN1Set, org.bouncycastle.asn1.ASN1Set)" map="A"/>
  <method class="org.bouncycastle.asn1.cms.EnvelopedData" name="org.bouncycastle.asn1.ASN1Set getRecipientInfos()" map="&#x0116;"/>
  <method class="org.bouncycastle.asn1.cms.EnvelopedData" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.cms.RecipientInfo" map="Z"/>
  <field class="org.bouncycastle.asn1.cms.RecipientInfo" name="info" map="q"/>
  <method class="org.bouncycastle.asn1.cms.RecipientInfo" name="org.bouncycastle.asn1.cms.KEKRecipientInfo getKEKInfo(org.bouncycastle.asn1.ASN1TaggedObject)" map="A"/>
  <method class="org.bouncycastle.asn1.cms.RecipientInfo" name="org.bouncycastle.asn1.cms.RecipientInfo getInstance(java.lang.Object)" map="L"/>
  <method class="org.bouncycastle.asn1.cms.RecipientInfo" name="org.bouncycastle.asn1.ASN1Integer getVersion()" map="i"/>
  <method class="org.bouncycastle.asn1.cms.RecipientInfo" name="org.bouncycastle.asn1.ASN1Encodable getInfo()" map="j"/>
  <method class="org.bouncycastle.asn1.cms.RecipientInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.cms.AttributeTable" map="_"/>
  <field class="org.bouncycastle.asn1.cms.AttributeTable" name="attributes" map="A"/>
  <method class="org.bouncycastle.asn1.cms.AttributeTable" name="void addAttribute(org.bouncycastle.asn1.ASN1ObjectIdentifier, org.bouncycastle.asn1.cms.Attribute)" map="A"/>
  <method class="org.bouncycastle.asn1.cms.AttributeTable" name="org.bouncycastle.asn1.ASN1EncodableVector getAll(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="A"/>
  <method class="org.bouncycastle.asn1.cms.AttributeTable" name="org.bouncycastle.asn1.cms.Attribute get(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="B"/>
  <class name="org.bouncycastle.asn1.cms.PasswordRecipientInfo" map="a"/>
  <field class="org.bouncycastle.asn1.cms.PasswordRecipientInfo" name="version" map="&#x0388;"/>
  <field class="org.bouncycastle.asn1.cms.PasswordRecipientInfo" name="encryptedKey" map="&#x0389;"/>
  <field class="org.bouncycastle.asn1.cms.PasswordRecipientInfo" name="keyDerivationAlgorithm" map="&#x038a;"/>
  <field class="org.bouncycastle.asn1.cms.PasswordRecipientInfo" name="keyEncryptionAlgorithm" map="&#x038c;"/>
  <method class="org.bouncycastle.asn1.cms.PasswordRecipientInfo" name="org.bouncycastle.asn1.ASN1Integer getVersion()" map="&#x0117;"/>
  <method class="org.bouncycastle.asn1.cms.PasswordRecipientInfo" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyDerivationAlgorithm()" map="&#x0118;"/>
  <method class="org.bouncycastle.asn1.cms.PasswordRecipientInfo" name="org.bouncycastle.asn1.cms.PasswordRecipientInfo getInstance(java.lang.Object)" map="&#x00b5;"/>
  <method class="org.bouncycastle.asn1.cms.PasswordRecipientInfo" name="org.bouncycastle.asn1.cms.PasswordRecipientInfo getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="R"/>
  <method class="org.bouncycastle.asn1.cms.PasswordRecipientInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cms.PasswordRecipientInfo" name="org.bouncycastle.asn1.ASN1OctetString getEncryptedKey()" map="&#x0119;"/>
  <method class="org.bouncycastle.asn1.cms.PasswordRecipientInfo" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyEncryptionAlgorithm()" map="&#x011a;"/>
  <package name="org.bouncycastle.asn1.cmp" map="K"/>
  <class name="org.bouncycastle.asn1.cmp.PKIStatusInfo" map="A"/>
  <field class="org.bouncycastle.asn1.cmp.PKIStatusInfo" name="status" map="&#x038e;"/>
  <field class="org.bouncycastle.asn1.cmp.PKIStatusInfo" name="failInfo" map="&#x038f;"/>
  <field class="org.bouncycastle.asn1.cmp.PKIStatusInfo" name="statusString" map="&#x0390;"/>
  <method class="org.bouncycastle.asn1.cmp.PKIStatusInfo" name="org.bouncycastle.asn1.cmp.PKIFreeText getStatusString()" map="&#x011b;"/>
  <method class="org.bouncycastle.asn1.cmp.PKIStatusInfo" name="org.bouncycastle.asn1.cmp.PKIStatusInfo getInstance(java.lang.Object)" map="&#x00ba;"/>
  <method class="org.bouncycastle.asn1.cmp.PKIStatusInfo" name="org.bouncycastle.asn1.DERBitString getFailInfo()" map="&#x011c;"/>
  <method class="org.bouncycastle.asn1.cmp.PKIStatusInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cmp.PKIStatusInfo" name="java.math.BigInteger getStatus()" map="&#x011d;"/>
  <class name="org.bouncycastle.asn1.cmp.PKIFailureInfo" map="B"/>
  <method class="org.bouncycastle.asn1.cmp.PKIFailureInfo" name="java.lang.String toString()" map="toString"/>
  <class name="org.bouncycastle.asn1.cmp.PKIFreeText" map="C"/>
  <field class="org.bouncycastle.asn1.cmp.PKIFreeText" name="strings" map="&#x0391;"/>
  <method class="org.bouncycastle.asn1.cmp.PKIFreeText" name="org.bouncycastle.asn1.cmp.PKIFreeText getInstance(java.lang.Object)" map="&#x00c0;"/>
  <method class="org.bouncycastle.asn1.cmp.PKIFreeText" name="int size()" map="&#x011e;"/>
  <method class="org.bouncycastle.asn1.cmp.PKIFreeText" name="org.bouncycastle.asn1.DERUTF8String getStringAt(int)" map="B"/>
  <method class="org.bouncycastle.asn1.cmp.PKIFreeText" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <package name="org.bouncycastle.asn1.x500" map="L"/>
  <package name="org.bouncycastle.asn1.x500.style" map="A"/>
  <class name="org.bouncycastle.asn1.x500.style.BCStyle" map="A"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="ST" map="v"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="GIVENNAME" map="w"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="SN" map="x"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="DC" map="y"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="POSTAL_CODE" map="z"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="T" map="&#x00a2;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="STREET" map="&#x00a3;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="TELEPHONE_NUMBER" map="&#x00a4;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="O" map="&#x00a5;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="defaultSymbols" map="&#x00aa;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="L" map="&#x00b5;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="DMD_NAME" map="&#x00ba;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="SURNAME" map="&#x00c0;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="E" map="&#x00c1;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="C" map="&#x00c2;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="CN" map="&#x00c3;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="PLACE_OF_BIRTH" map="&#x00c4;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="OU" map="&#x00c5;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="INITIALS" map="&#x00c6;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="GENERATION" map="&#x00c7;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="COUNTRY_OF_RESIDENCE" map="&#x00c8;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="DefaultLookUp" map="&#x00c9;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="GENDER" map="&#x00ca;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="PSEUDONYM" map="&#x00cb;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="UID" map="&#x00cc;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="NAME" map="&#x00cd;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="ORGANIZATION_IDENTIFIER" map="&#x00ce;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="NAME_AT_BIRTH" map="&#x00cf;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="UnstructuredAddress" map="&#x00d0;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="BUSINESS_CATEGORY" map="&#x00d1;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="DATE_OF_BIRTH" map="&#x00d2;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="COUNTRY_OF_CITIZENSHIP" map="&#x00d3;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="INSTANCE" map="&#x00d4;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="POSTAL_ADDRESS" map="&#x00d5;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="SERIALNUMBER" map="&#x00d6;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="DefaultSymbols" map="&#x00d8;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="EmailAddress" map="&#x00d9;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="DN_QUALIFIER" map="&#x00da;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="defaultLookUp" map="&#x00db;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="UNIQUE_IDENTIFIER" map="&#x00dc;"/>
  <field class="org.bouncycastle.asn1.x500.style.BCStyle" name="UnstructuredName" map="&#x00dd;"/>
  <method class="org.bouncycastle.asn1.x500.style.BCStyle" name="java.lang.String toString(org.bouncycastle.asn1.x500.X500Name)" map="B"/>
  <class name="org.bouncycastle.asn1.x500.style.IETFUtils" map="B"/>
  <method class="org.bouncycastle.asn1.x500.style.IETFUtils" name="java.lang.String stripInternalSpaces(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.asn1.x500.style.IETFUtils" name="void appendRDN(java.lang.StringBuffer, org.bouncycastle.asn1.x500.RDN, java.util.Hashtable)" map="A"/>
  <method class="org.bouncycastle.asn1.x500.style.IETFUtils" name="java.lang.String valueToString(org.bouncycastle.asn1.ASN1Encodable)" map="A"/>
  <method class="org.bouncycastle.asn1.x500.style.IETFUtils" name="java.lang.String bytesToString(byte[])" map="A"/>
  <method class="org.bouncycastle.asn1.x500.style.IETFUtils" name="void appendTypeAndValue(java.lang.StringBuffer, org.bouncycastle.asn1.x500.AttributeTypeAndValue, java.util.Hashtable)" map="A"/>
  <method class="org.bouncycastle.asn1.x500.style.IETFUtils" name="java.lang.String canonicalize(java.lang.String)" map="B"/>
  <method class="org.bouncycastle.asn1.x500.style.IETFUtils" name="boolean atvAreEqual(org.bouncycastle.asn1.x500.AttributeTypeAndValue, org.bouncycastle.asn1.x500.AttributeTypeAndValue)" map="A"/>
  <method class="org.bouncycastle.asn1.x500.style.IETFUtils" name="boolean rDNAreEqual(org.bouncycastle.asn1.x500.RDN, org.bouncycastle.asn1.x500.RDN)" map="A"/>
  <method class="org.bouncycastle.asn1.x500.style.IETFUtils" name="org.bouncycastle.asn1.ASN1Primitive decodeObject(java.lang.String)" map="C"/>
  <class name="org.bouncycastle.asn1.x500.style.AbstractX500NameStyle" map="C"/>
  <method class="org.bouncycastle.asn1.x500.style.AbstractX500NameStyle" name="boolean rdnAreEqual(org.bouncycastle.asn1.x500.RDN, org.bouncycastle.asn1.x500.RDN)" map="A"/>
  <method class="org.bouncycastle.asn1.x500.style.AbstractX500NameStyle" name="int calcHashCode(org.bouncycastle.asn1.ASN1Encodable)" map="A"/>
  <method class="org.bouncycastle.asn1.x500.style.AbstractX500NameStyle" name="int calculateHashCode(org.bouncycastle.asn1.x500.X500Name)" map="A"/>
  <method class="org.bouncycastle.asn1.x500.style.AbstractX500NameStyle" name="boolean areEqual(org.bouncycastle.asn1.x500.X500Name, org.bouncycastle.asn1.x500.X500Name)" map="A"/>
  <method class="org.bouncycastle.asn1.x500.style.AbstractX500NameStyle" name="boolean foundMatch(boolean, org.bouncycastle.asn1.x500.RDN, org.bouncycastle.asn1.x500.RDN[])" map="A"/>
  <method class="org.bouncycastle.asn1.x500.style.AbstractX500NameStyle" name="java.util.Hashtable copyHashTable(java.util.Hashtable)" map="A"/>
  <class name="org.bouncycastle.asn1.x500.style.RFC4519Style" map="D"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="registeredAddress" map="A"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="teletexTerminalIdentifier" map="B"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="searchGuide" map="C"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="destinationIndicator" map="D"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="uid" map="E"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="businessCategory" map="F"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="postalAddress" map="G"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="defaultSymbols" map="H"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="seeAlso" map="I"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="st" map="J"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="houseIdentifier" map="K"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="postalCode" map="L"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="name" map="M"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="description" map="N"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="sn" map="O"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="telexNumber" map="P"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="dc" map="Q"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="initials" map="R"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="preferredDeliveryMethod" map="S"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="DefaultLookUp" map="T"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="roleOccupant" map="U"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="x121Address" map="V"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="street" map="W"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="cn" map="X"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="ou" map="Y"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="givenName" map="Z"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="generationQualifier" map="_"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="owner" map="a"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="x500UniqueIdentifier" map="b"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="title" map="c"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="internationalISDNNumber" map="d"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="physicalDeliveryOfficeName" map="e"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="distinguishedName" map="f"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="facsimileTelephoneNumber" map="g"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="uniqueMember" map="h"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="INSTANCE" map="i"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="serialNumber" map="j"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="o" map="k"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="DefaultSymbols" map="l"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="member" map="m"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="l" map="n"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="telephoneNumber" map="o"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="defaultLookUp" map="p"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="userPassword" map="q"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="postOfficeBox" map="r"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="c" map="s"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="enhancedSearchGuide" map="t"/>
  <field class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="dnQualifier" map="u"/>
  <method class="org.bouncycastle.asn1.x500.style.RFC4519Style" name="java.lang.String toString(org.bouncycastle.asn1.x500.X500Name)" map="B"/>
  <class name="org.bouncycastle.asn1.x500.X500Name" map="A"/>
  <field class="org.bouncycastle.asn1.x500.X500Name" name="rdns" map="r"/>
  <field class="org.bouncycastle.asn1.x500.X500Name" name="hashCodeValue" map="s"/>
  <field class="org.bouncycastle.asn1.x500.X500Name" name="style" map="t"/>
  <field class="org.bouncycastle.asn1.x500.X500Name" name="isHashCodeCalculated" map="u"/>
  <field class="org.bouncycastle.asn1.x500.X500Name" name="defaultStyle" map="v"/>
  <method class="org.bouncycastle.asn1.x500.X500Name" name="org.bouncycastle.asn1.x500.X500Name getInstance(java.lang.Object)" map="M"/>
  <method class="org.bouncycastle.asn1.x500.X500Name" name="org.bouncycastle.asn1.x500.RDN[] getRDNs()" map="k"/>
  <method class="org.bouncycastle.asn1.x500.X500Name" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.asn1.x500.X500Name" name="org.bouncycastle.asn1.x500.X500Name getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="F"/>
  <method class="org.bouncycastle.asn1.x500.X500Name" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.x500.X500Name" name="org.bouncycastle.asn1.x500.X500Name getInstance(org.bouncycastle.asn1.x500.X500NameStyle, java.lang.Object)" map="A"/>
  <method class="org.bouncycastle.asn1.x500.X500Name" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.x500.X500Name" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.x500.RDN" map="B"/>
  <field class="org.bouncycastle.asn1.x500.RDN" name="values" map="&#x0392;"/>
  <method class="org.bouncycastle.asn1.x500.RDN" name="boolean isMultiValued()" map="&#x011f;"/>
  <method class="org.bouncycastle.asn1.x500.RDN" name="org.bouncycastle.asn1.x500.AttributeTypeAndValue getFirst()" map="&#x0120;"/>
  <method class="org.bouncycastle.asn1.x500.RDN" name="org.bouncycastle.asn1.x500.AttributeTypeAndValue[] getTypesAndValues()" map="&#x0121;"/>
  <method class="org.bouncycastle.asn1.x500.RDN" name="org.bouncycastle.asn1.x500.RDN getInstance(java.lang.Object)" map="&#x00c1;"/>
  <method class="org.bouncycastle.asn1.x500.RDN" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.x500.X500NameStyle" map="C"/>
  <method class="org.bouncycastle.asn1.x500.X500NameStyle" name="int calculateHashCode(org.bouncycastle.asn1.x500.X500Name)" map="A"/>
  <method class="org.bouncycastle.asn1.x500.X500NameStyle" name="boolean areEqual(org.bouncycastle.asn1.x500.X500Name, org.bouncycastle.asn1.x500.X500Name)" map="A"/>
  <method class="org.bouncycastle.asn1.x500.X500NameStyle" name="java.lang.String toString(org.bouncycastle.asn1.x500.X500Name)" map="B"/>
  <class name="org.bouncycastle.asn1.x500.AttributeTypeAndValue" map="D"/>
  <field class="org.bouncycastle.asn1.x500.AttributeTypeAndValue" name="type" map="&#x0393;"/>
  <field class="org.bouncycastle.asn1.x500.AttributeTypeAndValue" name="value" map="&#x0394;"/>
  <method class="org.bouncycastle.asn1.x500.AttributeTypeAndValue" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getType()" map="&#x0122;"/>
  <method class="org.bouncycastle.asn1.x500.AttributeTypeAndValue" name="org.bouncycastle.asn1.x500.AttributeTypeAndValue getInstance(java.lang.Object)" map="&#x00c2;"/>
  <method class="org.bouncycastle.asn1.x500.AttributeTypeAndValue" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.x500.AttributeTypeAndValue" name="org.bouncycastle.asn1.ASN1Encodable getValue()" map="&#x0123;"/>
  <package name="org.bouncycastle.asn1.teletrust" map="M"/>
  <class name="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" map="A"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="rsaSignatureWithripemd128" map="A"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="ripemd160" map="B"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="brainpoolP320t1" map="C"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="ripemd256" map="D"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="brainpoolP384t1" map="E"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="brainpoolP256t1" map="F"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="teleTrusTAlgorithm" map="G"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="brainpoolP512t1" map="H"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="brainpoolP192r1" map="I"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="ecSignWithSha1" map="J"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="brainpoolP320r1" map="K"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="brainpoolP160t1" map="L"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="brainpoolP384r1" map="M"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="ripemd128" map="N"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="brainpoolP256r1" map="O"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="ecc_brainpool" map="P"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="brainpoolP512r1" map="Q"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="rsaSignatureWithripemd160" map="R"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="ecSign" map="S"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="versionOne" map="T"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="ellipticCurve" map="U"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="brainpoolP224t1" map="V"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="rsaSignatureWithripemd256" map="W"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="brainpoolP160r1" map="X"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="teleTrusTRSAsignatureAlgorithm" map="Y"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="ecSignWithRipemd160" map="Z"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="brainpoolP224r1" map="_"/>
  <field class="org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers" name="brainpoolP192t1" map="a"/>
  <package name="org.bouncycastle.asn1.ess" map="N"/>
  <class name="org.bouncycastle.asn1.ess.ESSCertID" map="A"/>
  <field class="org.bouncycastle.asn1.ess.ESSCertID" name="certHash" map="&#x0395;"/>
  <field class="org.bouncycastle.asn1.ess.ESSCertID" name="issuerSerial" map="&#x0396;"/>
  <method class="org.bouncycastle.asn1.ess.ESSCertID" name="org.bouncycastle.asn1.ess.ESSCertID getInstance(java.lang.Object)" map="&#x00c3;"/>
  <method class="org.bouncycastle.asn1.ess.ESSCertID" name="byte[] getCertHash()" map="&#x0124;"/>
  <method class="org.bouncycastle.asn1.ess.ESSCertID" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.ess.SigningCertificate" map="B"/>
  <field class="org.bouncycastle.asn1.ess.SigningCertificate" name="policies" map="&#x0397;"/>
  <field class="org.bouncycastle.asn1.ess.SigningCertificate" name="certs" map="&#x0398;"/>
  <method class="org.bouncycastle.asn1.ess.SigningCertificate" name="org.bouncycastle.asn1.ess.SigningCertificate getInstance(java.lang.Object)" map="&#x00c4;"/>
  <method class="org.bouncycastle.asn1.ess.SigningCertificate" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.ess.SigningCertificate" name="org.bouncycastle.asn1.ess.ESSCertID[] getCerts()" map="&#x0125;"/>
  <class name="org.bouncycastle.asn1.ess.SigningCertificateV2" map="C"/>
  <field class="org.bouncycastle.asn1.ess.SigningCertificateV2" name="policies" map="&#x0399;"/>
  <field class="org.bouncycastle.asn1.ess.SigningCertificateV2" name="certs" map="&#x039a;"/>
  <method class="org.bouncycastle.asn1.ess.SigningCertificateV2" name="org.bouncycastle.asn1.ess.SigningCertificateV2 getInstance(java.lang.Object)" map="&#x00c5;"/>
  <method class="org.bouncycastle.asn1.ess.SigningCertificateV2" name="org.bouncycastle.asn1.ess.ESSCertIDv2[] getCerts()" map="&#x0126;"/>
  <method class="org.bouncycastle.asn1.ess.SigningCertificateV2" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.ess.ESSCertIDv2" map="D"/>
  <field class="org.bouncycastle.asn1.ess.ESSCertIDv2" name="certHash" map="&#x039b;"/>
  <field class="org.bouncycastle.asn1.ess.ESSCertIDv2" name="issuerSerial" map="&#x039c;"/>
  <field class="org.bouncycastle.asn1.ess.ESSCertIDv2" name="hashAlgorithm" map="&#x039d;"/>
  <field class="org.bouncycastle.asn1.ess.ESSCertIDv2" name="DEFAULT_ALG_ID" map="&#x039e;"/>
  <method class="org.bouncycastle.asn1.ess.ESSCertIDv2" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getHashAlgorithm()" map="&#x0127;"/>
  <method class="org.bouncycastle.asn1.ess.ESSCertIDv2" name="org.bouncycastle.asn1.ess.ESSCertIDv2 getInstance(java.lang.Object)" map="&#x00c6;"/>
  <method class="org.bouncycastle.asn1.ess.ESSCertIDv2" name="byte[] getCertHash()" map="&#x0128;"/>
  <method class="org.bouncycastle.asn1.ess.ESSCertIDv2" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <package name="org.bouncycastle.asn1.rosstandart" map="O"/>
  <class name="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" map="A"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_agreement_gost_3410_12_256" map="A"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_gost_3411_12_512" map="B"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_hmac_gost_3411_12_256" map="C"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_signwithdigest_gost_3410_12_512" map="D"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_agreement" map="E"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_gost_3410_12_256_paramSet" map="F"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_gost_3410_12_256" map="G"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_gost_3410_12_512_paramSet" map="H"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_gost_3410_12_512_paramSetC" map="I"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_gost_3410_12_512_paramSetB" map="J"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_agreement_gost_3410_12_512" map="K"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_gost_3410_12_512_paramSetA" map="L"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26" map="M"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_hmac_gost_3411_12_512" map="N"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_gost_28147_param_Z" map="O"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_gost_3410_12_512" map="P"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="rosstandart" map="Q"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_gost_3411_12_256" map="R"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_gost_3410_12_256_paramSetA" map="S"/>
  <field class="org.bouncycastle.asn1.rosstandart.RosstandartObjectIdentifiers" name="id_tc26_signwithdigest_gost_3410_12_256" map="T"/>
  <package name="org.bouncycastle.asn1.oiw" map="P"/>
  <class name="org.bouncycastle.asn1.oiw.OIWObjectIdentifiers" map="A"/>
  <field class="org.bouncycastle.asn1.oiw.OIWObjectIdentifiers" name="sha1WithRSA" map="A"/>
  <field class="org.bouncycastle.asn1.oiw.OIWObjectIdentifiers" name="md4WithRSA" map="B"/>
  <field class="org.bouncycastle.asn1.oiw.OIWObjectIdentifiers" name="dsaWithSHA1" map="C"/>
  <field class="org.bouncycastle.asn1.oiw.OIWObjectIdentifiers" name="desEDE" map="D"/>
  <field class="org.bouncycastle.asn1.oiw.OIWObjectIdentifiers" name="desCFB" map="E"/>
  <field class="org.bouncycastle.asn1.oiw.OIWObjectIdentifiers" name="md4WithRSAEncryption" map="F"/>
  <field class="org.bouncycastle.asn1.oiw.OIWObjectIdentifiers" name="desCBC" map="G"/>
  <field class="org.bouncycastle.asn1.oiw.OIWObjectIdentifiers" name="desECB" map="H"/>
  <field class="org.bouncycastle.asn1.oiw.OIWObjectIdentifiers" name="elGamalAlgorithm" map="I"/>
  <field class="org.bouncycastle.asn1.oiw.OIWObjectIdentifiers" name="idSHA1" map="J"/>
  <field class="org.bouncycastle.asn1.oiw.OIWObjectIdentifiers" name="desOFB" map="K"/>
  <field class="org.bouncycastle.asn1.oiw.OIWObjectIdentifiers" name="md5WithRSA" map="L"/>
  <package name="org.bouncycastle.asn1.x9" map="Q"/>
  <class name="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" map="A"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="mqvSinglePass_sha1kdf_scheme" map="A"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="ecdsa_with_SHA2" map="B"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="gnBasis" map="C"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="ecdsa_with_SHA1" map="D"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="dhHybrid2" map="E"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="ellipticCurve" map="F"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="x9_44" map="G"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="dhHybrid1" map="H"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="ppBasis" map="I"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2pnb176w1" map="J"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="prime239v3" map="K"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2tnb191v3" map="L"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="prime239v2" map="M"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="tpBasis" map="N"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2tnb191v2" map="O"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="prime239v1" map="P"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2tnb191v1" map="Q"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="dhpublicnumber" map="R"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2tnb431r1" map="S"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="ansi_X9_42" map="T"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="x9_63_scheme" map="U"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="id_fieldType" map="V"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="dhSinglePass_stdDH_sha1kdf_scheme" map="W"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="characteristic_two_field" map="X"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2pnb272w1" map="Y"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="prime256v1" map="Z"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="dhStatic" map="_"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="cTwoCurve" map="a"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2pnb163v3" map="b"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2pnb163v2" map="c"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2pnb163v1" map="d"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="prime_field" map="e"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="id_dsa_with_sha1" map="f"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="primeCurve" map="g"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2tnb239v3" map="h"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2tnb239v2" map="i"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2tnb239v1" map="j"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="x9_42_schemes" map="k"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="dhSinglePass_cofactorDH_sha1kdf_scheme" map="l"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="ansi_X9_62" map="m"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="prime192v3" map="n"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="prime192v2" map="o"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="prime192v1" map="p"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="ecdsa_with_SHA384" map="q"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="mqv2" map="r"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="mqv1" map="s"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2onb191v5" map="t"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2onb191v4" map="u"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2pnb208w1" map="v"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="id_publicKeyType" map="w"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="id_dsa" map="x"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="ecdsa_with_SHA512" map="y"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="ecdsa_with_SHA224" map="z"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="ecdsa_with_SHA256" map="&#x00a2;"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="id_ecPublicKey" map="&#x00a3;"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="dhHybridOneFlow" map="&#x00a4;"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="dhOneFlow" map="&#x00a5;"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="id_ecSigType" map="&#x00aa;"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2pnb368w1" map="&#x00b5;"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2pnb304w1" map="&#x00ba;"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="dhEphem" map="&#x00c0;"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="id_kdf_kdf3" map="&#x00c1;"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="id_kdf_kdf2" map="&#x00c2;"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="x9_44_components" map="&#x00c3;"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2tnb359v1" map="&#x00c4;"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2onb239v5" map="&#x00c5;"/>
  <field class="org.bouncycastle.asn1.x9.X9ObjectIdentifiers" name="c2onb239v4" map="&#x00c6;"/>
  <package name="org.bouncycastle.asn1.gm" map="R"/>
  <class name="org.bouncycastle.asn1.gm.GMObjectIdentifiers" map="A"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2encrypt_recommendedParameters" map="A"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="wapip192v1" map="B"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm1_ecb" map="C"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="ssf33_cbc" map="D"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sms4_wrap_pad" map="E"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="ssf33_cfb128" map="F"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2sign" map="G"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sms4_ofb128" map="H"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2encrypt_with_whirlpool" map="I"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2encrypt" map="J"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2encrypt_with_sm3" map="K"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sms4_ocb" map="L"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2sign_with_sha384" map="M"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm1_cfb128" map="N"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm9sign" map="O"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2p256v1" map="P"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2sign_with_sha224" map="Q"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2sign_with_sha512" map="R"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2sign_with_sha256" map="S"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm6_cbc" map="T"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="ssf33_ofb128" map="U"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sms4_ecb" map="V"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="id_sm9PublicKey" map="W"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm_scheme" map="X"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2exchange" map="Y"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2sign_with_whirlpool" map="Z"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sms4_xts" map="_"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm1_ofb128" map="a"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sms4_wrap" map="b"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2encrypt_with_sha1" map="c"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sms4_ccm" map="d"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2sign_with_rmd160" map="e"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2encrypt_specifiedParameters" map="f"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm5" map="g"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="ssf33_cfb8" map="h"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm3" map="i"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="ssf33_ecb" map="j"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2sign_with_sha1" map="k"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm6_cfb128" map="l"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="ssf33_cfb1" map="m"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm1_cbc" map="n"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2sign_with_sm3" map="o"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2encrypt_with_sha384" map="p"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm9encrypt" map="q"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm6_ecb" map="r"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2encrypt_with_sha512" map="s"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2encrypt_with_sha256" map="t"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2encrypt_with_sha224" map="u"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm9keyagreement" map="v"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2encrypt_with_md5" map="w"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm6_ofb128" map="x"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2sign_with_blake2s256" map="y"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm1_cfb8" map="z"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2sign_with_blake2b512" map="&#x00a2;"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sms4_ctr" map="&#x00a3;"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sms4_cfb8" map="&#x00a4;"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sms4_cbc" map="&#x00a5;"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2encrypt_with_blake2s256" map="&#x00aa;"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm1_cfb1" map="&#x00b5;"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2encrypt_with_blake2b512" map="&#x00ba;"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="hmac_sm3" map="&#x00c0;"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sm2encrypt_with_rmd160" map="&#x00c1;"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sms4_cfb1" map="&#x00c2;"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sms4_cfb128" map="&#x00c3;"/>
  <field class="org.bouncycastle.asn1.gm.GMObjectIdentifiers" name="sms4_gcm" map="&#x00c4;"/>
  <package name="org.bouncycastle.asn1.eac" map="S"/>
  <class name="org.bouncycastle.asn1.eac.EACObjectIdentifiers" map="A"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_CA_ECDH" map="A"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_CA_DH_3DES_CBC_CBC" map="B"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_TA_RSA_v1_5_SHA_512" map="C"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_TA_ECDSA" map="D"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_TA_RSA_PSS_SHA_256" map="E"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_CA_DH" map="F"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_TA_ECDSA_SHA_512" map="G"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_TA" map="H"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_PK_ECDH" map="I"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_TA_RSA" map="J"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_TA_ECDSA_SHA_384" map="K"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_TA_RSA_PSS_SHA_512" map="L"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_EAC_ePassport" map="M"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_TA_RSA_v1_5_SHA_1" map="N"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_CA_ECDH_3DES_CBC_CBC" map="O"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_TA_ECDSA_SHA_1" map="P"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_CA" map="Q"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_TA_RSA_v1_5_SHA_256" map="R"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_PK_DH" map="S"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_TA_RSA_PSS_SHA_1" map="T"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_PK" map="U"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_TA_ECDSA_SHA_256" map="V"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="id_TA_ECDSA_SHA_224" map="W"/>
  <field class="org.bouncycastle.asn1.eac.EACObjectIdentifiers" name="bsi_de" map="X"/>
  <package name="org.bouncycastle.asn1.iso" map="T"/>
  <class name="org.bouncycastle.asn1.iso.ISOIECObjectIdentifiers" map="A"/>
  <field class="org.bouncycastle.asn1.iso.ISOIECObjectIdentifiers" name="whirlpool" map="A"/>
  <field class="org.bouncycastle.asn1.iso.ISOIECObjectIdentifiers" name="id_ac_generic_hybrid" map="B"/>
  <field class="org.bouncycastle.asn1.iso.ISOIECObjectIdentifiers" name="ripemd128" map="C"/>
  <field class="org.bouncycastle.asn1.iso.ISOIECObjectIdentifiers" name="hash_algorithms" map="D"/>
  <field class="org.bouncycastle.asn1.iso.ISOIECObjectIdentifiers" name="is18033_2" map="E"/>
  <field class="org.bouncycastle.asn1.iso.ISOIECObjectIdentifiers" name="ripemd160" map="F"/>
  <field class="org.bouncycastle.asn1.iso.ISOIECObjectIdentifiers" name="id_kem_rsa" map="G"/>
  <field class="org.bouncycastle.asn1.iso.ISOIECObjectIdentifiers" name="iso_encryption_algorithms" map="H"/>
  <package name="org.bouncycastle.asn1.ntt" map="U"/>
  <class name="org.bouncycastle.asn1.ntt.NTTObjectIdentifiers" map="A"/>
  <field class="org.bouncycastle.asn1.ntt.NTTObjectIdentifiers" name="id_camellia192_cbc" map="A"/>
  <field class="org.bouncycastle.asn1.ntt.NTTObjectIdentifiers" name="id_camellia256_wrap" map="B"/>
  <field class="org.bouncycastle.asn1.ntt.NTTObjectIdentifiers" name="id_camellia128_wrap" map="C"/>
  <field class="org.bouncycastle.asn1.ntt.NTTObjectIdentifiers" name="id_camellia192_wrap" map="D"/>
  <field class="org.bouncycastle.asn1.ntt.NTTObjectIdentifiers" name="id_camellia256_cbc" map="E"/>
  <field class="org.bouncycastle.asn1.ntt.NTTObjectIdentifiers" name="id_camellia128_cbc" map="F"/>
  <package name="org.bouncycastle.asn1.sec" map="V"/>
  <class name="org.bouncycastle.asn1.sec.SECObjectIdentifiers" map="A"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="ellipticCurve" map="A"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secp224r1" map="B"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secp256r1" map="C"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="mqvFull_sha224kdf_scheme" map="D"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="dhSinglePass_cofactorDH_sha512kdf_scheme" map="E"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect113r2" map="F"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect113r1" map="G"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect163r2" map="H"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect131r2" map="I"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secp112r2" map="J"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect163r1" map="K"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect131r1" map="L"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secp112r1" map="M"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="dhSinglePass_stdDH_sha256kdf_scheme" map="N"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect409r1" map="O"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect239k1" map="P"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secp384r1" map="Q"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="mqvSinglePass_sha256kdf_scheme" map="R"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secg_scheme" map="S"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="dhSinglePass_cofactorDH_sha384kdf_scheme" map="T"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secp224k1" map="U"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secp256k1" map="V"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="dhSinglePass_stdDH_sha512kdf_scheme" map="W"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect193r2" map="X"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect193r1" map="Y"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="dhSinglePass_cofactorDH_sha224kdf_scheme" map="Z"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secp160r2" map="_"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secp160r1" map="a"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect163k1" map="b"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secp192r1" map="c"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect409k1" map="d"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="mqvSinglePass_sha512kdf_scheme" map="e"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="mqvFull_sha256kdf_scheme" map="f"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secp521r1" map="g"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="dhSinglePass_stdDH_sha384kdf_scheme" map="h"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect233r1" map="i"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="dhSinglePass_stdDH_sha224kdf_scheme" map="j"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect283r1" map="k"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect571r1" map="l"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="mqvSinglePass_sha384kdf_scheme" map="m"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secp192k1" map="n"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secp160k1" map="o"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="mqvFull_sha512kdf_scheme" map="p"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="mqvSinglePass_sha224kdf_scheme" map="q"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secp128r2" map="r"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="dhSinglePass_cofactorDH_sha256kdf_scheme" map="s"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="secp128r1" map="t"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect233k1" map="u"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect571k1" map="v"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="sect283k1" map="w"/>
  <field class="org.bouncycastle.asn1.sec.SECObjectIdentifiers" name="mqvFull_sha384kdf_scheme" map="x"/>
  <package name="org.bouncycastle.asn1.tsp" map="W"/>
  <class name="org.bouncycastle.asn1.tsp.TimeStampReq" map="A"/>
  <field class="org.bouncycastle.asn1.tsp.TimeStampReq" name="version" map="&#x039f;"/>
  <field class="org.bouncycastle.asn1.tsp.TimeStampReq" name="certReq" map="&#x03a0;"/>
  <field class="org.bouncycastle.asn1.tsp.TimeStampReq" name="tsaPolicy" map="&#x03a1;"/>
  <field class="org.bouncycastle.asn1.tsp.TimeStampReq" name="extensions" map="&#x03a3;"/>
  <field class="org.bouncycastle.asn1.tsp.TimeStampReq" name="nonce" map="&#x03a4;"/>
  <field class="org.bouncycastle.asn1.tsp.TimeStampReq" name="messageImprint" map="&#x03a5;"/>
  <method class="org.bouncycastle.asn1.tsp.TimeStampReq" name="org.bouncycastle.asn1.ASN1Integer getNonce()" map="&#x0129;"/>
  <method class="org.bouncycastle.asn1.tsp.TimeStampReq" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getReqPolicy()" map="&#x012a;"/>
  <method class="org.bouncycastle.asn1.tsp.TimeStampReq" name="org.bouncycastle.asn1.x509.Extensions getExtensions()" map="&#x012b;"/>
  <method class="org.bouncycastle.asn1.tsp.TimeStampReq" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.tsp.TimeStampReq" name="org.bouncycastle.asn1.tsp.MessageImprint getMessageImprint()" map="&#x012c;"/>
  <class name="org.bouncycastle.asn1.tsp.TSTInfo" map="B"/>
  <field class="org.bouncycastle.asn1.tsp.TSTInfo" name="ordering" map="&#x03a6;"/>
  <field class="org.bouncycastle.asn1.tsp.TSTInfo" name="accuracy" map="&#x03a7;"/>
  <field class="org.bouncycastle.asn1.tsp.TSTInfo" name="messageImprint" map="&#x03a8;"/>
  <field class="org.bouncycastle.asn1.tsp.TSTInfo" name="serialNumber" map="&#x03a9;"/>
  <field class="org.bouncycastle.asn1.tsp.TSTInfo" name="nonce" map="&#x03aa;"/>
  <field class="org.bouncycastle.asn1.tsp.TSTInfo" name="tsaPolicyId" map="&#x03ab;"/>
  <field class="org.bouncycastle.asn1.tsp.TSTInfo" name="version" map="&#x03ac;"/>
  <field class="org.bouncycastle.asn1.tsp.TSTInfo" name="extensions" map="&#x03ad;"/>
  <field class="org.bouncycastle.asn1.tsp.TSTInfo" name="genTime" map="&#x03ae;"/>
  <field class="org.bouncycastle.asn1.tsp.TSTInfo" name="tsa" map="&#x03af;"/>
  <method class="org.bouncycastle.asn1.tsp.TSTInfo" name="org.bouncycastle.asn1.ASN1Integer getNonce()" map="&#x012d;"/>
  <method class="org.bouncycastle.asn1.tsp.TSTInfo" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getPolicy()" map="&#x012e;"/>
  <method class="org.bouncycastle.asn1.tsp.TSTInfo" name="org.bouncycastle.asn1.ASN1GeneralizedTime getGenTime()" map="&#x012f;"/>
  <method class="org.bouncycastle.asn1.tsp.TSTInfo" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.tsp.TSTInfo" name="org.bouncycastle.asn1.tsp.MessageImprint getMessageImprint()" map="&#x0130;"/>
  <method class="org.bouncycastle.asn1.tsp.TSTInfo" name="org.bouncycastle.asn1.tsp.TSTInfo getInstance(java.lang.Object)" map="&#x00c7;"/>
  <class name="org.bouncycastle.asn1.tsp.MessageImprint" map="C"/>
  <field class="org.bouncycastle.asn1.tsp.MessageImprint" name="hashedMessage" map="&#x03b0;"/>
  <field class="org.bouncycastle.asn1.tsp.MessageImprint" name="hashAlgorithm" map="&#x03b1;"/>
  <method class="org.bouncycastle.asn1.tsp.MessageImprint" name="byte[] getHashedMessage()" map="&#x0131;"/>
  <method class="org.bouncycastle.asn1.tsp.MessageImprint" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getHashAlgorithm()" map="&#x0132;"/>
  <method class="org.bouncycastle.asn1.tsp.MessageImprint" name="org.bouncycastle.asn1.tsp.MessageImprint getInstance(java.lang.Object)" map="&#x00c8;"/>
  <method class="org.bouncycastle.asn1.tsp.MessageImprint" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.tsp.Accuracy" map="D"/>
  <field class="org.bouncycastle.asn1.tsp.Accuracy" name="millis" map="&#x03b2;"/>
  <field class="org.bouncycastle.asn1.tsp.Accuracy" name="micros" map="&#x03b3;"/>
  <field class="org.bouncycastle.asn1.tsp.Accuracy" name="seconds" map="&#x03b4;"/>
  <method class="org.bouncycastle.asn1.tsp.Accuracy" name="org.bouncycastle.asn1.tsp.Accuracy getInstance(java.lang.Object)" map="&#x00c9;"/>
  <method class="org.bouncycastle.asn1.tsp.Accuracy" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.tsp.TimeStampResp" map="E"/>
  <field class="org.bouncycastle.asn1.tsp.TimeStampResp" name="timeStampToken" map="&#x03b5;"/>
  <field class="org.bouncycastle.asn1.tsp.TimeStampResp" name="pkiStatusInfo" map="&#x03b6;"/>
  <method class="org.bouncycastle.asn1.tsp.TimeStampResp" name="org.bouncycastle.asn1.tsp.TimeStampResp getInstance(java.lang.Object)" map="&#x00ca;"/>
  <method class="org.bouncycastle.asn1.tsp.TimeStampResp" name="org.bouncycastle.asn1.cmp.PKIStatusInfo getStatus()" map="&#x0133;"/>
  <method class="org.bouncycastle.asn1.tsp.TimeStampResp" name="org.bouncycastle.asn1.cms.ContentInfo getTimeStampToken()" map="&#x0134;"/>
  <method class="org.bouncycastle.asn1.tsp.TimeStampResp" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <package name="org.bouncycastle.asn1.gnu" map="X"/>
  <class name="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" map="A"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="GNU" map="A"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="Serpent_128_CBC" map="B"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="notation" map="C"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="Serpent_128_OFB" map="D"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="encryptionAlgorithm" map="E"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="Serpent_256_CBC" map="F"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="Ed25519" map="G"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="Serpent_256_OFB" map="H"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="Serpent_192_CBC" map="I"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="Serpent_192_OFB" map="J"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="Tiger_192" map="K"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="pkaAddress" map="L"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="CRC" map="M"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="digestAlgorithm" map="N"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="Serpent_128_CFB" map="O"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="ellipticCurve" map="P"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="GnuPG" map="Q"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="Serpent_128_ECB" map="R"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="Serpent_256_CFB" map="S"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="GnuRadar" map="T"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="Serpent_256_ECB" map="U"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="Serpent_192_CFB" map="V"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="Serpent_192_ECB" map="W"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="Serpent" map="X"/>
  <field class="org.bouncycastle.asn1.gnu.GNUObjectIdentifiers" name="CRC32" map="Y"/>
  <package name="org.bouncycastle.asn1.cryptopro" map="Y"/>
  <class name="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" map="A"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_2001_CryptoPro_C" map="A"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_2001_CryptoPro_B" map="B"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_2001_CryptoPro_A" map="C"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gost_ElSgDH3410_default" map="D"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="id_Gost28147_89_CryptoPro_KeyWrap" map="E"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3411Hmac" map="F"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_2001DH" map="G"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="id_Gost28147_89_CryptoPro_C_ParamSet" map="H"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="GOST_id" map="I"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_94_CryptoPro_XchC" map="J"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_94_CryptoPro_XchB" map="K"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_94_CryptoPro_XchA" map="L"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_2001_CryptoPro_ESDH" map="M"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3411_94_CryptoProParamSet" map="N"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gost_ElSgDH3410_1" map="O"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_2001_CryptoPro_XchB" map="P"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="id_Gost28147_89_CryptoPro_A_ParamSet" map="Q"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3411_94_with_gostR3410_2001" map="R"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_2001_CryptoPro_XchA" map="S"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="id_Gost28147_89_CryptoPro_TestParamSet" map="T"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_94_CryptoPro_D" map="U"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_94_CryptoPro_C" map="V"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_94_CryptoPro_B" map="W"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_94_CryptoPro_A" map="X"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="id_Gost28147_89_None_KeyWrap" map="Y"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_2001" map="Z"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="id_Gost28147_89_CryptoPro_D_ParamSet" map="_"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3411_94_with_gostR3410_94" map="a"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR28147_gcfb" map="b"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3410_94" map="c"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="gostR3411" map="d"/>
  <field class="org.bouncycastle.asn1.cryptopro.CryptoProObjectIdentifiers" name="id_Gost28147_89_CryptoPro_B_ParamSet" map="e"/>
  <class name="org.bouncycastle.asn1.cryptopro.Gost2814789EncryptedKey" map="B"/>
  <field class="org.bouncycastle.asn1.cryptopro.Gost2814789EncryptedKey" name="macKey" map="&#x03b7;"/>
  <field class="org.bouncycastle.asn1.cryptopro.Gost2814789EncryptedKey" name="encryptedKey" map="&#x03b8;"/>
  <field class="org.bouncycastle.asn1.cryptopro.Gost2814789EncryptedKey" name="maskKey" map="&#x03b9;"/>
  <method class="org.bouncycastle.asn1.cryptopro.Gost2814789EncryptedKey" name="byte[] getMacKey()" map="&#x0135;"/>
  <method class="org.bouncycastle.asn1.cryptopro.Gost2814789EncryptedKey" name="org.bouncycastle.asn1.cryptopro.Gost2814789EncryptedKey getInstance(java.lang.Object)" map="&#x00cb;"/>
  <method class="org.bouncycastle.asn1.cryptopro.Gost2814789EncryptedKey" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cryptopro.Gost2814789EncryptedKey" name="byte[] getEncryptedKey()" map="&#x0136;"/>
  <class name="org.bouncycastle.asn1.cryptopro.GostR3410TransportParameters" map="C"/>
  <field class="org.bouncycastle.asn1.cryptopro.GostR3410TransportParameters" name="ephemeralPublicKey" map="&#x03ba;"/>
  <field class="org.bouncycastle.asn1.cryptopro.GostR3410TransportParameters" name="encryptionParamSet" map="&#x03bb;"/>
  <field class="org.bouncycastle.asn1.cryptopro.GostR3410TransportParameters" name="ukm" map="&#x03bc;"/>
  <method class="org.bouncycastle.asn1.cryptopro.GostR3410TransportParameters" name="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getEphemeralPublicKey()" map="&#x0137;"/>
  <method class="org.bouncycastle.asn1.cryptopro.GostR3410TransportParameters" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getEncryptionParamSet()" map="&#x0138;"/>
  <method class="org.bouncycastle.asn1.cryptopro.GostR3410TransportParameters" name="org.bouncycastle.asn1.cryptopro.GostR3410TransportParameters getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="S"/>
  <method class="org.bouncycastle.asn1.cryptopro.GostR3410TransportParameters" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.cryptopro.GostR3410TransportParameters" name="byte[] getUkm()" map="&#x0139;"/>
  <class name="org.bouncycastle.asn1.cryptopro.GostR3410KeyTransport" map="D"/>
  <field class="org.bouncycastle.asn1.cryptopro.GostR3410KeyTransport" name="sessionEncryptedKey" map="&#x03bd;"/>
  <field class="org.bouncycastle.asn1.cryptopro.GostR3410KeyTransport" name="transportParameters" map="&#x03be;"/>
  <method class="org.bouncycastle.asn1.cryptopro.GostR3410KeyTransport" name="org.bouncycastle.asn1.cryptopro.GostR3410TransportParameters getTransportParameters()" map="&#x013a;"/>
  <method class="org.bouncycastle.asn1.cryptopro.GostR3410KeyTransport" name="org.bouncycastle.asn1.cryptopro.GostR3410KeyTransport getInstance(java.lang.Object)" map="&#x00cc;"/>
  <method class="org.bouncycastle.asn1.cryptopro.GostR3410KeyTransport" name="org.bouncycastle.asn1.cryptopro.Gost2814789EncryptedKey getSessionEncryptedKey()" map="&#x013b;"/>
  <method class="org.bouncycastle.asn1.cryptopro.GostR3410KeyTransport" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.ASN1BitString" map="A"/>
  <field class="org.bouncycastle.asn1.ASN1BitString" name="padBits" map="&#x041a;"/>
  <field class="org.bouncycastle.asn1.ASN1BitString" name="table" map="&#x041b;"/>
  <field class="org.bouncycastle.asn1.ASN1BitString" name="data" map="&#x041c;"/>
  <method class="org.bouncycastle.asn1.ASN1BitString" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1BitString" name="byte[] derForm(byte[], int)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1BitString" name="byte[] getBytes()" map="&#x016e;"/>
  <method class="org.bouncycastle.asn1.ASN1BitString" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.ASN1BitString" name="byte[] getOctets()" map="&#x016f;"/>
  <method class="org.bouncycastle.asn1.ASN1BitString" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1BitString" name="org.bouncycastle.asn1.ASN1BitString fromInputStream(int, java.io.InputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1BitString" name="int getPadBits()" map="&#x0170;"/>
  <method class="org.bouncycastle.asn1.ASN1BitString" name="java.lang.String getString()" map="&#x016c;"/>
  <method class="org.bouncycastle.asn1.ASN1BitString" name="org.bouncycastle.asn1.ASN1Primitive toDLObject()" map="&#x0168;"/>
  <method class="org.bouncycastle.asn1.ASN1BitString" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.ASN1BitString" name="int intValue()" map="&#x0171;"/>
  <method class="org.bouncycastle.asn1.ASN1BitString" name="org.bouncycastle.asn1.ASN1Primitive toDERObject()" map="&#x016a;"/>
  <class name="org.bouncycastle.asn1.DefiniteLengthInputStream" map="B"/>
  <field class="org.bouncycastle.asn1.DefiniteLengthInputStream" name="_originalLength" map="G"/>
  <field class="org.bouncycastle.asn1.DefiniteLengthInputStream" name="EMPTY_BYTES" map="H"/>
  <field class="org.bouncycastle.asn1.DefiniteLengthInputStream" name="_remaining" map="I"/>
  <method class="org.bouncycastle.asn1.DefiniteLengthInputStream" name="int read()" map="read"/>
  <method class="org.bouncycastle.asn1.DefiniteLengthInputStream" name="int getRemaining()" map="A"/>
  <method class="org.bouncycastle.asn1.DefiniteLengthInputStream" name="byte[] toByteArray()" map="C"/>
  <method class="org.bouncycastle.asn1.DefiniteLengthInputStream" name="int read(byte[], int, int)" map="read"/>
  <class name="org.bouncycastle.asn1.DERUniversalString" map="C"/>
  <field class="org.bouncycastle.asn1.DERUniversalString" name="string" map="&#x040e;"/>
  <field class="org.bouncycastle.asn1.DERUniversalString" name="table" map="&#x040f;"/>
  <method class="org.bouncycastle.asn1.DERUniversalString" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.DERUniversalString" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.DERUniversalString" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERUniversalString" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DERUniversalString" name="byte[] getOctets()" map="&#x016d;"/>
  <method class="org.bouncycastle.asn1.DERUniversalString" name="java.lang.String getString()" map="&#x016c;"/>
  <method class="org.bouncycastle.asn1.DERUniversalString" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.DERUniversalString" name="java.lang.String toString()" map="toString"/>
  <class name="org.bouncycastle.asn1.DERGraphicString" map="D"/>
  <field class="org.bouncycastle.asn1.DERGraphicString" name="string" map="&#x0410;"/>
  <method class="org.bouncycastle.asn1.DERGraphicString" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.DERGraphicString" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.DERGraphicString" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERGraphicString" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DERGraphicString" name="java.lang.String getString()" map="&#x016c;"/>
  <method class="org.bouncycastle.asn1.DERGraphicString" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.DERT61String" map="E"/>
  <field class="org.bouncycastle.asn1.DERT61String" name="string" map="&#x0411;"/>
  <method class="org.bouncycastle.asn1.DERT61String" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.DERT61String" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.DERT61String" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERT61String" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DERT61String" name="java.lang.String getString()" map="&#x016c;"/>
  <method class="org.bouncycastle.asn1.DERT61String" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.DERT61String" name="java.lang.String toString()" map="toString"/>
  <class name="org.bouncycastle.asn1.ASN1SequenceParser" map="F"/>
  <class name="org.bouncycastle.asn1.DERPrintableString" map="G"/>
  <field class="org.bouncycastle.asn1.DERPrintableString" name="string" map="&#x0412;"/>
  <method class="org.bouncycastle.asn1.DERPrintableString" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.DERPrintableString" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.DERPrintableString" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERPrintableString" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DERPrintableString" name="java.lang.String getString()" map="&#x016c;"/>
  <method class="org.bouncycastle.asn1.DERPrintableString" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.DERPrintableString" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.BERSequenceParser" map="H"/>
  <field class="org.bouncycastle.asn1.BERSequenceParser" name="_parser" map="&#x0452;"/>
  <method class="org.bouncycastle.asn1.BERSequenceParser" name="org.bouncycastle.asn1.ASN1Primitive getLoadedObject()" map="B"/>
  <method class="org.bouncycastle.asn1.BERSequenceParser" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.BERApplicationSpecificParser" map="I"/>
  <field class="org.bouncycastle.asn1.BERApplicationSpecificParser" name="tag" map="B"/>
  <field class="org.bouncycastle.asn1.BERApplicationSpecificParser" name="parser" map="C"/>
  <method class="org.bouncycastle.asn1.BERApplicationSpecificParser" name="org.bouncycastle.asn1.ASN1Primitive getLoadedObject()" map="B"/>
  <method class="org.bouncycastle.asn1.BERApplicationSpecificParser" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.BEROctetString$1" map="1"/>
  <field class="org.bouncycastle.asn1.BEROctetString$1" name="this$0" map="A"/>
  <field class="org.bouncycastle.asn1.BEROctetString$1" name="counter" map="B"/>
  <method class="org.bouncycastle.asn1.BEROctetString$1" name="boolean hasMoreElements()" map="hasMoreElements"/>
  <method class="org.bouncycastle.asn1.BEROctetString$1" name="java.lang.Object nextElement()" map="nextElement"/>
  <class name="org.bouncycastle.asn1.BEROctetString" map="J"/>
  <field class="org.bouncycastle.asn1.BEROctetString" name="octs" map="&#x0420;"/>
  <field class="org.bouncycastle.asn1.BEROctetString" name="chunkSize" map="&#x0421;"/>
  <method class="org.bouncycastle.asn1.BEROctetString" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.BEROctetString" name="org.bouncycastle.asn1.BEROctetString fromSequence(org.bouncycastle.asn1.ASN1Sequence)" map="A"/>
  <method class="org.bouncycastle.asn1.BEROctetString" name="org.bouncycastle.asn1.ASN1OctetString[] access$000(org.bouncycastle.asn1.BEROctetString)" map="A"/>
  <method class="org.bouncycastle.asn1.BEROctetString" name="byte[] getOctets()" map="&#x0173;"/>
  <method class="org.bouncycastle.asn1.BEROctetString" name="java.util.Vector generateOcts()" map="&#x0174;"/>
  <method class="org.bouncycastle.asn1.BEROctetString" name="java.util.Enumeration getObjects()" map="&#x0175;"/>
  <method class="org.bouncycastle.asn1.BEROctetString" name="byte[] toBytes(org.bouncycastle.asn1.ASN1OctetString[])" map="A"/>
  <method class="org.bouncycastle.asn1.BEROctetString" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.BEROctetString" name="boolean isConstructed()" map="&#x016b;"/>
  <class name="org.bouncycastle.asn1.LazyConstructionEnumeration" map="K"/>
  <field class="org.bouncycastle.asn1.LazyConstructionEnumeration" name="nextObj" map="A"/>
  <field class="org.bouncycastle.asn1.LazyConstructionEnumeration" name="aIn" map="B"/>
  <method class="org.bouncycastle.asn1.LazyConstructionEnumeration" name="java.lang.Object readObject()" map="A"/>
  <method class="org.bouncycastle.asn1.LazyConstructionEnumeration" name="boolean hasMoreElements()" map="hasMoreElements"/>
  <method class="org.bouncycastle.asn1.LazyConstructionEnumeration" name="java.lang.Object nextElement()" map="nextElement"/>
  <class name="org.bouncycastle.asn1.DERSet" map="L"/>
  <field class="org.bouncycastle.asn1.DERSet" name="bodyLength" map="&#x042d;"/>
  <method class="org.bouncycastle.asn1.DERSet" name="int getBodyLength()" map="&#x0183;"/>
  <method class="org.bouncycastle.asn1.DERSet" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERSet" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.DERExternalParser" map="M"/>
  <field class="org.bouncycastle.asn1.DERExternalParser" name="_parser" map="A"/>
  <method class="org.bouncycastle.asn1.DERExternalParser" name="org.bouncycastle.asn1.ASN1Primitive getLoadedObject()" map="B"/>
  <method class="org.bouncycastle.asn1.DERExternalParser" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.DERNumericString" map="N"/>
  <field class="org.bouncycastle.asn1.DERNumericString" name="string" map="&#x0413;"/>
  <method class="org.bouncycastle.asn1.DERNumericString" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.DERNumericString" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.DERNumericString" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERNumericString" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DERNumericString" name="java.lang.String getString()" map="&#x016c;"/>
  <method class="org.bouncycastle.asn1.DERNumericString" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.DERNumericString" name="java.lang.String toString()" map="toString"/>
  <class name="org.bouncycastle.asn1.ASN1OctetString" map="O"/>
  <field class="org.bouncycastle.asn1.ASN1OctetString" name="string" map="&#x041f;"/>
  <method class="org.bouncycastle.asn1.ASN1OctetString" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1OctetString" name="org.bouncycastle.asn1.ASN1OctetString getInstance(java.lang.Object)" map="&#x00db;"/>
  <method class="org.bouncycastle.asn1.ASN1OctetString" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.ASN1OctetString" name="byte[] getOctets()" map="&#x0173;"/>
  <method class="org.bouncycastle.asn1.ASN1OctetString" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1OctetString" name="java.io.InputStream getOctetStream()" map="&#x0172;"/>
  <method class="org.bouncycastle.asn1.ASN1OctetString" name="org.bouncycastle.asn1.ASN1OctetString getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="V"/>
  <method class="org.bouncycastle.asn1.ASN1OctetString" name="org.bouncycastle.asn1.ASN1Primitive toDLObject()" map="&#x0168;"/>
  <method class="org.bouncycastle.asn1.ASN1OctetString" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.ASN1OctetString" name="org.bouncycastle.asn1.ASN1Primitive toDERObject()" map="&#x016a;"/>
  <method class="org.bouncycastle.asn1.ASN1OctetString" name="org.bouncycastle.asn1.ASN1Primitive getLoadedObject()" map="B"/>
  <class name="org.bouncycastle.asn1.ASN1Set" map="P"/>
  <field class="org.bouncycastle.asn1.ASN1Set" name="isSorted" map="&#x042b;"/>
  <field class="org.bouncycastle.asn1.ASN1Set" name="set" map="&#x042c;"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="void sort()" map="&#x017f;"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="org.bouncycastle.asn1.ASN1Encodable[] toArray()" map="&#x0180;"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="org.bouncycastle.asn1.ASN1Encodable getNext(java.util.Enumeration)" map="B"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="org.bouncycastle.asn1.ASN1Set getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="X"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="org.bouncycastle.asn1.ASN1Encodable getObjectAt(int)" map="D"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="boolean lessThanOrEqual(byte[], byte[])" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="java.util.Enumeration getObjects()" map="&#x0181;"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="org.bouncycastle.asn1.ASN1Primitive toDLObject()" map="&#x0168;"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="org.bouncycastle.asn1.ASN1Set getInstance(java.lang.Object)" map="&#x00dd;"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="int size()" map="&#x0182;"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="byte[] getDEREncoded(org.bouncycastle.asn1.ASN1Encodable)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="org.bouncycastle.asn1.ASN1Primitive toDERObject()" map="&#x016a;"/>
  <method class="org.bouncycastle.asn1.ASN1Set" name="boolean isConstructed()" map="&#x016b;"/>
  <class name="org.bouncycastle.asn1.ASN1Enumerated" map="Q"/>
  <field class="org.bouncycastle.asn1.ASN1Enumerated" name="bytes" map="&#x042f;"/>
  <field class="org.bouncycastle.asn1.ASN1Enumerated" name="cache" map="&#x0430;"/>
  <method class="org.bouncycastle.asn1.ASN1Enumerated" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Enumerated" name="org.bouncycastle.asn1.ASN1Enumerated getInstance(java.lang.Object)" map="&#x00de;"/>
  <method class="org.bouncycastle.asn1.ASN1Enumerated" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.ASN1Enumerated" name="org.bouncycastle.asn1.ASN1Enumerated getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="Y"/>
  <method class="org.bouncycastle.asn1.ASN1Enumerated" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Enumerated" name="org.bouncycastle.asn1.ASN1Enumerated fromOctetString(byte[])" map="E"/>
  <method class="org.bouncycastle.asn1.ASN1Enumerated" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.ASN1Enumerated" name="java.math.BigInteger getValue()" map="&#x0185;"/>
  <method class="org.bouncycastle.asn1.ASN1Enumerated" name="boolean isConstructed()" map="&#x016b;"/>
  <class name="org.bouncycastle.asn1.ASN1ApplicationSpecificParser" map="R"/>
  <class name="org.bouncycastle.asn1.BEROctetStringParser" map="S"/>
  <field class="org.bouncycastle.asn1.BEROctetStringParser" name="_parser" map="&#x041d;"/>
  <method class="org.bouncycastle.asn1.BEROctetStringParser" name="org.bouncycastle.asn1.ASN1Primitive getLoadedObject()" map="B"/>
  <method class="org.bouncycastle.asn1.BEROctetStringParser" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.BEROctetStringParser" name="java.io.InputStream getOctetStream()" map="&#x0172;"/>
  <class name="org.bouncycastle.asn1.ASN1TaggedObject" map="T"/>
  <field class="org.bouncycastle.asn1.ASN1TaggedObject" name="explicit" map="&#x0446;"/>
  <field class="org.bouncycastle.asn1.ASN1TaggedObject" name="tagNo" map="&#x0447;"/>
  <field class="org.bouncycastle.asn1.ASN1TaggedObject" name="empty" map="&#x0448;"/>
  <field class="org.bouncycastle.asn1.ASN1TaggedObject" name="obj" map="&#x0449;"/>
  <method class="org.bouncycastle.asn1.ASN1TaggedObject" name="org.bouncycastle.asn1.ASN1Primitive getObject()" map="&#x019c;"/>
  <method class="org.bouncycastle.asn1.ASN1TaggedObject" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.ASN1TaggedObject" name="int getTagNo()" map="&#x019d;"/>
  <method class="org.bouncycastle.asn1.ASN1TaggedObject" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1TaggedObject" name="org.bouncycastle.asn1.ASN1TaggedObject getInstance(java.lang.Object)" map="&#x00e4;"/>
  <method class="org.bouncycastle.asn1.ASN1TaggedObject" name="org.bouncycastle.asn1.ASN1TaggedObject getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="b"/>
  <method class="org.bouncycastle.asn1.ASN1TaggedObject" name="org.bouncycastle.asn1.ASN1Primitive toDLObject()" map="&#x0168;"/>
  <method class="org.bouncycastle.asn1.ASN1TaggedObject" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.ASN1TaggedObject" name="org.bouncycastle.asn1.ASN1Primitive toDERObject()" map="&#x016a;"/>
  <method class="org.bouncycastle.asn1.ASN1TaggedObject" name="boolean isExplicit()" map="&#x019e;"/>
  <method class="org.bouncycastle.asn1.ASN1TaggedObject" name="org.bouncycastle.asn1.ASN1Primitive getLoadedObject()" map="B"/>
  <method class="org.bouncycastle.asn1.ASN1TaggedObject" name="boolean isEmpty()" map="&#x019f;"/>
  <class name="org.bouncycastle.asn1.DERIA5String" map="U"/>
  <field class="org.bouncycastle.asn1.DERIA5String" name="string" map="&#x0414;"/>
  <method class="org.bouncycastle.asn1.DERIA5String" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.DERIA5String" name="boolean isIA5String(java.lang.String)" map="E"/>
  <method class="org.bouncycastle.asn1.DERIA5String" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.DERIA5String" name="org.bouncycastle.asn1.DERIA5String getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="T"/>
  <method class="org.bouncycastle.asn1.DERIA5String" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.DERIA5String" name="org.bouncycastle.asn1.DERIA5String getInstance(java.lang.Object)" map="&#x00d9;"/>
  <method class="org.bouncycastle.asn1.DERIA5String" name="java.lang.String getString()" map="&#x016c;"/>
  <method class="org.bouncycastle.asn1.DERIA5String" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.DERIA5String" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERIA5String" name="boolean isConstructed()" map="&#x016b;"/>
  <class name="org.bouncycastle.asn1.ASN1GeneralizedTime" map="V"/>
  <field class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="time" map="&#x0431;"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="java.util.Date getDate()" map="&#x0186;"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="java.lang.String convert(int)" map="E"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="org.bouncycastle.asn1.ASN1GeneralizedTime getInstance(java.lang.Object)" map="&#x00df;"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="boolean isDigit(int)" map="F"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="boolean hasSeconds()" map="&#x0187;"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="boolean hasFractionalSeconds()" map="&#x0188;"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="org.bouncycastle.asn1.ASN1Primitive toDERObject()" map="&#x016a;"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="java.lang.String getTime()" map="&#x0189;"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="java.lang.String calculateGMTOffset()" map="&#x018a;"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="boolean hasMinutes()" map="&#x018b;"/>
  <method class="org.bouncycastle.asn1.ASN1GeneralizedTime" name="org.bouncycastle.asn1.ASN1GeneralizedTime getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="Z"/>
  <class name="org.bouncycastle.asn1.ASN1ObjectIdentifier$OidHandle" map="_A"/>
  <field class="org.bouncycastle.asn1.ASN1ObjectIdentifier$OidHandle" name="enc" map="A"/>
  <field class="org.bouncycastle.asn1.ASN1ObjectIdentifier$OidHandle" name="key" map="B"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier$OidHandle" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier$OidHandle" name="int hashCode()" map="hashCode"/>
  <class name="org.bouncycastle.asn1.ASN1ObjectIdentifier" map="W"/>
  <field class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="body" map="&#x0432;"/>
  <field class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="identifier" map="&#x0433;"/>
  <field class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="pool" map="&#x0434;"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="org.bouncycastle.asn1.ASN1ObjectIdentifier intern()" map="&#x018d;"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="org.bouncycastle.asn1.ASN1ObjectIdentifier branch(java.lang.String)" map="F"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="void doOutput(java.io.ByteArrayOutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="byte[] getBody()" map="&#x018e;"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getInstance(java.lang.Object)" map="&#x00e0;"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="void writeField(java.io.ByteArrayOutputStream, java.math.BigInteger)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="java.lang.String getId()" map="&#x018f;"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="org.bouncycastle.asn1.ASN1ObjectIdentifier fromOctetString(byte[])" map="F"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="boolean isValidBranchID(java.lang.String, int)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="_"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="boolean isValidIdentifier(java.lang.String)" map="G"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.ASN1ObjectIdentifier" name="void writeField(java.io.ByteArrayOutputStream, long)" map="A"/>
  <class name="org.bouncycastle.asn1.ASN1ParsingException" map="X"/>
  <field class="org.bouncycastle.asn1.ASN1ParsingException" name="cause" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1ParsingException" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="org.bouncycastle.asn1.BERTags" map="Y"/>
  <class name="org.bouncycastle.asn1.DEROctetStringParser" map="Z"/>
  <field class="org.bouncycastle.asn1.DEROctetStringParser" name="stream" map="&#x041e;"/>
  <method class="org.bouncycastle.asn1.DEROctetStringParser" name="org.bouncycastle.asn1.ASN1Primitive getLoadedObject()" map="B"/>
  <method class="org.bouncycastle.asn1.DEROctetStringParser" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.DEROctetStringParser" name="java.io.InputStream getOctetStream()" map="&#x0172;"/>
  <class name="org.bouncycastle.asn1.ASN1TaggedObjectParser" map="_"/>
  <class name="org.bouncycastle.asn1.BERSetParser" map="a"/>
  <field class="org.bouncycastle.asn1.BERSetParser" name="_parser" map="&#x044f;"/>
  <method class="org.bouncycastle.asn1.BERSetParser" name="org.bouncycastle.asn1.ASN1Primitive getLoadedObject()" map="B"/>
  <method class="org.bouncycastle.asn1.BERSetParser" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.ASN1String" map="b"/>
  <method class="org.bouncycastle.asn1.ASN1String" name="java.lang.String getString()" map="&#x016c;"/>
  <class name="org.bouncycastle.asn1.ASN1SetParser" map="c"/>
  <class name="org.bouncycastle.asn1.ASN1Encodable" map="d"/>
  <method class="org.bouncycastle.asn1.ASN1Encodable" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.ASN1InputStream" map="e"/>
  <field class="org.bouncycastle.asn1.ASN1InputStream" name="limit" map="A"/>
  <field class="org.bouncycastle.asn1.ASN1InputStream" name="lazyEvaluate" map="B"/>
  <field class="org.bouncycastle.asn1.ASN1InputStream" name="tmpBuffers" map="C"/>
  <method class="org.bouncycastle.asn1.ASN1InputStream" name="byte[] getBuffer(org.bouncycastle.asn1.DefiniteLengthInputStream, byte[][])" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1InputStream" name="int readTagNumber(java.io.InputStream, int)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1InputStream" name="org.bouncycastle.asn1.ASN1EncodableVector buildDEREncodableVector(org.bouncycastle.asn1.DefiniteLengthInputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1InputStream" name="int getLimit()" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1InputStream" name="char[] getBMPCharBuffer(org.bouncycastle.asn1.DefiniteLengthInputStream)" map="B"/>
  <method class="org.bouncycastle.asn1.ASN1InputStream" name="org.bouncycastle.asn1.ASN1EncodableVector buildEncodableVector()" map="B"/>
  <method class="org.bouncycastle.asn1.ASN1InputStream" name="org.bouncycastle.asn1.ASN1Primitive readObject()" map="C"/>
  <method class="org.bouncycastle.asn1.ASN1InputStream" name="int readLength()" map="D"/>
  <method class="org.bouncycastle.asn1.ASN1InputStream" name="org.bouncycastle.asn1.ASN1Primitive createPrimitiveDERObject(int, org.bouncycastle.asn1.DefiniteLengthInputStream, byte[][])" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1InputStream" name="org.bouncycastle.asn1.ASN1Primitive buildObject(int, int, int)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1InputStream" name="int readLength(java.io.InputStream, int)" map="B"/>
  <class name="org.bouncycastle.asn1.BERTaggedObjectParser" map="f"/>
  <field class="org.bouncycastle.asn1.BERTaggedObjectParser" name="_parser" map="&#x044c;"/>
  <field class="org.bouncycastle.asn1.BERTaggedObjectParser" name="_constructed" map="&#x044d;"/>
  <field class="org.bouncycastle.asn1.BERTaggedObjectParser" name="_tagNumber" map="&#x044e;"/>
  <method class="org.bouncycastle.asn1.BERTaggedObjectParser" name="org.bouncycastle.asn1.ASN1Primitive getLoadedObject()" map="B"/>
  <method class="org.bouncycastle.asn1.BERTaggedObjectParser" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.DERNull" map="g"/>
  <field class="org.bouncycastle.asn1.DERNull" name="INSTANCE" map="&#x0435;"/>
  <field class="org.bouncycastle.asn1.DERNull" name="zeroBytes" map="&#x0436;"/>
  <method class="org.bouncycastle.asn1.DERNull" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERNull" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DERNull" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.ASN1Sequence" map="h"/>
  <field class="org.bouncycastle.asn1.ASN1Sequence" name="seq" map="&#x0423;"/>
  <method class="org.bouncycastle.asn1.ASN1Sequence" name="org.bouncycastle.asn1.ASN1Encodable[] toArray()" map="&#x0177;"/>
  <method class="org.bouncycastle.asn1.ASN1Sequence" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.ASN1Sequence" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="org.bouncycastle.asn1.ASN1Sequence" name="org.bouncycastle.asn1.ASN1Encodable getNext(java.util.Enumeration)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Sequence" name="org.bouncycastle.asn1.ASN1Encodable getObjectAt(int)" map="C"/>
  <method class="org.bouncycastle.asn1.ASN1Sequence" name="org.bouncycastle.asn1.ASN1Sequence getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="W"/>
  <method class="org.bouncycastle.asn1.ASN1Sequence" name="java.util.Enumeration getObjects()" map="&#x0178;"/>
  <method class="org.bouncycastle.asn1.ASN1Sequence" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Sequence" name="org.bouncycastle.asn1.ASN1Sequence getInstance(java.lang.Object)" map="&#x00dc;"/>
  <method class="org.bouncycastle.asn1.ASN1Sequence" name="org.bouncycastle.asn1.ASN1Primitive toDLObject()" map="&#x0168;"/>
  <method class="org.bouncycastle.asn1.ASN1Sequence" name="int size()" map="&#x0179;"/>
  <method class="org.bouncycastle.asn1.ASN1Sequence" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.ASN1Sequence" name="org.bouncycastle.asn1.ASN1Primitive toDERObject()" map="&#x016a;"/>
  <method class="org.bouncycastle.asn1.ASN1Sequence" name="boolean isConstructed()" map="&#x016b;"/>
  <class name="org.bouncycastle.asn1.DERUTF8String" map="i"/>
  <field class="org.bouncycastle.asn1.DERUTF8String" name="string" map="&#x0415;"/>
  <method class="org.bouncycastle.asn1.DERUTF8String" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.DERUTF8String" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.DERUTF8String" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERUTF8String" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DERUTF8String" name="java.lang.String getString()" map="&#x016c;"/>
  <method class="org.bouncycastle.asn1.DERUTF8String" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.DERUTF8String" name="java.lang.String toString()" map="toString"/>
  <class name="org.bouncycastle.asn1.DERApplicationSpecific" map="j"/>
  <method class="org.bouncycastle.asn1.DERApplicationSpecific" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.DERApplicationSpecific" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.DLSequence" map="k"/>
  <field class="org.bouncycastle.asn1.DLSequence" name="bodyLength" map="&#x0424;"/>
  <method class="org.bouncycastle.asn1.DLSequence" name="int getBodyLength()" map="&#x017a;"/>
  <method class="org.bouncycastle.asn1.DLSequence" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DLSequence" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.ASN1OutputStream$ImplicitOutputStream" map="_A"/>
  <field class="org.bouncycastle.asn1.ASN1OutputStream$ImplicitOutputStream" name="this$0" map="B"/>
  <field class="org.bouncycastle.asn1.ASN1OutputStream$ImplicitOutputStream" name="first" map="C"/>
  <method class="org.bouncycastle.asn1.ASN1OutputStream$ImplicitOutputStream" name="void write(int)" map="A"/>
  <class name="org.bouncycastle.asn1.ASN1OutputStream" map="l"/>
  <field class="org.bouncycastle.asn1.ASN1OutputStream" name="os" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1OutputStream" name="org.bouncycastle.asn1.ASN1OutputStream getDERSubStream()" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1OutputStream" name="void close()" map="B"/>
  <method class="org.bouncycastle.asn1.ASN1OutputStream" name="void write(int)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1OutputStream" name="void writeEncoded(int, int, byte[])" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1OutputStream" name="void write(byte[])" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1OutputStream" name="org.bouncycastle.asn1.ASN1OutputStream getDLSubStream()" map="C"/>
  <method class="org.bouncycastle.asn1.ASN1OutputStream" name="void write(byte[], int, int)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1OutputStream" name="void writeLength(int)" map="B"/>
  <method class="org.bouncycastle.asn1.ASN1OutputStream" name="void writeObject(org.bouncycastle.asn1.ASN1Encodable)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1OutputStream" name="void writeEncoded(int, byte[])" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1OutputStream" name="void writeTag(int, int)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1OutputStream" name="void writeImplicitObject(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <class name="org.bouncycastle.asn1.DERBitString" map="m"/>
  <method class="org.bouncycastle.asn1.DERBitString" name="org.bouncycastle.asn1.DERBitString fromOctetString(byte[])" map="D"/>
  <method class="org.bouncycastle.asn1.DERBitString" name="org.bouncycastle.asn1.DERBitString getInstance(java.lang.Object)" map="&#x00da;"/>
  <method class="org.bouncycastle.asn1.DERBitString" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERBitString" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DERBitString" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.DERBitString" name="org.bouncycastle.asn1.DERBitString getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="U"/>
  <class name="org.bouncycastle.asn1.DLSet" map="n"/>
  <field class="org.bouncycastle.asn1.DLSet" name="bodyLength" map="&#x042e;"/>
  <method class="org.bouncycastle.asn1.DLSet" name="int getBodyLength()" map="&#x0184;"/>
  <method class="org.bouncycastle.asn1.DLSet" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DLSet" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.InMemoryRepresentable" map="o"/>
  <method class="org.bouncycastle.asn1.InMemoryRepresentable" name="org.bouncycastle.asn1.ASN1Primitive getLoadedObject()" map="B"/>
  <class name="org.bouncycastle.asn1.BERTaggedObject" map="p"/>
  <method class="org.bouncycastle.asn1.BERTaggedObject" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.BERTaggedObject" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.BERTaggedObject" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.DERGeneralString" map="q"/>
  <field class="org.bouncycastle.asn1.DERGeneralString" name="string" map="&#x0416;"/>
  <method class="org.bouncycastle.asn1.DERGeneralString" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.DERGeneralString" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.DERGeneralString" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERGeneralString" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DERGeneralString" name="java.lang.String getString()" map="&#x016c;"/>
  <method class="org.bouncycastle.asn1.DERGeneralString" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.DERGeneralString" name="java.lang.String toString()" map="toString"/>
  <class name="org.bouncycastle.asn1.DERSequence" map="r"/>
  <field class="org.bouncycastle.asn1.DERSequence" name="bodyLength" map="&#x0425;"/>
  <method class="org.bouncycastle.asn1.DERSequence" name="int getBodyLength()" map="&#x017b;"/>
  <method class="org.bouncycastle.asn1.DERSequence" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERSequence" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.DLTaggedObject" map="s"/>
  <field class="org.bouncycastle.asn1.DLTaggedObject" name="ZERO_BYTES" map="&#x044a;"/>
  <method class="org.bouncycastle.asn1.DLTaggedObject" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DLTaggedObject" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DLTaggedObject" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.DERTaggedObject" map="t"/>
  <field class="org.bouncycastle.asn1.DERTaggedObject" name="ZERO_BYTES" map="&#x044b;"/>
  <method class="org.bouncycastle.asn1.DERTaggedObject" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERTaggedObject" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DERTaggedObject" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.ASN1OctetStringParser" map="u"/>
  <method class="org.bouncycastle.asn1.ASN1OctetStringParser" name="java.io.InputStream getOctetStream()" map="&#x0172;"/>
  <class name="org.bouncycastle.asn1.ASN1EncodableVector" map="v"/>
  <field class="org.bouncycastle.asn1.ASN1EncodableVector" name="v" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1EncodableVector" name="void add(org.bouncycastle.asn1.ASN1Encodable)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1EncodableVector" name="int size()" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1EncodableVector" name="org.bouncycastle.asn1.ASN1Encodable get(int)" map="A"/>
  <class name="org.bouncycastle.asn1.IndefiniteLengthInputStream" map="w"/>
  <field class="org.bouncycastle.asn1.IndefiniteLengthInputStream" name="_eofReached" map="C"/>
  <field class="org.bouncycastle.asn1.IndefiniteLengthInputStream" name="_eofOn00" map="D"/>
  <field class="org.bouncycastle.asn1.IndefiniteLengthInputStream" name="_b2" map="E"/>
  <field class="org.bouncycastle.asn1.IndefiniteLengthInputStream" name="_b1" map="F"/>
  <method class="org.bouncycastle.asn1.IndefiniteLengthInputStream" name="int read()" map="read"/>
  <method class="org.bouncycastle.asn1.IndefiniteLengthInputStream" name="void setEofOn00(boolean)" map="B"/>
  <method class="org.bouncycastle.asn1.IndefiniteLengthInputStream" name="boolean checkForEof()" map="B"/>
  <method class="org.bouncycastle.asn1.IndefiniteLengthInputStream" name="int read(byte[], int, int)" map="read"/>
  <class name="org.bouncycastle.asn1.BERApplicationSpecific" map="x"/>
  <method class="org.bouncycastle.asn1.BERApplicationSpecific" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.BERApplicationSpecific" name="byte[] getEncodedVector(org.bouncycastle.asn1.ASN1EncodableVector)" map="A"/>
  <class name="org.bouncycastle.asn1.ASN1Primitive" map="y"/>
  <method class="org.bouncycastle.asn1.ASN1Primitive" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Primitive" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.ASN1Primitive" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.asn1.ASN1Primitive" name="org.bouncycastle.asn1.ASN1Primitive fromByteArray(byte[])" map="C"/>
  <method class="org.bouncycastle.asn1.ASN1Primitive" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Primitive" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Primitive" name="org.bouncycastle.asn1.ASN1Primitive toDLObject()" map="&#x0168;"/>
  <method class="org.bouncycastle.asn1.ASN1Primitive" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.ASN1Primitive" name="org.bouncycastle.asn1.ASN1Primitive toDERObject()" map="&#x016a;"/>
  <method class="org.bouncycastle.asn1.ASN1Primitive" name="boolean isConstructed()" map="&#x016b;"/>
  <class name="org.bouncycastle.asn1.ASN1StreamParser" map="z"/>
  <field class="org.bouncycastle.asn1.ASN1StreamParser" name="_in" map="A"/>
  <field class="org.bouncycastle.asn1.ASN1StreamParser" name="_limit" map="B"/>
  <field class="org.bouncycastle.asn1.ASN1StreamParser" name="tmpBuffers" map="C"/>
  <method class="org.bouncycastle.asn1.ASN1StreamParser" name="void set00Check(boolean)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1StreamParser" name="org.bouncycastle.asn1.ASN1Primitive readTaggedObject(boolean, int)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1StreamParser" name="org.bouncycastle.asn1.ASN1Encodable readIndef(int)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1StreamParser" name="org.bouncycastle.asn1.ASN1EncodableVector readVector()" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1StreamParser" name="org.bouncycastle.asn1.ASN1Encodable readObject()" map="B"/>
  <class name="org.bouncycastle.asn1.OIDTokenizer" map="$A"/>
  <field class="org.bouncycastle.asn1.OIDTokenizer" name="index" map="A"/>
  <field class="org.bouncycastle.asn1.OIDTokenizer" name="oid" map="B"/>
  <method class="org.bouncycastle.asn1.OIDTokenizer" name="boolean hasMoreTokens()" map="A"/>
  <method class="org.bouncycastle.asn1.OIDTokenizer" name="java.lang.String nextToken()" map="B"/>
  <class name="org.bouncycastle.asn1.ASN1Null" map="AA"/>
  <method class="org.bouncycastle.asn1.ASN1Null" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Null" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.ASN1Null" name="java.lang.String toString()" map="toString"/>
  <class name="org.bouncycastle.asn1.BERConstructedOctetString" map="BA"/>
  <field class="org.bouncycastle.asn1.BERConstructedOctetString" name="octs" map="&#x0422;"/>
  <method class="org.bouncycastle.asn1.BERConstructedOctetString" name="java.util.Enumeration getObjects()" map="&#x0175;"/>
  <method class="org.bouncycastle.asn1.BERConstructedOctetString" name="java.util.Vector generateOcts()" map="&#x0176;"/>
  <method class="org.bouncycastle.asn1.BERConstructedOctetString" name="org.bouncycastle.asn1.BEROctetString fromSequence(org.bouncycastle.asn1.ASN1Sequence)" map="A"/>
  <method class="org.bouncycastle.asn1.BERConstructedOctetString" name="byte[] toBytes(java.util.Vector)" map="A"/>
  <method class="org.bouncycastle.asn1.BERConstructedOctetString" name="byte[] getOctets()" map="&#x0173;"/>
  <class name="org.bouncycastle.asn1.ASN1Integer" map="CA"/>
  <field class="org.bouncycastle.asn1.ASN1Integer" name="bytes" map="&#x0437;"/>
  <method class="org.bouncycastle.asn1.ASN1Integer" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Integer" name="org.bouncycastle.asn1.ASN1Integer getInstance(java.lang.Object)" map="&#x00e1;"/>
  <method class="org.bouncycastle.asn1.ASN1Integer" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.ASN1Integer" name="boolean isMalformed(byte[])" map="G"/>
  <method class="org.bouncycastle.asn1.ASN1Integer" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Integer" name="org.bouncycastle.asn1.ASN1Integer getInstance(org.bouncycastle.asn1.ASN1TaggedObject, boolean)" map="a"/>
  <method class="org.bouncycastle.asn1.ASN1Integer" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.ASN1Integer" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.ASN1Integer" name="java.math.BigInteger getValue()" map="&#x0190;"/>
  <method class="org.bouncycastle.asn1.ASN1Integer" name="boolean isConstructed()" map="&#x016b;"/>
  <class name="org.bouncycastle.asn1.DLBitString" map="DA"/>
  <method class="org.bouncycastle.asn1.DLBitString" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DLBitString" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DLBitString" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.DERGeneralizedTime" map="EA"/>
  <method class="org.bouncycastle.asn1.DERGeneralizedTime" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERGeneralizedTime" name="byte[] getDERTime()" map="&#x018c;"/>
  <method class="org.bouncycastle.asn1.DERGeneralizedTime" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.DERSetParser" map="FA"/>
  <field class="org.bouncycastle.asn1.DERSetParser" name="_parser" map="&#x0451;"/>
  <method class="org.bouncycastle.asn1.DERSetParser" name="org.bouncycastle.asn1.ASN1Primitive getLoadedObject()" map="B"/>
  <method class="org.bouncycastle.asn1.DERSetParser" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.DERVisibleString" map="GA"/>
  <field class="org.bouncycastle.asn1.DERVisibleString" name="string" map="&#x0417;"/>
  <method class="org.bouncycastle.asn1.DERVisibleString" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.DERVisibleString" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.DERVisibleString" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERVisibleString" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DERVisibleString" name="java.lang.String getString()" map="&#x016c;"/>
  <method class="org.bouncycastle.asn1.DERVisibleString" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.DERVisibleString" name="java.lang.String toString()" map="toString"/>
  <class name="org.bouncycastle.asn1.ASN1Object" map="HA"/>
  <method class="org.bouncycastle.asn1.ASN1Object" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.asn1.ASN1Object" name="byte[] getEncoded(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Object" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.ASN1Object" name="byte[] getEncoded()" map="P"/>
  <method class="org.bouncycastle.asn1.ASN1Object" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.DERBMPString" map="IA"/>
  <field class="org.bouncycastle.asn1.DERBMPString" name="string" map="&#x0418;"/>
  <method class="org.bouncycastle.asn1.DERBMPString" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.DERBMPString" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.DERBMPString" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERBMPString" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DERBMPString" name="java.lang.String getString()" map="&#x016c;"/>
  <method class="org.bouncycastle.asn1.DERBMPString" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.DERBMPString" name="java.lang.String toString()" map="toString"/>
  <class name="org.bouncycastle.asn1.LimitedInputStream" map="JA"/>
  <field class="org.bouncycastle.asn1.LimitedInputStream" name="_in" map="A"/>
  <field class="org.bouncycastle.asn1.LimitedInputStream" name="_limit" map="B"/>
  <method class="org.bouncycastle.asn1.LimitedInputStream" name="void setParentEofDetect(boolean)" map="A"/>
  <method class="org.bouncycastle.asn1.LimitedInputStream" name="int getRemaining()" map="A"/>
  <class name="org.bouncycastle.asn1.BERSequence" map="KA"/>
  <method class="org.bouncycastle.asn1.BERSequence" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.BERSequence" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.DEROutputStream" map="LA"/>
  <method class="org.bouncycastle.asn1.DEROutputStream" name="org.bouncycastle.asn1.ASN1OutputStream getDLSubStream()" map="C"/>
  <method class="org.bouncycastle.asn1.DEROutputStream" name="void writeObject(org.bouncycastle.asn1.ASN1Encodable)" map="A"/>
  <method class="org.bouncycastle.asn1.DEROutputStream" name="org.bouncycastle.asn1.ASN1OutputStream getDERSubStream()" map="A"/>
  <class name="org.bouncycastle.asn1.DLOutputStream" map="MA"/>
  <method class="org.bouncycastle.asn1.DLOutputStream" name="void writeObject(org.bouncycastle.asn1.ASN1Encodable)" map="A"/>
  <class name="org.bouncycastle.asn1.ASN1Choice" map="NA"/>
  <class name="org.bouncycastle.asn1.DERSequenceParser" map="OA"/>
  <field class="org.bouncycastle.asn1.DERSequenceParser" name="_parser" map="&#x0453;"/>
  <method class="org.bouncycastle.asn1.DERSequenceParser" name="org.bouncycastle.asn1.ASN1Primitive getLoadedObject()" map="B"/>
  <method class="org.bouncycastle.asn1.DERSequenceParser" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.asn1.DEROctetString" map="PA"/>
  <method class="org.bouncycastle.asn1.DEROctetString" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DEROctetString" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DEROctetString" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.DERExternal" map="QA"/>
  <field class="org.bouncycastle.asn1.DERExternal" name="directReference" map="&#x0438;"/>
  <field class="org.bouncycastle.asn1.DERExternal" name="encoding" map="&#x0439;"/>
  <field class="org.bouncycastle.asn1.DERExternal" name="dataValueDescriptor" map="&#x043a;"/>
  <field class="org.bouncycastle.asn1.DERExternal" name="indirectReference" map="&#x043b;"/>
  <field class="org.bouncycastle.asn1.DERExternal" name="externalContent" map="&#x043c;"/>
  <method class="org.bouncycastle.asn1.DERExternal" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.DERExternal" name="org.bouncycastle.asn1.ASN1Primitive getExternalContent()" map="&#x0191;"/>
  <method class="org.bouncycastle.asn1.DERExternal" name="org.bouncycastle.asn1.ASN1Primitive getObjFromVector(org.bouncycastle.asn1.ASN1EncodableVector, int)" map="A"/>
  <method class="org.bouncycastle.asn1.DERExternal" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.DERExternal" name="void setEncoding(int)" map="G"/>
  <method class="org.bouncycastle.asn1.DERExternal" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.DERExternal" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getDirectReference()" map="&#x0192;"/>
  <method class="org.bouncycastle.asn1.DERExternal" name="org.bouncycastle.asn1.ASN1Primitive getDataValueDescriptor()" map="&#x0193;"/>
  <method class="org.bouncycastle.asn1.DERExternal" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERExternal" name="org.bouncycastle.asn1.ASN1Integer getIndirectReference()" map="&#x0194;"/>
  <method class="org.bouncycastle.asn1.DERExternal" name="int getEncoding()" map="&#x0195;"/>
  <method class="org.bouncycastle.asn1.DERExternal" name="boolean isConstructed()" map="&#x016b;"/>
  <class name="org.bouncycastle.asn1.LazyEncodedSequence" map="RA"/>
  <field class="org.bouncycastle.asn1.LazyEncodedSequence" name="encoded" map="&#x0426;"/>
  <method class="org.bouncycastle.asn1.LazyEncodedSequence" name="void parse()" map="&#x017c;"/>
  <method class="org.bouncycastle.asn1.LazyEncodedSequence" name="java.util.Enumeration getObjects()" map="&#x0178;"/>
  <method class="org.bouncycastle.asn1.LazyEncodedSequence" name="int size()" map="&#x0179;"/>
  <method class="org.bouncycastle.asn1.LazyEncodedSequence" name="org.bouncycastle.asn1.ASN1Primitive toDLObject()" map="&#x0168;"/>
  <method class="org.bouncycastle.asn1.LazyEncodedSequence" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.LazyEncodedSequence" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.LazyEncodedSequence" name="org.bouncycastle.asn1.ASN1Primitive toDERObject()" map="&#x016a;"/>
  <method class="org.bouncycastle.asn1.LazyEncodedSequence" name="org.bouncycastle.asn1.ASN1Encodable getObjectAt(int)" map="C"/>
  <class name="org.bouncycastle.asn1.BERSet" map="SA"/>
  <method class="org.bouncycastle.asn1.BERSet" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.BERSet" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.ConstructedOctetStream" map="TA"/>
  <field class="org.bouncycastle.asn1.ConstructedOctetStream" name="_parser" map="A"/>
  <field class="org.bouncycastle.asn1.ConstructedOctetStream" name="_first" map="B"/>
  <field class="org.bouncycastle.asn1.ConstructedOctetStream" name="_currentStream" map="C"/>
  <method class="org.bouncycastle.asn1.ConstructedOctetStream" name="int read()" map="read"/>
  <method class="org.bouncycastle.asn1.ConstructedOctetStream" name="int read(byte[], int, int)" map="read"/>
  <class name="org.bouncycastle.asn1.BERFactory" map="UA"/>
  <field class="org.bouncycastle.asn1.BERFactory" name="EMPTY_SET" map="A"/>
  <field class="org.bouncycastle.asn1.BERFactory" name="EMPTY_SEQUENCE" map="B"/>
  <method class="org.bouncycastle.asn1.BERFactory" name="org.bouncycastle.asn1.BERSequence createSequence(org.bouncycastle.asn1.ASN1EncodableVector)" map="A"/>
  <class name="org.bouncycastle.asn1.ASN1ApplicationSpecific" map="VA"/>
  <field class="org.bouncycastle.asn1.ASN1ApplicationSpecific" name="tag" map="&#x043d;"/>
  <field class="org.bouncycastle.asn1.ASN1ApplicationSpecific" name="octets" map="&#x043e;"/>
  <field class="org.bouncycastle.asn1.ASN1ApplicationSpecific" name="isConstructed" map="&#x043f;"/>
  <method class="org.bouncycastle.asn1.ASN1ApplicationSpecific" name="int getApplicationTag()" map="&#x0196;"/>
  <method class="org.bouncycastle.asn1.ASN1ApplicationSpecific" name="org.bouncycastle.asn1.ASN1ApplicationSpecific getInstance(java.lang.Object)" map="&#x00e2;"/>
  <method class="org.bouncycastle.asn1.ASN1ApplicationSpecific" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.ASN1ApplicationSpecific" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1ApplicationSpecific" name="org.bouncycastle.asn1.ASN1Primitive getObject(int)" map="H"/>
  <method class="org.bouncycastle.asn1.ASN1ApplicationSpecific" name="byte[] replaceTagNumber(int, byte[])" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1ApplicationSpecific" name="byte[] getContents()" map="&#x0197;"/>
  <method class="org.bouncycastle.asn1.ASN1ApplicationSpecific" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.ASN1ApplicationSpecific" name="boolean isConstructed()" map="&#x016b;"/>
  <class name="org.bouncycastle.asn1.ASN1UTCTime" map="WA"/>
  <field class="org.bouncycastle.asn1.ASN1UTCTime" name="time" map="&#x0440;"/>
  <method class="org.bouncycastle.asn1.ASN1UTCTime" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1UTCTime" name="java.lang.String getAdjustedTime()" map="&#x0198;"/>
  <method class="org.bouncycastle.asn1.ASN1UTCTime" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.ASN1UTCTime" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1UTCTime" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.ASN1UTCTime" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.ASN1UTCTime" name="java.util.Date getAdjustedDate()" map="&#x0199;"/>
  <method class="org.bouncycastle.asn1.ASN1UTCTime" name="java.lang.String getTime()" map="&#x019a;"/>
  <method class="org.bouncycastle.asn1.ASN1UTCTime" name="boolean isConstructed()" map="&#x016b;"/>
  <class name="org.bouncycastle.asn1.DERFactory" map="XA"/>
  <field class="org.bouncycastle.asn1.DERFactory" name="EMPTY_SET" map="A"/>
  <field class="org.bouncycastle.asn1.DERFactory" name="EMPTY_SEQUENCE" map="B"/>
  <method class="org.bouncycastle.asn1.DERFactory" name="org.bouncycastle.asn1.ASN1Set createSet(org.bouncycastle.asn1.ASN1EncodableVector)" map="A"/>
  <method class="org.bouncycastle.asn1.DERFactory" name="org.bouncycastle.asn1.ASN1Sequence createSequence(org.bouncycastle.asn1.ASN1EncodableVector)" map="B"/>
  <class name="org.bouncycastle.asn1.ASN1Exception" map="YA"/>
  <field class="org.bouncycastle.asn1.ASN1Exception" name="cause" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Exception" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="org.bouncycastle.asn1.ASN1Boolean" map="ZA"/>
  <field class="org.bouncycastle.asn1.ASN1Boolean" name="TRUE_VALUE" map="&#x0441;"/>
  <field class="org.bouncycastle.asn1.ASN1Boolean" name="FALSE_VALUE" map="&#x0442;"/>
  <field class="org.bouncycastle.asn1.ASN1Boolean" name="TRUE" map="&#x0443;"/>
  <field class="org.bouncycastle.asn1.ASN1Boolean" name="FALSE" map="&#x0444;"/>
  <field class="org.bouncycastle.asn1.ASN1Boolean" name="value" map="&#x0445;"/>
  <method class="org.bouncycastle.asn1.ASN1Boolean" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Boolean" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.ASN1Boolean" name="boolean isTrue()" map="&#x019b;"/>
  <method class="org.bouncycastle.asn1.ASN1Boolean" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Boolean" name="org.bouncycastle.asn1.ASN1Boolean getInstance(boolean)" map="A"/>
  <method class="org.bouncycastle.asn1.ASN1Boolean" name="org.bouncycastle.asn1.ASN1Boolean fromOctetString(byte[])" map="H"/>
  <method class="org.bouncycastle.asn1.ASN1Boolean" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.asn1.ASN1Boolean" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.ASN1Boolean" name="org.bouncycastle.asn1.ASN1Boolean getInstance(java.lang.Object)" map="&#x00e3;"/>
  <method class="org.bouncycastle.asn1.ASN1Boolean" name="boolean isConstructed()" map="&#x016b;"/>
  <class name="org.bouncycastle.asn1.DERVideotexString" map="_A"/>
  <field class="org.bouncycastle.asn1.DERVideotexString" name="string" map="&#x0419;"/>
  <method class="org.bouncycastle.asn1.DERVideotexString" name="boolean asn1Equals(org.bouncycastle.asn1.ASN1Primitive)" map="A"/>
  <method class="org.bouncycastle.asn1.DERVideotexString" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.asn1.DERVideotexString" name="int encodedLength()" map="&#x0169;"/>
  <method class="org.bouncycastle.asn1.DERVideotexString" name="boolean isConstructed()" map="&#x016b;"/>
  <method class="org.bouncycastle.asn1.DERVideotexString" name="java.lang.String getString()" map="&#x016c;"/>
  <method class="org.bouncycastle.asn1.DERVideotexString" name="void encode(org.bouncycastle.asn1.ASN1OutputStream)" map="A"/>
  <class name="org.bouncycastle.asn1.StreamUtil" map="aA"/>
  <field class="org.bouncycastle.asn1.StreamUtil" name="MAX_MEMORY" map="A"/>
  <method class="org.bouncycastle.asn1.StreamUtil" name="int calculateTagLength(int)" map="A"/>
  <method class="org.bouncycastle.asn1.StreamUtil" name="int findLimit(java.io.InputStream)" map="A"/>
  <method class="org.bouncycastle.asn1.StreamUtil" name="int calculateBodyLength(int)" map="B"/>
  <package name="org.bouncycastle.tsp" map="F"/>
  <class name="org.bouncycastle.tsp.TimeStampRequestGenerator" map="A"/>
  <field class="org.bouncycastle.tsp.TimeStampRequestGenerator" name="reqPolicy" map="A"/>
  <field class="org.bouncycastle.tsp.TimeStampRequestGenerator" name="certReq" map="B"/>
  <field class="org.bouncycastle.tsp.TimeStampRequestGenerator" name="extGenerator" map="C"/>
  <method class="org.bouncycastle.tsp.TimeStampRequestGenerator" name="org.bouncycastle.tsp.TimeStampRequest generate(java.lang.String, byte[], java.math.BigInteger)" map="A"/>
  <method class="org.bouncycastle.tsp.TimeStampRequestGenerator" name="org.bouncycastle.tsp.TimeStampRequest generate(org.bouncycastle.asn1.ASN1ObjectIdentifier, byte[], java.math.BigInteger)" map="A"/>
  <method class="org.bouncycastle.tsp.TimeStampRequestGenerator" name="void setCertReq(boolean)" map="A"/>
  <class name="org.bouncycastle.tsp.TimeStampToken$CertID" map="_A"/>
  <field class="org.bouncycastle.tsp.TimeStampToken$CertID" name="this$0" map="A"/>
  <field class="org.bouncycastle.tsp.TimeStampToken$CertID" name="certID" map="B"/>
  <field class="org.bouncycastle.tsp.TimeStampToken$CertID" name="certIDv2" map="C"/>
  <class name="org.bouncycastle.tsp.TimeStampToken" map="B"/>
  <field class="org.bouncycastle.tsp.TimeStampToken" name="certID" map="A"/>
  <field class="org.bouncycastle.tsp.TimeStampToken" name="tstInfo" map="B"/>
  <field class="org.bouncycastle.tsp.TimeStampToken" name="tsaSignerInfo" map="C"/>
  <field class="org.bouncycastle.tsp.TimeStampToken" name="tsToken" map="D"/>
  <method class="org.bouncycastle.tsp.TimeStampToken" name="org.bouncycastle.cms.CMSSignedData getSignedData(org.bouncycastle.asn1.cms.ContentInfo)" map="A"/>
  <method class="org.bouncycastle.tsp.TimeStampToken" name="org.bouncycastle.asn1.cms.AttributeTable getSignedAttributes()" map="A"/>
  <method class="org.bouncycastle.tsp.TimeStampToken" name="boolean isSignatureValid(org.bouncycastle.cms.SignerInformationVerifier)" map="A"/>
  <method class="org.bouncycastle.tsp.TimeStampToken" name="org.bouncycastle.tsp.TimeStampTokenInfo getTimeStampInfo()" map="B"/>
  <method class="org.bouncycastle.tsp.TimeStampToken" name="byte[] getEncoded()" map="C"/>
  <class name="org.bouncycastle.tsp.TimeStampRequest" map="C"/>
  <field class="org.bouncycastle.tsp.TimeStampRequest" name="EMPTY_SET" map="A"/>
  <field class="org.bouncycastle.tsp.TimeStampRequest" name="extensions" map="B"/>
  <field class="org.bouncycastle.tsp.TimeStampRequest" name="req" map="C"/>
  <method class="org.bouncycastle.tsp.TimeStampRequest" name="java.math.BigInteger getNonce()" map="A"/>
  <method class="org.bouncycastle.tsp.TimeStampRequest" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getMessageImprintAlgOID()" map="B"/>
  <method class="org.bouncycastle.tsp.TimeStampRequest" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getReqPolicy()" map="C"/>
  <method class="org.bouncycastle.tsp.TimeStampRequest" name="byte[] getEncoded()" map="D"/>
  <method class="org.bouncycastle.tsp.TimeStampRequest" name="byte[] getMessageImprintDigest()" map="E"/>
  <class name="org.bouncycastle.tsp.TSPValidationException" map="D"/>
  <field class="org.bouncycastle.tsp.TSPValidationException" name="failureCode" map="B"/>
  <class name="org.bouncycastle.tsp.TimeStampResponse" map="E"/>
  <field class="org.bouncycastle.tsp.TimeStampResponse" name="timeStampToken" map="A"/>
  <field class="org.bouncycastle.tsp.TimeStampResponse" name="resp" map="B"/>
  <method class="org.bouncycastle.tsp.TimeStampResponse" name="org.bouncycastle.asn1.cmp.PKIFailureInfo getFailInfo()" map="A"/>
  <method class="org.bouncycastle.tsp.TimeStampResponse" name="void validate(org.bouncycastle.tsp.TimeStampRequest)" map="A"/>
  <method class="org.bouncycastle.tsp.TimeStampResponse" name="java.lang.String getStatusString()" map="B"/>
  <method class="org.bouncycastle.tsp.TimeStampResponse" name="org.bouncycastle.tsp.TimeStampToken getTimeStampToken()" map="C"/>
  <method class="org.bouncycastle.tsp.TimeStampResponse" name="org.bouncycastle.asn1.tsp.TimeStampResp readTimeStampResp(java.io.InputStream)" map="A"/>
  <method class="org.bouncycastle.tsp.TimeStampResponse" name="int getStatus()" map="D"/>
  <class name="org.bouncycastle.tsp.TSPException" map="F"/>
  <field class="org.bouncycastle.tsp.TSPException" name="underlyingException" map="A"/>
  <method class="org.bouncycastle.tsp.TSPException" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="org.bouncycastle.tsp.TimeStampTokenInfo" map="G"/>
  <field class="org.bouncycastle.tsp.TimeStampTokenInfo" name="tstInfo" map="A"/>
  <field class="org.bouncycastle.tsp.TimeStampTokenInfo" name="genTime" map="B"/>
  <method class="org.bouncycastle.tsp.TimeStampTokenInfo" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getPolicy()" map="A"/>
  <method class="org.bouncycastle.tsp.TimeStampTokenInfo" name="java.math.BigInteger getNonce()" map="B"/>
  <method class="org.bouncycastle.tsp.TimeStampTokenInfo" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getMessageImprintAlgOID()" map="C"/>
  <method class="org.bouncycastle.tsp.TimeStampTokenInfo" name="org.bouncycastle.asn1.tsp.TSTInfo toASN1Structure()" map="D"/>
  <method class="org.bouncycastle.tsp.TimeStampTokenInfo" name="java.util.Date getGenTime()" map="E"/>
  <method class="org.bouncycastle.tsp.TimeStampTokenInfo" name="byte[] getMessageImprintDigest()" map="F"/>
  <package name="org.bouncycastle.cert" map="G"/>
  <package name="org.bouncycastle.cert.selector" map="A"/>
  <class name="org.bouncycastle.cert.selector.X509CertificateHolderSelector" map="A"/>
  <field class="org.bouncycastle.cert.selector.X509CertificateHolderSelector" name="subjectKeyId" map="I"/>
  <field class="org.bouncycastle.cert.selector.X509CertificateHolderSelector" name="issuer" map="J"/>
  <field class="org.bouncycastle.cert.selector.X509CertificateHolderSelector" name="serialNumber" map="K"/>
  <method class="org.bouncycastle.cert.selector.X509CertificateHolderSelector" name="java.lang.Object clone()" map="clone"/>
  <method class="org.bouncycastle.cert.selector.X509CertificateHolderSelector" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.cert.selector.X509CertificateHolderSelector" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.cert.selector.X509CertificateHolderSelector" name="org.bouncycastle.asn1.x500.X500Name getIssuer()" map="D"/>
  <method class="org.bouncycastle.cert.selector.X509CertificateHolderSelector" name="boolean match(java.lang.Object)" map="A"/>
  <method class="org.bouncycastle.cert.selector.X509CertificateHolderSelector" name="boolean equalsObj(java.lang.Object, java.lang.Object)" map="B"/>
  <method class="org.bouncycastle.cert.selector.X509CertificateHolderSelector" name="byte[] getSubjectKeyIdentifier()" map="E"/>
  <method class="org.bouncycastle.cert.selector.X509CertificateHolderSelector" name="java.math.BigInteger getSerialNumber()" map="F"/>
  <class name="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$GeneralDigest" map="_A"/>
  <field class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$GeneralDigest" name="xBuf" map="A"/>
  <field class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$GeneralDigest" name="xBufOff" map="B"/>
  <field class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$GeneralDigest" name="byteCount" map="C"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$GeneralDigest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$GeneralDigest" name="void processLength(long)" map="A"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$GeneralDigest" name="void finish()" map="B"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$GeneralDigest" name="void processWord(byte[], int)" map="A"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$GeneralDigest" name="void update(byte[], int, int)" map="A"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$GeneralDigest" name="void update(byte)" map="A"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$GeneralDigest" name="void processBlock()" map="C"/>
  <class name="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" map="_B"/>
  <field class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="H5" map="D"/>
  <field class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="H4" map="E"/>
  <field class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="H3" map="F"/>
  <field class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="H2" map="G"/>
  <field class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="H1" map="H"/>
  <field class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="xOff" map="I"/>
  <field class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="X" map="J"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="void processLength(long)" map="A"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="void reset()" map="A"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="int g(int, int, int)" map="A"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="void processWord(byte[], int)" map="A"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="void processBlock()" map="C"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="int f(int, int, int)" map="B"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="int h(int, int, int)" map="C"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="int doFinal(byte[], int)" map="B"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator$SHA1Digest" name="int getDigestSize()" map="D"/>
  <class name="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator" map="B"/>
  <method class="org.bouncycastle.cert.selector.MSOutlookKeyIdCalculator" name="byte[] calculateKeyId(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)" map="A"/>
  <package name="org.bouncycastle.cert.jcajce" map="B"/>
  <class name="org.bouncycastle.cert.jcajce.CertHelper" map="A"/>
  <method class="org.bouncycastle.cert.jcajce.CertHelper" name="java.security.cert.CertificateFactory createCertificateFactory(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.cert.jcajce.CertHelper" name="java.security.cert.CertificateFactory getCertificateFactory(java.lang.String)" map="B"/>
  <class name="org.bouncycastle.cert.jcajce.JcaX509CertificateConverter$ExCertificateException" map="_A"/>
  <field class="org.bouncycastle.cert.jcajce.JcaX509CertificateConverter$ExCertificateException" name="this$0" map="A"/>
  <field class="org.bouncycastle.cert.jcajce.JcaX509CertificateConverter$ExCertificateException" name="cause" map="B"/>
  <method class="org.bouncycastle.cert.jcajce.JcaX509CertificateConverter$ExCertificateException" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="org.bouncycastle.cert.jcajce.JcaX509CertificateConverter$ExCertificateParsingException" map="_B"/>
  <field class="org.bouncycastle.cert.jcajce.JcaX509CertificateConverter$ExCertificateParsingException" name="this$0" map="A"/>
  <field class="org.bouncycastle.cert.jcajce.JcaX509CertificateConverter$ExCertificateParsingException" name="cause" map="B"/>
  <method class="org.bouncycastle.cert.jcajce.JcaX509CertificateConverter$ExCertificateParsingException" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="org.bouncycastle.cert.jcajce.JcaX509CertificateConverter" map="B"/>
  <field class="org.bouncycastle.cert.jcajce.JcaX509CertificateConverter" name="helper" map="A"/>
  <method class="org.bouncycastle.cert.jcajce.JcaX509CertificateConverter" name="java.security.cert.X509Certificate getCertificate(org.bouncycastle.cert.X509CertificateHolder)" map="A"/>
  <class name="org.bouncycastle.cert.jcajce.DefaultCertHelper" map="C"/>
  <method class="org.bouncycastle.cert.jcajce.DefaultCertHelper" name="java.security.cert.CertificateFactory createCertificateFactory(java.lang.String)" map="A"/>
  <class name="org.bouncycastle.cert.jcajce.JcaX509CertificateHolder" map="D"/>
  <package name="org.bouncycastle.cert.ocsp" map="C"/>
  <class name="org.bouncycastle.cert.ocsp.OCSPReq" map="A"/>
  <field class="org.bouncycastle.cert.ocsp.OCSPReq" name="extensions" map="A"/>
  <field class="org.bouncycastle.cert.ocsp.OCSPReq" name="req" map="B"/>
  <field class="org.bouncycastle.cert.ocsp.OCSPReq" name="EMPTY_CERTS" map="C"/>
  <method class="org.bouncycastle.cert.ocsp.OCSPReq" name="byte[] getEncoded()" map="A"/>
  <class name="org.bouncycastle.cert.ocsp.UnknownStatus" map="B"/>
  <class name="org.bouncycastle.cert.ocsp.OCSPResp" map="C"/>
  <field class="org.bouncycastle.cert.ocsp.OCSPResp" name="resp" map="A"/>
  <method class="org.bouncycastle.cert.ocsp.OCSPResp" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.cert.ocsp.OCSPResp" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.cert.ocsp.OCSPResp" name="java.lang.Object getResponseObject()" map="A"/>
  <method class="org.bouncycastle.cert.ocsp.OCSPResp" name="int getStatus()" map="B"/>
  <class name="org.bouncycastle.cert.ocsp.BasicOCSPResp" map="D"/>
  <field class="org.bouncycastle.cert.ocsp.BasicOCSPResp" name="extensions" map="D"/>
  <field class="org.bouncycastle.cert.ocsp.BasicOCSPResp" name="data" map="E"/>
  <field class="org.bouncycastle.cert.ocsp.BasicOCSPResp" name="resp" map="F"/>
  <method class="org.bouncycastle.cert.ocsp.BasicOCSPResp" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.cert.ocsp.BasicOCSPResp" name="byte[] getSignature()" map="C"/>
  <method class="org.bouncycastle.cert.ocsp.BasicOCSPResp" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.cert.ocsp.BasicOCSPResp" name="byte[] getEncoded()" map="D"/>
  <method class="org.bouncycastle.cert.ocsp.BasicOCSPResp" name="boolean isSignatureValid(org.bouncycastle.operator.ContentVerifierProvider)" map="A"/>
  <method class="org.bouncycastle.cert.ocsp.BasicOCSPResp" name="org.bouncycastle.cert.X509CertificateHolder[] getCerts()" map="E"/>
  <method class="org.bouncycastle.cert.ocsp.BasicOCSPResp" name="org.bouncycastle.cert.ocsp.SingleResp[] getResponses()" map="F"/>
  <class name="org.bouncycastle.cert.ocsp.OCSPReqBuilder$RequestObject" map="_A"/>
  <field class="org.bouncycastle.cert.ocsp.OCSPReqBuilder$RequestObject" name="this$0" map="A"/>
  <field class="org.bouncycastle.cert.ocsp.OCSPReqBuilder$RequestObject" name="certId" map="B"/>
  <field class="org.bouncycastle.cert.ocsp.OCSPReqBuilder$RequestObject" name="extensions" map="C"/>
  <method class="org.bouncycastle.cert.ocsp.OCSPReqBuilder$RequestObject" name="org.bouncycastle.asn1.ocsp.Request toRequest()" map="A"/>
  <class name="org.bouncycastle.cert.ocsp.OCSPReqBuilder" map="E"/>
  <field class="org.bouncycastle.cert.ocsp.OCSPReqBuilder" name="requestExtensions" map="A"/>
  <field class="org.bouncycastle.cert.ocsp.OCSPReqBuilder" name="requestorName" map="B"/>
  <field class="org.bouncycastle.cert.ocsp.OCSPReqBuilder" name="list" map="C"/>
  <method class="org.bouncycastle.cert.ocsp.OCSPReqBuilder" name="org.bouncycastle.cert.ocsp.OCSPReq generateRequest(org.bouncycastle.operator.ContentSigner, org.bouncycastle.cert.X509CertificateHolder[])" map="A"/>
  <method class="org.bouncycastle.cert.ocsp.OCSPReqBuilder" name="org.bouncycastle.cert.ocsp.OCSPReq build()" map="A"/>
  <method class="org.bouncycastle.cert.ocsp.OCSPReqBuilder" name="org.bouncycastle.cert.ocsp.OCSPReqBuilder addRequest(org.bouncycastle.cert.ocsp.CertificateID)" map="A"/>
  <method class="org.bouncycastle.cert.ocsp.OCSPReqBuilder" name="org.bouncycastle.cert.ocsp.OCSPReqBuilder setRequestExtensions(org.bouncycastle.asn1.x509.Extensions)" map="A"/>
  <class name="org.bouncycastle.cert.ocsp.CertificateID" map="F"/>
  <field class="org.bouncycastle.cert.ocsp.CertificateID" name="HASH_SHA1" map="A"/>
  <field class="org.bouncycastle.cert.ocsp.CertificateID" name="id" map="B"/>
  <method class="org.bouncycastle.cert.ocsp.CertificateID" name="boolean matchesIssuer(org.bouncycastle.cert.X509CertificateHolder, org.bouncycastle.operator.DigestCalculatorProvider)" map="A"/>
  <method class="org.bouncycastle.cert.ocsp.CertificateID" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.cert.ocsp.CertificateID" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.cert.ocsp.CertificateID" name="org.bouncycastle.asn1.ocsp.CertID toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.cert.ocsp.CertificateID" name="org.bouncycastle.asn1.ocsp.CertID createCertID(org.bouncycastle.operator.DigestCalculator, org.bouncycastle.cert.X509CertificateHolder, org.bouncycastle.asn1.ASN1Integer)" map="A"/>
  <method class="org.bouncycastle.cert.ocsp.CertificateID" name="org.bouncycastle.asn1.ASN1ObjectIdentifier getHashAlgOID()" map="B"/>
  <method class="org.bouncycastle.cert.ocsp.CertificateID" name="java.math.BigInteger getSerialNumber()" map="C"/>
  <class name="org.bouncycastle.cert.ocsp.OCSPUtils" map="G"/>
  <field class="org.bouncycastle.cert.ocsp.OCSPUtils" name="EMPTY_LIST" map="A"/>
  <field class="org.bouncycastle.cert.ocsp.OCSPUtils" name="EMPTY_SET" map="B"/>
  <field class="org.bouncycastle.cert.ocsp.OCSPUtils" name="EMPTY_CERTS" map="C"/>
  <method class="org.bouncycastle.cert.ocsp.OCSPUtils" name="java.util.Date extractDate(org.bouncycastle.asn1.ASN1GeneralizedTime)" map="A"/>
  <class name="org.bouncycastle.cert.ocsp.RevokedStatus" map="H"/>
  <field class="org.bouncycastle.cert.ocsp.RevokedStatus" name="info" map="B"/>
  <class name="org.bouncycastle.cert.ocsp.SingleResp" map="I"/>
  <field class="org.bouncycastle.cert.ocsp.SingleResp" name="extensions" map="A"/>
  <field class="org.bouncycastle.cert.ocsp.SingleResp" name="resp" map="B"/>
  <method class="org.bouncycastle.cert.ocsp.SingleResp" name="java.util.Date getNextUpdate()" map="A"/>
  <method class="org.bouncycastle.cert.ocsp.SingleResp" name="java.util.Date getThisUpdate()" map="B"/>
  <method class="org.bouncycastle.cert.ocsp.SingleResp" name="org.bouncycastle.cert.ocsp.CertificateStatus getCertStatus()" map="C"/>
  <method class="org.bouncycastle.cert.ocsp.SingleResp" name="org.bouncycastle.cert.ocsp.CertificateID getCertID()" map="D"/>
  <class name="org.bouncycastle.cert.ocsp.CertificateStatus" map="J"/>
  <field class="org.bouncycastle.cert.ocsp.CertificateStatus" name="GOOD" map="A"/>
  <class name="org.bouncycastle.cert.ocsp.OCSPException" map="K"/>
  <field class="org.bouncycastle.cert.ocsp.OCSPException" name="cause" map="A"/>
  <method class="org.bouncycastle.cert.ocsp.OCSPException" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="org.bouncycastle.cert.CertUtils" map="A"/>
  <field class="org.bouncycastle.cert.CertUtils" name="EMPTY_LIST" map="A"/>
  <field class="org.bouncycastle.cert.CertUtils" name="EMPTY_SET" map="B"/>
  <method class="org.bouncycastle.cert.CertUtils" name="org.bouncycastle.asn1.ASN1Primitive parseNonEmptyASN1(byte[])" map="A"/>
  <class name="org.bouncycastle.cert.CertIOException" map="B"/>
  <field class="org.bouncycastle.cert.CertIOException" name="cause" map="A"/>
  <method class="org.bouncycastle.cert.CertIOException" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="org.bouncycastle.cert.X509CertificateHolder" map="C"/>
  <field class="org.bouncycastle.cert.X509CertificateHolder" name="extensions" map="G"/>
  <field class="org.bouncycastle.cert.X509CertificateHolder" name="x509Certificate" map="H"/>
  <method class="org.bouncycastle.cert.X509CertificateHolder" name="byte[] getEncoded()" map="G"/>
  <method class="org.bouncycastle.cert.X509CertificateHolder" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.cert.X509CertificateHolder" name="org.bouncycastle.asn1.x509.Certificate toASN1Structure()" map="H"/>
  <method class="org.bouncycastle.cert.X509CertificateHolder" name="org.bouncycastle.asn1.x509.Extension getExtension(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="A"/>
  <method class="org.bouncycastle.cert.X509CertificateHolder" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.cert.X509CertificateHolder" name="void init(org.bouncycastle.asn1.x509.Certificate)" map="A"/>
  <method class="org.bouncycastle.cert.X509CertificateHolder" name="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getSubjectPublicKeyInfo()" map="I"/>
  <method class="org.bouncycastle.cert.X509CertificateHolder" name="boolean isValidOn(java.util.Date)" map="A"/>
  <method class="org.bouncycastle.cert.X509CertificateHolder" name="org.bouncycastle.asn1.x509.Certificate parseBytes(byte[])" map="A"/>
  <package name="org.bouncycastle.util" map="H"/>
  <package name="org.bouncycastle.util.encoders" map="A"/>
  <class name="org.bouncycastle.util.encoders.HexEncoder" map="A"/>
  <field class="org.bouncycastle.util.encoders.HexEncoder" name="encodingTable" map="D"/>
  <field class="org.bouncycastle.util.encoders.HexEncoder" name="decodingTable" map="E"/>
  <method class="org.bouncycastle.util.encoders.HexEncoder" name="boolean ignore(char)" map="B"/>
  <method class="org.bouncycastle.util.encoders.HexEncoder" name="void initialiseDecodingTable()" map="B"/>
  <method class="org.bouncycastle.util.encoders.HexEncoder" name="int encode(byte[], int, int, java.io.OutputStream)" map="A"/>
  <method class="org.bouncycastle.util.encoders.HexEncoder" name="int decode(java.lang.String, java.io.OutputStream)" map="A"/>
  <class name="org.bouncycastle.util.encoders.Base64Encoder" map="B"/>
  <field class="org.bouncycastle.util.encoders.Base64Encoder" name="encodingTable" map="A"/>
  <field class="org.bouncycastle.util.encoders.Base64Encoder" name="decodingTable" map="B"/>
  <field class="org.bouncycastle.util.encoders.Base64Encoder" name="padding" map="C"/>
  <method class="org.bouncycastle.util.encoders.Base64Encoder" name="boolean ignore(char)" map="A"/>
  <method class="org.bouncycastle.util.encoders.Base64Encoder" name="void initialiseDecodingTable()" map="A"/>
  <method class="org.bouncycastle.util.encoders.Base64Encoder" name="int encode(byte[], int, int, java.io.OutputStream)" map="A"/>
  <method class="org.bouncycastle.util.encoders.Base64Encoder" name="int decodeLastBlock(java.io.OutputStream, char, char, char, char)" map="A"/>
  <method class="org.bouncycastle.util.encoders.Base64Encoder" name="int nextI(java.lang.String, int, int)" map="A"/>
  <method class="org.bouncycastle.util.encoders.Base64Encoder" name="int decode(java.lang.String, java.io.OutputStream)" map="A"/>
  <class name="org.bouncycastle.util.encoders.Hex" map="C"/>
  <field class="org.bouncycastle.util.encoders.Hex" name="encoder" map="A"/>
  <method class="org.bouncycastle.util.encoders.Hex" name="byte[] encode(byte[], int, int)" map="A"/>
  <method class="org.bouncycastle.util.encoders.Hex" name="byte[] decode(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.util.encoders.Hex" name="byte[] encode(byte[])" map="A"/>
  <method class="org.bouncycastle.util.encoders.Hex" name="java.lang.String toHexString(byte[])" map="B"/>
  <method class="org.bouncycastle.util.encoders.Hex" name="java.lang.String toHexString(byte[], int, int)" map="B"/>
  <class name="org.bouncycastle.util.encoders.Encoder" map="D"/>
  <method class="org.bouncycastle.util.encoders.Encoder" name="int encode(byte[], int, int, java.io.OutputStream)" map="A"/>
  <method class="org.bouncycastle.util.encoders.Encoder" name="int decode(java.lang.String, java.io.OutputStream)" map="A"/>
  <class name="org.bouncycastle.util.encoders.DecoderException" map="E"/>
  <field class="org.bouncycastle.util.encoders.DecoderException" name="cause" map="A"/>
  <method class="org.bouncycastle.util.encoders.DecoderException" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="org.bouncycastle.util.encoders.EncoderException" map="F"/>
  <field class="org.bouncycastle.util.encoders.EncoderException" name="cause" map="A"/>
  <method class="org.bouncycastle.util.encoders.EncoderException" name="java.lang.Throwable getCause()" map="getCause"/>
  <class name="org.bouncycastle.util.encoders.Base64" map="G"/>
  <field class="org.bouncycastle.util.encoders.Base64" name="encoder" map="A"/>
  <method class="org.bouncycastle.util.encoders.Base64" name="byte[] decode(java.lang.String)" map="A"/>
  <package name="org.bouncycastle.util.io" map="B"/>
  <class name="org.bouncycastle.util.io.TeeOutputStream" map="A"/>
  <field class="org.bouncycastle.util.io.TeeOutputStream" name="output2" map="A"/>
  <field class="org.bouncycastle.util.io.TeeOutputStream" name="output1" map="B"/>
  <method class="org.bouncycastle.util.io.TeeOutputStream" name="void flush()" map="flush"/>
  <method class="org.bouncycastle.util.io.TeeOutputStream" name="void write(byte[], int, int)" map="write"/>
  <method class="org.bouncycastle.util.io.TeeOutputStream" name="void write(byte[])" map="write"/>
  <method class="org.bouncycastle.util.io.TeeOutputStream" name="void write(int)" map="write"/>
  <method class="org.bouncycastle.util.io.TeeOutputStream" name="void close()" map="close"/>
  <class name="org.bouncycastle.util.io.Streams" map="B"/>
  <field class="org.bouncycastle.util.io.Streams" name="BUFFER_SIZE" map="A"/>
  <method class="org.bouncycastle.util.io.Streams" name="byte[] readAll(java.io.InputStream)" map="A"/>
  <method class="org.bouncycastle.util.io.Streams" name="void pipeAll(java.io.InputStream, java.io.OutputStream)" map="A"/>
  <method class="org.bouncycastle.util.io.Streams" name="int readFully(java.io.InputStream, byte[])" map="A"/>
  <method class="org.bouncycastle.util.io.Streams" name="int readFully(java.io.InputStream, byte[], int, int)" map="A"/>
  <class name="org.bouncycastle.util.io.TeeInputStream" map="C"/>
  <field class="org.bouncycastle.util.io.TeeInputStream" name="output" map="A"/>
  <field class="org.bouncycastle.util.io.TeeInputStream" name="input" map="B"/>
  <method class="org.bouncycastle.util.io.TeeInputStream" name="int read()" map="read"/>
  <method class="org.bouncycastle.util.io.TeeInputStream" name="int read(byte[])" map="read"/>
  <method class="org.bouncycastle.util.io.TeeInputStream" name="void close()" map="close"/>
  <method class="org.bouncycastle.util.io.TeeInputStream" name="int read(byte[], int, int)" map="read"/>
  <class name="org.bouncycastle.util.Selector" map="A"/>
  <method class="org.bouncycastle.util.Selector" name="boolean match(java.lang.Object)" map="A"/>
  <class name="org.bouncycastle.util.Arrays$Iterator" map="_A"/>
  <field class="org.bouncycastle.util.Arrays$Iterator" name="position" map="A"/>
  <field class="org.bouncycastle.util.Arrays$Iterator" name="dataArray" map="B"/>
  <method class="org.bouncycastle.util.Arrays$Iterator" name="boolean hasNext()" map="hasNext"/>
  <method class="org.bouncycastle.util.Arrays$Iterator" name="void remove()" map="remove"/>
  <method class="org.bouncycastle.util.Arrays$Iterator" name="java.lang.Object next()" map="next"/>
  <class name="org.bouncycastle.util.Arrays" map="B"/>
  <method class="org.bouncycastle.util.Arrays" name="void fill(byte[], byte)" map="A"/>
  <method class="org.bouncycastle.util.Arrays" name="boolean areEqual(byte[], byte[])" map="A"/>
  <method class="org.bouncycastle.util.Arrays" name="int hashCode(int[])" map="A"/>
  <method class="org.bouncycastle.util.Arrays" name="int hashCode(short[][])" map="A"/>
  <method class="org.bouncycastle.util.Arrays" name="boolean constantTimeAreEqual(byte[], byte[])" map="B"/>
  <method class="org.bouncycastle.util.Arrays" name="byte[] concatenate(byte[], byte[])" map="C"/>
  <method class="org.bouncycastle.util.Arrays" name="boolean areEqual(char[], char[])" map="A"/>
  <method class="org.bouncycastle.util.Arrays" name="int hashCode(short[])" map="A"/>
  <method class="org.bouncycastle.util.Arrays" name="boolean areEqual(short[], short[])" map="A"/>
  <method class="org.bouncycastle.util.Arrays" name="int hashCode(byte[])" map="A"/>
  <method class="org.bouncycastle.util.Arrays" name="int hashCode(char[])" map="A"/>
  <method class="org.bouncycastle.util.Arrays" name="short[] clone(short[])" map="B"/>
  <method class="org.bouncycastle.util.Arrays" name="int hashCode(short[][][])" map="A"/>
  <method class="org.bouncycastle.util.Arrays" name="byte[] clone(byte[])" map="B"/>
  <class name="org.bouncycastle.util.Pack" map="C"/>
  <method class="org.bouncycastle.util.Pack" name="void longToBigEndian(long, byte[], int)" map="A"/>
  <method class="org.bouncycastle.util.Pack" name="long bigEndianToLong(byte[], int)" map="A"/>
  <method class="org.bouncycastle.util.Pack" name="void shortToLittleEndian(short, byte[], int)" map="A"/>
  <method class="org.bouncycastle.util.Pack" name="int littleEndianToInt(byte[], int)" map="B"/>
  <method class="org.bouncycastle.util.Pack" name="void longToLittleEndian(long[], int, int, byte[], int)" map="A"/>
  <method class="org.bouncycastle.util.Pack" name="int bigEndianToInt(byte[], int)" map="C"/>
  <method class="org.bouncycastle.util.Pack" name="long littleEndianToLong(byte[], int)" map="D"/>
  <method class="org.bouncycastle.util.Pack" name="void intToBigEndian(int, byte[], int)" map="A"/>
  <method class="org.bouncycastle.util.Pack" name="void longToLittleEndian(long, byte[], int)" map="B"/>
  <method class="org.bouncycastle.util.Pack" name="void intToLittleEndian(int, byte[], int)" map="B"/>
  <method class="org.bouncycastle.util.Pack" name="short littleEndianToShort(byte[], int)" map="E"/>
  <class name="org.bouncycastle.util.Encodable" map="D"/>
  <class name="org.bouncycastle.util.Strings$1" map="1"/>
  <method class="org.bouncycastle.util.Strings$1" name="java.lang.Object run()" map="run"/>
  <method class="org.bouncycastle.util.Strings$1" name="java.lang.String run()" map="A"/>
  <class name="org.bouncycastle.util.Strings" map="E"/>
  <field class="org.bouncycastle.util.Strings" name="LINE_SEPARATOR" map="A"/>
  <method class="org.bouncycastle.util.Strings" name="java.lang.String lineSeparator()" map="A"/>
  <method class="org.bouncycastle.util.Strings" name="byte[] toByteArray(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.util.Strings" name="char[] asCharArray(byte[])" map="A"/>
  <method class="org.bouncycastle.util.Strings" name="java.lang.String fromByteArray(byte[])" map="B"/>
  <method class="org.bouncycastle.util.Strings" name="java.lang.String toLowerCase(java.lang.String)" map="B"/>
  <method class="org.bouncycastle.util.Strings" name="java.lang.String fromUTF8ByteArray(byte[])" map="C"/>
  <method class="org.bouncycastle.util.Strings" name="java.lang.String toUpperCase(java.lang.String)" map="C"/>
  <class name="org.bouncycastle.util.Properties$1" map="1"/>
  <field class="org.bouncycastle.util.Properties$1" name="val$propertyName" map="A"/>
  <method class="org.bouncycastle.util.Properties$1" name="java.lang.Object run()" map="run"/>
  <class name="org.bouncycastle.util.Properties" map="F"/>
  <field class="org.bouncycastle.util.Properties" name="threadProperties" map="A"/>
  <method class="org.bouncycastle.util.Properties" name="java.lang.String fetchProperty(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.util.Properties" name="boolean isOverrideSet(java.lang.String)" map="B"/>
  <method class="org.bouncycastle.util.Properties" name="java.lang.ThreadLocal access$000()" map="A"/>
  <class name="org.bouncycastle.util.Memoable" map="G"/>
  <class name="org.bouncycastle.util.Integers" map="H"/>
  <method class="org.bouncycastle.util.Integers" name="java.lang.Integer valueOf(int)" map="A"/>
  <class name="org.bouncycastle.util.Iterable" map="I"/>
  <package name="org.bouncycastle.cms" map="I"/>
  <package name="org.bouncycastle.cms.jcajce" map="A"/>
  <class name="org.bouncycastle.cms.jcajce.DefaultJcaJceExtHelper" map="A"/>
  <method class="org.bouncycastle.cms.jcajce.DefaultJcaJceExtHelper" name="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper createAsymmetricUnwrapper(org.bouncycastle.asn1.x509.AlgorithmIdentifier, java.security.PrivateKey)" map="A"/>
  <class name="org.bouncycastle.cms.jcajce.JcaJceExtHelper" map="B"/>
  <method class="org.bouncycastle.cms.jcajce.JcaJceExtHelper" name="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper createAsymmetricUnwrapper(org.bouncycastle.asn1.x509.AlgorithmIdentifier, java.security.PrivateKey)" map="A"/>
  <class name="org.bouncycastle.cms.jcajce.NamedJcaJceExtHelper" map="C"/>
  <method class="org.bouncycastle.cms.jcajce.NamedJcaJceExtHelper" name="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper createAsymmetricUnwrapper(org.bouncycastle.asn1.x509.AlgorithmIdentifier, java.security.PrivateKey)" map="A"/>
  <class name="org.bouncycastle.cms.jcajce.ProviderJcaJceExtHelper" map="D"/>
  <method class="org.bouncycastle.cms.jcajce.ProviderJcaJceExtHelper" name="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper createAsymmetricUnwrapper(org.bouncycastle.asn1.x509.AlgorithmIdentifier, java.security.PrivateKey)" map="A"/>
  <class name="org.bouncycastle.cms.jcajce.JceKeyTransEnvelopedRecipient$1" map="1"/>
  <field class="org.bouncycastle.cms.jcajce.JceKeyTransEnvelopedRecipient$1" name="this$0" map="A"/>
  <field class="org.bouncycastle.cms.jcajce.JceKeyTransEnvelopedRecipient$1" name="val$dataCipher" map="B"/>
  <field class="org.bouncycastle.cms.jcajce.JceKeyTransEnvelopedRecipient$1" name="val$contentEncryptionAlgorithm" map="C"/>
  <method class="org.bouncycastle.cms.jcajce.JceKeyTransEnvelopedRecipient$1" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmIdentifier()" map="A"/>
  <method class="org.bouncycastle.cms.jcajce.JceKeyTransEnvelopedRecipient$1" name="java.io.InputStream getInputStream(java.io.InputStream)" map="A"/>
  <class name="org.bouncycastle.cms.jcajce.JceKeyTransEnvelopedRecipient" map="E"/>
  <method class="org.bouncycastle.cms.jcajce.JceKeyTransEnvelopedRecipient" name="org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.asn1.x509.AlgorithmIdentifier, byte[])" map="B"/>
  <class name="org.bouncycastle.cms.jcajce.JceKeyTransRecipient" map="F"/>
  <field class="org.bouncycastle.cms.jcajce.JceKeyTransRecipient" name="contentHelper" map="A"/>
  <field class="org.bouncycastle.cms.jcajce.JceKeyTransRecipient" name="extraMappings" map="B"/>
  <field class="org.bouncycastle.cms.jcajce.JceKeyTransRecipient" name="unwrappedKeyMustBeEncodable" map="C"/>
  <field class="org.bouncycastle.cms.jcajce.JceKeyTransRecipient" name="helper" map="D"/>
  <field class="org.bouncycastle.cms.jcajce.JceKeyTransRecipient" name="recipientKey" map="E"/>
  <field class="org.bouncycastle.cms.jcajce.JceKeyTransRecipient" name="validateKeySize" map="F"/>
  <method class="org.bouncycastle.cms.jcajce.JceKeyTransRecipient" name="java.security.Key extractSecretKey(org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.asn1.x509.AlgorithmIdentifier, byte[])" map="C"/>
  <method class="org.bouncycastle.cms.jcajce.JceKeyTransRecipient" name="org.bouncycastle.cms.jcajce.JceKeyTransRecipient setProvider(java.lang.String)" map="A"/>
  <class name="org.bouncycastle.cms.jcajce.CMSUtils" map="G"/>
  <field class="org.bouncycastle.cms.jcajce.CMSUtils" name="ecAlgs" map="A"/>
  <field class="org.bouncycastle.cms.jcajce.CMSUtils" name="gostAlgs" map="B"/>
  <field class="org.bouncycastle.cms.jcajce.CMSUtils" name="mqvAlgs" map="C"/>
  <method class="org.bouncycastle.cms.jcajce.CMSUtils" name="void loadParameters(java.security.AlgorithmParameters, org.bouncycastle.asn1.ASN1Encodable)" map="A"/>
  <method class="org.bouncycastle.cms.jcajce.CMSUtils" name="boolean isGOST(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="A"/>
  <class name="org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder$1" map="1"/>
  <class name="org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder$Helper" map="_A"/>
  <field class="org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder$Helper" name="this$0" map="A"/>
  <method class="org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder$Helper" name="org.bouncycastle.operator.DigestCalculatorProvider createDigestCalculatorProvider()" map="A"/>
  <method class="org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder$Helper" name="org.bouncycastle.operator.ContentVerifierProvider createContentVerifierProvider(java.security.cert.X509Certificate)" map="A"/>
  <class name="org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder$NamedHelper" map="_B"/>
  <field class="org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder$NamedHelper" name="this$0" map="A"/>
  <field class="org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder$NamedHelper" name="providerName" map="B"/>
  <method class="org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder$NamedHelper" name="org.bouncycastle.operator.DigestCalculatorProvider createDigestCalculatorProvider()" map="A"/>
  <method class="org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder$NamedHelper" name="org.bouncycastle.operator.ContentVerifierProvider createContentVerifierProvider(java.security.cert.X509Certificate)" map="A"/>
  <class name="org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder" map="H"/>
  <field class="org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder" name="helper" map="A"/>
  <method class="org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder" name="org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder setProvider(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder" name="org.bouncycastle.cms.SignerInformationVerifier build(java.security.cert.X509Certificate)" map="A"/>
  <class name="org.bouncycastle.cms.jcajce.EnvelopedDataHelper$JCECallback" map="_A"/>
  <method class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper$JCECallback" name="java.lang.Object doInJCE()" map="A"/>
  <class name="org.bouncycastle.cms.jcajce.EnvelopedDataHelper$1" map="1"/>
  <field class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper$1" name="this$0" map="A"/>
  <field class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper$1" name="val$sKey" map="B"/>
  <field class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper$1" name="val$encryptionAlgID" map="C"/>
  <method class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper$1" name="java.lang.Object doInJCE()" map="A"/>
  <class name="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" map="I"/>
  <field class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="rc2Table" map="A"/>
  <field class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="PBKDF2_ALG_NAMES" map="B"/>
  <field class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="CIPHER_ALG_NAMES" map="C"/>
  <field class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="BASE_CIPHER_NAMES" map="D"/>
  <field class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="helper" map="E"/>
  <field class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="rc2Ekb" map="F"/>
  <field class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="MAC_ALG_NAMES" map="G"/>
  <field class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="KEY_SIZE_PROVIDER" map="H"/>
  <method class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="org.bouncycastle.operator.jcajce.JceAsymmetricKeyUnwrapper createAsymmetricUnwrapper(org.bouncycastle.asn1.x509.AlgorithmIdentifier, java.security.PrivateKey)" map="A"/>
  <method class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="java.security.KeyFactory createKeyFactory(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="A"/>
  <method class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="javax.crypto.Cipher createCipher(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="B"/>
  <method class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="java.security.AlgorithmParameters createAlgorithmParameters(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="C"/>
  <method class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="java.lang.Object execute(org.bouncycastle.cms.jcajce.EnvelopedDataHelper$JCECallback)" map="A"/>
  <method class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="java.security.Key getJceKey(org.bouncycastle.asn1.ASN1ObjectIdentifier, org.bouncycastle.operator.GenericKey)" map="A"/>
  <method class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="javax.crypto.KeyAgreement createKeyAgreement(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="D"/>
  <method class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="javax.crypto.Cipher createContentCipher(java.security.Key, org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <method class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="java.lang.String getBaseCipherName(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="E"/>
  <method class="org.bouncycastle.cms.jcajce.EnvelopedDataHelper" name="void keySizeCheck(org.bouncycastle.asn1.x509.AlgorithmIdentifier, java.security.Key)" map="A"/>
  <class name="org.bouncycastle.cms.RecipientInformationStore" map="A"/>
  <field class="org.bouncycastle.cms.RecipientInformationStore" name="all" map="&#x0427;"/>
  <field class="org.bouncycastle.cms.RecipientInformationStore" name="table" map="&#x0428;"/>
  <method class="org.bouncycastle.cms.RecipientInformationStore" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="org.bouncycastle.cms.RecipientInformationStore" name="org.bouncycastle.cms.RecipientInformation get(org.bouncycastle.cms.RecipientId)" map="A"/>
  <method class="org.bouncycastle.cms.RecipientInformationStore" name="java.util.Collection getRecipients()" map="&#x017d;"/>
  <method class="org.bouncycastle.cms.RecipientInformationStore" name="java.util.Collection getRecipients(org.bouncycastle.cms.RecipientId)" map="B"/>
  <class name="org.bouncycastle.cms.PasswordRecipientInformation" map="B"/>
  <field class="org.bouncycastle.cms.PasswordRecipientInformation" name="BLOCKSIZES" map="K"/>
  <field class="org.bouncycastle.cms.PasswordRecipientInformation" name="info" map="L"/>
  <field class="org.bouncycastle.cms.PasswordRecipientInformation" name="KEYSIZES" map="M"/>
  <method class="org.bouncycastle.cms.PasswordRecipientInformation" name="org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.cms.Recipient)" map="A"/>
  <method class="org.bouncycastle.cms.PasswordRecipientInformation" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getKeyDerivationAlgorithm()" map="B"/>
  <class name="org.bouncycastle.cms.CMSSignedHelper" map="C"/>
  <field class="org.bouncycastle.cms.CMSSignedHelper" name="INSTANCE" map="A"/>
  <field class="org.bouncycastle.cms.CMSSignedHelper" name="encryptionAlgs" map="B"/>
  <method class="org.bouncycastle.cms.CMSSignedHelper" name="java.lang.String getEncryptionAlgName(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.cms.CMSSignedHelper" name="void addEntries(org.bouncycastle.asn1.ASN1ObjectIdentifier, java.lang.String)" map="A"/>
  <class name="org.bouncycastle.cms.KeyTransRecipientId" map="D"/>
  <field class="org.bouncycastle.cms.KeyTransRecipientId" name="baseSelector" map="F"/>
  <method class="org.bouncycastle.cms.KeyTransRecipientId" name="java.lang.Object clone()" map="clone"/>
  <method class="org.bouncycastle.cms.KeyTransRecipientId" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.cms.KeyTransRecipientId" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.cms.KeyTransRecipientId" name="org.bouncycastle.asn1.x500.X500Name getIssuer()" map="A"/>
  <method class="org.bouncycastle.cms.KeyTransRecipientId" name="boolean match(java.lang.Object)" map="A"/>
  <method class="org.bouncycastle.cms.KeyTransRecipientId" name="byte[] getSubjectKeyIdentifier()" map="B"/>
  <method class="org.bouncycastle.cms.KeyTransRecipientId" name="java.math.BigInteger getSerialNumber()" map="C"/>
  <class name="org.bouncycastle.cms.CMSUtils" map="E"/>
  <field class="org.bouncycastle.cms.CMSUtils" name="ecAlgs" map="A"/>
  <field class="org.bouncycastle.cms.CMSUtils" name="gostAlgs" map="B"/>
  <field class="org.bouncycastle.cms.CMSUtils" name="mqvAlgs" map="C"/>
  <field class="org.bouncycastle.cms.CMSUtils" name="des" map="D"/>
  <method class="org.bouncycastle.cms.CMSUtils" name="boolean isEquivalent(org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <method class="org.bouncycastle.cms.CMSUtils" name="org.bouncycastle.asn1.cms.ContentInfo readContentInfo(byte[])" map="A"/>
  <method class="org.bouncycastle.cms.CMSUtils" name="byte[] streamToByteArray(java.io.InputStream)" map="A"/>
  <method class="org.bouncycastle.cms.CMSUtils" name="org.bouncycastle.asn1.cms.ContentInfo readContentInfo(org.bouncycastle.asn1.ASN1InputStream)" map="A"/>
  <class name="org.bouncycastle.cms.KEKRecipient" map="F"/>
  <method class="org.bouncycastle.cms.KEKRecipient" name="org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.asn1.x509.AlgorithmIdentifier, byte[])" map="A"/>
  <class name="org.bouncycastle.cms.SignerInformationVerifier" map="G"/>
  <field class="org.bouncycastle.cms.SignerInformationVerifier" name="digestProvider" map="A"/>
  <field class="org.bouncycastle.cms.SignerInformationVerifier" name="sigAlgorithmFinder" map="B"/>
  <field class="org.bouncycastle.cms.SignerInformationVerifier" name="verifierProvider" map="C"/>
  <field class="org.bouncycastle.cms.SignerInformationVerifier" name="sigNameGenerator" map="D"/>
  <method class="org.bouncycastle.cms.SignerInformationVerifier" name="boolean hasAssociatedCertificate()" map="A"/>
  <method class="org.bouncycastle.cms.SignerInformationVerifier" name="org.bouncycastle.operator.DigestCalculator getDigestCalculator(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <method class="org.bouncycastle.cms.SignerInformationVerifier" name="org.bouncycastle.cert.X509CertificateHolder getAssociatedCertificate()" map="B"/>
  <method class="org.bouncycastle.cms.SignerInformationVerifier" name="org.bouncycastle.operator.ContentVerifier getContentVerifier(org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.cms.CMSAlgorithm" map="H"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="GOST3411" map="A"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="SHA1" map="B"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="AES192_WRAP" map="C"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECCDH_SHA1KDF" map="D"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECMQV_SHA1KDF" map="E"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="AES256_CBC" map="F"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="DES_CBC" map="G"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="AES192_CBC_CMAC" map="H"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="RC2_CBC" map="I"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="SHA384" map="J"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECDH_SHA512KDF" map="K"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECDH_SHA256KDF" map="L"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECDH_SHA224KDF" map="M"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="AES128_GCM" map="N"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="AES128_WRAP" map="O"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="AES256_WRAP" map="P"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="SHA512" map="Q"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="SHA256" map="R"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="SHA224" map="S"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="AES256_GCM" map="T"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="SEED_WRAP" map="U"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="DES_EDE3_WRAP" map="V"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="AES192_CBC" map="W"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="GOST28147_CRYPTOPRO_WRAP" map="X"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="AES128_CBC_CMAC" map="Y"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="CAMELLIA128_CBC" map="Z"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="GOST28147_WRAP" map="_"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="MD5" map="a"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="AES192_GCM" map="b"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECKA_EG_X963KDF" map="c"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECDHGOST3410_2001" map="d"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="CAMELLIA256_CBC" map="e"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="RIPEMD160" map="f"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="CAMELLIA192_CBC" map="g"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="AES128_CCM" map="h"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="CAMELLIA192_WRAP" map="i"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="AES256_CCM" map="j"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="RIPEMD256" map="k"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="SEED_CBC" map="l"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="CAMELLIA128_WRAP" map="m"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="CAST5_CBC" map="n"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="DES_EDE3_CBC" map="o"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECKA_EG_X963KDF_SHA384" map="p"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="AES256_CBC_CMAC" map="q"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="IDEA_CBC" map="r"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="GOST3411_2012_512" map="s"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="GOST3411_2012_256" map="t"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECCDH_SHA384KDF" map="u"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="CAMELLIA256_WRAP" map="v"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="RIPEMD128" map="w"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECDH_SHA1KDF" map="x"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECKA_EG_X963KDF_SHA512" map="y"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECKA_EG_X963KDF_SHA256" map="z"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECDHGOST3410_2012_512" map="&#x00a2;"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECDHGOST3410_2012_256" map="&#x00a3;"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="AES192_CCM" map="&#x00a4;"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECCDH_SHA512KDF" map="&#x00a5;"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECCDH_SHA256KDF" map="&#x00aa;"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECCDH_SHA224KDF" map="&#x00b5;"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECMQV_SHA384KDF" map="&#x00ba;"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECDH_SHA384KDF" map="&#x00c0;"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECMQV_SHA512KDF" map="&#x00c1;"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECMQV_SHA256KDF" map="&#x00c2;"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="ECMQV_SHA224KDF" map="&#x00c3;"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="AES128_CBC" map="&#x00c4;"/>
  <field class="org.bouncycastle.cms.CMSAlgorithm" name="GOST28147_GCFB" map="&#x00c5;"/>
  <class name="org.bouncycastle.cms.CMSTypedData" map="I"/>
  <class name="org.bouncycastle.cms.OriginatorInformation" map="J"/>
  <field class="org.bouncycastle.cms.OriginatorInformation" name="originatorInfo" map="A"/>
  <class name="org.bouncycastle.cms.DefaultCMSSignatureAlgorithmNameGenerator" map="K"/>
  <field class="org.bouncycastle.cms.DefaultCMSSignatureAlgorithmNameGenerator" name="digestAlgs" map="A"/>
  <field class="org.bouncycastle.cms.DefaultCMSSignatureAlgorithmNameGenerator" name="encryptionAlgs" map="B"/>
  <method class="org.bouncycastle.cms.DefaultCMSSignatureAlgorithmNameGenerator" name="java.lang.String getSignatureName(org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <method class="org.bouncycastle.cms.DefaultCMSSignatureAlgorithmNameGenerator" name="java.lang.String getEncryptionAlgName(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="A"/>
  <method class="org.bouncycastle.cms.DefaultCMSSignatureAlgorithmNameGenerator" name="void addEntries(org.bouncycastle.asn1.ASN1ObjectIdentifier, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.bouncycastle.cms.DefaultCMSSignatureAlgorithmNameGenerator" name="java.lang.String getDigestAlgName(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="B"/>
  <class name="org.bouncycastle.cms.CMSReadable" map="L"/>
  <method class="org.bouncycastle.cms.CMSReadable" name="java.io.InputStream getInputStream()" map="A"/>
  <class name="org.bouncycastle.cms.CMSEnvelopedHelper$CMSEnvelopedSecureReadable" map="_A"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedHelper$CMSEnvelopedSecureReadable" name="readable" map="A"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedHelper$CMSEnvelopedSecureReadable" name="algorithm" map="B"/>
  <method class="org.bouncycastle.cms.CMSEnvelopedHelper$CMSEnvelopedSecureReadable" name="java.io.InputStream getInputStream()" map="A"/>
  <class name="org.bouncycastle.cms.CMSEnvelopedHelper" map="M"/>
  <method class="org.bouncycastle.cms.CMSEnvelopedHelper" name="void readRecipientInfo(java.util.List, org.bouncycastle.asn1.cms.RecipientInfo, org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.cms.CMSSecureReadable, org.bouncycastle.cms.AuthAttributesProvider)" map="A"/>
  <method class="org.bouncycastle.cms.CMSEnvelopedHelper" name="org.bouncycastle.cms.RecipientInformationStore buildRecipientInformationStore(org.bouncycastle.asn1.ASN1Set, org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.cms.CMSSecureReadable, org.bouncycastle.cms.AuthAttributesProvider)" map="A"/>
  <method class="org.bouncycastle.cms.CMSEnvelopedHelper" name="org.bouncycastle.cms.RecipientInformationStore buildRecipientInformationStore(org.bouncycastle.asn1.ASN1Set, org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.cms.CMSSecureReadable)" map="A"/>
  <class name="org.bouncycastle.cms.PasswordRecipient$PRF" map="_A"/>
  <field class="org.bouncycastle.cms.PasswordRecipient$PRF" name="HMacSHA1" map="A"/>
  <field class="org.bouncycastle.cms.PasswordRecipient$PRF" name="HMacSHA256" map="B"/>
  <field class="org.bouncycastle.cms.PasswordRecipient$PRF" name="hmac" map="C"/>
  <field class="org.bouncycastle.cms.PasswordRecipient$PRF" name="HMacSHA384" map="D"/>
  <field class="org.bouncycastle.cms.PasswordRecipient$PRF" name="HMacSHA512" map="E"/>
  <field class="org.bouncycastle.cms.PasswordRecipient$PRF" name="prfAlgID" map="F"/>
  <field class="org.bouncycastle.cms.PasswordRecipient$PRF" name="HMacSHA224" map="G"/>
  <method class="org.bouncycastle.cms.PasswordRecipient$PRF" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getAlgorithmID()" map="A"/>
  <class name="org.bouncycastle.cms.PasswordRecipient" map="N"/>
  <method class="org.bouncycastle.cms.PasswordRecipient" name="org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.asn1.x509.AlgorithmIdentifier, byte[], byte[])" map="A"/>
  <method class="org.bouncycastle.cms.PasswordRecipient" name="byte[] calculateDerivedKey(int, org.bouncycastle.asn1.x509.AlgorithmIdentifier, int)" map="A"/>
  <method class="org.bouncycastle.cms.PasswordRecipient" name="int getPasswordConversionScheme()" map="A"/>
  <class name="org.bouncycastle.cms.CMSSignerDigestMismatchException" map="O"/>
  <class name="org.bouncycastle.cms.SignerId" map="P"/>
  <field class="org.bouncycastle.cms.SignerId" name="baseSelector" map="A"/>
  <method class="org.bouncycastle.cms.SignerId" name="java.lang.Object clone()" map="clone"/>
  <method class="org.bouncycastle.cms.SignerId" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.cms.SignerId" name="int hashCode()" map="hashCode"/>
  <class name="org.bouncycastle.cms.PasswordRecipientId" map="Q"/>
  <method class="org.bouncycastle.cms.PasswordRecipientId" name="java.lang.Object clone()" map="clone"/>
  <method class="org.bouncycastle.cms.PasswordRecipientId" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.cms.PasswordRecipientId" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.cms.PasswordRecipientId" name="boolean match(java.lang.Object)" map="A"/>
  <class name="org.bouncycastle.cms.KeyAgreeRecipient" map="R"/>
  <method class="org.bouncycastle.cms.KeyAgreeRecipient" name="org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.asn1.x509.SubjectPublicKeyInfo, org.bouncycastle.asn1.ASN1OctetString, byte[])" map="A"/>
  <method class="org.bouncycastle.cms.KeyAgreeRecipient" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getPrivateKeyAlgorithmIdentifier()" map="B"/>
  <class name="org.bouncycastle.cms.CMSSignatureAlgorithmNameGenerator" map="S"/>
  <method class="org.bouncycastle.cms.CMSSignatureAlgorithmNameGenerator" name="java.lang.String getSignatureName(org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <class name="org.bouncycastle.cms.RecipientInformation" map="T"/>
  <field class="org.bouncycastle.cms.RecipientInformation" name="operator" map="A"/>
  <field class="org.bouncycastle.cms.RecipientInformation" name="keyEncAlg" map="B"/>
  <field class="org.bouncycastle.cms.RecipientInformation" name="additionalData" map="C"/>
  <field class="org.bouncycastle.cms.RecipientInformation" name="rid" map="D"/>
  <field class="org.bouncycastle.cms.RecipientInformation" name="secureReadable" map="E"/>
  <field class="org.bouncycastle.cms.RecipientInformation" name="messageAlgorithm" map="F"/>
  <method class="org.bouncycastle.cms.RecipientInformation" name="org.bouncycastle.cms.RecipientId getRID()" map="A"/>
  <method class="org.bouncycastle.cms.RecipientInformation" name="org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.cms.Recipient)" map="A"/>
  <method class="org.bouncycastle.cms.RecipientInformation" name="byte[] getContent(org.bouncycastle.cms.Recipient)" map="B"/>
  <method class="org.bouncycastle.cms.RecipientInformation" name="org.bouncycastle.cms.CMSTypedStream getContentStream(org.bouncycastle.cms.Recipient)" map="C"/>
  <class name="org.bouncycastle.cms.KEKRecipientId" map="U"/>
  <field class="org.bouncycastle.cms.KEKRecipientId" name="keyIdentifier" map="G"/>
  <method class="org.bouncycastle.cms.KEKRecipientId" name="java.lang.Object clone()" map="clone"/>
  <method class="org.bouncycastle.cms.KEKRecipientId" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.cms.KEKRecipientId" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.cms.KEKRecipientId" name="boolean match(java.lang.Object)" map="A"/>
  <class name="org.bouncycastle.cms.OriginatorId" map="V"/>
  <field class="org.bouncycastle.cms.OriginatorId" name="subjectKeyId" map="B"/>
  <field class="org.bouncycastle.cms.OriginatorId" name="issuer" map="C"/>
  <field class="org.bouncycastle.cms.OriginatorId" name="serialNumber" map="D"/>
  <method class="org.bouncycastle.cms.OriginatorId" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.cms.OriginatorId" name="java.lang.Object clone()" map="clone"/>
  <method class="org.bouncycastle.cms.OriginatorId" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.cms.OriginatorId" name="void setSubjectKeyID(byte[])" map="A"/>
  <method class="org.bouncycastle.cms.OriginatorId" name="void setIssuerAndSerial(org.bouncycastle.asn1.x500.X500Name, java.math.BigInteger)" map="A"/>
  <method class="org.bouncycastle.cms.OriginatorId" name="boolean equalsObj(java.lang.Object, java.lang.Object)" map="A"/>
  <class name="org.bouncycastle.cms.CMSEnvelopedDataGenerator" map="W"/>
  <class name="org.bouncycastle.cms.CMSEnvelopedGenerator" map="X"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="CAMELLIA256_WRAP" map="A"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="DES_EDE3_CBC" map="B"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="AES128_CBC" map="C"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="AES128_WRAP" map="D"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="CAMELLIA128_CBC" map="E"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="AES256_CBC" map="F"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="RC2_CBC" map="G"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="CAMELLIA256_CBC" map="H"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="AES192_CBC" map="I"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="SEED_WRAP" map="J"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="CAMELLIA192_CBC" map="K"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="CAMELLIA128_WRAP" map="L"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="SEED_CBC" map="M"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="ECDH_SHA1KDF" map="N"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="AES192_WRAP" map="O"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="DES_EDE3_WRAP" map="P"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="CAMELLIA192_WRAP" map="Q"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="ECMQV_SHA1KDF" map="R"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedGenerator" name="AES256_WRAP" map="S"/>
  <class name="org.bouncycastle.cms.KeyTransRecipient" map="Y"/>
  <method class="org.bouncycastle.cms.KeyTransRecipient" name="org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.asn1.x509.AlgorithmIdentifier, byte[])" map="B"/>
  <class name="org.bouncycastle.cms.CMSProcessable" map="Z"/>
  <method class="org.bouncycastle.cms.CMSProcessable" name="void write(java.io.OutputStream)" map="A"/>
  <class name="org.bouncycastle.cms.PKCS7ProcessableObject" map="_"/>
  <field class="org.bouncycastle.cms.PKCS7ProcessableObject" name="structure" map="A"/>
  <field class="org.bouncycastle.cms.PKCS7ProcessableObject" name="type" map="B"/>
  <method class="org.bouncycastle.cms.PKCS7ProcessableObject" name="void write(java.io.OutputStream)" map="A"/>
  <class name="org.bouncycastle.cms.KeyTransRecipientInformation" map="a"/>
  <field class="org.bouncycastle.cms.KeyTransRecipientInformation" name="info" map="G"/>
  <method class="org.bouncycastle.cms.KeyTransRecipientInformation" name="org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.cms.Recipient)" map="A"/>
  <class name="org.bouncycastle.cms.CMSException" map="b"/>
  <field class="org.bouncycastle.cms.CMSException" name="e" map="A"/>
  <method class="org.bouncycastle.cms.CMSException" name="java.lang.Throwable getCause()" map="getCause"/>
  <method class="org.bouncycastle.cms.CMSException" name="java.lang.Exception getUnderlyingException()" map="A"/>
  <class name="org.bouncycastle.cms.CMSSignedData" map="c"/>
  <field class="org.bouncycastle.cms.CMSSignedData" name="contentInfo" map="I"/>
  <field class="org.bouncycastle.cms.CMSSignedData" name="hashes" map="J"/>
  <field class="org.bouncycastle.cms.CMSSignedData" name="HELPER" map="K"/>
  <field class="org.bouncycastle.cms.CMSSignedData" name="signedContent" map="L"/>
  <field class="org.bouncycastle.cms.CMSSignedData" name="signedData" map="M"/>
  <field class="org.bouncycastle.cms.CMSSignedData" name="signerInfoStore" map="N"/>
  <method class="org.bouncycastle.cms.CMSSignedData" name="java.lang.String getSignedContentTypeOID()" map="J"/>
  <method class="org.bouncycastle.cms.CMSSignedData" name="org.bouncycastle.cms.SignerInformationStore getSignerInfos()" map="K"/>
  <method class="org.bouncycastle.cms.CMSSignedData" name="byte[] getEncoded()" map="L"/>
  <method class="org.bouncycastle.cms.CMSSignedData" name="org.bouncycastle.cms.CMSTypedData getSignedContent()" map="M"/>
  <method class="org.bouncycastle.cms.CMSSignedData" name="org.bouncycastle.asn1.cms.SignedData getSignedData()" map="N"/>
  <class name="org.bouncycastle.cms.KeyAgreeRecipientId" map="d"/>
  <field class="org.bouncycastle.cms.KeyAgreeRecipientId" name="baseSelector" map="H"/>
  <method class="org.bouncycastle.cms.KeyAgreeRecipientId" name="java.lang.Object clone()" map="clone"/>
  <method class="org.bouncycastle.cms.KeyAgreeRecipientId" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.cms.KeyAgreeRecipientId" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.cms.KeyAgreeRecipientId" name="boolean match(java.lang.Object)" map="A"/>
  <class name="org.bouncycastle.cms.SignerInformationStore" map="e"/>
  <field class="org.bouncycastle.cms.SignerInformationStore" name="all" map="&#x0429;"/>
  <field class="org.bouncycastle.cms.SignerInformationStore" name="table" map="&#x042a;"/>
  <method class="org.bouncycastle.cms.SignerInformationStore" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="org.bouncycastle.cms.SignerInformationStore" name="java.util.Collection getSigners()" map="&#x017e;"/>
  <class name="org.bouncycastle.cms.CMSSecureReadable" map="f"/>
  <method class="org.bouncycastle.cms.CMSSecureReadable" name="java.io.InputStream getInputStream()" map="A"/>
  <class name="org.bouncycastle.cms.CMSTypedStream$FullReaderStream" map="_A"/>
  <method class="org.bouncycastle.cms.CMSTypedStream$FullReaderStream" name="int read(byte[], int, int)" map="read"/>
  <class name="org.bouncycastle.cms.CMSTypedStream" map="g"/>
  <field class="org.bouncycastle.cms.CMSTypedStream" name="_in" map="A"/>
  <field class="org.bouncycastle.cms.CMSTypedStream" name="_oid" map="B"/>
  <method class="org.bouncycastle.cms.CMSTypedStream" name="java.io.InputStream getContentStream()" map="A"/>
  <class name="org.bouncycastle.cms.RecipientOperator" map="h"/>
  <field class="org.bouncycastle.cms.RecipientOperator" name="algorithmIdentifier" map="A"/>
  <field class="org.bouncycastle.cms.RecipientOperator" name="operator" map="B"/>
  <method class="org.bouncycastle.cms.RecipientOperator" name="java.io.InputStream getInputStream(java.io.InputStream)" map="A"/>
  <class name="org.bouncycastle.cms.AuthAttributesProvider" map="i"/>
  <class name="org.bouncycastle.cms.KeyAgreeRecipientInformation" map="j"/>
  <field class="org.bouncycastle.cms.KeyAgreeRecipientInformation" name="encryptedKey" map="H"/>
  <field class="org.bouncycastle.cms.KeyAgreeRecipientInformation" name="info" map="I"/>
  <method class="org.bouncycastle.cms.KeyAgreeRecipientInformation" name="void readRecipientInfo(java.util.List, org.bouncycastle.asn1.cms.KeyAgreeRecipientInfo, org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.cms.CMSSecureReadable, org.bouncycastle.cms.AuthAttributesProvider)" map="A"/>
  <method class="org.bouncycastle.cms.KeyAgreeRecipientInformation" name="org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.cms.Recipient)" map="A"/>
  <method class="org.bouncycastle.cms.KeyAgreeRecipientInformation" name="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getPublicKeyInfoFromOriginatorPublicKey(org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.asn1.cms.OriginatorPublicKey)" map="A"/>
  <method class="org.bouncycastle.cms.KeyAgreeRecipientInformation" name="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getSenderPublicKeyInfo(org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.asn1.cms.OriginatorIdentifierOrKey)" map="A"/>
  <method class="org.bouncycastle.cms.KeyAgreeRecipientInformation" name="org.bouncycastle.asn1.x509.SubjectPublicKeyInfo getPublicKeyInfoFromOriginatorId(org.bouncycastle.cms.OriginatorId)" map="A"/>
  <class name="org.bouncycastle.cms.KEKRecipientInformation" map="k"/>
  <field class="org.bouncycastle.cms.KEKRecipientInformation" name="info" map="J"/>
  <method class="org.bouncycastle.cms.KEKRecipientInformation" name="org.bouncycastle.cms.RecipientOperator getRecipientOperator(org.bouncycastle.cms.Recipient)" map="A"/>
  <class name="org.bouncycastle.cms.CMSEnvelopedData" map="l"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedData" name="contentInfo" map="O"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedData" name="unprotectedAttributes" map="P"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedData" name="recipientInfoStore" map="Q"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedData" name="encAlg" map="R"/>
  <field class="org.bouncycastle.cms.CMSEnvelopedData" name="originatorInfo" map="S"/>
  <method class="org.bouncycastle.cms.CMSEnvelopedData" name="org.bouncycastle.cms.RecipientInformationStore getRecipientInfos()" map="O"/>
  <class name="org.bouncycastle.cms.SignerInformation" map="m"/>
  <field class="org.bouncycastle.cms.SignerInformation" name="unsignedAttributeSet" map="A"/>
  <field class="org.bouncycastle.cms.SignerInformation" name="sid" map="B"/>
  <field class="org.bouncycastle.cms.SignerInformation" name="info" map="C"/>
  <field class="org.bouncycastle.cms.SignerInformation" name="isCounterSignature" map="D"/>
  <field class="org.bouncycastle.cms.SignerInformation" name="signature" map="E"/>
  <field class="org.bouncycastle.cms.SignerInformation" name="unsignedAttributeValues" map="F"/>
  <field class="org.bouncycastle.cms.SignerInformation" name="signedAttributeValues" map="G"/>
  <field class="org.bouncycastle.cms.SignerInformation" name="encryptionAlgorithm" map="H"/>
  <field class="org.bouncycastle.cms.SignerInformation" name="resultDigest" map="I"/>
  <field class="org.bouncycastle.cms.SignerInformation" name="digestAlgorithm" map="J"/>
  <field class="org.bouncycastle.cms.SignerInformation" name="content" map="K"/>
  <field class="org.bouncycastle.cms.SignerInformation" name="contentType" map="L"/>
  <field class="org.bouncycastle.cms.SignerInformation" name="signedAttributeSet" map="M"/>
  <method class="org.bouncycastle.cms.SignerInformation" name="org.bouncycastle.asn1.cms.AttributeTable getUnsignedAttributes()" map="A"/>
  <method class="org.bouncycastle.cms.SignerInformation" name="org.bouncycastle.asn1.cms.Time getSigningTime()" map="B"/>
  <method class="org.bouncycastle.cms.SignerInformation" name="boolean doVerify(org.bouncycastle.cms.SignerInformationVerifier)" map="A"/>
  <method class="org.bouncycastle.cms.SignerInformation" name="boolean verify(org.bouncycastle.cms.SignerInformationVerifier)" map="B"/>
  <method class="org.bouncycastle.cms.SignerInformation" name="byte[] getSignature()" map="C"/>
  <method class="org.bouncycastle.cms.SignerInformation" name="org.bouncycastle.cms.SignerId getSID()" map="D"/>
  <method class="org.bouncycastle.cms.SignerInformation" name="org.bouncycastle.asn1.ASN1Primitive getSingleValuedSignedAttribute(org.bouncycastle.asn1.ASN1ObjectIdentifier, java.lang.String)" map="A"/>
  <method class="org.bouncycastle.cms.SignerInformation" name="org.bouncycastle.asn1.cms.AttributeTable getSignedAttributes()" map="E"/>
  <method class="org.bouncycastle.cms.SignerInformation" name="java.lang.String getEncryptionAlgOID()" map="F"/>
  <method class="org.bouncycastle.cms.SignerInformation" name="byte[] getEncodedSignedAttributes()" map="G"/>
  <method class="org.bouncycastle.cms.SignerInformation" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigestAlgorithmID()" map="H"/>
  <class name="org.bouncycastle.cms.CMSProcessableByteArray" map="n"/>
  <field class="org.bouncycastle.cms.CMSProcessableByteArray" name="bytes" map="C"/>
  <field class="org.bouncycastle.cms.CMSProcessableByteArray" name="type" map="D"/>
  <method class="org.bouncycastle.cms.CMSProcessableByteArray" name="java.io.InputStream getInputStream()" map="A"/>
  <method class="org.bouncycastle.cms.CMSProcessableByteArray" name="void write(java.io.OutputStream)" map="A"/>
  <class name="org.bouncycastle.cms.RecipientId" map="o"/>
  <field class="org.bouncycastle.cms.RecipientId" name="type" map="E"/>
  <class name="org.bouncycastle.cms.CMSVerifierCertificateNotValidException" map="p"/>
  <class name="org.bouncycastle.cms.Recipient" map="q"/>
  <package name="org.bouncycastle.pqc" map="J"/>
  <package name="org.bouncycastle.pqc.asn1" map="A"/>
  <class name="org.bouncycastle.pqc.asn1.XMSSMTKeyParams" map="A"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSMTKeyParams" name="height" map="&#x03bf;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSMTKeyParams" name="version" map="&#x03c0;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSMTKeyParams" name="treeDigest" map="&#x03c1;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSMTKeyParams" name="layers" map="&#x03c2;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSMTKeyParams" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getTreeDigest()" map="&#x013c;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSMTKeyParams" name="org.bouncycastle.pqc.asn1.XMSSMTKeyParams getInstance(java.lang.Object)" map="&#x00cd;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSMTKeyParams" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSMTKeyParams" name="int getLayers()" map="&#x013d;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSMTKeyParams" name="int getHeight()" map="&#x013e;"/>
  <class name="org.bouncycastle.pqc.asn1.RainbowPublicKey" map="B"/>
  <field class="org.bouncycastle.pqc.asn1.RainbowPublicKey" name="version" map="&#x03c3;"/>
  <field class="org.bouncycastle.pqc.asn1.RainbowPublicKey" name="coeffSingular" map="&#x03c4;"/>
  <field class="org.bouncycastle.pqc.asn1.RainbowPublicKey" name="coeffQuadratic" map="&#x03c5;"/>
  <field class="org.bouncycastle.pqc.asn1.RainbowPublicKey" name="oid" map="&#x03c6;"/>
  <field class="org.bouncycastle.pqc.asn1.RainbowPublicKey" name="coeffScalar" map="&#x03c7;"/>
  <field class="org.bouncycastle.pqc.asn1.RainbowPublicKey" name="docLength" map="&#x03c8;"/>
  <method class="org.bouncycastle.pqc.asn1.RainbowPublicKey" name="org.bouncycastle.pqc.asn1.RainbowPublicKey getInstance(java.lang.Object)" map="&#x00ce;"/>
  <method class="org.bouncycastle.pqc.asn1.RainbowPublicKey" name="int getDocLength()" map="&#x013f;"/>
  <method class="org.bouncycastle.pqc.asn1.RainbowPublicKey" name="short[][] getCoeffSingular()" map="&#x0140;"/>
  <method class="org.bouncycastle.pqc.asn1.RainbowPublicKey" name="short[] getCoeffScalar()" map="&#x0141;"/>
  <method class="org.bouncycastle.pqc.asn1.RainbowPublicKey" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.pqc.asn1.RainbowPublicKey" name="short[][] getCoeffQuadratic()" map="&#x0142;"/>
  <class name="org.bouncycastle.pqc.asn1.McEliecePrivateKey" map="C"/>
  <field class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="encP2" map="&#x03c9;"/>
  <field class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="encP1" map="&#x03ca;"/>
  <field class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="encSInv" map="&#x03cb;"/>
  <field class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="encField" map="&#x03cc;"/>
  <field class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="k" map="&#x03cd;"/>
  <field class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="encGp" map="&#x03ce;"/>
  <field class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="n" map="&#x03d0;"/>
  <method class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="org.bouncycastle.pqc.asn1.McEliecePrivateKey getInstance(java.lang.Object)" map="&#x00cf;"/>
  <method class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.Permutation getP1()" map="&#x0143;"/>
  <method class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="int getK()" map="&#x0144;"/>
  <method class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.GF2mField getField()" map="&#x0145;"/>
  <method class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="int getN()" map="&#x0146;"/>
  <method class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.Permutation getP2()" map="&#x0147;"/>
  <method class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM getGoppaPoly()" map="&#x0148;"/>
  <method class="org.bouncycastle.pqc.asn1.McEliecePrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getSInv()" map="&#x0149;"/>
  <class name="org.bouncycastle.pqc.asn1.SPHINCS256KeyParams" map="D"/>
  <field class="org.bouncycastle.pqc.asn1.SPHINCS256KeyParams" name="version" map="&#x03d1;"/>
  <field class="org.bouncycastle.pqc.asn1.SPHINCS256KeyParams" name="treeDigest" map="&#x03d2;"/>
  <method class="org.bouncycastle.pqc.asn1.SPHINCS256KeyParams" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getTreeDigest()" map="&#x014a;"/>
  <method class="org.bouncycastle.pqc.asn1.SPHINCS256KeyParams" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.pqc.asn1.SPHINCS256KeyParams" name="org.bouncycastle.pqc.asn1.SPHINCS256KeyParams getInstance(java.lang.Object)" map="&#x00d0;"/>
  <class name="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" map="E"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="mcEliece" map="A"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="mcElieceCca2" map="B"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="rainbowWithSha256" map="C"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="rainbowWithSha224" map="D"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="mcElieceKobara_Imai" map="E"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="xmss_with_SHA256" map="F"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="gmssWithSha512" map="G"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="xmss_mt_with_SHA512" map="H"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="newHope" map="I"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="xmss_mt_with_SHAKE128" map="J"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="gmss" map="K"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="sphincs256_with_BLAKE512" map="L"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="rainbowWithSha1" map="M"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="rainbowWithSha512" map="N"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="gmssWithSha384" map="O"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="xmss_with_SHAKE256" map="P"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="xmss_with_SHA512" map="Q"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="sphincs256_with_SHA512" map="R"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="rainbow" map="S"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="rainbowWithSha384" map="T"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="sphincs256_with_SHA3_512" map="U"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="mcEliecePointcheval" map="V"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="mcElieceFujisaki" map="W"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="gmssWithSha256" map="X"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="sphincs256" map="Y"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="gmssWithSha224" map="Z"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="xmss_mt" map="_"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="xmss" map="a"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="xmss_mt_with_SHA256" map="b"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="xmss_with_SHAKE128" map="c"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="gmssWithSha1" map="d"/>
  <field class="org.bouncycastle.pqc.asn1.PQCObjectIdentifiers" name="xmss_mt_with_SHAKE256" map="e"/>
  <class name="org.bouncycastle.pqc.asn1.XMSSPublicKey" map="F"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSPublicKey" name="root" map="&#x03d3;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSPublicKey" name="publicSeed" map="&#x03d4;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSPublicKey" name="byte[] getRoot()" map="&#x014b;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSPublicKey" name="org.bouncycastle.pqc.asn1.XMSSPublicKey getInstance(java.lang.Object)" map="&#x00d1;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSPublicKey" name="byte[] getPublicSeed()" map="&#x014c;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSPublicKey" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.pqc.asn1.RainbowPrivateKey" map="G"/>
  <field class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="version" map="&#x03d5;"/>
  <field class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="b2" map="&#x03d6;"/>
  <field class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="b1" map="&#x03da;"/>
  <field class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="invA2" map="&#x03dc;"/>
  <field class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="oid" map="&#x03de;"/>
  <field class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="invA1" map="&#x03e0;"/>
  <field class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="layers" map="&#x03e2;"/>
  <field class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="vi" map="&#x03e3;"/>
  <method class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="short[][] getInvA2()" map="&#x014d;"/>
  <method class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="short[][] getInvA1()" map="&#x014e;"/>
  <method class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="org.bouncycastle.pqc.asn1.RainbowPrivateKey getInstance(java.lang.Object)" map="&#x00d2;"/>
  <method class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="short[] getB2()" map="&#x014f;"/>
  <method class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="int[] getVi()" map="&#x0150;"/>
  <method class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="org.bouncycastle.pqc.crypto.rainbow.Layer[] getLayers()" map="&#x0151;"/>
  <method class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.pqc.asn1.RainbowPrivateKey" name="short[] getB1()" map="&#x0152;"/>
  <class name="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey" map="H"/>
  <field class="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey" name="encP" map="&#x03e4;"/>
  <field class="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey" name="encField" map="&#x03e5;"/>
  <field class="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey" name="k" map="&#x03e6;"/>
  <field class="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey" name="encGp" map="&#x03e7;"/>
  <field class="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey" name="digest" map="&#x03e8;"/>
  <field class="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey" name="n" map="&#x03e9;"/>
  <method class="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM getGoppaPoly()" map="&#x0153;"/>
  <method class="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.Permutation getP()" map="&#x0154;"/>
  <method class="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey" name="int getK()" map="&#x0155;"/>
  <method class="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigest()" map="&#x0156;"/>
  <method class="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.GF2mField getField()" map="&#x0157;"/>
  <method class="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey" name="int getN()" map="&#x0158;"/>
  <method class="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey" name="org.bouncycastle.pqc.asn1.McElieceCCA2PrivateKey getInstance(java.lang.Object)" map="&#x00d3;"/>
  <class name="org.bouncycastle.pqc.asn1.XMSSMTPrivateKey" map="I"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSMTPrivateKey" name="secretKeyPRF" map="&#x03ea;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSMTPrivateKey" name="root" map="&#x03eb;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSMTPrivateKey" name="bdsState" map="&#x03ec;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSMTPrivateKey" name="index" map="&#x03ed;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSMTPrivateKey" name="secretKeySeed" map="&#x03ee;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSMTPrivateKey" name="publicSeed" map="&#x03ef;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSMTPrivateKey" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <class name="org.bouncycastle.pqc.asn1.XMSSPrivateKey" map="J"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSPrivateKey" name="secretKeyPRF" map="&#x03f0;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSPrivateKey" name="root" map="&#x03f1;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSPrivateKey" name="bdsState" map="&#x03f2;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSPrivateKey" name="index" map="&#x03f3;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSPrivateKey" name="secretKeySeed" map="&#x0401;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSPrivateKey" name="publicSeed" map="&#x0402;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSPrivateKey" name="byte[] getRoot()" map="&#x0159;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSPrivateKey" name="byte[] getSecretKeySeed()" map="&#x015a;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSPrivateKey" name="byte[] getBdsState()" map="&#x015b;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSPrivateKey" name="byte[] getPublicSeed()" map="&#x015c;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSPrivateKey" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSPrivateKey" name="org.bouncycastle.pqc.asn1.XMSSPrivateKey getInstance(java.lang.Object)" map="&#x00d4;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSPrivateKey" name="byte[] getSecretKeyPRF()" map="&#x015d;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSPrivateKey" name="int getIndex()" map="&#x015e;"/>
  <class name="org.bouncycastle.pqc.asn1.XMSSKeyParams" map="K"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSKeyParams" name="height" map="&#x0403;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSKeyParams" name="version" map="&#x0404;"/>
  <field class="org.bouncycastle.pqc.asn1.XMSSKeyParams" name="treeDigest" map="&#x0405;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSKeyParams" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getTreeDigest()" map="&#x015f;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSKeyParams" name="org.bouncycastle.pqc.asn1.XMSSKeyParams getInstance(java.lang.Object)" map="&#x00d5;"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSKeyParams" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.pqc.asn1.XMSSKeyParams" name="int getHeight()" map="&#x0160;"/>
  <class name="org.bouncycastle.pqc.asn1.McElieceCCA2PublicKey" map="L"/>
  <field class="org.bouncycastle.pqc.asn1.McElieceCCA2PublicKey" name="t" map="&#x0406;"/>
  <field class="org.bouncycastle.pqc.asn1.McElieceCCA2PublicKey" name="g" map="&#x0407;"/>
  <field class="org.bouncycastle.pqc.asn1.McElieceCCA2PublicKey" name="digest" map="&#x0408;"/>
  <field class="org.bouncycastle.pqc.asn1.McElieceCCA2PublicKey" name="n" map="&#x0409;"/>
  <method class="org.bouncycastle.pqc.asn1.McElieceCCA2PublicKey" name="org.bouncycastle.pqc.asn1.McElieceCCA2PublicKey getInstance(java.lang.Object)" map="&#x00d6;"/>
  <method class="org.bouncycastle.pqc.asn1.McElieceCCA2PublicKey" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigest()" map="&#x0161;"/>
  <method class="org.bouncycastle.pqc.asn1.McElieceCCA2PublicKey" name="int getN()" map="&#x0162;"/>
  <method class="org.bouncycastle.pqc.asn1.McElieceCCA2PublicKey" name="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getG()" map="&#x0163;"/>
  <method class="org.bouncycastle.pqc.asn1.McElieceCCA2PublicKey" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.pqc.asn1.McElieceCCA2PublicKey" name="int getT()" map="&#x0164;"/>
  <class name="org.bouncycastle.pqc.asn1.McEliecePublicKey" map="M"/>
  <field class="org.bouncycastle.pqc.asn1.McEliecePublicKey" name="t" map="&#x040a;"/>
  <field class="org.bouncycastle.pqc.asn1.McEliecePublicKey" name="g" map="&#x040b;"/>
  <field class="org.bouncycastle.pqc.asn1.McEliecePublicKey" name="n" map="&#x040c;"/>
  <method class="org.bouncycastle.pqc.asn1.McEliecePublicKey" name="int getN()" map="&#x0165;"/>
  <method class="org.bouncycastle.pqc.asn1.McEliecePublicKey" name="org.bouncycastle.pqc.asn1.McEliecePublicKey getInstance(java.lang.Object)" map="&#x00d8;"/>
  <method class="org.bouncycastle.pqc.asn1.McEliecePublicKey" name="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getG()" map="&#x0166;"/>
  <method class="org.bouncycastle.pqc.asn1.McEliecePublicKey" name="org.bouncycastle.asn1.ASN1Primitive toASN1Primitive()" map="A"/>
  <method class="org.bouncycastle.pqc.asn1.McEliecePublicKey" name="int getT()" map="&#x0167;"/>
  <package name="org.bouncycastle.pqc.jcajce" map="B"/>
  <package name="org.bouncycastle.pqc.jcajce.spec" map="A"/>
  <class name="org.bouncycastle.pqc.jcajce.spec.RainbowPublicKeySpec" map="A"/>
  <field class="org.bouncycastle.pqc.jcajce.spec.RainbowPublicKeySpec" name="coeffsingular" map="A"/>
  <field class="org.bouncycastle.pqc.jcajce.spec.RainbowPublicKeySpec" name="coeffquadratic" map="B"/>
  <field class="org.bouncycastle.pqc.jcajce.spec.RainbowPublicKeySpec" name="docLength" map="C"/>
  <field class="org.bouncycastle.pqc.jcajce.spec.RainbowPublicKeySpec" name="coeffscalar" map="D"/>
  <method class="org.bouncycastle.pqc.jcajce.spec.RainbowPublicKeySpec" name="int getDocLength()" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.spec.RainbowPublicKeySpec" name="short[][] getCoeffSingular()" map="B"/>
  <method class="org.bouncycastle.pqc.jcajce.spec.RainbowPublicKeySpec" name="short[] getCoeffScalar()" map="C"/>
  <method class="org.bouncycastle.pqc.jcajce.spec.RainbowPublicKeySpec" name="short[][] getCoeffQuadratic()" map="D"/>
  <class name="org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec" map="B"/>
  <field class="org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec" name="A1inv" map="A"/>
  <field class="org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec" name="b2" map="B"/>
  <field class="org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec" name="b1" map="C"/>
  <field class="org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec" name="layers" map="D"/>
  <field class="org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec" name="vi" map="E"/>
  <field class="org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec" name="A2inv" map="F"/>
  <method class="org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec" name="short[][] getInvA2()" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec" name="short[][] getInvA1()" map="B"/>
  <method class="org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec" name="short[] getB2()" map="C"/>
  <method class="org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec" name="int[] getVi()" map="D"/>
  <method class="org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec" name="org.bouncycastle.pqc.crypto.rainbow.Layer[] getLayers()" map="E"/>
  <method class="org.bouncycastle.pqc.jcajce.spec.RainbowPrivateKeySpec" name="short[] getB1()" map="F"/>
  <package name="org.bouncycastle.pqc.jcajce.provider" map="B"/>
  <package name="org.bouncycastle.pqc.jcajce.provider.xmss" map="A"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPrivateKey" map="A"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPrivateKey" name="keyParams" map="C"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPrivateKey" name="treeDigest" map="D"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPrivateKey" name="java.lang.String getFormat()" map="getFormat"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPrivateKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPrivateKey" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPrivateKey" name="org.bouncycastle.pqc.asn1.XMSSMTPrivateKey createKeyStructure()" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPrivateKey" name="java.lang.String getAlgorithm()" map="getAlgorithm"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPrivateKey" name="byte[] getEncoded()" map="getEncoded"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPublicKey" map="B"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPublicKey" name="treeDigest" map="C"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPublicKey" name="keyParams" map="D"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPublicKey" name="java.lang.String getFormat()" map="getFormat"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPublicKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPublicKey" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPublicKey" name="java.lang.String getAlgorithm()" map="getAlgorithm"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPublicKey" name="byte[] getEncoded()" map="getEncoded"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPrivateKey" map="C"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPrivateKey" name="treeDigest" map="A"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPrivateKey" name="keyParams" map="B"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPrivateKey" name="java.lang.String getFormat()" map="getFormat"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPrivateKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPrivateKey" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPrivateKey" name="org.bouncycastle.pqc.asn1.XMSSPrivateKey createKeyStructure()" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPrivateKey" name="java.lang.String getAlgorithm()" map="getAlgorithm"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSPrivateKey" name="byte[] getEncoded()" map="getEncoded"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPublicKey" map="D"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPublicKey" name="keyParams" map="A"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPublicKey" name="treeDigest" map="B"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPublicKey" name="java.lang.String getFormat()" map="getFormat"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPublicKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPublicKey" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPublicKey" name="java.lang.String getAlgorithm()" map="getAlgorithm"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.BCXMSSMTPublicKey" name="byte[] getEncoded()" map="getEncoded"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.xmss.XMSSMTKeyFactorySpi" map="E"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.XMSSMTKeyFactorySpi" name="java.security.PublicKey engineGeneratePublic(java.security.spec.KeySpec)" map="engineGeneratePublic"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.XMSSMTKeyFactorySpi" name="java.security.PrivateKey engineGeneratePrivate(java.security.spec.KeySpec)" map="engineGeneratePrivate"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.XMSSMTKeyFactorySpi" name="java.security.Key engineTranslateKey(java.security.Key)" map="engineTranslateKey"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.XMSSMTKeyFactorySpi" name="java.security.spec.KeySpec engineGetKeySpec(java.security.Key, java.lang.Class)" map="engineGetKeySpec"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.XMSSMTKeyFactorySpi" name="java.security.PrivateKey generatePrivate(org.bouncycastle.asn1.pkcs.PrivateKeyInfo)" map="E"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.XMSSMTKeyFactorySpi" name="java.security.PublicKey generatePublic(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)" map="A"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.xmss.XMSSKeyFactorySpi" map="F"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.XMSSKeyFactorySpi" name="java.security.PublicKey engineGeneratePublic(java.security.spec.KeySpec)" map="engineGeneratePublic"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.XMSSKeyFactorySpi" name="java.security.PrivateKey engineGeneratePrivate(java.security.spec.KeySpec)" map="engineGeneratePrivate"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.XMSSKeyFactorySpi" name="java.security.Key engineTranslateKey(java.security.Key)" map="engineTranslateKey"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.XMSSKeyFactorySpi" name="java.security.spec.KeySpec engineGetKeySpec(java.security.Key, java.lang.Class)" map="engineGetKeySpec"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.XMSSKeyFactorySpi" name="java.security.PrivateKey generatePrivate(org.bouncycastle.asn1.pkcs.PrivateKeyInfo)" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.XMSSKeyFactorySpi" name="java.security.PublicKey generatePublic(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)" map="A"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.xmss.DigestUtil" map="G"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.xmss.DigestUtil" name="org.bouncycastle.crypto.Digest getDigest(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="A"/>
  <package name="org.bouncycastle.pqc.jcajce.provider.util" map="B"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.util.KeyUtil" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.util.KeyUtil" name="byte[] getEncodedSubjectPublicKeyInfo(org.bouncycastle.asn1.x509.AlgorithmIdentifier, org.bouncycastle.asn1.ASN1Encodable)" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.util.KeyUtil" name="byte[] getEncodedSubjectPublicKeyInfo(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)" map="A"/>
  <package name="org.bouncycastle.pqc.jcajce.provider.sphincs" map="C"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PublicKey" map="A"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PublicKey" name="treeDigest" map="C"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PublicKey" name="params" map="D"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PublicKey" name="java.lang.String getFormat()" map="getFormat"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PublicKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PublicKey" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PublicKey" name="java.lang.String getAlgorithm()" map="getAlgorithm"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PublicKey" name="byte[] getEncoded()" map="getEncoded"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.sphincs.Sphincs256KeyFactorySpi" map="B"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.Sphincs256KeyFactorySpi" name="java.security.PublicKey engineGeneratePublic(java.security.spec.KeySpec)" map="engineGeneratePublic"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.Sphincs256KeyFactorySpi" name="java.security.PrivateKey engineGeneratePrivate(java.security.spec.KeySpec)" map="engineGeneratePrivate"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.Sphincs256KeyFactorySpi" name="java.security.Key engineTranslateKey(java.security.Key)" map="engineTranslateKey"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.Sphincs256KeyFactorySpi" name="java.security.spec.KeySpec engineGetKeySpec(java.security.Key, java.lang.Class)" map="engineGetKeySpec"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.Sphincs256KeyFactorySpi" name="java.security.PrivateKey generatePrivate(org.bouncycastle.asn1.pkcs.PrivateKeyInfo)" map="B"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.Sphincs256KeyFactorySpi" name="java.security.PublicKey generatePublic(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)" map="A"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PrivateKey" map="C"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PrivateKey" name="treeDigest" map="A"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PrivateKey" name="params" map="B"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PrivateKey" name="java.lang.String getFormat()" map="getFormat"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PrivateKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PrivateKey" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PrivateKey" name="java.lang.String getAlgorithm()" map="getAlgorithm"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.sphincs.BCSphincs256PrivateKey" name="byte[] getEncoded()" map="getEncoded"/>
  <package name="org.bouncycastle.pqc.jcajce.provider.newhope" map="D"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.newhope.NHKeyFactorySpi" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.NHKeyFactorySpi" name="java.security.PublicKey engineGeneratePublic(java.security.spec.KeySpec)" map="engineGeneratePublic"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.NHKeyFactorySpi" name="java.security.PrivateKey engineGeneratePrivate(java.security.spec.KeySpec)" map="engineGeneratePrivate"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.NHKeyFactorySpi" name="java.security.Key engineTranslateKey(java.security.Key)" map="engineTranslateKey"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.NHKeyFactorySpi" name="java.security.spec.KeySpec engineGetKeySpec(java.security.Key, java.lang.Class)" map="engineGetKeySpec"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.NHKeyFactorySpi" name="java.security.PrivateKey generatePrivate(org.bouncycastle.asn1.pkcs.PrivateKeyInfo)" map="C"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.NHKeyFactorySpi" name="java.security.PublicKey generatePublic(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)" map="A"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPublicKey" map="B"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPublicKey" name="params" map="B"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPublicKey" name="java.lang.String getFormat()" map="getFormat"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPublicKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPublicKey" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPublicKey" name="java.lang.String getAlgorithm()" map="getAlgorithm"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPublicKey" name="byte[] getEncoded()" map="getEncoded"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPrivateKey" map="C"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPrivateKey" name="params" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPrivateKey" name="java.lang.String getFormat()" map="getFormat"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPrivateKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPrivateKey" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPrivateKey" name="java.lang.String getAlgorithm()" map="getAlgorithm"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPrivateKey" name="byte[] getEncoded()" map="getEncoded"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.newhope.BCNHPrivateKey" name="short[] convert(byte[])" map="A"/>
  <package name="org.bouncycastle.pqc.jcajce.provider.rainbow" map="E"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" map="A"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="A1inv" map="A"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="b2" map="B"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="b1" map="C"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="layers" map="D"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="vi" map="E"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="A2inv" map="F"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="byte[] getEncoded()" map="getEncoded"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="java.lang.String getAlgorithm()" map="getAlgorithm"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="org.bouncycastle.pqc.crypto.rainbow.Layer[] getLayers()" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="int[] getVi()" map="B"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="short[][] getInvA1()" map="C"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="short[] getB2()" map="D"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="short[] getB1()" map="E"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="java.lang.String getFormat()" map="getFormat"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPrivateKey" name="short[][] getInvA2()" map="F"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.rainbow.RainbowKeyFactorySpi" map="B"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.RainbowKeyFactorySpi" name="java.security.PublicKey engineGeneratePublic(java.security.spec.KeySpec)" map="engineGeneratePublic"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.RainbowKeyFactorySpi" name="java.security.PrivateKey engineGeneratePrivate(java.security.spec.KeySpec)" map="engineGeneratePrivate"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.RainbowKeyFactorySpi" name="java.security.Key engineTranslateKey(java.security.Key)" map="engineTranslateKey"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.RainbowKeyFactorySpi" name="java.security.spec.KeySpec engineGetKeySpec(java.security.Key, java.lang.Class)" map="engineGetKeySpec"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.RainbowKeyFactorySpi" name="java.security.PrivateKey generatePrivate(org.bouncycastle.asn1.pkcs.PrivateKeyInfo)" map="D"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.RainbowKeyFactorySpi" name="java.security.PublicKey generatePublic(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)" map="A"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPublicKey" map="C"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPublicKey" name="coeffsingular" map="A"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPublicKey" name="coeffquadratic" map="B"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPublicKey" name="docLength" map="C"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPublicKey" name="coeffscalar" map="D"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPublicKey" name="byte[] getEncoded()" map="getEncoded"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPublicKey" name="java.lang.String getAlgorithm()" map="getAlgorithm"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPublicKey" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPublicKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPublicKey" name="short[][] getCoeffQuadratic()" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPublicKey" name="short[][] getCoeffSingular()" map="B"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPublicKey" name="short[] getCoeffScalar()" map="C"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPublicKey" name="int getDocLength()" map="D"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.rainbow.BCRainbowPublicKey" name="java.lang.String getFormat()" map="getFormat"/>
  <package name="org.bouncycastle.pqc.jcajce.provider.mceliece" map="F"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PublicKey" map="A"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PublicKey" name="params" map="&#x00a2;"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PublicKey" name="byte[] getEncoded()" map="getEncoded"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PublicKey" name="java.lang.String getAlgorithm()" map="getAlgorithm"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PublicKey" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PublicKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PublicKey" name="int getN()" map="o"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PublicKey" name="java.lang.String getFormat()" map="getFormat"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PublicKey" name="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getG()" map="p"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PublicKey" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PublicKey" name="int getT()" map="q"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.mceliece.McElieceCCA2KeyFactorySpi" map="B"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.McElieceCCA2KeyFactorySpi" name="java.security.PublicKey engineGeneratePublic(java.security.spec.KeySpec)" map="engineGeneratePublic"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.McElieceCCA2KeyFactorySpi" name="java.security.PrivateKey engineGeneratePrivate(java.security.spec.KeySpec)" map="engineGeneratePrivate"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.McElieceCCA2KeyFactorySpi" name="java.security.Key engineTranslateKey(java.security.Key)" map="engineTranslateKey"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.McElieceCCA2KeyFactorySpi" name="java.security.spec.KeySpec engineGetKeySpec(java.security.Key, java.lang.Class)" map="engineGetKeySpec"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.McElieceCCA2KeyFactorySpi" name="java.security.PublicKey generatePublic(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)" map="A"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePublicKey" map="C"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePublicKey" name="params" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePublicKey" name="byte[] getEncoded()" map="getEncoded"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePublicKey" name="java.lang.String getAlgorithm()" map="getAlgorithm"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePublicKey" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePublicKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePublicKey" name="int getN()" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePublicKey" name="java.lang.String getFormat()" map="getFormat"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePublicKey" name="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getG()" map="B"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePublicKey" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePublicKey" name="int getT()" map="C"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.mceliece.Utils" map="D"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.Utils" name="org.bouncycastle.crypto.Digest getDigest(org.bouncycastle.asn1.x509.AlgorithmIdentifier)" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.Utils" name="org.bouncycastle.asn1.x509.AlgorithmIdentifier getDigAlgId(java.lang.String)" map="A"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.mceliece.McElieceKeyFactorySpi" map="E"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.McElieceKeyFactorySpi" name="java.security.PublicKey engineGeneratePublic(java.security.spec.KeySpec)" map="engineGeneratePublic"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.McElieceKeyFactorySpi" name="java.security.PrivateKey engineGeneratePrivate(java.security.spec.KeySpec)" map="engineGeneratePrivate"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.McElieceKeyFactorySpi" name="java.security.Key engineTranslateKey(java.security.Key)" map="engineTranslateKey"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.McElieceKeyFactorySpi" name="java.security.spec.KeySpec engineGetKeySpec(java.security.Key, java.lang.Class)" map="engineGetKeySpec"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.McElieceKeyFactorySpi" name="java.security.PublicKey generatePublic(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)" map="A"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PrivateKey" map="F"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PrivateKey" name="params" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.Permutation getP()" map="A"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PrivateKey" name="byte[] getEncoded()" map="getEncoded"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PrivateKey" name="java.lang.String getAlgorithm()" map="getAlgorithm"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PrivateKey" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PrivateKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PrivateKey" name="int getK()" map="B"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getH()" map="C"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.GF2mField getField()" map="D"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PrivateKey" name="int getN()" map="E"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PrivateKey" name="java.lang.String getFormat()" map="getFormat"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcElieceCCA2PrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM getGoppaPoly()" map="F"/>
  <class name="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePrivateKey" map="G"/>
  <field class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePrivateKey" name="params" map="&#x00a3;"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePrivateKey" name="byte[] getEncoded()" map="getEncoded"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePrivateKey" name="java.lang.String getAlgorithm()" map="getAlgorithm"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePrivateKey" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePrivateKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.Permutation getP1()" map="r"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePrivateKey" name="int getK()" map="s"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.GF2mField getField()" map="t"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePrivateKey" name="int getN()" map="u"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.Permutation getP2()" map="v"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePrivateKey" name="java.lang.String getFormat()" map="getFormat"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM getGoppaPoly()" map="w"/>
  <method class="org.bouncycastle.pqc.jcajce.provider.mceliece.BCMcEliecePrivateKey" name="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getSInv()" map="x"/>
  <package name="org.bouncycastle.pqc.jcajce.interfaces" map="C"/>
  <class name="org.bouncycastle.pqc.jcajce.interfaces.XMSSKey" map="A"/>
  <class name="org.bouncycastle.pqc.jcajce.interfaces.SPHINCSKey" map="B"/>
  <class name="org.bouncycastle.pqc.jcajce.interfaces.NHPrivateKey" map="C"/>
  <class name="org.bouncycastle.pqc.jcajce.interfaces.NHPublicKey" map="D"/>
  <class name="org.bouncycastle.pqc.jcajce.interfaces.XMSSMTKey" map="E"/>
  <class name="org.bouncycastle.pqc.jcajce.interfaces.NHKey" map="F"/>
  <package name="org.bouncycastle.pqc.math" map="C"/>
  <package name="org.bouncycastle.pqc.math.linearalgebra" map="A"/>
  <class name="org.bouncycastle.pqc.math.linearalgebra.GoppaCode" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GoppaCode" name="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix createCanonicalCheckMatrix(org.bouncycastle.pqc.math.linearalgebra.GF2mField, org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM)" map="A"/>
  <class name="org.bouncycastle.pqc.math.linearalgebra.Matrix" map="B"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.Matrix" name="numColumns" map="A"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.Matrix" name="numRows" map="B"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.Matrix" name="int getNumColumns()" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.Matrix" name="int getNumRows()" map="B"/>
  <class name="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix" map="C"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix" name="matrix" map="C"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix" name="length" map="D"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix" name="byte[] getEncoded()" map="C"/>
  <class name="org.bouncycastle.pqc.math.linearalgebra.Permutation" map="D"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.Permutation" name="perm" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.Permutation" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.Permutation" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.Permutation" name="boolean isPermutation(int[])" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.Permutation" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.Permutation" name="byte[] getEncoded()" map="A"/>
  <class name="org.bouncycastle.pqc.math.linearalgebra.GF2mField" map="E"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.GF2mField" name="polynomial" map="A"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.GF2mField" name="degree" map="B"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2mField" name="java.lang.String polyToString(int)" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2mField" name="byte[] getEncoded()" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2mField" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2mField" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2mField" name="int mult(int, int)" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2mField" name="int exp(int, int)" map="B"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2mField" name="int add(int, int)" map="C"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2mField" name="boolean isElementOfThisField(int)" map="B"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2mField" name="java.lang.String elementToStr(int)" map="C"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2mField" name="int getDegree()" map="B"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2mField" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.GF2mField" name="int inverse(int)" map="D"/>
  <class name="org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2" map="F"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2" name="int gcd(int, int)" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2" name="int degree(int)" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2" name="boolean isIrreducible(int)" map="B"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2" name="int remainder(int, int)" map="B"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2" name="int modMultiply(int, int, int)" map="A"/>
  <class name="org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2m" map="G"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2m" name="sqMatrix" map="A"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2m" name="sqRootMatrix" map="B"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2m" name="p" map="C"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2m" name="field" map="D"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2m" name="void computeSquareRootMatrix()" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2m" name="void swapColumns(org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM[], int, int)" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2m" name="void computeSquaringMatrix()" map="B"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialRingGF2m" name="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM[] getSquareRootMatrix()" map="C"/>
  <class name="org.bouncycastle.pqc.math.linearalgebra.LittleEndianConversions" map="H"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.LittleEndianConversions" name="byte[] I2OSP(int)" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.LittleEndianConversions" name="int OS2IP(byte[], int)" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.LittleEndianConversions" name="int OS2IP(byte[])" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.LittleEndianConversions" name="int OS2IP(byte[], int, int)" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.LittleEndianConversions" name="void I2OSP(int, byte[], int, int)" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.LittleEndianConversions" name="void I2OSP(int, byte[], int)" map="A"/>
  <class name="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" map="I"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="coefficients" map="A"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="degree" map="B"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="field" map="C"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="void multThisWithElement(int)" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="int[] multWithMonomial(int[], int)" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM multWithElement(int)" map="B"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="int getCoefficient(int)" map="C"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="int computeDegree(int[])" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="byte[] getEncoded()" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="int getDegree()" map="B"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="void addToThis(org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM)" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="int evaluateAt(int)" map="D"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="int[] multWithElement(int[], int)" map="B"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="int headCoefficient(int[])" map="B"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="boolean isEqual(int[], int[])" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="int[] add(int[], int[])" map="B"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="int[] normalForm(int[])" map="C"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM mod(org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM)" map="B"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="void computeDegree()" map="C"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM" name="int[] mod(int[], int[])" map="C"/>
  <class name="org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions" map="J"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions" name="TWO" map="A"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions" name="ZERO" map="B"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions" name="FOUR" map="C"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions" name="ONE" map="D"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions" name="jacobiTable" map="E"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions" name="sr" map="F"/>
  <field class="org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions" name="SMALL_PRIMES" map="G"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.IntegerFunctions" name="int ceilLog256(int)" map="A"/>
  <class name="org.bouncycastle.pqc.math.linearalgebra.IntUtils" map="K"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.IntUtils" name="int[] clone(int[])" map="A"/>
  <method class="org.bouncycastle.pqc.math.linearalgebra.IntUtils" name="boolean equals(int[], int[])" map="A"/>
  <package name="org.bouncycastle.pqc.crypto" map="D"/>
  <package name="org.bouncycastle.pqc.crypto.xmss" map="A"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSUtil$CheckingStream" map="_A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil$CheckingStream" name="mainClass" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil$CheckingStream" name="components" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil$CheckingStream" name="found" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil$CheckingStream" name="java.lang.Class resolveClass(java.io.ObjectStreamClass)" map="resolveClass"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="int getDigestSize(org.bouncycastle.crypto.Digest)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="boolean hasNullPointer(byte[][])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="java.lang.Object deserialize(byte[], java.lang.Class)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="long bytesToXBigEndian(byte[], int, int)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="boolean isIndexValid(int, long)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="byte[] cloneArray(byte[])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="int calculateTau(int, int)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="boolean isNewAuthenticationPathNeeded(long, int, int)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="int getLeafIndex(long, int)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="long getTreeIndex(long, int)" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="byte[] serialize(java.lang.Object)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="void copyBytesAtOffset(byte[], byte[], int)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="byte[][] cloneArray(byte[][])" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="byte[] toBytesBigEndian(long, int)" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="int log2(int)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSUtil" name="byte[] extractBytesAtOffset(byte[], int, int)" map="B"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSParameters" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSParameters" name="height" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSParameters" name="k" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSParameters" name="wotsPlus" map="C"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSParameters" name="oid" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSParameters" name="org.bouncycastle.crypto.Digest getDigest()" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSParameters" name="int getWinternitzParameter()" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSParameters" name="int getK()" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSParameters" name="org.bouncycastle.pqc.crypto.xmss.WOTSPlus getWOTSPlus()" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSParameters" name="int determineMinK()" map="E"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSParameters" name="int getDigestSize()" map="F"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSParameters" name="int getHeight()" map="G"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder" map="_A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder" name="type" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder" name="layerAddress" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder" name="treeAddress" map="C"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder" name="keyAndMask" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder" name="int access$200(org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder" name="long access$100(org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder)" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder withLayerAddress(int)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder" name="int access$000(org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder)" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder withKeyAndMask(int)" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder withTreeAddress(long)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder getThis()" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder" name="int access$300(org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder)" map="D"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSAddress" map="C"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress" name="type" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress" name="layerAddress" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress" name="treeAddress" map="C"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress" name="keyAndMask" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress" name="long getTreeAddress()" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress" name="int getLayerAddress()" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress" name="int getKeyAndMask()" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSAddress" name="byte[] toByteArray()" map="D"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSStoreableObjectInterface" map="D"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSNodeUtil" map="E"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSNodeUtil" name="org.bouncycastle.pqc.crypto.xmss.XMSSNode lTree(org.bouncycastle.pqc.crypto.xmss.WOTSPlus, org.bouncycastle.pqc.crypto.xmss.WOTSPlusPublicKeyParameters, org.bouncycastle.pqc.crypto.xmss.LTreeAddress)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSNodeUtil" name="org.bouncycastle.pqc.crypto.xmss.XMSSNode randomizeHash(org.bouncycastle.pqc.crypto.xmss.WOTSPlus, org.bouncycastle.pqc.crypto.xmss.XMSSNode, org.bouncycastle.pqc.crypto.xmss.XMSSNode, org.bouncycastle.pqc.crypto.xmss.XMSSAddress)" map="A"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$1" map="1"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder" map="_A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder" name="chainAddress" map="E"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder" name="hashAddress" map="F"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder" name="otsAddress" map="G"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder" name="int access$100(org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSAddress build()" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder withHashAddress(int)" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder getThis()" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder" name="int access$200(org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder)" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder withChainAddress(int)" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder getThis()" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder withOTSAddress(int)" map="E"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder" name="int access$000(org.bouncycastle.pqc.crypto.xmss.OTSHashAddress$Builder)" map="C"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress" map="F"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress" name="chainAddress" map="E"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress" name="hashAddress" map="F"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress" name="otsAddress" map="G"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress" name="int getHashAddress()" map="E"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress" name="int getChainAddress()" map="F"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress" name="int getOTSAddress()" map="G"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.OTSHashAddress" name="byte[] toByteArray()" map="D"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$1" map="1"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder" map="_A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder" name="root" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder" name="publicKey" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder" name="publicSeed" map="C"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder" name="params" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSParameters access$000(org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder" name="byte[] access$100(org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder)" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder withPublicSeed(byte[])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder withRoot(byte[])" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder" name="byte[] access$300(org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder)" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder" name="byte[] access$200(org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder)" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters build()" map="A"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters" map="G"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters" name="root" map="W"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters" name="publicSeed" map="X"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters" name="params" map="Y"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters" name="byte[] getRoot()" map="N"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters" name="org.bouncycastle.pqc.crypto.xmss.XMSSParameters getParameters()" map="O"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters" name="byte[] getPublicSeed()" map="P"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPublicKeyParameters" name="byte[] toByteArray()" map="Q"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$1" map="1"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder" map="_A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder" name="root" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder" name="publicKey" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder" name="publicSeed" map="C"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder" name="params" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder" name="byte[] access$100(org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder" name="byte[] access$300(org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder)" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder" name="byte[] access$200(org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder)" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder withRoot(byte[])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters access$000(org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder)" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder withPublicSeed(byte[])" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters build()" map="A"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters" map="H"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters" name="root" map="G"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters" name="publicSeed" map="H"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters" name="params" map="I"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters" name="byte[] getRoot()" map="F"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters" name="byte[] getPublicSeed()" map="G"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters" name="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters getParameters()" map="H"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPublicKeyParameters" name="byte[] toByteArray()" map="I"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.WOTSPlusPublicKeyParameters" map="I"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusPublicKeyParameters" name="publicKey" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusPublicKeyParameters" name="byte[][] toByteArray()" map="A"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.BDSStateMap" map="J"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDSStateMap" name="bdsState" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDSStateMap" name="void setXMSS(org.bouncycastle.pqc.crypto.xmss.XMSSParameters)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDSStateMap" name="void updateState(org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters, long, byte[], byte[])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDSStateMap" name="org.bouncycastle.pqc.crypto.xmss.BDS update(int, byte[], byte[], org.bouncycastle.pqc.crypto.xmss.OTSHashAddress)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDSStateMap" name="void put(int, org.bouncycastle.pqc.crypto.xmss.BDS)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDSStateMap" name="org.bouncycastle.pqc.crypto.xmss.BDS get(int)" map="A"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$1" map="1"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder" map="_A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder" name="treeIndex" map="H"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder" name="treeHeight" map="I"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder" name="int access$100(org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder withTreeHeight(int)" map="F"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder getThis()" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSAddress build()" map="E"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder getThis()" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder" name="int access$000(org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder)" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress$Builder withTreeIndex(int)" map="G"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress" map="K"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress" name="treeIndex" map="H"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress" name="padding" map="I"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress" name="treeHeight" map="J"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress" name="int getTreeHeight()" map="H"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress" name="int getTreeIndex()" map="I"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.HashTreeAddress" name="byte[] toByteArray()" map="D"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSOid" map="L"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSOid" map="M"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSOid" name="stringRepresentation" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSOid" name="oid" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSOid" name="oidLookupTable" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSOid" name="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSOid lookup(java.lang.String, int, int, int, int)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSOid" name="java.lang.String toString()" map="toString"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSOid" name="java.lang.String createKey(java.lang.String, int, int, int, int)" map="B"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$1" map="1"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" map="_A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="secretKeySeed" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="params" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="xmss" map="C"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="index" map="D"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="secretKeyPRF" map="E"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="root" map="F"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="bdsState" map="G"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="privateKey" map="H"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="publicSeed" map="I"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="byte[] access$400(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder withBDSState(org.bouncycastle.pqc.crypto.xmss.BDS)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="byte[] access$300(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder)" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder withSecretKeyPRF(byte[])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSParameters access$200(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder)" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="byte[] access$100(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder)" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder withSecretKeySeed(byte[])" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder withIndex(int)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSParameters access$000(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder)" map="E"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="int access$800(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder)" map="F"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder withPublicSeed(byte[])" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder withRoot(byte[])" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="byte[] access$600(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder)" map="G"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters build()" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="byte[] access$500(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder)" map="H"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.BDS access$700(org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters$Builder)" map="I"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters" map="N"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters" name="secretKeyPRF" map="J"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters" name="root" map="K"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters" name="bdsState" map="L"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters" name="secretKeySeed" map="M"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters" name="publicSeed" map="N"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters" name="params" map="O"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters" name="org.bouncycastle.pqc.crypto.xmss.XMSSParameters getParameters()" map="J"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters" name="byte[] toByteArray()" map="K"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSNode" map="O"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSNode" name="height" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSNode" name="value" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSNode" name="byte[] getValue()" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSNode" name="java.lang.Object clone()" map="clone"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSNode" name="org.bouncycastle.pqc.crypto.xmss.XMSSNode clone()" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSNode" name="int getHeight()" map="C"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters" map="P"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters" name="height" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters" name="xmssParams" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters" name="oid" map="C"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters" name="layers" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters" name="org.bouncycastle.crypto.Digest getDigest()" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters" name="int getWinternitzParameter()" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters" name="org.bouncycastle.pqc.crypto.xmss.XMSSParameters getXMSSParameters()" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters" name="int xmssTreeHeight(int, int)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters" name="int getLen()" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters" name="int getDigestSize()" map="E"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters" name="int getLayers()" map="F"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters" name="int getHeight()" map="G"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.KeyedHashFunctions" map="Q"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.KeyedHashFunctions" name="digestSize" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.KeyedHashFunctions" name="digest" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.KeyedHashFunctions" name="byte[] F(byte[], byte[])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.KeyedHashFunctions" name="byte[] PRF(byte[], byte[])" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.KeyedHashFunctions" name="byte[] coreDigest(int, byte[], byte[])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.KeyedHashFunctions" name="byte[] H(byte[], byte[])" map="C"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.WOTSPlusOid" map="R"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusOid" name="stringRepresentation" map="D"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusOid" name="oid" map="E"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusOid" name="oidLookupTable" map="F"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusOid" name="java.lang.String createKey(java.lang.String, int, int, int)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusOid" name="org.bouncycastle.pqc.crypto.xmss.WOTSPlusOid lookup(java.lang.String, int, int, int)" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusOid" name="java.lang.String toString()" map="toString"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.WOTSPlus" map="S"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.WOTSPlus" name="secretKeySeed" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.WOTSPlus" name="khf" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.WOTSPlus" name="publicSeed" map="C"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.WOTSPlus" name="params" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlus" name="org.bouncycastle.pqc.crypto.xmss.KeyedHashFunctions getKhf()" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlus" name="void importKeys(byte[], byte[])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlus" name="org.bouncycastle.pqc.crypto.xmss.WOTSPlusPublicKeyParameters getPublicKey(org.bouncycastle.pqc.crypto.xmss.OTSHashAddress)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlus" name="org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters getParams()" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlus" name="byte[] expandSecretKeySeed(int)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlus" name="byte[] getWOTSPlusSecretKey(byte[], org.bouncycastle.pqc.crypto.xmss.OTSHashAddress)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlus" name="byte[] chain(byte[], int, int, org.bouncycastle.pqc.crypto.xmss.OTSHashAddress)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlus" name="byte[] getPublicSeed()" map="C"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash" map="T"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash" name="nextIndex" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash" name="height" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash" name="initialHeight" map="C"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash" name="tailNode" map="D"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash" name="initialized" map="E"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash" name="finished" map="F"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash" name="boolean isFinished()" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash" name="void setNode(org.bouncycastle.pqc.crypto.xmss.XMSSNode)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash" name="int getIndexLeaf()" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash" name="void initialize(int)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash" name="boolean isInitialized()" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash" name="org.bouncycastle.pqc.crypto.xmss.XMSSNode getTailNode()" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash" name="void update(java.util.Stack, org.bouncycastle.pqc.crypto.xmss.WOTSPlus, byte[], byte[], org.bouncycastle.pqc.crypto.xmss.OTSHashAddress)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash" name="int getHeight()" map="E"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.BDS" map="U"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDS" name="keep" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDS" name="authenticationPath" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDS" name="treeHashInstances" map="C"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDS" name="k" map="D"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDS" name="wotsPlus" map="E"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDS" name="index" map="F"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDS" name="retain" map="G"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDS" name="root" map="H"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDS" name="stack" map="I"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDS" name="treeHeight" map="J"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.BDS" name="used" map="K"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDS" name="void setXMSS(org.bouncycastle.pqc.crypto.xmss.XMSSParameters)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDS" name="void validate()" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDS" name="org.bouncycastle.pqc.crypto.xmss.BDSTreeHash getBDSTreeHashInstanceForUpdate()" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDS" name="void nextAuthenticationPath(byte[], byte[], org.bouncycastle.pqc.crypto.xmss.OTSHashAddress)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDS" name="void initialize(byte[], byte[], org.bouncycastle.pqc.crypto.xmss.OTSHashAddress)" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDS" name="org.bouncycastle.pqc.crypto.xmss.BDS getNextState(byte[], byte[], org.bouncycastle.pqc.crypto.xmss.OTSHashAddress)" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.BDS" name="int getIndex()" map="C"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters" map="V"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters" name="len" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters" name="len2" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters" name="len1" map="C"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters" name="winternitzParameter" map="D"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters" name="digestSize" map="E"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters" name="oid" map="F"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters" name="digest" map="G"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters" name="org.bouncycastle.crypto.Digest getDigest()" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters" name="int getWinternitzParameter()" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters" name="int getLen()" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.WOTSPlusParameters" name="int getDigestSize()" map="D"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$1" map="1"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder" map="_A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder" name="lTreeAddress" map="J"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder" name="treeIndex" map="K"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder" name="treeHeight" map="L"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder getThis()" map="F"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder" name="int access$000(org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder withTreeIndex(int)" map="H"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSAddress build()" map="G"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder withTreeHeight(int)" map="I"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder withLTreeAddress(int)" map="J"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder" name="int access$200(org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder)" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSAddress$Builder getThis()" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder" name="int access$100(org.bouncycastle.pqc.crypto.xmss.LTreeAddress$Builder)" map="C"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.LTreeAddress" map="W"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress" name="lTreeAddress" map="K"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress" name="treeIndex" map="L"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress" name="treeHeight" map="M"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress" name="int getLTreeAddress()" map="J"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress" name="int getTreeHeight()" map="K"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress" name="int getTreeIndex()" map="L"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.LTreeAddress" name="byte[] toByteArray()" map="D"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$1" map="1"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" map="_A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="secretKeySeed" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="params" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="xmss" map="C"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="index" map="D"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="secretKeyPRF" map="E"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="root" map="F"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="bdsState" map="G"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="privateKey" map="H"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="publicSeed" map="I"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="byte[] access$100(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder withIndex(long)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="byte[] access$400(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder)" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder withBDSState(org.bouncycastle.pqc.crypto.xmss.BDSStateMap)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="byte[] access$700(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder)" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="byte[] access$600(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder)" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder withSecretKeyPRF(byte[])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters build()" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder withRoot(byte[])" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder withSecretKeySeed(byte[])" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSParameters access$200(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder)" map="E"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.BDSStateMap access$800(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder)" map="F"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters access$000(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder)" map="G"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="byte[] access$500(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder)" map="H"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder withPublicSeed(byte[])" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder" name="long access$300(org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters$Builder)" map="I"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters" map="X"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters" name="secretKeyPRF" map="P"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters" name="root" map="Q"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters" name="bdsState" map="R"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters" name="index" map="S"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters" name="secretKeySeed" map="T"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters" name="publicSeed" map="U"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters" name="params" map="V"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters" name="org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters getParameters()" map="L"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters" name="byte[] toByteArray()" map="M"/>
  <class name="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSMTOid" map="Y"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSMTOid" name="stringRepresentation" map="G"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSMTOid" name="oid" map="H"/>
  <field class="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSMTOid" name="oidLookupTable" map="I"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSMTOid" name="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSMTOid lookup(java.lang.String, int, int, int, int, int)" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSMTOid" name="java.lang.String createKey(java.lang.String, int, int, int, int, int)" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.xmss.DefaultXMSSMTOid" name="java.lang.String toString()" map="toString"/>
  <package name="org.bouncycastle.pqc.crypto.sphincs" map="B"/>
  <class name="org.bouncycastle.pqc.crypto.sphincs.SPHINCSPrivateKeyParameters" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.sphincs.SPHINCSPrivateKeyParameters" name="keyData" map="Z"/>
  <method class="org.bouncycastle.pqc.crypto.sphincs.SPHINCSPrivateKeyParameters" name="byte[] getKeyData()" map="R"/>
  <class name="org.bouncycastle.pqc.crypto.sphincs.SPHINCSPublicKeyParameters" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.sphincs.SPHINCSPublicKeyParameters" name="keyData" map="_"/>
  <method class="org.bouncycastle.pqc.crypto.sphincs.SPHINCSPublicKeyParameters" name="byte[] getKeyData()" map="S"/>
  <package name="org.bouncycastle.pqc.crypto.newhope" map="C"/>
  <class name="org.bouncycastle.pqc.crypto.newhope.NHPrivateKeyParameters" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.newhope.NHPrivateKeyParameters" name="secData" map="a"/>
  <method class="org.bouncycastle.pqc.crypto.newhope.NHPrivateKeyParameters" name="short[] getSecData()" map="T"/>
  <class name="org.bouncycastle.pqc.crypto.newhope.NHPublicKeyParameters" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.newhope.NHPublicKeyParameters" name="pubData" map="b"/>
  <method class="org.bouncycastle.pqc.crypto.newhope.NHPublicKeyParameters" name="byte[] getPubData()" map="U"/>
  <package name="org.bouncycastle.pqc.crypto.rainbow" map="D"/>
  <package name="org.bouncycastle.pqc.crypto.rainbow.util" map="A"/>
  <class name="org.bouncycastle.pqc.crypto.rainbow.util.RainbowUtil" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.util.RainbowUtil" name="short[] convertArray(byte[])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.util.RainbowUtil" name="short[][][] convertArray(byte[][][])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.util.RainbowUtil" name="boolean equals(short[][], short[][])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.util.RainbowUtil" name="byte[][][] convertArray(short[][][])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.util.RainbowUtil" name="boolean equals(short[][][], short[][][])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.util.RainbowUtil" name="int[] convertArraytoInt(byte[])" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.util.RainbowUtil" name="byte[] convertArray(short[])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.util.RainbowUtil" name="boolean equals(short[], short[])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.util.RainbowUtil" name="short[][] convertArray(byte[][])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.util.RainbowUtil" name="byte[] convertIntArray(int[])" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.util.RainbowUtil" name="byte[][] convertArray(short[][])" map="A"/>
  <class name="org.bouncycastle.pqc.crypto.rainbow.Layer" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="coeff_eta" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="coeff_gamma" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="oi" map="C"/>
  <field class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="coeff_beta" map="D"/>
  <field class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="vi" map="E"/>
  <field class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="coeff_alpha" map="F"/>
  <field class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="viNext" map="G"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="short[][][] getCoeffAlpha()" map="A"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="int getVi()" map="B"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="short[][] getCoeffGamma()" map="C"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="short[] getCoeffEta()" map="D"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="short[][][] getCoeffBeta()" map="E"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="int getViNext()" map="F"/>
  <method class="org.bouncycastle.pqc.crypto.rainbow.Layer" name="int getOi()" map="G"/>
  <package name="org.bouncycastle.pqc.crypto.mceliece" map="E"/>
  <class name="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters" map="A"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters" name="k" map="d"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters" name="h" map="e"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters" name="p" map="f"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters" name="field" map="g"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters" name="qInv" map="h"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters" name="goppaPoly" map="i"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters" name="n" map="j"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters" name="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getH()" map="W"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters" name="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM getGoppaPoly()" map="X"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters" name="org.bouncycastle.pqc.math.linearalgebra.Permutation getP()" map="Y"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters" name="int getK()" map="Z"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters" name="org.bouncycastle.pqc.math.linearalgebra.GF2mField getField()" map="_"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PrivateKeyParameters" name="int getN()" map="a"/>
  <class name="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2KeyParameters" map="B"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2KeyParameters" name="params" map="c"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2KeyParameters" name="java.lang.String getDigest()" map="V"/>
  <class name="org.bouncycastle.pqc.crypto.mceliece.McElieceParameters" map="C"/>
  <class name="org.bouncycastle.pqc.crypto.mceliece.McEliecePublicKeyParameters" map="D"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McEliecePublicKeyParameters" name="t" map="o"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McEliecePublicKeyParameters" name="g" map="p"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McEliecePublicKeyParameters" name="n" map="q"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McEliecePublicKeyParameters" name="int getN()" map="e"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McEliecePublicKeyParameters" name="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getG()" map="f"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McEliecePublicKeyParameters" name="int getT()" map="g"/>
  <class name="org.bouncycastle.pqc.crypto.mceliece.McElieceKeyParameters" map="E"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McElieceKeyParameters" name="params" map="n"/>
  <class name="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PublicKeyParameters" map="F"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PublicKeyParameters" name="t" map="k"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PublicKeyParameters" name="matrixG" map="l"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PublicKeyParameters" name="n" map="m"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PublicKeyParameters" name="int getN()" map="b"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PublicKeyParameters" name="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getG()" map="c"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McElieceCCA2PublicKeyParameters" name="int getT()" map="d"/>
  <class name="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" map="G"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="n" map="r"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="k" map="s"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="h" map="t"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="sInv" map="u"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="field" map="v"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="goppaPoly" map="w"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="p2" map="x"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="p1" map="y"/>
  <field class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="qInv" map="z"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="org.bouncycastle.pqc.math.linearalgebra.GF2Matrix getSInv()" map="h"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="org.bouncycastle.pqc.math.linearalgebra.PolynomialGF2mSmallM getGoppaPoly()" map="i"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="int getK()" map="j"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="org.bouncycastle.pqc.math.linearalgebra.Permutation getP2()" map="k"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="org.bouncycastle.pqc.math.linearalgebra.GF2mField getField()" map="l"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="int getN()" map="m"/>
  <method class="org.bouncycastle.pqc.crypto.mceliece.McEliecePrivateKeyParameters" name="org.bouncycastle.pqc.math.linearalgebra.Permutation getP1()" map="n"/>
  <package name="org.bouncycastle.jcajce" map="K"/>
  <package name="org.bouncycastle.jcajce.util" map="A"/>
  <class name="org.bouncycastle.jcajce.util.NamedJcaJceHelper" map="A"/>
  <field class="org.bouncycastle.jcajce.util.NamedJcaJceHelper" name="providerName" map="A"/>
  <method class="org.bouncycastle.jcajce.util.NamedJcaJceHelper" name="java.security.MessageDigest createDigest(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.jcajce.util.NamedJcaJceHelper" name="java.security.KeyFactory createKeyFactory(java.lang.String)" map="B"/>
  <method class="org.bouncycastle.jcajce.util.NamedJcaJceHelper" name="java.security.AlgorithmParameters createAlgorithmParameters(java.lang.String)" map="C"/>
  <method class="org.bouncycastle.jcajce.util.NamedJcaJceHelper" name="javax.crypto.Cipher createCipher(java.lang.String)" map="D"/>
  <method class="org.bouncycastle.jcajce.util.NamedJcaJceHelper" name="java.security.Signature createSignature(java.lang.String)" map="E"/>
  <method class="org.bouncycastle.jcajce.util.NamedJcaJceHelper" name="javax.crypto.KeyAgreement createKeyAgreement(java.lang.String)" map="F"/>
  <class name="org.bouncycastle.jcajce.util.JcaJceHelper" map="B"/>
  <method class="org.bouncycastle.jcajce.util.JcaJceHelper" name="java.security.MessageDigest createDigest(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.jcajce.util.JcaJceHelper" name="java.security.KeyFactory createKeyFactory(java.lang.String)" map="B"/>
  <method class="org.bouncycastle.jcajce.util.JcaJceHelper" name="java.security.AlgorithmParameters createAlgorithmParameters(java.lang.String)" map="C"/>
  <method class="org.bouncycastle.jcajce.util.JcaJceHelper" name="javax.crypto.Cipher createCipher(java.lang.String)" map="D"/>
  <method class="org.bouncycastle.jcajce.util.JcaJceHelper" name="java.security.Signature createSignature(java.lang.String)" map="E"/>
  <method class="org.bouncycastle.jcajce.util.JcaJceHelper" name="javax.crypto.KeyAgreement createKeyAgreement(java.lang.String)" map="F"/>
  <class name="org.bouncycastle.jcajce.util.DefaultJcaJceHelper" map="C"/>
  <method class="org.bouncycastle.jcajce.util.DefaultJcaJceHelper" name="java.security.MessageDigest createDigest(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.jcajce.util.DefaultJcaJceHelper" name="java.security.KeyFactory createKeyFactory(java.lang.String)" map="B"/>
  <method class="org.bouncycastle.jcajce.util.DefaultJcaJceHelper" name="java.security.AlgorithmParameters createAlgorithmParameters(java.lang.String)" map="C"/>
  <method class="org.bouncycastle.jcajce.util.DefaultJcaJceHelper" name="javax.crypto.Cipher createCipher(java.lang.String)" map="D"/>
  <method class="org.bouncycastle.jcajce.util.DefaultJcaJceHelper" name="java.security.Signature createSignature(java.lang.String)" map="E"/>
  <method class="org.bouncycastle.jcajce.util.DefaultJcaJceHelper" name="javax.crypto.KeyAgreement createKeyAgreement(java.lang.String)" map="F"/>
  <class name="org.bouncycastle.jcajce.util.ProviderJcaJceHelper" map="D"/>
  <method class="org.bouncycastle.jcajce.util.ProviderJcaJceHelper" name="java.security.MessageDigest createDigest(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.jcajce.util.ProviderJcaJceHelper" name="java.security.KeyFactory createKeyFactory(java.lang.String)" map="B"/>
  <method class="org.bouncycastle.jcajce.util.ProviderJcaJceHelper" name="java.security.AlgorithmParameters createAlgorithmParameters(java.lang.String)" map="C"/>
  <method class="org.bouncycastle.jcajce.util.ProviderJcaJceHelper" name="javax.crypto.Cipher createCipher(java.lang.String)" map="D"/>
  <method class="org.bouncycastle.jcajce.util.ProviderJcaJceHelper" name="java.security.Signature createSignature(java.lang.String)" map="E"/>
  <method class="org.bouncycastle.jcajce.util.ProviderJcaJceHelper" name="javax.crypto.KeyAgreement createKeyAgreement(java.lang.String)" map="F"/>
  <class name="org.bouncycastle.jcajce.util.AlgorithmParametersUtils" map="E"/>
  <method class="org.bouncycastle.jcajce.util.AlgorithmParametersUtils" name="void loadParameters(java.security.AlgorithmParameters, org.bouncycastle.asn1.ASN1Encodable)" map="A"/>
  <class name="org.bouncycastle.jcajce.util.MessageDigestUtils" map="F"/>
  <field class="org.bouncycastle.jcajce.util.MessageDigestUtils" name="digestOidMap" map="A"/>
  <method class="org.bouncycastle.jcajce.util.MessageDigestUtils" name="java.lang.String getDigestName(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="A"/>
  <package name="org.bouncycastle.jcajce.spec" map="B"/>
  <class name="org.bouncycastle.jcajce.spec.UserKeyingMaterialSpec" map="A"/>
  <field class="org.bouncycastle.jcajce.spec.UserKeyingMaterialSpec" name="userKeyingMaterial" map="A"/>
  <class name="org.bouncycastle.jcajce.spec.GOST28147WrapParameterSpec" map="B"/>
  <field class="org.bouncycastle.jcajce.spec.GOST28147WrapParameterSpec" name="oidMappings" map="A"/>
  <field class="org.bouncycastle.jcajce.spec.GOST28147WrapParameterSpec" name="sBox" map="B"/>
  <field class="org.bouncycastle.jcajce.spec.GOST28147WrapParameterSpec" name="ukm" map="C"/>
  <method class="org.bouncycastle.jcajce.spec.GOST28147WrapParameterSpec" name="java.lang.String getName(org.bouncycastle.asn1.ASN1ObjectIdentifier)" map="A"/>
  <package name="org.bouncycastle.jcajce.provider" map="C"/>
  <package name="org.bouncycastle.jcajce.provider.util" map="A"/>
  <class name="org.bouncycastle.jcajce.provider.util.AsymmetricKeyInfoConverter" map="A"/>
  <method class="org.bouncycastle.jcajce.provider.util.AsymmetricKeyInfoConverter" name="java.security.PublicKey generatePublic(org.bouncycastle.asn1.x509.SubjectPublicKeyInfo)" map="A"/>
  <class name="org.bouncycastle.jcajce.provider.util.AlgorithmProvider" map="B"/>
  <method class="org.bouncycastle.jcajce.provider.util.AlgorithmProvider" name="void configure(org.bouncycastle.jcajce.provider.config.ConfigurableProvider)" map="A"/>
  <package name="org.bouncycastle.jcajce.provider.config" map="B"/>
  <class name="org.bouncycastle.jcajce.provider.config.ProviderConfiguration" map="A"/>
  <class name="org.bouncycastle.jcajce.provider.config.ConfigurableProvider" map="B"/>
  <class name="org.bouncycastle.jcajce.provider.config.ProviderConfigurationPermission" map="C"/>
  <field class="org.bouncycastle.jcajce.provider.config.ProviderConfigurationPermission" name="permissionMask" map="A"/>
  <field class="org.bouncycastle.jcajce.provider.config.ProviderConfigurationPermission" name="actions" map="B"/>
  <method class="org.bouncycastle.jcajce.provider.config.ProviderConfigurationPermission" name="boolean implies(java.security.Permission)" map="implies"/>
  <method class="org.bouncycastle.jcajce.provider.config.ProviderConfigurationPermission" name="int calculateMask(java.lang.String)" map="A"/>
  <method class="org.bouncycastle.jcajce.provider.config.ProviderConfigurationPermission" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.bouncycastle.jcajce.provider.config.ProviderConfigurationPermission" name="int hashCode()" map="hashCode"/>
  <method class="org.bouncycastle.jcajce.provider.config.ProviderConfigurationPermission" name="java.lang.String getActions()" map="getActions"/>
  <package name="org.bouncycastle.jcajce.provider.asymmetric" map="C"/>
  <package name="org.bouncycastle.jcajce.provider.asymmetric.util" map="A"/>
  <class name="org.bouncycastle.jcajce.provider.asymmetric.util.PKCS12BagAttributeCarrierImpl" map="A"/>
  <field class="org.bouncycastle.jcajce.provider.asymmetric.util.PKCS12BagAttributeCarrierImpl" name="pkcs12Ordering" map="A"/>
  <field class="org.bouncycastle.jcajce.provider.asymmetric.util.PKCS12BagAttributeCarrierImpl" name="pkcs12Attributes" map="B"/>
  <package name="org.bouncycastle.jcajce.provider.digest" map="D"/>
  <class name="org.bouncycastle.jcajce.provider.digest.GOST3411$Digest" map="_A"/>
  <method class="org.bouncycastle.jcajce.provider.digest.GOST3411$Digest" name="java.lang.Object clone()" map="clone"/>
  <class name="org.bouncycastle.jcajce.provider.digest.GOST3411" map="A"/>
  <class name="org.bouncycastle.jcajce.provider.digest.SHA1$Digest" map="_A"/>
  <method class="org.bouncycastle.jcajce.provider.digest.SHA1$Digest" name="java.lang.Object clone()" map="clone"/>
  <class name="org.bouncycastle.jcajce.provider.digest.SHA1" map="B"/>
  <class name="org.bouncycastle.jcajce.provider.digest.RIPEMD160$Digest" map="_A"/>
  <method class="org.bouncycastle.jcajce.provider.digest.RIPEMD160$Digest" name="java.lang.Object clone()" map="clone"/>
  <class name="org.bouncycastle.jcajce.provider.digest.RIPEMD160" map="C"/>
  <class name="org.bouncycastle.jcajce.provider.digest.RIPEMD128$Digest" map="_A"/>
  <method class="org.bouncycastle.jcajce.provider.digest.RIPEMD128$Digest" name="java.lang.Object clone()" map="clone"/>
  <class name="org.bouncycastle.jcajce.provider.digest.RIPEMD128" map="D"/>
  <class name="org.bouncycastle.jcajce.provider.digest.SHA256$Digest" map="_A"/>
  <method class="org.bouncycastle.jcajce.provider.digest.SHA256$Digest" name="java.lang.Object clone()" map="clone"/>
  <class name="org.bouncycastle.jcajce.provider.digest.SHA256" map="E"/>
  <class name="org.bouncycastle.jcajce.provider.digest.SHA224$Digest" map="_A"/>
  <method class="org.bouncycastle.jcajce.provider.digest.SHA224$Digest" name="java.lang.Object clone()" map="clone"/>
  <class name="org.bouncycastle.jcajce.provider.digest.SHA224" map="F"/>
  <class name="org.bouncycastle.jcajce.provider.digest.SHA512$Digest" map="_A"/>
  <method class="org.bouncycastle.jcajce.provider.digest.SHA512$Digest" name="java.lang.Object clone()" map="clone"/>
  <class name="org.bouncycastle.jcajce.provider.digest.SHA512" map="G"/>
  <class name="org.bouncycastle.jcajce.provider.digest.RIPEMD256$Digest" map="_A"/>
  <method class="org.bouncycastle.jcajce.provider.digest.RIPEMD256$Digest" name="java.lang.Object clone()" map="clone"/>
  <class name="org.bouncycastle.jcajce.provider.digest.RIPEMD256" map="H"/>
  <class name="org.bouncycastle.jcajce.provider.digest.SHA384$Digest" map="_A"/>
  <method class="org.bouncycastle.jcajce.provider.digest.SHA384$Digest" name="java.lang.Object clone()" map="clone"/>
  <class name="org.bouncycastle.jcajce.provider.digest.SHA384" map="I"/>
  <class name="org.bouncycastle.jcajce.provider.digest.BCMessageDigest" map="J"/>
  <field class="org.bouncycastle.jcajce.provider.digest.BCMessageDigest" name="digest" map="A"/>
  <method class="org.bouncycastle.jcajce.provider.digest.BCMessageDigest" name="void engineUpdate(byte[], int, int)" map="engineUpdate"/>
  <method class="org.bouncycastle.jcajce.provider.digest.BCMessageDigest" name="void engineUpdate(byte)" map="engineUpdate"/>
  <method class="org.bouncycastle.jcajce.provider.digest.BCMessageDigest" name="void engineReset()" map="engineReset"/>
  <method class="org.bouncycastle.jcajce.provider.digest.BCMessageDigest" name="byte[] engineDigest()" map="engineDigest"/>
  <class name="org.bouncycastle.jcajce.provider.digest.MD5$Digest" map="_A"/>
  <method class="org.bouncycastle.jcajce.provider.digest.MD5$Digest" name="java.lang.Object clone()" map="clone"/>
  <class name="org.bouncycastle.jcajce.provider.digest.MD5" map="K"/>
  <class name="org.bouncycastle.jcajce.provider.digest.MD2$Digest" map="_A"/>
  <method class="org.bouncycastle.jcajce.provider.digest.MD2$Digest" name="java.lang.Object clone()" map="clone"/>
  <class name="org.bouncycastle.jcajce.provider.digest.MD2" map="L"/>
  <package name="org.bouncycastle.jcajce.provider.symmetric" map="E"/>
  <package name="org.bouncycastle.jcajce.provider.symmetric.util" map="A"/>
  <class name="org.bouncycastle.jcajce.provider.symmetric.util.ClassUtil$1" map="1"/>
  <field class="org.bouncycastle.jcajce.provider.symmetric.util.ClassUtil$1" name="val$className" map="A"/>
  <method class="org.bouncycastle.jcajce.provider.symmetric.util.ClassUtil$1" name="java.lang.Object run()" map="run"/>
  <class name="org.bouncycastle.jcajce.provider.symmetric.util.ClassUtil" map="A"/>
  <method class="org.bouncycastle.jcajce.provider.symmetric.util.ClassUtil" name="java.lang.Class loadClass(java.lang.Class, java.lang.String)" map="A"/>
  <package name="org.bouncycastle.jcajce.io" map="D"/>
  <class name="org.bouncycastle.jcajce.io.CipherInputStream" map="A"/>
  <field class="org.bouncycastle.jcajce.io.CipherInputStream" name="cipher" map="A"/>
  <field class="org.bouncycastle.jcajce.io.CipherInputStream" name="buf" map="B"/>
  <field class="org.bouncycastle.jcajce.io.CipherInputStream" name="maxBuf" map="C"/>
  <field class="org.bouncycastle.jcajce.io.CipherInputStream" name="inputBuffer" map="D"/>
  <field class="org.bouncycastle.jcajce.io.CipherInputStream" name="bufOff" map="E"/>
  <field class="org.bouncycastle.jcajce.io.CipherInputStream" name="finalized" map="F"/>
  <method class="org.bouncycastle.jcajce.io.CipherInputStream" name="void reset()" map="reset"/>
  <method class="org.bouncycastle.jcajce.io.CipherInputStream" name="void close()" map="close"/>
  <method class="org.bouncycastle.jcajce.io.CipherInputStream" name="boolean markSupported()" map="markSupported"/>
  <method class="org.bouncycastle.jcajce.io.CipherInputStream" name="void mark(int)" map="mark"/>
  <method class="org.bouncycastle.jcajce.io.CipherInputStream" name="byte[] finaliseCipher()" map="A"/>
  <method class="org.bouncycastle.jcajce.io.CipherInputStream" name="int nextChunk()" map="B"/>
  <method class="org.bouncycastle.jcajce.io.CipherInputStream" name="int read()" map="read"/>
  <method class="org.bouncycastle.jcajce.io.CipherInputStream" name="int read(byte[], int, int)" map="read"/>
  <method class="org.bouncycastle.jcajce.io.CipherInputStream" name="long skip(long)" map="skip"/>
  <method class="org.bouncycastle.jcajce.io.CipherInputStream" name="int available()" map="available"/>
  <package name="org.w3c" map="E"/>
  <package name="org.w3c.dom" map="A"/>
  <package name="org.w3c.dom.ranges" map="A"/>
  <class name="org.w3c.dom.ranges.DocumentRange" map="A"/>
  <package name="org.w3c.dom.traversal" map="B"/>
  <class name="org.w3c.dom.traversal.DocumentTraversal" map="A"/>
  <package name="org.w3c.dom.html" map="C"/>
  <class name="org.w3c.dom.html.HTMLTableRowElement" map="A"/>
  <class name="org.w3c.dom.html.HTMLTableColElement" map="B"/>
  <class name="org.w3c.dom.html.HTMLMenuElement" map="C"/>
  <class name="org.w3c.dom.html.HTMLImageElement" map="D"/>
  <class name="org.w3c.dom.html.HTMLMetaElement" map="E"/>
  <class name="org.w3c.dom.html.HTMLUListElement" map="F"/>
  <class name="org.w3c.dom.html.HTMLTableElement" map="G"/>
  <class name="org.w3c.dom.html.HTMLAnchorElement" map="H"/>
  <class name="org.w3c.dom.html.HTMLAreaElement" map="I"/>
  <class name="org.w3c.dom.html.HTMLScriptElement" map="J"/>
  <class name="org.w3c.dom.html.HTMLFormElement" map="K"/>
  <class name="org.w3c.dom.html.HTMLButtonElement" map="L"/>
  <class name="org.w3c.dom.html.HTMLFrameElement" map="M"/>
  <class name="org.w3c.dom.html.HTMLSelectElement" map="N"/>
  <class name="org.w3c.dom.html.HTMLParamElement" map="O"/>
  <class name="org.w3c.dom.html.HTMLOptionElement" map="P"/>
  <class name="org.w3c.dom.html.HTMLBaseElement" map="Q"/>
  <class name="org.w3c.dom.html.HTMLOptGroupElement" map="R"/>
  <class name="org.w3c.dom.html.HTMLTitleElement" map="S"/>
  <class name="org.w3c.dom.html.HTMLQuoteElement" map="T"/>
  <class name="org.w3c.dom.html.HTMLLabelElement" map="U"/>
  <class name="org.w3c.dom.html.HTMLMapElement" map="V"/>
  <class name="org.w3c.dom.html.HTMLDivElement" map="W"/>
  <class name="org.w3c.dom.html.HTMLIFrameElement" map="X"/>
  <class name="org.w3c.dom.html.HTMLPreElement" map="Y"/>
  <class name="org.w3c.dom.html.HTMLBodyElement" map="Z"/>
  <class name="org.w3c.dom.html.HTMLModElement" map="_"/>
  <class name="org.w3c.dom.html.HTMLFrameSetElement" map="a"/>
  <class name="org.w3c.dom.html.HTMLHeadingElement" map="b"/>
  <class name="org.w3c.dom.html.HTMLHRElement" map="c"/>
  <class name="org.w3c.dom.html.HTMLLIElement" map="d"/>
  <class name="org.w3c.dom.html.HTMLTableCaptionElement" map="e"/>
  <class name="org.w3c.dom.html.HTMLDocument" map="f"/>
  <class name="org.w3c.dom.html.HTMLAppletElement" map="g"/>
  <class name="org.w3c.dom.html.HTMLLegendElement" map="h"/>
  <class name="org.w3c.dom.html.HTMLTextAreaElement" map="i"/>
  <class name="org.w3c.dom.html.HTMLStyleElement" map="j"/>
  <class name="org.w3c.dom.html.HTMLTableCellElement" map="k"/>
  <class name="org.w3c.dom.html.HTMLLinkElement" map="l"/>
  <class name="org.w3c.dom.html.HTMLFieldSetElement" map="m"/>
  <class name="org.w3c.dom.html.HTMLInputElement" map="n"/>
  <class name="org.w3c.dom.html.HTMLElement" map="o"/>
  <class name="org.w3c.dom.html.HTMLOListElement" map="p"/>
  <class name="org.w3c.dom.html.HTMLHtmlElement" map="q"/>
  <class name="org.w3c.dom.html.HTMLIsIndexElement" map="r"/>
  <class name="org.w3c.dom.html.HTMLBRElement" map="s"/>
  <class name="org.w3c.dom.html.HTMLObjectElement" map="t"/>
  <class name="org.w3c.dom.html.HTMLDListElement" map="u"/>
  <class name="org.w3c.dom.html.HTMLDirectoryElement" map="v"/>
  <class name="org.w3c.dom.html.HTMLTableSectionElement" map="w"/>
  <class name="org.w3c.dom.html.HTMLParagraphElement" map="x"/>
  <class name="org.w3c.dom.html.HTMLBaseFontElement" map="y"/>
  <class name="org.w3c.dom.html.HTMLHeadElement" map="z"/>
  <class name="org.w3c.dom.html.HTMLFontElement" map="$A"/>
  <package name="org.w3c.dom.events" map="D"/>
  <class name="org.w3c.dom.events.DocumentEvent" map="A"/>
  <class name="org.w3c.dom.events.EventTarget" map="B"/>
  <class name="org.w3c.dom.DocumentFragment" map="A"/>
  <class name="org.w3c.dom.Notation" map="B"/>
  <class name="org.w3c.dom.TypeInfo" map="C"/>
  <class name="org.w3c.dom.DocumentType" map="D"/>
  <method class="org.w3c.dom.DocumentType" name="java.lang.String getPublicId()" map="&#x00db;"/>
  <method class="org.w3c.dom.DocumentType" name="java.lang.String getInternalSubset()" map="&#x00dc;"/>
  <method class="org.w3c.dom.DocumentType" name="java.lang.String getSystemId()" map="&#x00dd;"/>
  <method class="org.w3c.dom.DocumentType" name="java.lang.String getName()" map="&#x00de;"/>
  <class name="org.w3c.dom.NamedNodeMap" map="E"/>
  <method class="org.w3c.dom.NamedNodeMap" name="org.w3c.dom.Node item(int)" map="A"/>
  <method class="org.w3c.dom.NamedNodeMap" name="org.w3c.dom.Node removeNamedItem(java.lang.String)" map="A"/>
  <method class="org.w3c.dom.NamedNodeMap" name="org.w3c.dom.Node getNamedItem(java.lang.String)" map="B"/>
  <method class="org.w3c.dom.NamedNodeMap" name="int getLength()" map="A"/>
  <method class="org.w3c.dom.NamedNodeMap" name="org.w3c.dom.Node removeNamedItemNS(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.w3c.dom.NamedNodeMap" name="org.w3c.dom.Node setNamedItemNS(org.w3c.dom.Node)" map="A"/>
  <method class="org.w3c.dom.NamedNodeMap" name="org.w3c.dom.Node getNamedItemNS(java.lang.String, java.lang.String)" map="B"/>
  <class name="org.w3c.dom.ElementTraversal" map="F"/>
  <class name="org.w3c.dom.EntityReference" map="G"/>
  <class name="org.w3c.dom.Comment" map="H"/>
  <class name="org.w3c.dom.CharacterData" map="I"/>
  <method class="org.w3c.dom.CharacterData" name="java.lang.String getData()" map="&#x00cb;"/>
  <class name="org.w3c.dom.Document" map="J"/>
  <method class="org.w3c.dom.Document" name="org.w3c.dom.NodeList getElementsByTagNameNS(java.lang.String, java.lang.String)" map="G"/>
  <method class="org.w3c.dom.Document" name="org.w3c.dom.Node importNode(org.w3c.dom.Node, boolean)" map="A"/>
  <method class="org.w3c.dom.Document" name="org.w3c.dom.Text createTextNode(java.lang.String)" map="J"/>
  <method class="org.w3c.dom.Document" name="org.w3c.dom.Element createElement(java.lang.String)" map="K"/>
  <method class="org.w3c.dom.Document" name="org.w3c.dom.NodeList getElementsByTagName(java.lang.String)" map="L"/>
  <method class="org.w3c.dom.Document" name="java.lang.String getDocumentURI()" map="&#x00d1;"/>
  <method class="org.w3c.dom.Document" name="org.w3c.dom.Attr createAttributeNS(java.lang.String, java.lang.String)" map="H"/>
  <method class="org.w3c.dom.Document" name="void normalizeDocument()" map="&#x00d2;"/>
  <method class="org.w3c.dom.Document" name="org.w3c.dom.Element getDocumentElement()" map="&#x00d3;"/>
  <method class="org.w3c.dom.Document" name="org.w3c.dom.Element createElementNS(java.lang.String, java.lang.String)" map="I"/>
  <method class="org.w3c.dom.Document" name="org.w3c.dom.DocumentType getDoctype()" map="&#x00d4;"/>
  <class name="org.w3c.dom.Element" map="K"/>
  <method class="org.w3c.dom.Element" name="boolean hasAttribute(java.lang.String)" map="F"/>
  <method class="org.w3c.dom.Element" name="void setIdAttribute(java.lang.String, boolean)" map="A"/>
  <method class="org.w3c.dom.Element" name="org.w3c.dom.Attr getAttributeNode(java.lang.String)" map="G"/>
  <method class="org.w3c.dom.Element" name="org.w3c.dom.NodeList getElementsByTagName(java.lang.String)" map="H"/>
  <method class="org.w3c.dom.Element" name="void setAttribute(java.lang.String, java.lang.String)" map="C"/>
  <method class="org.w3c.dom.Element" name="void setAttributeNS(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.w3c.dom.Element" name="java.lang.String getAttributeNS(java.lang.String, java.lang.String)" map="D"/>
  <method class="org.w3c.dom.Element" name="org.w3c.dom.Attr getAttributeNodeNS(java.lang.String, java.lang.String)" map="E"/>
  <method class="org.w3c.dom.Element" name="java.lang.String getAttribute(java.lang.String)" map="I"/>
  <class name="org.w3c.dom.DOMConfiguration" map="L"/>
  <class name="org.w3c.dom.DOMErrorHandler" map="M"/>
  <class name="org.w3c.dom.Text" map="N"/>
  <class name="org.w3c.dom.DOMException" map="O"/>
  <field class="org.w3c.dom.DOMException" name="code" map="A"/>
  <class name="org.w3c.dom.DOMStringList" map="P"/>
  <class name="org.w3c.dom.NodeList" map="Q"/>
  <method class="org.w3c.dom.NodeList" name="org.w3c.dom.Node item(int)" map="B"/>
  <method class="org.w3c.dom.NodeList" name="int getLength()" map="&#x00c5;"/>
  <class name="org.w3c.dom.Attr" map="R"/>
  <method class="org.w3c.dom.Attr" name="org.w3c.dom.Element getOwnerElement()" map="&#x00c6;"/>
  <method class="org.w3c.dom.Attr" name="java.lang.String getValue()" map="&#x00c7;"/>
  <method class="org.w3c.dom.Attr" name="boolean getSpecified()" map="&#x00c8;"/>
  <method class="org.w3c.dom.Attr" name="void setValue(java.lang.String)" map="E"/>
  <method class="org.w3c.dom.Attr" name="java.lang.String getName()" map="&#x00c9;"/>
  <class name="org.w3c.dom.Node" map="S"/>
  <method class="org.w3c.dom.Node" name="org.w3c.dom.Node getParentNode()" map="w"/>
  <method class="org.w3c.dom.Node" name="org.w3c.dom.Node removeChild(org.w3c.dom.Node)" map="A"/>
  <method class="org.w3c.dom.Node" name="org.w3c.dom.Node getNextSibling()" map="x"/>
  <method class="org.w3c.dom.Node" name="org.w3c.dom.NodeList getChildNodes()" map="y"/>
  <method class="org.w3c.dom.Node" name="void setNodeValue(java.lang.String)" map="B"/>
  <method class="org.w3c.dom.Node" name="org.w3c.dom.Node insertBefore(org.w3c.dom.Node, org.w3c.dom.Node)" map="A"/>
  <method class="org.w3c.dom.Node" name="org.w3c.dom.Node getFirstChild()" map="z"/>
  <method class="org.w3c.dom.Node" name="org.w3c.dom.Node cloneNode(boolean)" map="A"/>
  <method class="org.w3c.dom.Node" name="org.w3c.dom.Document getOwnerDocument()" map="&#x00a2;"/>
  <method class="org.w3c.dom.Node" name="boolean hasAttributes()" map="&#x00a3;"/>
  <method class="org.w3c.dom.Node" name="java.lang.String getPrefix()" map="&#x00a4;"/>
  <method class="org.w3c.dom.Node" name="org.w3c.dom.Node replaceChild(org.w3c.dom.Node, org.w3c.dom.Node)" map="B"/>
  <method class="org.w3c.dom.Node" name="org.w3c.dom.NamedNodeMap getAttributes()" map="&#x00a5;"/>
  <method class="org.w3c.dom.Node" name="java.lang.String getTextContent()" map="&#x00aa;"/>
  <method class="org.w3c.dom.Node" name="java.lang.String getNodeName()" map="&#x00b5;"/>
  <method class="org.w3c.dom.Node" name="void setTextContent(java.lang.String)" map="C"/>
  <method class="org.w3c.dom.Node" name="boolean hasChildNodes()" map="&#x00ba;"/>
  <method class="org.w3c.dom.Node" name="java.lang.String getNodeValue()" map="&#x00c0;"/>
  <method class="org.w3c.dom.Node" name="java.lang.String getNamespaceURI()" map="&#x00c1;"/>
  <method class="org.w3c.dom.Node" name="org.w3c.dom.Node getPreviousSibling()" map="&#x00c2;"/>
  <method class="org.w3c.dom.Node" name="short getNodeType()" map="&#x00c3;"/>
  <method class="org.w3c.dom.Node" name="boolean isEqualNode(org.w3c.dom.Node)" map="B"/>
  <method class="org.w3c.dom.Node" name="java.lang.String getLocalName()" map="&#x00c4;"/>
  <method class="org.w3c.dom.Node" name="void setPrefix(java.lang.String)" map="D"/>
  <method class="org.w3c.dom.Node" name="org.w3c.dom.Node appendChild(org.w3c.dom.Node)" map="C"/>
  <class name="org.w3c.dom.ProcessingInstruction" map="T"/>
  <method class="org.w3c.dom.ProcessingInstruction" name="java.lang.String getData()" map="&#x00cb;"/>
  <method class="org.w3c.dom.ProcessingInstruction" name="java.lang.String getTarget()" map="&#x00df;"/>
  <class name="org.w3c.dom.Entity" map="U"/>
  <class name="org.w3c.dom.CDATASection" map="V"/>
  <package name="org.jdom" map="F"/>
  <package name="org.jdom.output" map="A"/>
  <class name="org.jdom.output.SAXOutputter" map="A"/>
  <field class="org.jdom.output.SAXOutputter" name="attrTypeToNameMap" map="&#x0451;"/>
  <method class="org.jdom.output.SAXOutputter" name="void setProperty(java.lang.String, java.lang.Object)" map="A"/>
  <method class="org.jdom.output.SAXOutputter" name="void setFeature(java.lang.String, boolean)" map="A"/>
  <method class="org.jdom.output.SAXOutputter" name="void setDTDHandler(org.xml.sax.DTDHandler)" map="A"/>
  <method class="org.jdom.output.SAXOutputter" name="void setEntityResolver(org.xml.sax.EntityResolver)" map="A"/>
  <method class="org.jdom.output.SAXOutputter" name="boolean getFeature(java.lang.String)" map="A"/>
  <method class="org.jdom.output.SAXOutputter" name="void setErrorHandler(org.xml.sax.ErrorHandler)" map="A"/>
  <method class="org.jdom.output.SAXOutputter" name="void setContentHandler(org.xml.sax.ContentHandler)" map="A"/>
  <class name="org.jdom.output.Format$TextMode" map="_A"/>
  <field class="org.jdom.output.Format$TextMode" name="PRESERVE" map="A"/>
  <field class="org.jdom.output.Format$TextMode" name="name" map="B"/>
  <field class="org.jdom.output.Format$TextMode" name="TRIM" map="C"/>
  <field class="org.jdom.output.Format$TextMode" name="TRIM_FULL_WHITE" map="D"/>
  <field class="org.jdom.output.Format$TextMode" name="NORMALIZE" map="E"/>
  <method class="org.jdom.output.Format$TextMode" name="java.lang.String toString()" map="toString"/>
  <class name="org.jdom.output.Format$DefaultEscapeStrategy" map="_B"/>
  <field class="org.jdom.output.Format$DefaultEscapeStrategy" name="this$0" map="this$0"/>
  <field class="org.jdom.output.Format$DefaultEscapeStrategy" name="canEncode" map="A"/>
  <field class="org.jdom.output.Format$DefaultEscapeStrategy" name="encoder" map="B"/>
  <field class="org.jdom.output.Format$DefaultEscapeStrategy" name="bits" map="C"/>
  <method class="org.jdom.output.Format$DefaultEscapeStrategy" name="boolean shouldEscape(char)" map="A"/>
  <class name="org.jdom.output.Format" map="B"/>
  <field class="org.jdom.output.Format" name="omitEncoding" map="A"/>
  <field class="org.jdom.output.Format" name="encoding" map="B"/>
  <field class="org.jdom.output.Format" name="indent" map="C"/>
  <field class="org.jdom.output.Format" name="class$java$lang$String" map="class$java$lang$String"/>
  <field class="org.jdom.output.Format" name="ignoreTrAXEscapingPIs" map="D"/>
  <field class="org.jdom.output.Format" name="lineSeparator" map="E"/>
  <field class="org.jdom.output.Format" name="expandEmptyElements" map="F"/>
  <field class="org.jdom.output.Format" name="mode" map="G"/>
  <field class="org.jdom.output.Format" name="escapeStrategy" map="H"/>
  <field class="org.jdom.output.Format" name="omitDeclaration" map="I"/>
  <method class="org.jdom.output.Format" name="org.jdom.output.Format setIndent(java.lang.String)" map="A"/>
  <method class="org.jdom.output.Format" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jdom.output.Format" name="org.jdom.output.Format getPrettyFormat()" map="A"/>
  <method class="org.jdom.output.Format" name="org.jdom.output.Format setTextMode(org.jdom.output.Format$TextMode)" map="A"/>
  <method class="org.jdom.output.Format" name="void setIgnoreTrAXEscapingPIs(boolean)" map="A"/>
  <method class="org.jdom.output.Format" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jdom.output.Format" name="org.jdom.output.Format getRawFormat()" map="B"/>
  <class name="org.jdom.output.NamespaceStack" map="C"/>
  <field class="org.jdom.output.NamespaceStack" name="uris" map="A"/>
  <field class="org.jdom.output.NamespaceStack" name="prefixes" map="B"/>
  <method class="org.jdom.output.NamespaceStack" name="int size()" map="A"/>
  <method class="org.jdom.output.NamespaceStack" name="java.lang.String toString()" map="toString"/>
  <method class="org.jdom.output.NamespaceStack" name="java.lang.String getURI(java.lang.String)" map="A"/>
  <method class="org.jdom.output.NamespaceStack" name="void push(org.jdom.Namespace)" map="A"/>
  <method class="org.jdom.output.NamespaceStack" name="java.lang.String pop()" map="B"/>
  <class name="org.jdom.output.XMLOutputter$NamespaceStack" map="_A"/>
  <field class="org.jdom.output.XMLOutputter$NamespaceStack" name="this$0" map="this$0"/>
  <class name="org.jdom.output.XMLOutputter" map="D"/>
  <field class="org.jdom.output.XMLOutputter" name="escapeOutput" map="A"/>
  <field class="org.jdom.output.XMLOutputter" name="preserveFormat" map="B"/>
  <field class="org.jdom.output.XMLOutputter" name="currentFormat" map="C"/>
  <field class="org.jdom.output.XMLOutputter" name="userFormat" map="D"/>
  <method class="org.jdom.output.XMLOutputter" name="java.lang.String outputString(org.jdom.ProcessingInstruction)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void printElementNamespace(java.io.Writer, org.jdom.Element, org.jdom.output.XMLOutputter$NamespaceStack)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="java.io.Writer makeWriter(java.io.OutputStream, java.lang.String)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void indent(java.io.Writer, int)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void printComment(java.io.Writer, org.jdom.Comment)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void output(org.jdom.DocType, java.io.Writer)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void printEntityRef(java.io.Writer, org.jdom.EntityRef)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void printDocType(java.io.Writer, org.jdom.DocType)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="int skipTrailingWhite(java.util.List, int)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void output(org.jdom.Element, java.io.OutputStream)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void printAdditionalNamespaces(java.io.Writer, org.jdom.Element, org.jdom.output.XMLOutputter$NamespaceStack)" map="B"/>
  <method class="org.jdom.output.XMLOutputter" name="java.lang.String outputString(org.jdom.Comment)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void printElement(java.io.Writer, org.jdom.Element, int, org.jdom.output.XMLOutputter$NamespaceStack)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void newline(java.io.Writer)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void output(org.jdom.ProcessingInstruction, java.io.Writer)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void printString(java.io.Writer, java.lang.String)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="java.lang.String toString()" map="toString"/>
  <method class="org.jdom.output.XMLOutputter" name="void printQualifiedName(java.io.Writer, org.jdom.Attribute)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void printCDATA(java.io.Writer, org.jdom.CDATA)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="java.lang.String outputString(org.jdom.DocType)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void printQualifiedName(java.io.Writer, org.jdom.Element)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="java.lang.String outputString(org.jdom.Element)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="boolean isAllWhitespace(java.lang.Object)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void printProcessingInstruction(java.io.Writer, org.jdom.ProcessingInstruction)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="int skipLeadingWhite(java.util.List, int)" map="B"/>
  <method class="org.jdom.output.XMLOutputter" name="boolean endsWithWhite(java.lang.String)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void printAttributes(java.io.Writer, java.util.List, org.jdom.Element, org.jdom.output.XMLOutputter$NamespaceStack)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void printTextRange(java.io.Writer, java.util.List, int, int)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="void printNamespace(java.io.Writer, org.jdom.Namespace, org.jdom.output.XMLOutputter$NamespaceStack)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="int nextNonText(java.util.List, int)" map="C"/>
  <method class="org.jdom.output.XMLOutputter" name="org.jdom.output.XMLOutputter$NamespaceStack createNamespaceStack()" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="boolean startsWithWhite(java.lang.String)" map="B"/>
  <method class="org.jdom.output.XMLOutputter" name="void output(org.jdom.Comment, java.io.Writer)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="java.io.Writer makeWriter(java.io.OutputStream)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="java.lang.String escapeAttributeEntities(java.lang.String)" map="C"/>
  <method class="org.jdom.output.XMLOutputter" name="void printContentRange(java.io.Writer, java.util.List, int, int, int, org.jdom.output.XMLOutputter$NamespaceStack)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="java.lang.String escapeElementEntities(java.lang.String)" map="D"/>
  <method class="org.jdom.output.XMLOutputter" name="void output(org.jdom.Element, java.io.Writer)" map="A"/>
  <method class="org.jdom.output.XMLOutputter" name="java.lang.Object clone()" map="clone"/>
  <class name="org.jdom.output.EscapeStrategy" map="E"/>
  <method class="org.jdom.output.EscapeStrategy" name="boolean shouldEscape(char)" map="A"/>
  <package name="org.jdom.input" map="B"/>
  <class name="org.jdom.input.SAXHandler" map="A"/>
  <field class="org.jdom.input.SAXHandler" name="expand" map="M"/>
  <field class="org.jdom.input.SAXHandler" name="textBuffer" map="N"/>
  <field class="org.jdom.input.SAXHandler" name="currentElement" map="O"/>
  <field class="org.jdom.input.SAXHandler" name="locator" map="P"/>
  <field class="org.jdom.input.SAXHandler" name="attrNameToTypeMap" map="Q"/>
  <field class="org.jdom.input.SAXHandler" name="ignoringWhite" map="R"/>
  <field class="org.jdom.input.SAXHandler" name="factory" map="S"/>
  <field class="org.jdom.input.SAXHandler" name="previousCDATA" map="T"/>
  <field class="org.jdom.input.SAXHandler" name="atRoot" map="U"/>
  <field class="org.jdom.input.SAXHandler" name="ignoringBoundaryWhite" map="V"/>
  <field class="org.jdom.input.SAXHandler" name="declaredNamespaces" map="W"/>
  <field class="org.jdom.input.SAXHandler" name="externalEntities" map="X"/>
  <field class="org.jdom.input.SAXHandler" name="document" map="Y"/>
  <field class="org.jdom.input.SAXHandler" name="suppress" map="Z"/>
  <field class="org.jdom.input.SAXHandler" name="entityDepth" map="_"/>
  <field class="org.jdom.input.SAXHandler" name="inCDATA" map="a"/>
  <field class="org.jdom.input.SAXHandler" name="inInternalSubset" map="b"/>
  <field class="org.jdom.input.SAXHandler" name="internalSubset" map="c"/>
  <field class="org.jdom.input.SAXHandler" name="inDTD" map="d"/>
  <method class="org.jdom.input.SAXHandler" name="void setDocumentLocator(org.xml.sax.Locator)" map="A"/>
  <method class="org.jdom.input.SAXHandler" name="void unparsedEntityDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="org.jdom.input.SAXHandler" name="void setIgnoringElementContentWhitespace(boolean)" map="A"/>
  <method class="org.jdom.input.SAXHandler" name="void notationDecl(java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="org.jdom.input.SAXHandler" name="void startDTD(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.jdom.input.SAXHandler" name="void attributeDecl(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.jdom.input.SAXHandler" name="void setExpandEntities(boolean)" map="B"/>
  <method class="org.jdom.input.SAXHandler" name="void flushCharacters()" map="H"/>
  <method class="org.jdom.input.SAXHandler" name="void startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)" map="A"/>
  <method class="org.jdom.input.SAXHandler" name="void transferNamespaces(org.jdom.Element)" map="A"/>
  <method class="org.jdom.input.SAXHandler" name="void startDocument()" map="E"/>
  <method class="org.jdom.input.SAXHandler" name="void characters(char[], int, int)" map="C"/>
  <method class="org.jdom.input.SAXHandler" name="void endDTD()" map="B"/>
  <method class="org.jdom.input.SAXHandler" name="void skippedEntity(java.lang.String)" map="C"/>
  <method class="org.jdom.input.SAXHandler" name="void processingInstruction(java.lang.String, java.lang.String)" map="C"/>
  <method class="org.jdom.input.SAXHandler" name="void elementDecl(java.lang.String, java.lang.String)" map="F"/>
  <method class="org.jdom.input.SAXHandler" name="void internalEntityDecl(java.lang.String, java.lang.String)" map="E"/>
  <method class="org.jdom.input.SAXHandler" name="void startCDATA()" map="A"/>
  <method class="org.jdom.input.SAXHandler" name="void flushCharacters(java.lang.String)" map="E"/>
  <method class="org.jdom.input.SAXHandler" name="void setIgnoringBoundaryWhitespace(boolean)" map="C"/>
  <method class="org.jdom.input.SAXHandler" name="void startEntity(java.lang.String)" map="A"/>
  <method class="org.jdom.input.SAXHandler" name="void endCDATA()" map="C"/>
  <method class="org.jdom.input.SAXHandler" name="void appendExternalId(java.lang.String, java.lang.String)" map="G"/>
  <method class="org.jdom.input.SAXHandler" name="void ignorableWhitespace(char[], int, int)" map="B"/>
  <method class="org.jdom.input.SAXHandler" name="void startPrefixMapping(java.lang.String, java.lang.String)" map="D"/>
  <method class="org.jdom.input.SAXHandler" name="int getAttributeType(java.lang.String)" map="F"/>
  <method class="org.jdom.input.SAXHandler" name="void endEntity(java.lang.String)" map="B"/>
  <method class="org.jdom.input.SAXHandler" name="org.jdom.Document getDocument()" map="I"/>
  <method class="org.jdom.input.SAXHandler" name="org.jdom.Element getCurrentElement()" map="J"/>
  <method class="org.jdom.input.SAXHandler" name="void endElement(java.lang.String, java.lang.String, java.lang.String)" map="C"/>
  <method class="org.jdom.input.SAXHandler" name="void comment(char[], int, int)" map="A"/>
  <method class="org.jdom.input.SAXHandler" name="void externalEntityDecl(java.lang.String, java.lang.String, java.lang.String)" map="D"/>
  <class name="org.jdom.input.BuilderErrorHandler" map="B"/>
  <method class="org.jdom.input.BuilderErrorHandler" name="void error(org.xml.sax.SAXParseException)" map="A"/>
  <method class="org.jdom.input.BuilderErrorHandler" name="void warning(org.xml.sax.SAXParseException)" map="B"/>
  <method class="org.jdom.input.BuilderErrorHandler" name="void fatalError(org.xml.sax.SAXParseException)" map="C"/>
  <class name="org.jdom.input.TextBuffer" map="C"/>
  <field class="org.jdom.input.TextBuffer" name="prefixString" map="A"/>
  <field class="org.jdom.input.TextBuffer" name="arraySize" map="B"/>
  <field class="org.jdom.input.TextBuffer" name="array" map="C"/>
  <method class="org.jdom.input.TextBuffer" name="void append(char[], int, int)" map="A"/>
  <method class="org.jdom.input.TextBuffer" name="void clear()" map="A"/>
  <method class="org.jdom.input.TextBuffer" name="void ensureCapacity(int)" map="A"/>
  <method class="org.jdom.input.TextBuffer" name="java.lang.String toString()" map="toString"/>
  <method class="org.jdom.input.TextBuffer" name="boolean isAllWhitespace()" map="B"/>
  <class name="org.jdom.input.SAXBuilder" map="D"/>
  <field class="org.jdom.input.SAXBuilder" name="expand" map="A"/>
  <field class="org.jdom.input.SAXBuilder" name="saxErrorHandler" map="B"/>
  <field class="org.jdom.input.SAXBuilder" name="ignoringWhite" map="C"/>
  <field class="org.jdom.input.SAXBuilder" name="factory" map="D"/>
  <field class="org.jdom.input.SAXBuilder" name="features" map="E"/>
  <field class="org.jdom.input.SAXBuilder" name="saxXMLFilter" map="F"/>
  <field class="org.jdom.input.SAXBuilder" name="properties" map="G"/>
  <field class="org.jdom.input.SAXBuilder" name="saxDTDHandler" map="H"/>
  <field class="org.jdom.input.SAXBuilder" name="saxEntityResolver" map="I"/>
  <field class="org.jdom.input.SAXBuilder" name="reuseParser" map="J"/>
  <field class="org.jdom.input.SAXBuilder" name="ignoringBoundaryWhite" map="K"/>
  <field class="org.jdom.input.SAXBuilder" name="skipNextEntityExpandConfig" map="L"/>
  <field class="org.jdom.input.SAXBuilder" name="class$java$util$Map" map="class$java$util$Map"/>
  <field class="org.jdom.input.SAXBuilder" name="validate" map="M"/>
  <field class="org.jdom.input.SAXBuilder" name="saxParser" map="N"/>
  <field class="org.jdom.input.SAXBuilder" name="fastReconfigure" map="O"/>
  <field class="org.jdom.input.SAXBuilder" name="saxDriverClass" map="P"/>
  <field class="org.jdom.input.SAXBuilder" name="skipNextLexicalReportingConfig" map="Q"/>
  <method class="org.jdom.input.SAXBuilder" name="org.jdom.Document build(java.net.URL)" map="A"/>
  <method class="org.jdom.input.SAXBuilder" name="java.lang.Class class$(java.lang.String)" map="class$"/>
  <method class="org.jdom.input.SAXBuilder" name="void configureContentHandler(org.jdom.input.SAXHandler)" map="A"/>
  <method class="org.jdom.input.SAXBuilder" name="void internalSetFeature(org.xml.sax.XMLReader, java.lang.String, boolean, java.lang.String)" map="A"/>
  <method class="org.jdom.input.SAXBuilder" name="org.jdom.Document build(java.io.Reader)" map="A"/>
  <method class="org.jdom.input.SAXBuilder" name="org.jdom.Document build(java.io.InputStream)" map="A"/>
  <method class="org.jdom.input.SAXBuilder" name="void configureParser(org.xml.sax.XMLReader, org.jdom.input.SAXHandler)" map="A"/>
  <method class="org.jdom.input.SAXBuilder" name="java.net.URL fileToURL(java.io.File)" map="A"/>
  <method class="org.jdom.input.SAXBuilder" name="org.xml.sax.XMLReader createParser()" map="A"/>
  <method class="org.jdom.input.SAXBuilder" name="org.jdom.input.SAXHandler createContentHandler()" map="B"/>
  <method class="org.jdom.input.SAXBuilder" name="org.jdom.Document build(java.io.File)" map="B"/>
  <method class="org.jdom.input.SAXBuilder" name="void internalSetProperty(org.xml.sax.XMLReader, java.lang.String, java.lang.Object, java.lang.String)" map="A"/>
  <method class="org.jdom.input.SAXBuilder" name="void setFeaturesAndProperties(org.xml.sax.XMLReader, boolean)" map="A"/>
  <method class="org.jdom.input.SAXBuilder" name="org.jdom.Document build(org.xml.sax.InputSource)" map="A"/>
  <class name="org.jdom.input.JDOMParseException" map="E"/>
  <field class="org.jdom.input.JDOMParseException" name="partialDocument" map="B"/>
  <package name="org.jdom.transform" map="C"/>
  <class name="org.jdom.transform.JDOMSource$DocumentReader" map="_A"/>
  <method class="org.jdom.transform.JDOMSource$DocumentReader" name="void parse(org.xml.sax.InputSource)" map="A"/>
  <class name="org.jdom.transform.JDOMSource" map="A"/>
  <package name="org.jdom.filter" map="D"/>
  <class name="org.jdom.filter.Filter" map="A"/>
  <method class="org.jdom.filter.Filter" name="boolean matches(java.lang.Object)" map="A"/>
  <class name="org.jdom.filter.ElementFilter" map="B"/>
  <field class="org.jdom.filter.ElementFilter" name="name" map="A"/>
  <field class="org.jdom.filter.ElementFilter" name="namespace" map="B"/>
  <method class="org.jdom.filter.ElementFilter" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jdom.filter.ElementFilter" name="int hashCode()" map="hashCode"/>
  <method class="org.jdom.filter.ElementFilter" name="boolean matches(java.lang.Object)" map="A"/>
  <class name="org.jdom.filter.AbstractFilter" map="C"/>
  <class name="org.jdom.ContentList$FilterList" map="_A"/>
  <field class="org.jdom.ContentList$FilterList" name="this$0" map="this$0"/>
  <field class="org.jdom.ContentList$FilterList" name="filter" map="A"/>
  <field class="org.jdom.ContentList$FilterList" name="expected" map="B"/>
  <field class="org.jdom.ContentList$FilterList" name="count" map="C"/>
  <method class="org.jdom.ContentList$FilterList" name="java.lang.Object remove(int)" map="remove"/>
  <method class="org.jdom.ContentList$FilterList" name="java.util.ListIterator listIterator(int)" map="listIterator"/>
  <method class="org.jdom.ContentList$FilterList" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="org.jdom.ContentList$FilterList" name="int getAdjustedIndex(int)" map="A"/>
  <method class="org.jdom.ContentList$FilterList" name="java.lang.Object get(int)" map="get"/>
  <method class="org.jdom.ContentList$FilterList" name="void add(int, java.lang.Object)" map="add"/>
  <method class="org.jdom.ContentList$FilterList" name="int size()" map="size"/>
  <method class="org.jdom.ContentList$FilterList" name="java.util.ListIterator listIterator()" map="listIterator"/>
  <method class="org.jdom.ContentList$FilterList" name="java.lang.Object set(int, java.lang.Object)" map="set"/>
  <class name="org.jdom.ContentList$FilterListIterator" map="_B"/>
  <field class="org.jdom.ContentList$FilterListIterator" name="canset" map="A"/>
  <field class="org.jdom.ContentList$FilterListIterator" name="fsize" map="B"/>
  <field class="org.jdom.ContentList$FilterListIterator" name="filter" map="C"/>
  <field class="org.jdom.ContentList$FilterListIterator" name="tmpcursor" map="D"/>
  <field class="org.jdom.ContentList$FilterListIterator" name="forward" map="E"/>
  <field class="org.jdom.ContentList$FilterListIterator" name="this$0" map="this$0"/>
  <field class="org.jdom.ContentList$FilterListIterator" name="canremove" map="F"/>
  <field class="org.jdom.ContentList$FilterListIterator" name="expected" map="G"/>
  <field class="org.jdom.ContentList$FilterListIterator" name="index" map="H"/>
  <field class="org.jdom.ContentList$FilterListIterator" name="cursor" map="I"/>
  <method class="org.jdom.ContentList$FilterListIterator" name="boolean hasNext()" map="hasNext"/>
  <method class="org.jdom.ContentList$FilterListIterator" name="void remove()" map="remove"/>
  <method class="org.jdom.ContentList$FilterListIterator" name="boolean hasPrevious()" map="hasPrevious"/>
  <method class="org.jdom.ContentList$FilterListIterator" name="void set(java.lang.Object)" map="set"/>
  <method class="org.jdom.ContentList$FilterListIterator" name="int previousIndex()" map="previousIndex"/>
  <method class="org.jdom.ContentList$FilterListIterator" name="void add(java.lang.Object)" map="add"/>
  <method class="org.jdom.ContentList$FilterListIterator" name="java.lang.Object next()" map="next"/>
  <method class="org.jdom.ContentList$FilterListIterator" name="void checkConcurrentModification()" map="A"/>
  <method class="org.jdom.ContentList$FilterListIterator" name="int nextIndex()" map="nextIndex"/>
  <method class="org.jdom.ContentList$FilterListIterator" name="java.lang.Object previous()" map="previous"/>
  <class name="org.jdom.ContentList" map="A"/>
  <field class="org.jdom.ContentList" name="size" map="A"/>
  <field class="org.jdom.ContentList" name="elementData" map="B"/>
  <field class="org.jdom.ContentList" name="parent" map="C"/>
  <method class="org.jdom.ContentList" name="boolean addAll(int, java.util.Collection)" map="addAll"/>
  <method class="org.jdom.ContentList" name="java.lang.Object set(int, java.lang.Object)" map="set"/>
  <method class="org.jdom.ContentList" name="int indexOfFirstElement()" map="A"/>
  <method class="org.jdom.ContentList" name="void add(int, org.jdom.Content)" map="A"/>
  <method class="org.jdom.ContentList" name="void documentCanContain(int, org.jdom.Content)" map="B"/>
  <method class="org.jdom.ContentList" name="java.lang.String toString()" map="toString"/>
  <method class="org.jdom.ContentList" name="int access$200(org.jdom.ContentList)" map="access$200"/>
  <method class="org.jdom.ContentList" name="int access$000(org.jdom.ContentList)" map="access$000"/>
  <method class="org.jdom.ContentList" name="org.jdom.Content[] access$100(org.jdom.ContentList)" map="access$100"/>
  <method class="org.jdom.ContentList" name="int getModCount()" map="B"/>
  <method class="org.jdom.ContentList" name="java.lang.Object remove(int)" map="remove"/>
  <method class="org.jdom.ContentList" name="boolean addAll(java.util.Collection)" map="addAll"/>
  <method class="org.jdom.ContentList" name="void removeParent(org.jdom.Content)" map="A"/>
  <method class="org.jdom.ContentList" name="java.lang.Object get(int)" map="get"/>
  <method class="org.jdom.ContentList" name="void ensureCapacity(int)" map="A"/>
  <method class="org.jdom.ContentList" name="void elementCanContain(int, org.jdom.Content)" map="C"/>
  <method class="org.jdom.ContentList" name="int size()" map="size"/>
  <method class="org.jdom.ContentList" name="java.util.List getView(org.jdom.filter.Filter)" map="A"/>
  <method class="org.jdom.ContentList" name="void add(int, java.lang.Object)" map="add"/>
  <method class="org.jdom.ContentList" name="int indexOfDocType()" map="C"/>
  <method class="org.jdom.ContentList" name="void clear()" map="clear"/>
  <class name="org.jdom.Attribute" map="B"/>
  <field class="org.jdom.Attribute" name="name" map="A"/>
  <field class="org.jdom.Attribute" name="parent" map="B"/>
  <field class="org.jdom.Attribute" name="type" map="C"/>
  <field class="org.jdom.Attribute" name="namespace" map="D"/>
  <field class="org.jdom.Attribute" name="value" map="E"/>
  <method class="org.jdom.Attribute" name="java.lang.String getQualifiedName()" map="A"/>
  <method class="org.jdom.Attribute" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jdom.Attribute" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jdom.Attribute" name="int getIntValue()" map="B"/>
  <method class="org.jdom.Attribute" name="java.lang.String toString()" map="toString"/>
  <method class="org.jdom.Attribute" name="boolean getBooleanValue()" map="C"/>
  <method class="org.jdom.Attribute" name="java.lang.String getValue()" map="D"/>
  <method class="org.jdom.Attribute" name="org.jdom.Attribute setNamespace(org.jdom.Namespace)" map="A"/>
  <method class="org.jdom.Attribute" name="org.jdom.Namespace getNamespace()" map="E"/>
  <method class="org.jdom.Attribute" name="double getDoubleValue()" map="F"/>
  <method class="org.jdom.Attribute" name="int hashCode()" map="hashCode"/>
  <method class="org.jdom.Attribute" name="float getFloatValue()" map="G"/>
  <method class="org.jdom.Attribute" name="org.jdom.Attribute setParent(org.jdom.Element)" map="A"/>
  <method class="org.jdom.Attribute" name="java.lang.String getNamespaceURI()" map="H"/>
  <method class="org.jdom.Attribute" name="java.lang.String getName()" map="I"/>
  <method class="org.jdom.Attribute" name="org.jdom.Attribute setAttributeType(int)" map="A"/>
  <method class="org.jdom.Attribute" name="org.jdom.Element getParent()" map="J"/>
  <method class="org.jdom.Attribute" name="org.jdom.Attribute setName(java.lang.String)" map="A"/>
  <method class="org.jdom.Attribute" name="org.jdom.Attribute setValue(java.lang.String)" map="B"/>
  <class name="org.jdom.Content" map="C"/>
  <field class="org.jdom.Content" name="parent" map="A"/>
  <method class="org.jdom.Content" name="java.lang.String getValue()" map="A"/>
  <method class="org.jdom.Content" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jdom.Content" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jdom.Content" name="int hashCode()" map="hashCode"/>
  <method class="org.jdom.Content" name="org.jdom.Parent getParent()" map="B"/>
  <method class="org.jdom.Content" name="org.jdom.Content setParent(org.jdom.Parent)" map="A"/>
  <method class="org.jdom.Content" name="org.jdom.Element getParentElement()" map="C"/>
  <class name="org.jdom.Parent" map="D"/>
  <method class="org.jdom.Parent" name="org.jdom.Parent getParent()" map="B"/>
  <class name="org.jdom.IllegalTargetException" map="E"/>
  <class name="org.jdom.Verifier" map="F"/>
  <method class="org.jdom.Verifier" name="boolean isLowSurrogate(char)" map="A"/>
  <method class="org.jdom.Verifier" name="boolean isXMLLetter(char)" map="B"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkPublicID(java.lang.String)" map="A"/>
  <method class="org.jdom.Verifier" name="boolean isXMLCombiningChar(char)" map="C"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkNamespaceCollision(org.jdom.Attribute, org.jdom.Element)" map="A"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkSystemLiteral(java.lang.String)" map="B"/>
  <method class="org.jdom.Verifier" name="boolean isHighSurrogate(char)" map="D"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkNamespaceCollision(org.jdom.Namespace, org.jdom.Attribute)" map="A"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkNamespaceCollision(org.jdom.Namespace, java.util.List)" map="A"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkElementName(java.lang.String)" map="C"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkNamespaceURI(java.lang.String)" map="D"/>
  <method class="org.jdom.Verifier" name="boolean isXMLExtender(char)" map="E"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkNamespacePrefix(java.lang.String)" map="E"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkCharacterData(java.lang.String)" map="F"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkXMLName(java.lang.String)" map="G"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkCDATASection(java.lang.String)" map="H"/>
  <method class="org.jdom.Verifier" name="boolean isXMLCharacter(int)" map="A"/>
  <method class="org.jdom.Verifier" name="boolean isXMLPublicIDCharacter(char)" map="F"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkNamespaceCollision(org.jdom.Namespace, org.jdom.Element)" map="A"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkNamespaceCollision(org.jdom.Namespace, org.jdom.Namespace)" map="A"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkProcessingInstructionTarget(java.lang.String)" map="I"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkAttributeName(java.lang.String)" map="J"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkProcessingInstructionData(java.lang.String)" map="K"/>
  <method class="org.jdom.Verifier" name="boolean isXMLNameCharacter(char)" map="G"/>
  <method class="org.jdom.Verifier" name="boolean isXMLWhitespace(char)" map="H"/>
  <method class="org.jdom.Verifier" name="boolean isXMLDigit(char)" map="I"/>
  <method class="org.jdom.Verifier" name="boolean isXMLNameStartCharacter(char)" map="J"/>
  <method class="org.jdom.Verifier" name="java.lang.String checkCommentData(java.lang.String)" map="L"/>
  <method class="org.jdom.Verifier" name="int decodeSurrogatePair(char, char)" map="A"/>
  <class name="org.jdom.IllegalNameException" map="G"/>
  <class name="org.jdom.JDOMFactory" map="H"/>
  <method class="org.jdom.JDOMFactory" name="void setAttribute(org.jdom.Element, org.jdom.Attribute)" map="A"/>
  <method class="org.jdom.JDOMFactory" name="org.jdom.CDATA cdata(java.lang.String)" map="A"/>
  <method class="org.jdom.JDOMFactory" name="void addContent(org.jdom.Parent, org.jdom.Content)" map="A"/>
  <method class="org.jdom.JDOMFactory" name="org.jdom.Document document(org.jdom.Element)" map="A"/>
  <method class="org.jdom.JDOMFactory" name="org.jdom.DocType docType(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.jdom.JDOMFactory" name="org.jdom.Element element(java.lang.String, org.jdom.Namespace)" map="A"/>
  <method class="org.jdom.JDOMFactory" name="org.jdom.EntityRef entityRef(java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="org.jdom.JDOMFactory" name="org.jdom.ProcessingInstruction processingInstruction(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.jdom.JDOMFactory" name="org.jdom.EntityRef entityRef(java.lang.String)" map="B"/>
  <method class="org.jdom.JDOMFactory" name="org.jdom.Text text(java.lang.String)" map="C"/>
  <method class="org.jdom.JDOMFactory" name="org.jdom.Comment comment(java.lang.String)" map="D"/>
  <method class="org.jdom.JDOMFactory" name="org.jdom.Attribute attribute(java.lang.String, java.lang.String, int, org.jdom.Namespace)" map="A"/>
  <class name="org.jdom.Namespace" map="I"/>
  <field class="org.jdom.Namespace" name="NO_NAMESPACE" map="A"/>
  <field class="org.jdom.Namespace" name="uri" map="B"/>
  <field class="org.jdom.Namespace" name="prefix" map="C"/>
  <field class="org.jdom.Namespace" name="namespaces" map="D"/>
  <field class="org.jdom.Namespace" name="XML_NAMESPACE" map="E"/>
  <method class="org.jdom.Namespace" name="java.lang.String getURI()" map="A"/>
  <method class="org.jdom.Namespace" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jdom.Namespace" name="int hashCode()" map="hashCode"/>
  <method class="org.jdom.Namespace" name="java.lang.String toString()" map="toString"/>
  <method class="org.jdom.Namespace" name="org.jdom.Namespace getNamespace(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.jdom.Namespace" name="java.lang.String getPrefix()" map="B"/>
  <class name="org.jdom.Comment" map="J"/>
  <field class="org.jdom.Comment" name="text" map="B"/>
  <method class="org.jdom.Comment" name="java.lang.String getValue()" map="A"/>
  <method class="org.jdom.Comment" name="java.lang.String getText()" map="D"/>
  <method class="org.jdom.Comment" name="org.jdom.Comment setText(java.lang.String)" map="A"/>
  <method class="org.jdom.Comment" name="java.lang.String toString()" map="toString"/>
  <class name="org.jdom.CDATA" map="K"/>
  <method class="org.jdom.CDATA" name="org.jdom.Text setText(java.lang.String)" map="S"/>
  <method class="org.jdom.CDATA" name="java.lang.String toString()" map="toString"/>
  <class name="org.jdom.DataConversionException" map="L"/>
  <class name="org.jdom.EntityRef" map="M"/>
  <field class="org.jdom.EntityRef" name="name" map="C"/>
  <field class="org.jdom.EntityRef" name="publicID" map="D"/>
  <field class="org.jdom.EntityRef" name="systemID" map="E"/>
  <method class="org.jdom.EntityRef" name="java.lang.String getValue()" map="A"/>
  <method class="org.jdom.EntityRef" name="org.jdom.EntityRef setPublicID(java.lang.String)" map="B"/>
  <method class="org.jdom.EntityRef" name="java.lang.String getName()" map="E"/>
  <method class="org.jdom.EntityRef" name="org.jdom.EntityRef setName(java.lang.String)" map="C"/>
  <method class="org.jdom.EntityRef" name="java.lang.String toString()" map="toString"/>
  <method class="org.jdom.EntityRef" name="org.jdom.EntityRef setSystemID(java.lang.String)" map="D"/>
  <class name="org.jdom.Document" map="N"/>
  <field class="org.jdom.Document" name="propertyMap" map="F"/>
  <field class="org.jdom.Document" name="content" map="G"/>
  <field class="org.jdom.Document" name="baseURI" map="H"/>
  <method class="org.jdom.Document" name="boolean hasRootElement()" map="F"/>
  <method class="org.jdom.Document" name="void setBaseURI(java.lang.String)" map="E"/>
  <method class="org.jdom.Document" name="int hashCode()" map="hashCode"/>
  <method class="org.jdom.Document" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jdom.Document" name="org.jdom.Document setRootElement(org.jdom.Element)" map="A"/>
  <method class="org.jdom.Document" name="org.jdom.Document setDocType(org.jdom.DocType)" map="A"/>
  <method class="org.jdom.Document" name="org.jdom.Document addContent(org.jdom.Content)" map="A"/>
  <method class="org.jdom.Document" name="org.jdom.Element getRootElement()" map="G"/>
  <method class="org.jdom.Document" name="org.jdom.DocType getDocType()" map="H"/>
  <method class="org.jdom.Document" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jdom.Document" name="java.lang.String toString()" map="toString"/>
  <method class="org.jdom.Document" name="org.jdom.Parent getParent()" map="B"/>
  <class name="org.jdom.Element" map="O"/>
  <field class="org.jdom.Element" name="attributes" map="I"/>
  <field class="org.jdom.Element" name="additionalNamespaces" map="J"/>
  <field class="org.jdom.Element" name="name" map="K"/>
  <field class="org.jdom.Element" name="namespace" map="L"/>
  <field class="org.jdom.Element" name="content" map="M"/>
  <method class="org.jdom.Element" name="org.jdom.Element setAttribute(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.jdom.Element" name="java.lang.String getAttributeValue(java.lang.String, org.jdom.Namespace)" map="A"/>
  <method class="org.jdom.Element" name="org.jdom.Attribute getAttribute(java.lang.String, org.jdom.Namespace)" map="B"/>
  <method class="org.jdom.Element" name="java.lang.String getQualifiedName()" map="I"/>
  <method class="org.jdom.Element" name="java.util.List getAdditionalNamespaces()" map="J"/>
  <method class="org.jdom.Element" name="boolean isAncestor(org.jdom.Element)" map="B"/>
  <method class="org.jdom.Element" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jdom.Element" name="org.jdom.Element setAttribute(org.jdom.Attribute)" map="A"/>
  <method class="org.jdom.Element" name="org.jdom.Element addContent(org.jdom.Content)" map="B"/>
  <method class="org.jdom.Element" name="java.lang.String toString()" map="toString"/>
  <method class="org.jdom.Element" name="org.jdom.Element getChild(java.lang.String)" map="F"/>
  <method class="org.jdom.Element" name="java.util.List getChildren(java.lang.String, org.jdom.Namespace)" map="C"/>
  <method class="org.jdom.Element" name="java.util.List getChildren()" map="K"/>
  <method class="org.jdom.Element" name="java.lang.String getAttributeValue(java.lang.String, org.jdom.Namespace, java.lang.String)" map="A"/>
  <method class="org.jdom.Element" name="java.lang.String getValue()" map="A"/>
  <method class="org.jdom.Element" name="java.lang.String getNamespacePrefix()" map="L"/>
  <method class="org.jdom.Element" name="org.jdom.Namespace getNamespace()" map="M"/>
  <method class="org.jdom.Element" name="boolean removeAttribute(java.lang.String)" map="G"/>
  <method class="org.jdom.Element" name="org.jdom.Element setName(java.lang.String)" map="H"/>
  <method class="org.jdom.Element" name="boolean removeAttribute(java.lang.String, org.jdom.Namespace)" map="D"/>
  <method class="org.jdom.Element" name="java.lang.String getNamespaceURI()" map="N"/>
  <method class="org.jdom.Element" name="java.lang.String getName()" map="O"/>
  <method class="org.jdom.Element" name="org.jdom.Attribute getAttribute(java.lang.String)" map="I"/>
  <method class="org.jdom.Element" name="org.jdom.Element addContent(java.lang.String)" map="J"/>
  <method class="org.jdom.Element" name="java.util.List getAttributes()" map="P"/>
  <method class="org.jdom.Element" name="org.jdom.Element getChild(java.lang.String, org.jdom.Namespace)" map="E"/>
  <method class="org.jdom.Element" name="org.jdom.Element setText(java.lang.String)" map="K"/>
  <method class="org.jdom.Element" name="org.jdom.Element setNamespace(org.jdom.Namespace)" map="A"/>
  <method class="org.jdom.Element" name="void addNamespaceDeclaration(org.jdom.Namespace)" map="B"/>
  <method class="org.jdom.Element" name="java.lang.String getText()" map="Q"/>
  <method class="org.jdom.Element" name="java.lang.String getAttributeValue(java.lang.String)" map="L"/>
  <method class="org.jdom.Element" name="java.util.List getContent()" map="R"/>
  <method class="org.jdom.Element" name="boolean removeChildren(java.lang.String, org.jdom.Namespace)" map="F"/>
  <method class="org.jdom.Element" name="java.util.List getChildren(java.lang.String)" map="M"/>
  <method class="org.jdom.Element" name="boolean removeChildren(java.lang.String)" map="N"/>
  <class name="org.jdom.DefaultJDOMFactory" map="P"/>
  <method class="org.jdom.DefaultJDOMFactory" name="void setAttribute(org.jdom.Element, org.jdom.Attribute)" map="A"/>
  <method class="org.jdom.DefaultJDOMFactory" name="org.jdom.CDATA cdata(java.lang.String)" map="A"/>
  <method class="org.jdom.DefaultJDOMFactory" name="void addContent(org.jdom.Parent, org.jdom.Content)" map="A"/>
  <method class="org.jdom.DefaultJDOMFactory" name="org.jdom.Document document(org.jdom.Element)" map="A"/>
  <method class="org.jdom.DefaultJDOMFactory" name="org.jdom.DocType docType(java.lang.String, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.jdom.DefaultJDOMFactory" name="org.jdom.Element element(java.lang.String, org.jdom.Namespace)" map="A"/>
  <method class="org.jdom.DefaultJDOMFactory" name="org.jdom.EntityRef entityRef(java.lang.String, java.lang.String, java.lang.String)" map="B"/>
  <method class="org.jdom.DefaultJDOMFactory" name="org.jdom.ProcessingInstruction processingInstruction(java.lang.String, java.lang.String)" map="A"/>
  <method class="org.jdom.DefaultJDOMFactory" name="org.jdom.EntityRef entityRef(java.lang.String)" map="B"/>
  <method class="org.jdom.DefaultJDOMFactory" name="org.jdom.Text text(java.lang.String)" map="C"/>
  <method class="org.jdom.DefaultJDOMFactory" name="org.jdom.Comment comment(java.lang.String)" map="D"/>
  <method class="org.jdom.DefaultJDOMFactory" name="org.jdom.Attribute attribute(java.lang.String, java.lang.String, int, org.jdom.Namespace)" map="A"/>
  <class name="org.jdom.DocType" map="Q"/>
  <field class="org.jdom.DocType" name="elementName" map="N"/>
  <field class="org.jdom.DocType" name="internalSubset" map="O"/>
  <field class="org.jdom.DocType" name="publicID" map="P"/>
  <field class="org.jdom.DocType" name="systemID" map="Q"/>
  <method class="org.jdom.DocType" name="void setInternalSubset(java.lang.String)" map="O"/>
  <method class="org.jdom.DocType" name="org.jdom.DocType setElementName(java.lang.String)" map="P"/>
  <method class="org.jdom.DocType" name="org.jdom.DocType setSystemID(java.lang.String)" map="Q"/>
  <method class="org.jdom.DocType" name="java.lang.String getElementName()" map="S"/>
  <method class="org.jdom.DocType" name="org.jdom.DocType setPublicID(java.lang.String)" map="R"/>
  <method class="org.jdom.DocType" name="java.lang.String getInternalSubset()" map="T"/>
  <method class="org.jdom.DocType" name="java.lang.String getSystemID()" map="U"/>
  <method class="org.jdom.DocType" name="java.lang.String toString()" map="toString"/>
  <method class="org.jdom.DocType" name="java.lang.String getValue()" map="A"/>
  <method class="org.jdom.DocType" name="java.lang.String getPublicID()" map="V"/>
  <class name="org.jdom.Text" map="R"/>
  <field class="org.jdom.Text" name="value" map="R"/>
  <method class="org.jdom.Text" name="java.lang.String getValue()" map="A"/>
  <method class="org.jdom.Text" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jdom.Text" name="java.lang.String getText()" map="W"/>
  <method class="org.jdom.Text" name="org.jdom.Text setText(java.lang.String)" map="S"/>
  <method class="org.jdom.Text" name="java.lang.String normalizeString(java.lang.String)" map="T"/>
  <method class="org.jdom.Text" name="java.lang.String toString()" map="toString"/>
  <method class="org.jdom.Text" name="java.lang.String getTextNormalize()" map="X"/>
  <class name="org.jdom.AttributeList" map="S"/>
  <field class="org.jdom.AttributeList" name="size" map="A"/>
  <field class="org.jdom.AttributeList" name="elementData" map="B"/>
  <field class="org.jdom.AttributeList" name="parent" map="C"/>
  <method class="org.jdom.AttributeList" name="boolean remove(java.lang.String, org.jdom.Namespace)" map="A"/>
  <method class="org.jdom.AttributeList" name="boolean addAll(int, java.util.Collection)" map="addAll"/>
  <method class="org.jdom.AttributeList" name="java.lang.Object remove(int)" map="remove"/>
  <method class="org.jdom.AttributeList" name="java.lang.Object get(java.lang.String, org.jdom.Namespace)" map="B"/>
  <method class="org.jdom.AttributeList" name="java.lang.Object set(int, org.jdom.Attribute)" map="A"/>
  <method class="org.jdom.AttributeList" name="int indexOfDuplicate(org.jdom.Attribute)" map="A"/>
  <method class="org.jdom.AttributeList" name="void clear()" map="clear"/>
  <method class="org.jdom.AttributeList" name="void add(int, org.jdom.Attribute)" map="B"/>
  <method class="org.jdom.AttributeList" name="java.lang.Object get(int)" map="get"/>
  <method class="org.jdom.AttributeList" name="void add(int, java.lang.Object)" map="add"/>
  <method class="org.jdom.AttributeList" name="boolean add(java.lang.Object)" map="add"/>
  <method class="org.jdom.AttributeList" name="int size()" map="size"/>
  <method class="org.jdom.AttributeList" name="boolean addAll(java.util.Collection)" map="addAll"/>
  <method class="org.jdom.AttributeList" name="java.lang.String toString()" map="toString"/>
  <method class="org.jdom.AttributeList" name="int indexOf(java.lang.String, org.jdom.Namespace)" map="C"/>
  <method class="org.jdom.AttributeList" name="void ensureCapacity(int)" map="A"/>
  <method class="org.jdom.AttributeList" name="java.lang.Object set(int, java.lang.Object)" map="set"/>
  <class name="org.jdom.IllegalDataException" map="T"/>
  <class name="org.jdom.NamespaceKey" map="U"/>
  <field class="org.jdom.NamespaceKey" name="uri" map="A"/>
  <field class="org.jdom.NamespaceKey" name="prefix" map="B"/>
  <field class="org.jdom.NamespaceKey" name="hash" map="C"/>
  <method class="org.jdom.NamespaceKey" name="boolean equals(java.lang.Object)" map="equals"/>
  <method class="org.jdom.NamespaceKey" name="int hashCode()" map="hashCode"/>
  <method class="org.jdom.NamespaceKey" name="java.lang.String toString()" map="toString"/>
  <class name="org.jdom.JDOMException" map="V"/>
  <field class="org.jdom.JDOMException" name="cause" map="A"/>
  <method class="org.jdom.JDOMException" name="void printStackTrace(java.io.PrintStream)" map="printStackTrace"/>
  <method class="org.jdom.JDOMException" name="void printStackTrace(java.io.PrintWriter)" map="printStackTrace"/>
  <method class="org.jdom.JDOMException" name="java.lang.Throwable getCause()" map="getCause"/>
  <method class="org.jdom.JDOMException" name="java.lang.String getMessage()" map="getMessage"/>
  <method class="org.jdom.JDOMException" name="java.lang.Throwable initCause(java.lang.Throwable)" map="initCause"/>
  <method class="org.jdom.JDOMException" name="java.lang.Throwable getNestedExceptionFromField(java.lang.Throwable, java.lang.String, java.lang.String)" map="A"/>
  <method class="org.jdom.JDOMException" name="void printStackTrace()" map="printStackTrace"/>
  <method class="org.jdom.JDOMException" name="java.lang.Throwable getNestedException(java.lang.Throwable)" map="A"/>
  <method class="org.jdom.JDOMException" name="java.lang.Throwable getNestedException(java.lang.Throwable, java.lang.String, java.lang.String)" map="B"/>
  <class name="org.jdom.ProcessingInstruction" map="W"/>
  <field class="org.jdom.ProcessingInstruction" name="target" map="S"/>
  <field class="org.jdom.ProcessingInstruction" name="mapData" map="T"/>
  <field class="org.jdom.ProcessingInstruction" name="rawData" map="U"/>
  <method class="org.jdom.ProcessingInstruction" name="int[] extractQuotedString(java.lang.String)" map="U"/>
  <method class="org.jdom.ProcessingInstruction" name="java.lang.String getTarget()" map="Y"/>
  <method class="org.jdom.ProcessingInstruction" name="org.jdom.ProcessingInstruction setTarget(java.lang.String)" map="V"/>
  <method class="org.jdom.ProcessingInstruction" name="java.util.Map parseData(java.lang.String)" map="W"/>
  <method class="org.jdom.ProcessingInstruction" name="java.lang.String getData()" map="Z"/>
  <method class="org.jdom.ProcessingInstruction" name="java.lang.Object clone()" map="clone"/>
  <method class="org.jdom.ProcessingInstruction" name="org.jdom.ProcessingInstruction setData(java.lang.String)" map="X"/>
  <method class="org.jdom.ProcessingInstruction" name="java.lang.String toString()" map="toString"/>
  <method class="org.jdom.ProcessingInstruction" name="java.lang.String getValue()" map="A"/>
  <class name="org.jdom.IllegalAddException" map="X"/>
  <package name="fi" map="G"/>
  <package name="fi.iki" map="A"/>
  <package name="fi.iki.elonen" map="A"/>
  <class name="fi.iki.elonen.NanoHTTPD$DefaultAsyncRunner" map="_A"/>
  <field class="fi.iki.elonen.NanoHTTPD$DefaultAsyncRunner" name="running" map="A"/>
  <field class="fi.iki.elonen.NanoHTTPD$DefaultAsyncRunner" name="requestCount" map="B"/>
  <method class="fi.iki.elonen.NanoHTTPD$DefaultAsyncRunner" name="void exec(fi.iki.elonen.NanoHTTPD$ClientHandler)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$DefaultAsyncRunner" name="void closeAll()" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$DefaultAsyncRunner" name="void closed(fi.iki.elonen.NanoHTTPD$ClientHandler)" map="B"/>
  <class name="fi.iki.elonen.NanoHTTPD$TempFile" map="_B"/>
  <method class="fi.iki.elonen.NanoHTTPD$TempFile" name="java.lang.String getName()" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$TempFile" name="void delete()" map="B"/>
  <class name="fi.iki.elonen.NanoHTTPD$Method" map="_C"/>
  <field class="fi.iki.elonen.NanoHTTPD$Method" name="TRACE" map="A"/>
  <field class="fi.iki.elonen.NanoHTTPD$Method" name="PUT" map="B"/>
  <field class="fi.iki.elonen.NanoHTTPD$Method" name="$VALUES" map="C"/>
  <field class="fi.iki.elonen.NanoHTTPD$Method" name="OPTIONS" map="D"/>
  <field class="fi.iki.elonen.NanoHTTPD$Method" name="CONNECT" map="E"/>
  <field class="fi.iki.elonen.NanoHTTPD$Method" name="HEAD" map="F"/>
  <field class="fi.iki.elonen.NanoHTTPD$Method" name="DELETE" map="G"/>
  <field class="fi.iki.elonen.NanoHTTPD$Method" name="POST" map="H"/>
  <field class="fi.iki.elonen.NanoHTTPD$Method" name="GET" map="I"/>
  <field class="fi.iki.elonen.NanoHTTPD$Method" name="PATCH" map="J"/>
  <method class="fi.iki.elonen.NanoHTTPD$Method" name="fi.iki.elonen.NanoHTTPD$Method valueOf(java.lang.String)" map="valueOf"/>
  <method class="fi.iki.elonen.NanoHTTPD$Method" name="fi.iki.elonen.NanoHTTPD$Method[] values()" map="values"/>
  <method class="fi.iki.elonen.NanoHTTPD$Method" name="fi.iki.elonen.NanoHTTPD$Method lookup(java.lang.String)" map="A"/>
  <class name="fi.iki.elonen.NanoHTTPD$Response$Status" map="_A"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="SWITCH_PROTOCOL" map="A"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="NOT_FOUND" map="B"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="METHOD_NOT_ALLOWED" map="C"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="OK" map="D"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="NOT_MODIFIED" map="E"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="REDIRECT" map="F"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="UNAUTHORIZED" map="G"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="BAD_REQUEST" map="H"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="PARTIAL_CONTENT" map="I"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="INTERNAL_ERROR" map="J"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="NO_CONTENT" map="K"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="ACCEPTED" map="L"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="description" map="M"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="$VALUES" map="N"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="requestStatus" map="O"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="FORBIDDEN" map="P"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="CREATED" map="Q"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="REQUEST_TIMEOUT" map="R"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="UNSUPPORTED_HTTP_VERSION" map="S"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response$Status" name="RANGE_NOT_SATISFIABLE" map="T"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response$Status" name="fi.iki.elonen.NanoHTTPD$Response$Status[] values()" map="values"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response$Status" name="java.lang.String getDescription()" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response$Status" name="fi.iki.elonen.NanoHTTPD$Response$Status valueOf(java.lang.String)" map="valueOf"/>
  <class name="fi.iki.elonen.NanoHTTPD$Response$ChunkedOutputStream" map="_B"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response$ChunkedOutputStream" name="void finish()" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response$ChunkedOutputStream" name="void write(byte[], int, int)" map="write"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response$ChunkedOutputStream" name="void write(byte[])" map="write"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response$ChunkedOutputStream" name="void write(int)" map="write"/>
  <class name="fi.iki.elonen.NanoHTTPD$Response$IStatus" map="_C"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response$IStatus" name="java.lang.String getDescription()" map="A"/>
  <class name="fi.iki.elonen.NanoHTTPD$Response" map="_D"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response" name="contentLength" map="A"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response" name="mimeType" map="B"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response" name="chunkedTransfer" map="C"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response" name="status" map="D"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response" name="data" map="E"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response" name="header" map="F"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response" name="requestMethod" map="G"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response" name="encodeAsGzip" map="H"/>
  <field class="fi.iki.elonen.NanoHTTPD$Response" name="keepAlive" map="I"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response" name="java.lang.String getHeader(java.lang.String)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response" name="long sendContentLengthHeaderIfNotAlreadyPresent(java.io.PrintWriter, java.util.Map, long)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response" name="void setKeepAlive(boolean)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response" name="java.lang.String getMimeType()" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response" name="void sendBody(java.io.OutputStream, long)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response" name="void close()" map="close"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response" name="boolean headerAlreadySent(java.util.Map, java.lang.String)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response" name="void setGzipEncoding(boolean)" map="B"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response" name="void setRequestMethod(fi.iki.elonen.NanoHTTPD$Method)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response" name="void setChunkedTransfer(boolean)" map="C"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response" name="void sendBodyWithCorrectTransferAndEncoding(java.io.OutputStream, long)" map="B"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response" name="void addHeader(java.lang.String, java.lang.String)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response" name="void send(java.io.OutputStream)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$Response" name="void sendBodyWithCorrectEncoding(java.io.OutputStream, long)" map="C"/>
  <class name="fi.iki.elonen.NanoHTTPD$IHTTPSession" map="_E"/>
  <method class="fi.iki.elonen.NanoHTTPD$IHTTPSession" name="java.lang.String getUri()" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$IHTTPSession" name="void parseBody(java.util.Map)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$IHTTPSession" name="fi.iki.elonen.NanoHTTPD$Method getMethod()" map="B"/>
  <method class="fi.iki.elonen.NanoHTTPD$IHTTPSession" name="java.util.Map getParms()" map="C"/>
  <class name="fi.iki.elonen.NanoHTTPD$TempFileManagerFactory" map="_F"/>
  <method class="fi.iki.elonen.NanoHTTPD$TempFileManagerFactory" name="fi.iki.elonen.NanoHTTPD$TempFileManager create()" map="A"/>
  <class name="fi.iki.elonen.NanoHTTPD$DefaultTempFileManager" map="_G"/>
  <field class="fi.iki.elonen.NanoHTTPD$DefaultTempFileManager" name="tempFiles" map="A"/>
  <field class="fi.iki.elonen.NanoHTTPD$DefaultTempFileManager" name="tmpdir" map="B"/>
  <method class="fi.iki.elonen.NanoHTTPD$DefaultTempFileManager" name="void clear()" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$DefaultTempFileManager" name="fi.iki.elonen.NanoHTTPD$TempFile createTempFile()" map="B"/>
  <class name="fi.iki.elonen.NanoHTTPD$Cookie" map="_H"/>
  <method class="fi.iki.elonen.NanoHTTPD$Cookie" name="java.lang.String getHTTPHeader()" map="A"/>
  <class name="fi.iki.elonen.NanoHTTPD$TempFileManager" map="_I"/>
  <method class="fi.iki.elonen.NanoHTTPD$TempFileManager" name="void clear()" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$TempFileManager" name="fi.iki.elonen.NanoHTTPD$TempFile createTempFile()" map="B"/>
  <class name="fi.iki.elonen.NanoHTTPD$ServerRunnable" map="_J"/>
  <field class="fi.iki.elonen.NanoHTTPD$ServerRunnable" name="this$0" map="A"/>
  <field class="fi.iki.elonen.NanoHTTPD$ServerRunnable" name="bindException" map="B"/>
  <field class="fi.iki.elonen.NanoHTTPD$ServerRunnable" name="timeout" map="C"/>
  <field class="fi.iki.elonen.NanoHTTPD$ServerRunnable" name="hasBinded" map="D"/>
  <method class="fi.iki.elonen.NanoHTTPD$ServerRunnable" name="boolean access$1200(fi.iki.elonen.NanoHTTPD$ServerRunnable)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$ServerRunnable" name="java.io.IOException access$1300(fi.iki.elonen.NanoHTTPD$ServerRunnable)" map="B"/>
  <method class="fi.iki.elonen.NanoHTTPD$ServerRunnable" name="void run()" map="run"/>
  <class name="fi.iki.elonen.NanoHTTPD$AsyncRunner" map="_K"/>
  <method class="fi.iki.elonen.NanoHTTPD$AsyncRunner" name="void exec(fi.iki.elonen.NanoHTTPD$ClientHandler)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$AsyncRunner" name="void closeAll()" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$AsyncRunner" name="void closed(fi.iki.elonen.NanoHTTPD$ClientHandler)" map="B"/>
  <class name="fi.iki.elonen.NanoHTTPD$HTTPSession" map="_L"/>
  <field class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="method" map="A"/>
  <field class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="inputStream" map="B"/>
  <field class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="headers" map="C"/>
  <field class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="uri" map="D"/>
  <field class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="protocolVersion" map="E"/>
  <field class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="splitbyte" map="F"/>
  <field class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="remoteIp" map="G"/>
  <field class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="queryParameterString" map="H"/>
  <field class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="this$0" map="I"/>
  <field class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="outputStream" map="J"/>
  <field class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="rlen" map="K"/>
  <field class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="parms" map="L"/>
  <field class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="cookies" map="M"/>
  <field class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="tempFileManager" map="N"/>
  <method class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="void decodeMultipartFormData(java.lang.String, java.nio.ByteBuffer, java.util.Map, java.util.Map)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="void decodeHeader(java.io.BufferedReader, java.util.Map, java.util.Map, java.util.Map)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="java.util.Map getParms()" map="C"/>
  <method class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="java.lang.String saveTmpFile(java.nio.ByteBuffer, int, int)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="void execute()" map="D"/>
  <method class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="int[] getBoundaryPositions(java.nio.ByteBuffer, byte[])" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="java.io.RandomAccessFile getTmpBucket()" map="E"/>
  <method class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="int findHeaderEnd(byte[], int)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="void decodeParms(java.lang.String, java.util.Map)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="fi.iki.elonen.NanoHTTPD$Method getMethod()" map="B"/>
  <method class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="void parseBody(java.util.Map)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$HTTPSession" name="java.lang.String getUri()" map="A"/>
  <class name="fi.iki.elonen.NanoHTTPD$ResponseException" map="_M"/>
  <field class="fi.iki.elonen.NanoHTTPD$ResponseException" name="status" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$ResponseException" name="fi.iki.elonen.NanoHTTPD$Response$Status getStatus()" map="A"/>
  <class name="fi.iki.elonen.NanoHTTPD$DefaultTempFileManagerFactory" map="_N"/>
  <field class="fi.iki.elonen.NanoHTTPD$DefaultTempFileManagerFactory" name="this$0" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$DefaultTempFileManagerFactory" name="fi.iki.elonen.NanoHTTPD$TempFileManager create()" map="A"/>
  <class name="fi.iki.elonen.NanoHTTPD$CookieHandler" map="_O"/>
  <field class="fi.iki.elonen.NanoHTTPD$CookieHandler" name="this$0" map="A"/>
  <field class="fi.iki.elonen.NanoHTTPD$CookieHandler" name="queue" map="B"/>
  <field class="fi.iki.elonen.NanoHTTPD$CookieHandler" name="cookies" map="C"/>
  <method class="fi.iki.elonen.NanoHTTPD$CookieHandler" name="java.util.Iterator iterator()" map="iterator"/>
  <method class="fi.iki.elonen.NanoHTTPD$CookieHandler" name="void unloadQueue(fi.iki.elonen.NanoHTTPD$Response)" map="A"/>
  <class name="fi.iki.elonen.NanoHTTPD$DefaultTempFile" map="_P"/>
  <field class="fi.iki.elonen.NanoHTTPD$DefaultTempFile" name="fstream" map="A"/>
  <field class="fi.iki.elonen.NanoHTTPD$DefaultTempFile" name="file" map="B"/>
  <method class="fi.iki.elonen.NanoHTTPD$DefaultTempFile" name="java.lang.String getName()" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD$DefaultTempFile" name="void delete()" map="B"/>
  <class name="fi.iki.elonen.NanoHTTPD$ClientHandler" map="_Q"/>
  <field class="fi.iki.elonen.NanoHTTPD$ClientHandler" name="this$0" map="A"/>
  <field class="fi.iki.elonen.NanoHTTPD$ClientHandler" name="acceptSocket" map="B"/>
  <field class="fi.iki.elonen.NanoHTTPD$ClientHandler" name="inputStream" map="C"/>
  <method class="fi.iki.elonen.NanoHTTPD$ClientHandler" name="void run()" map="run"/>
  <method class="fi.iki.elonen.NanoHTTPD$ClientHandler" name="void close()" map="A"/>
  <class name="fi.iki.elonen.NanoHTTPD$1" map="1"/>
  <class name="fi.iki.elonen.NanoHTTPD" map="A"/>
  <field class="fi.iki.elonen.NanoHTTPD" name="CONTENT_DISPOSITION_PATTERN" map="A"/>
  <field class="fi.iki.elonen.NanoHTTPD" name="asyncRunner" map="B"/>
  <field class="fi.iki.elonen.NanoHTTPD" name="CONTENT_DISPOSITION_ATTRIBUTE_PATTERN" map="C"/>
  <field class="fi.iki.elonen.NanoHTTPD" name="myPort" map="D"/>
  <field class="fi.iki.elonen.NanoHTTPD" name="CONTENT_TYPE_PATTERN" map="E"/>
  <field class="fi.iki.elonen.NanoHTTPD" name="sslServerSocketFactory" map="F"/>
  <field class="fi.iki.elonen.NanoHTTPD" name="tempFileManagerFactory" map="G"/>
  <field class="fi.iki.elonen.NanoHTTPD" name="hostname" map="H"/>
  <field class="fi.iki.elonen.NanoHTTPD" name="myServerSocket" map="I"/>
  <field class="fi.iki.elonen.NanoHTTPD" name="myThread" map="J"/>
  <field class="fi.iki.elonen.NanoHTTPD" name="LOG" map="K"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="fi.iki.elonen.NanoHTTPD$ClientHandler createClientHandler(java.net.Socket, java.io.InputStream)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="java.util.regex.Pattern access$400()" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="fi.iki.elonen.NanoHTTPD$Response newFixedLengthResponse(fi.iki.elonen.NanoHTTPD$Response$IStatus, java.lang.String, java.lang.String)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="fi.iki.elonen.NanoHTTPD$ServerRunnable createServerRunnable(int)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="void stop()" map="B"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="java.util.logging.Logger access$200()" map="C"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="int access$700(fi.iki.elonen.NanoHTTPD)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="void setAsyncRunner(fi.iki.elonen.NanoHTTPD$AsyncRunner)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="java.net.ServerSocket access$800(fi.iki.elonen.NanoHTTPD)" map="B"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="java.util.regex.Pattern access$500()" map="D"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="void start(int)" map="B"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="void access$000(java.lang.Object)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="fi.iki.elonen.NanoHTTPD$Response newFixedLengthResponse(fi.iki.elonen.NanoHTTPD$Response$IStatus, java.lang.String, java.io.InputStream, long)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="java.lang.String decodePercent(java.lang.String)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="void safeClose(java.lang.Object)" map="B"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="void setTempFileManagerFactory(fi.iki.elonen.NanoHTTPD$TempFileManagerFactory)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="fi.iki.elonen.NanoHTTPD$TempFileManagerFactory access$100(fi.iki.elonen.NanoHTTPD)" map="C"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="fi.iki.elonen.NanoHTTPD$Response serve(fi.iki.elonen.NanoHTTPD$IHTTPSession)" map="A"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="void start()" map="E"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="java.lang.String access$600(fi.iki.elonen.NanoHTTPD)" map="D"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="java.util.regex.Pattern access$300()" map="F"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="fi.iki.elonen.NanoHTTPD$Response newFixedLengthResponse(java.lang.String)" map="B"/>
  <method class="fi.iki.elonen.NanoHTTPD" name="boolean useGzipWhenAccepted(fi.iki.elonen.NanoHTTPD$Response)" map="A"/>
</map>
</yguard>
