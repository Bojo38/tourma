/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package bb.tourma;

import bb.tourma.data.Category;
import bb.tourma.data.Clan;
import bb.tourma.data.Coach;
import bb.tourma.data.CoachMatch;
import bb.tourma.data.Criterion;
import bb.tourma.data.Formula;
import bb.tourma.data.Group;
import bb.tourma.data.GroupPoints;
import bb.tourma.data.Match;
import bb.tourma.data.Pool;
import bb.tourma.data.Rankings;
import bb.tourma.data.RosterType;
import bb.tourma.data.Round;
import bb.tourma.data.Team;
import bb.tourma.data.TeamMatch;
import bb.tourma.data.Tournament;
import bb.tourma.data.ranking.AnnexClanRanking;
import bb.tourma.data.ranking.AnnexIndivRanking;
import bb.tourma.data.ranking.AnnexRanking;
import bb.tourma.data.ranking.AnnexTeamRanking;
import bb.tourma.data.ranking.ClanRanking;
import bb.tourma.data.ranking.IndivRanking;
import bb.tourma.data.ranking.IndivRankingsSet;
import bb.tourma.data.ranking.Ranking;
import bb.tourma.data.ranking.TeamRanking;
import bb.tourma.data.ranking.TeamRankingsSet;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.ProtocolException;
import java.net.URL;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.time.LocalDateTime;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import javax.swing.JOptionPane;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.net.HttpURLConnection;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import org.json.JSONArray;
import org.json.JSONObject;
import org.json.JSONWriter;

enum SubRankingType {
    NONE,
    ForPOOL,
    ForCUP
};

/**
 *
 * @author WFMJ7631
 */
public class JdgSynchronizeWithServer extends javax.swing.JDialog {

    Tournament mTournament;

    /**
     * Creates new form JdgSynchronizeWithServer
     */
    public JdgSynchronizeWithServer(java.awt.Frame parent, boolean modal, final Tournament tour) {
        super(parent, modal);
        initComponents();

        mTournament = tour;

        this.update();
    }

    private void update() {
        this.JpfPassword.setText(mTournament.getPassword());
        this.jtfLogin.setText(mTournament.getLogin());
        this.jtfUrl.setText(mTournament.getURL());
        this.jtfTournamentId.setText(Long.toString(mTournament.getTournament_id()));

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        bgAutoUpdate = new javax.swing.ButtonGroup();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jtfTournamentId = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jtfLogin = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        JpfPassword = new javax.swing.JPasswordField();
        jLabel4 = new javax.swing.JLabel();
        jtfUrl = new javax.swing.JTextField();
        jPanel3 = new javax.swing.JPanel();
        jPanel4 = new javax.swing.JPanel();
        jbtSync = new javax.swing.JButton();
        jPanel5 = new javax.swing.JPanel();
        jrbPeriodicUpdate = new javax.swing.JRadioButton();
        jrbEventUpdate = new javax.swing.JRadioButton();
        jPanel6 = new javax.swing.JPanel();
        jcxAutomatic = new javax.swing.JCheckBox();
        jPanel2 = new javax.swing.JPanel();
        jbtOK = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        jPanel1.setLayout(new java.awt.GridLayout(5, 2));

        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("bb/tourma/languages/language"); // NOI18N
        jLabel1.setText(bundle.getString("TournamentID")); // NOI18N
        jPanel1.add(jLabel1);

        jtfTournamentId.setText("1234");
        jtfTournamentId.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jtfTournamentIdActionPerformed(evt);
            }
        });
        jPanel1.add(jtfTournamentId);

        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        jLabel2.setText(bundle.getString("login")); // NOI18N
        jPanel1.add(jLabel2);

        jtfLogin.setText("lord_bojo");
        jtfLogin.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jtfLoginActionPerformed(evt);
            }
        });
        jPanel1.add(jtfLogin);

        jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        jLabel3.setText(bundle.getString("password")); // NOI18N
        jPanel1.add(jLabel3);

        JpfPassword.setText("7539");
        JpfPassword.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                JpfPasswordActionPerformed(evt);
            }
        });
        jPanel1.add(JpfPassword);

        jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        jLabel4.setText(bundle.getString("URL")); // NOI18N
        jPanel1.add(jLabel4);

        jtfUrl.setText("http://192.168.1.100:443");
        jtfUrl.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jtfUrlActionPerformed(evt);
            }
        });
        jPanel1.add(jtfUrl);

        getContentPane().add(jPanel1, java.awt.BorderLayout.PAGE_START);

        jPanel3.setLayout(new java.awt.BorderLayout());

        jPanel4.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jbtSync.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bb/tourma/images/reload.png"))); // NOI18N
        jbtSync.setText(bundle.getString("Synchronize")); // NOI18N
        jbtSync.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbtSyncActionPerformed(evt);
            }
        });
        jPanel4.add(jbtSync);

        jPanel3.add(jPanel4, java.awt.BorderLayout.SOUTH);

        jPanel5.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle.getString("Update Types"))); // NOI18N
        jPanel5.setEnabled(false);
        jPanel5.setLayout(new java.awt.GridLayout(1, 2));

        jrbPeriodicUpdate.setText(bundle.getString("Periodic Update")); // NOI18N
        jrbPeriodicUpdate.setToolTipText("Update every 5 minutes");
        jrbPeriodicUpdate.setEnabled(false);
        jPanel5.add(jrbPeriodicUpdate);

        jrbEventUpdate.setText(bundle.getString("EventUpdate")); // NOI18N
        jrbEventUpdate.setToolTipText("Update from PC after each local modification (enter match, change setting, generate round) and read from internet every minute.");
        jrbEventUpdate.setEnabled(false);
        jPanel5.add(jrbEventUpdate);

        jPanel3.add(jPanel5, java.awt.BorderLayout.CENTER);

        jcxAutomatic.setText(bundle.getString("AutomaticRefresh")); // NOI18N
        jcxAutomatic.setEnabled(false);
        jPanel6.add(jcxAutomatic);

        jPanel3.add(jPanel6, java.awt.BorderLayout.NORTH);

        getContentPane().add(jPanel3, java.awt.BorderLayout.CENTER);

        jbtOK.setText("OK");
        jbtOK.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbtOKActionPerformed(evt);
            }
        });
        jPanel2.add(jbtOK);

        getContentPane().add(jPanel2, java.awt.BorderLayout.SOUTH);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jbtOKActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbtOKActionPerformed
        this.setVisible(false);
    }//GEN-LAST:event_jbtOKActionPerformed

    private SSLContext getSSLContext() {
        TrustManager[] trustAllCerts = new TrustManager[]{
            new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                    return null;
                }

                @Override
                public void checkClientTrusted(X509Certificate[] arg0, String arg1)
                        throws CertificateException {
                }

                @Override
                public void checkServerTrusted(X509Certificate[] arg0, String arg1)
                        throws CertificateException {
                }
            }
        };

        SSLContext sslContext = null;
        try {
            sslContext = SSLContext.getInstance("SSL");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        try {
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
        } catch (KeyManagementException e) {
            e.printStackTrace();
        }
        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());

        // Create all-trusting host name verifier
        HostnameVerifier validHosts = new HostnameVerifier() {
            @Override
            public boolean verify(String arg0, SSLSession arg1) {
                return true;
            }
        };
        // All hosts will be valid
        HttpsURLConnection.setDefaultHostnameVerifier(validHosts);

        return sslContext;
    }

    public static void allowMethods(String... methods) {
        try {
            Field methodsField = HttpURLConnection.class.getDeclaredField("methods");

            Field modifiersField = Field.class.getDeclaredField("modifiers");
            modifiersField.setAccessible(true);
            modifiersField.setInt(methodsField, methodsField.getModifiers() & ~Modifier.FINAL);

            methodsField.setAccessible(true);

            String[] oldMethods = (String[]) methodsField.get(null);
            Set<String> methodsSet = new LinkedHashSet<>(Arrays.asList(oldMethods));
            methodsSet.addAll(Arrays.asList(methods));
            String[] newMethods = methodsSet.toArray(new String[0]);

            methodsField.set(null/*static field*/, newMethods);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new IllegalStateException(e);
        }
    }

    String methodGET(String url) throws IOException {
        String inline = "";

        SSLContext sslContext = getSSLContext();
        HttpsURLConnection connection = (HttpsURLConnection) new URL(url).openConnection();
        connection.setSSLSocketFactory(sslContext.getSocketFactory());

        System.out.println(url);
        
        connection.setRequestMethod("GET");
        connection.connect();
        //Getting the response code
        int responsecode = connection.getResponseCode();
        if (responsecode != 200) {
            JOptionPane.showMessageDialog(this, "HTTP error: " + responsecode, "Io Error", JOptionPane.ERROR_MESSAGE);
        } else {
            System.out.println("Response to request: " + url);
            Scanner sc = new Scanner(connection.getInputStream());

            while (sc.hasNext()) {
                inline += sc.nextLine();
            }
            System.out.println(inline);
            sc.close();
        }
        return inline;
    }

    public int methodPOST(String url, JSONObject object) throws IOException {
        int result = 0;

        SSLContext sslContext = getSSLContext();
        HttpsURLConnection connection = (HttpsURLConnection) new URL(url).openConnection();
        connection.setSSLSocketFactory(sslContext.getSocketFactory());

        connection.setRequestMethod("POST");
        connection.setRequestProperty("Content-Type", "application/json; utf-8");
        connection.setRequestProperty("Accept", "application/json");

        connection.setDoOutput(true);

        try (OutputStream os = connection.getOutputStream()) {
            String written = JSONWriter.valueToString(object);
            byte[] input = written.getBytes("utf-8");
            System.out.println(written);
            os.write(input, 0, input.length);
        }

        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
            System.out.println("Response to Patch: " + url);
            try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    System.out.println(line);
                }
            }
        } else {
            System.out.println(connection.getResponseCode());
        }

        connection.connect();
        return result;
    }

    public int methodPATCH(String url, JSONObject object) throws IOException {
        int result = 0;

        System.out.println("PATCH: "+url);
        
        SSLContext sslContext = getSSLContext();
        HttpsURLConnection connection = (HttpsURLConnection) new URL(url).openConnection();
        connection.setSSLSocketFactory(sslContext.getSocketFactory());

        //connection.setRequestProperty("X-HTTP-Method-Override", "PATCH");
        connection.setRequestMethod("PATCH");
        connection.setRequestProperty("Content-Type", "application/json; utf-8");
        connection.setRequestProperty("Accept", "application/json");

        connection.setDoOutput(true);

        try (OutputStream os = connection.getOutputStream()) {
            String written = JSONWriter.valueToString(object);
            byte[] input = written.getBytes("utf-8");
            System.out.println(written);
            os.write(input, 0, input.length);
        }

        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
            System.out.println("Response to Patch: " + url);
            try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    System.out.println(line);
                }
            }
        } else {
            System.out.println(connection.getResponseCode());
        }

        connection.connect();
        return result;
    }

    private boolean synchronizeGroupOpposingPoints(String url, long tourId, int gid, int oid) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/groups/" + gid + "/" + oid);

        boolean error = false;

        Group group = mTournament.getGroup(gid);
        Group opp = mTournament.getGroup(oid);
        GroupPoints gp = group.getOpponentModificationPoints(opp);

        if( gp==null)
        {
            gp=new GroupPoints();
            group.setOpponentModificationPoints(opp, gp);
        }
        
        // Download Params
        JSONObject obj = new JSONObject(lineGet);
        boolean toUpload = false;
        boolean toDownload = false;
        Object lastUpdatedDate = obj.get("updateDateTime");
        if (lastUpdatedDate == JSONObject.NULL) {
            toUpload = true;
        } else {
            LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
            if (dt.isAfter(gp.getUpdateDateTime())) {
                toDownload = true;
            }
            if (dt.isBefore(gp.getUpdateDateTime())) {
                toUpload = true;
            }
        }

        // If needed update Params
        // Check date 
        if (toUpload) {
            JSONObject obj2 = gp.getJSON();
            int result = methodPATCH(url + "/tournaments/" + tourId + "/groups/" + gid + "/" + oid, obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing parameters: " + result);
                error = true;
            }

        } else {
            if (toDownload) {
                gp.updateFromJSON(obj);
            }

        }

        return error;
    }

    private boolean synchronizeParams(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/params");

        boolean error = false;

        // Download Params
        JSONObject obj = new JSONObject(lineGet);
        boolean toUpload = false;
        boolean toDownload = false;
        Object lastUpdatedDate = obj.get("updateDateTime");
        if (lastUpdatedDate == JSONObject.NULL) {
            toUpload = true;
        } else {
            LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
            if (dt.isAfter(mTournament.getParams().getUpdateDateTime())) {
                toDownload = true;
            }
            if (dt.isBefore(mTournament.getParams().getUpdateDateTime())) {
                toUpload = true;
            }
        }

        // If needed update Params
        // Check date 
        if (toUpload) {
            JSONObject obj2 = mTournament.getParams().getJSON();
            int result = methodPATCH(url + "/tournaments/" + tourId + "/params", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing parameters: " + result);
                error = true;
            }

        } else {
            if (toDownload) {
                mTournament.getParams().updateFromJSON(obj);
            }

        }

        if (!error) {
            error = synchronizeCriteria(url, tourId);
            if (!error) {
                error = synchronizeFormula(url, tourId);
            }
        }

        return error;
    }

    private boolean synchronizeRosters(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/rosters");

        boolean error = false;

        // Download Array of rosters
        JSONArray array = new JSONArray(lineGet);

        List<RosterType> rts = new ArrayList<>();

        
        for ( RosterType entry : mTournament.getRosterType()) {
            rts.add(entry);
        }

        for (int i = 0; i < array.length(); i++) {
            
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");

            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getRosterType().size() > i) {
                    if (dt.isAfter(rts.get(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                    if (dt.isBefore(rts.get(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                } else {
                    RosterType rt=new RosterType("new");
                    mTournament.getRosterType().add(rt);
                    rts.add(rt);
                    toDownload = true;
                }
            }

            if (toUpload) {
                JSONObject obj2 = rts.get(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/rosters/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing rosters: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                rts.get(i).updateFromJSON(obj);
            }
        }

        int diff = mTournament.getRosterType().size() - array.length();
        for (int i = 0; i < diff; i++) {
            JSONObject obj2 = rts.get(array.length() + i).getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/rosters", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing rosters: " + result);
                error = true;
            }
        }

        return error;
    }

    private boolean synchronizeCategories(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/categories");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getCategoriesCount() > i) {
                    if (dt.isAfter(mTournament.getCategory(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                    if (dt.isBefore(mTournament.getCategory(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                } else {
                    mTournament.addCategory(new Category(obj.getString("name")));
                    toDownload = true;
                }
            }

            if (toUpload) {

                JSONObject obj2 = mTournament.getCategory(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/categories/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing categories: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                mTournament.getCategory(i).updateFromJSON(obj);
            }
        }

        int diff = mTournament.getCategoriesCount() - array.length();
        for (int i = 0; i < diff; i++) {
            JSONObject obj2 = mTournament.getCategory(array.length() + i).getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/categories", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                error = true;
            }

        }

        return error;
    }

    private boolean synchronizeMatchs(String url, long tourId, int roundId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/rounds/" + roundId + "/matchs");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);
        Round round = mTournament.getRound(roundId);

        for (int i = 0; i < array.length(); i++) {
            JSONObject object = array.getJSONObject(i);
            String matchType = object.getString("matchType");

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = object.get("updateDateTime");
            Match m = null;
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (round.getMatchsCount() > i) {
                    m = mTournament.getRound(roundId).getMatch(i);
                    if (dt.isAfter(m.getUpdateDateTime())) {
                        toDownload = true;
                    }
                    if (dt.isBefore(m.getUpdateDateTime())) {
                        toUpload = true;
                    }
                } else {
                    if (matchType.equals("TeamMatch")) {
                        m = new TeamMatch(round);

                    } else {
                        m = new CoachMatch(round);
                    }
                    round.addMatch(m);
                    toDownload = true;
                }
            }

            if ((m != null) && (!error)) {
                if (toUpload) {
                    JSONObject obj2 = m.getJSON();
                    int result = methodPATCH(url + "/tournaments/" + tourId + "/rounds/" + roundId + "/matchs/" + i, obj2);
                    if (result != 0) {
                        JOptionPane.showMessageDialog(this, "Error detected while synchronizing match " + i + " of round " + roundId + ": " + result);
                        error = true;
                    }
                }
                if (toDownload) {
                    m.updateFromJSON(object);
                }
            }
        }

        return error;
    }

    private boolean synchronizeRanking(String url, Ranking ranking) throws IOException {

        System.out.println(url);

        String lineGet = methodGET(url);

        boolean error = false;
        JSONObject object = new JSONObject(lineGet);

        boolean toUpload = false;
        boolean toDownload = false;
        Object lastUpdatedDate = object.get("updateDateTime");
        if (lastUpdatedDate == JSONObject.NULL) {
            toUpload = true;
        } else {
            LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);

            if (dt.isAfter(ranking.getUpdateDateTime())) {
                toDownload = true;
            }
            if (dt.isBefore(ranking.getUpdateDateTime())) {
                toUpload = true;
            }
        }

        if (toUpload) {
            JSONObject obj2 = ranking.getJSON();
            int result = methodPATCH(url, obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing  ranking (" + url + "): " + result);
                error = true;
            }
        }

        if (toDownload) {
            ranking.updateFromJSON(object);
        }

        return error;
    }

    private boolean synchronizeTeamAnnexRanking(String url, long tourId, int roundId, Criterion crit, Formula form, AnnexRanking.SubType subranking, TeamRankingsSet rankingSet) throws IOException {

        String urlEnd = "";
        AnnexTeamRanking ranking = null;

        switch (subranking) {
            case POSITIVE:
                urlEnd = "/rankings/team/annex/" + crit.getName().replace(" ", "") + "/+";
                ranking = rankingSet.getAnnexPosRanking().get(crit);
                break;
            case NEGATIVE:
                urlEnd = "/rankings/team/annex/" + crit.getName().replace(" ", "") + "/-";
                ranking = rankingSet.getAnnexNegRanking().get(crit);
                break;
            case DIFFERENCE:
                urlEnd = "/rankings/team/annex/" + crit.getName().replace(" ", "") + "/=";
                ranking = rankingSet.getAnnexDifRanking().get(crit);
                break;
            case FORMULA:
                urlEnd = "/rankings/team/annex/" + form.getName().replace(" ", "");
                ranking = rankingSet.getAnnexFormRanking().get(form);
                break;
            default:
                return true;
        }

        boolean error = synchronizeRanking(url + "/tournaments/" + tourId + "/rounds/" + roundId + urlEnd, ranking);
        return error;
    }

    private boolean synchronizeClanAnnexRanking(String url, long tourId, int roundId, Criterion crit, Formula form, AnnexRanking.SubType subranking) throws IOException {

        String urlEnd = "";
        AnnexClanRanking ranking = null;
        if (mTournament.getRound(roundId).getRankings(false).getClanRankingSet() != null) {
            switch (subranking) {
                case POSITIVE:
                    urlEnd = "/rankings/clan/annex/" + crit.getName() + "/+";
                    ranking = mTournament.getRound(roundId).getRankings(false).getClanRankingSet().getAnnexPosRanking().get(crit);
                    break;
                case NEGATIVE:
                    urlEnd = "/rankings/clan/annex/" + crit.getName() + "/-";
                    ranking = mTournament.getRound(roundId).getRankings(false).getClanRankingSet().getAnnexNegRanking().get(crit);
                    break;
                case DIFFERENCE:
                    urlEnd = "/rankings/clan/annex/" + crit.getName() + "/=";
                    ranking = mTournament.getRound(roundId).getRankings(false).getClanRankingSet().getAnnexDifRanking().get(crit);
                    break;
                case FORMULA:
                    urlEnd = "/rankings/clan/annex/" + form.getName();
                    ranking = mTournament.getRound(roundId).getRankings(false).getClanRankingSet().getAnnexFormRanking().get(form);
                    break;
                default:
                    return true;
            }

            boolean error = synchronizeRanking(url + "/tournaments/" + tourId + "/rounds/" + roundId + urlEnd, ranking);
            return error;
        } else {
            return false;
        }
    }

    private boolean synchronizeIndivdualAnnexRanking(String url, long tourId, int roundId, Criterion crit, Formula form, AnnexRanking.SubType subranking, IndivRankingsSet rankingSet) throws IOException {

        String urlEnd = "";
        AnnexIndivRanking ranking = null;

        switch (subranking) {
            case POSITIVE:
                urlEnd = "/rankings/indiv/annex/" + crit.getName().replace(" ", "") + "/+";
                ranking = rankingSet.getAnnexPosRanking().get(crit);
                break;
            case NEGATIVE:
                urlEnd = "/rankings/indiv/annex/" + crit.getName().replace(" ", "") + "/-";
                ranking = rankingSet.getAnnexNegRanking().get(crit);
                break;
            case DIFFERENCE:
                urlEnd = "/rankings/indiv/annex/" + crit.getName().replace(" ", "") + "/=";
                ranking = rankingSet.getAnnexDifRanking().get(crit);
                break;
            case FORMULA:
                urlEnd = "/rankings/indiv/annex/" + form.getName().replace(" ", "");
                ranking = rankingSet.getAnnexFormRanking().get(form);
                break;
            default:
                return true;
        }

        boolean error = synchronizeRanking(url + "/tournaments/" + tourId + "/rounds/" + roundId + urlEnd, ranking);
        return error;
    }

    private boolean synchronizeIndivdualRanking(String url, long tourId, int roundId, int poolId, SubRankingType subranking, IndivRankingsSet rankingSet) throws IOException {

        String urlEnd = "";
        IndivRanking ranking = null;

        if (poolId == -1) {
            switch (subranking) {
                case NONE:
                    urlEnd = "/rankings/indiv/ranking";
                    ranking = rankingSet.getRanking();
                    break;
                case ForPOOL:
                    urlEnd = "/rankings/indiv/pool";
                    ranking = rankingSet.getRankingForPool();
                    break;
                case ForCUP:
                    urlEnd = "/rankings/indiv/cup";
                    ranking = rankingSet.getRankingForCup();
                    break;
                default:
                    return true;
            }
        } else {
            urlEnd = "/rankings/pool/indiv/" + poolId;
            ranking = rankingSet.getRanking();
        }

        boolean error = synchronizeRanking(url + "/tournaments/" + tourId + "/rounds/" + roundId + urlEnd, ranking);

        return error;
    }

    private boolean synchronizeTeamRanking(String url, long tourId, int roundId, int poolId, SubRankingType subranking, TeamRankingsSet rankingSet) throws IOException {

        String urlEnd = "";
        TeamRanking ranking = null;

        if (poolId == -1) {
            switch (subranking) {
                case NONE:
                    urlEnd = "/rankings/team/ranking";
                    ranking = rankingSet.getRanking();
                    break;
                case ForPOOL:
                    urlEnd = "/rankings/team/pool";
                    ranking = rankingSet.getRankingForPool();
                    break;
                case ForCUP:
                    urlEnd = "/rankings/team/cup";
                    ranking = rankingSet.getRankingForCup();
                    break;
                default:
                    return true;
            }
        } else {
            urlEnd = "/rankings/pool/team/" + poolId;
            ranking = rankingSet.getRanking();
        }

        boolean error = synchronizeRanking(url + "/tournaments/" + tourId + "/rounds/" + roundId + urlEnd, ranking);

        return error;
    }

    private boolean synchronizeClanRanking(String url, long tourId, int roundId, SubRankingType subranking) throws IOException {

        String urlEnd = "";
        ClanRanking ranking = null;

        switch (subranking) {
            case NONE:
                urlEnd = "/rankings/clan/ranking";
                if (mTournament.getRound(roundId).getRankings(false).getClanRankingSet() != null) {
                    ranking = mTournament.getRound(roundId).getRankings(false).getClanRankingSet().getRanking();
                }
                break;
            case ForPOOL:
                //urlEnd = "/rankings/team/pool";
                //ranking = mTournament.getRound(roundId).getRankings(false).getTeamRankingSet().getRankingForPool();
                break;
            case ForCUP:
                //urlEnd = "/rankings/team/cup";
                // ranking = mTournament.getRound(roundId).getRankings(false).getTeamRankingSet().getRankingForCup();
                break;
            default:
                return true;
        }

        boolean error = false;
        if (ranking != null) {
            error = synchronizeRanking(url + "/tournaments/" + tourId + "/rounds/" + roundId + urlEnd, ranking);
        }

        return error;
    }

    private boolean synchronizeIndivdualRankingSet(String url, long tourId, int roundId, int poolId, IndivRankingsSet rankingSet) throws IOException {

        boolean error = synchronizeIndivdualRanking(url, tourId, roundId, poolId, SubRankingType.NONE, rankingSet);

        if (mTournament.getPoolCount() > 0) {
            if (!error) {
                error = synchronizeIndivdualRanking(url, tourId, roundId, poolId, SubRankingType.ForPOOL, rankingSet);
            }
        }

        if (mTournament.getCup() != null) {
            if (!error) {
                error = synchronizeIndivdualRanking(url, tourId, roundId, poolId, SubRankingType.ForCUP, rankingSet);
            }

        }

        for (int i = 0; i < mTournament.getParams().getCriteriaCount(); i++) {
            Criterion crit = mTournament.getParams().getCriterion(i);
            if (!error) {
                error = synchronizeIndivdualAnnexRanking(url, tourId, roundId, crit, null, AnnexRanking.SubType.POSITIVE, rankingSet);
            }
            if (!error) {
                error = synchronizeIndivdualAnnexRanking(url, tourId, roundId, crit, null, AnnexRanking.SubType.NEGATIVE, rankingSet);
            }
            if (!error) {
                error = synchronizeIndivdualAnnexRanking(url, tourId, roundId, crit, null, AnnexRanking.SubType.DIFFERENCE, rankingSet);
            }
        }

        for (int i = 0; i < mTournament.getParams().getFormulaCount(); i++) {
            Formula form = mTournament.getParams().getFormula(i);
            if (!error) {
                error = synchronizeIndivdualAnnexRanking(url, tourId, roundId, null, form, AnnexRanking.SubType.FORMULA, rankingSet);
            }
        }
        return error;
    }

    private boolean synchronizeClanRankingSet(String url, long tourId, int roundId) throws IOException {

        boolean error = synchronizeClanRanking(url, tourId, roundId, SubRankingType.NONE);

        for (int i = 0; i < mTournament.getParams().getCriteriaCount(); i++) {
            Criterion crit = mTournament.getParams().getCriterion(i);
            if (!error) {
                error = synchronizeClanAnnexRanking(url, tourId, roundId, crit, null, AnnexRanking.SubType.POSITIVE);
            }
            if (!error) {
                error = synchronizeClanAnnexRanking(url, tourId, roundId, crit, null, AnnexRanking.SubType.NEGATIVE);
            }
            if (!error) {
                error = synchronizeClanAnnexRanking(url, tourId, roundId, crit, null, AnnexRanking.SubType.DIFFERENCE);
            }
        }

        for (int i = 0; i < mTournament.getParams().getFormulaCount(); i++) {
            Formula form = mTournament.getParams().getFormula(i);
            if (!error) {
                error = synchronizeClanAnnexRanking(url, tourId, roundId, null, form, AnnexRanking.SubType.FORMULA);
            }
        }
        return error;
    }

    private boolean synchronizeTeamRankingSet(String url, long tourId, int roundId, int poolId, TeamRankingsSet rankingSet) throws IOException {

        boolean error = synchronizeTeamRanking(url, tourId, roundId, poolId, SubRankingType.NONE, rankingSet);

        if (mTournament.getPoolCount() > 0) {
            if (!error) {
                error = synchronizeTeamRanking(url, tourId, roundId, poolId, SubRankingType.ForPOOL, rankingSet);
            }
        }

        if (mTournament.getCup() != null) {
            if (!error) {
                error = synchronizeTeamRanking(url, tourId, roundId, poolId, SubRankingType.ForCUP, rankingSet);
            }

        }

        for (int i = 0; i < mTournament.getParams().getCriteriaCount(); i++) {
            Criterion crit = mTournament.getParams().getCriterion(i);
            if (!error) {
                error = synchronizeTeamAnnexRanking(url, tourId, roundId, crit, null, AnnexRanking.SubType.POSITIVE, rankingSet);
            }
            if (!error) {
                error = synchronizeTeamAnnexRanking(url, tourId, roundId, crit, null, AnnexRanking.SubType.NEGATIVE, rankingSet);
            }
            if (!error) {
                error = synchronizeTeamAnnexRanking(url, tourId, roundId, crit, null, AnnexRanking.SubType.DIFFERENCE, rankingSet);
            }
        }

        for (int i = 0; i < mTournament.getParams().getFormulaCount(); i++) {
            Formula form = mTournament.getParams().getFormula(i);
            if (!error) {
                error = synchronizeTeamAnnexRanking(url, tourId, roundId, null, form, AnnexRanking.SubType.FORMULA, rankingSet);
            }
        }
        return error;

    }

    private boolean synchronizeCategoryRankings(String url, long tourId, int roundId) throws IOException {
        boolean error = false;

        for (int i = 0; i < mTournament.getCategoriesCount(); i++) {
            Category cat = mTournament.getCategory(i);

            if (mTournament.getRound(roundId).getRankings(false).getCategoryIndivRanking() != null) {
                IndivRanking ranking = mTournament.getRound(roundId).getRankings(false).getCategoryIndivRanking().get(cat);
                String complete_url = url + "/tournaments/" + tourId + "/rounds/" + roundId + "/rankings/category/indiv/" + cat.getName();

                if (!error) {
                    error = synchronizeRanking(complete_url, ranking);
                }
            }

        }

        for (int i = 0; i < mTournament.getCategoriesCount(); i++) {
            Category cat = mTournament.getCategory(i);
            if (mTournament.getRound(roundId).getRankings(false).getCategoryTeamRanking() != null) {
                TeamRanking ranking = mTournament.getRound(roundId).getRankings(false).getCategoryTeamRanking().get(cat);
                String complete_url = url + "/tournaments/" + tourId + "/rounds/" + roundId + "/rankings/category/team/" + cat.getName();

                if (!error) {
                    error = synchronizeRanking(complete_url, ranking);
                }
            }

        }
        return error;
    }

    private boolean synchronizeGroupRankings(String url, long tourId, int roundId) throws IOException {
        boolean error = false;

        for (int i = 0; i < mTournament.getGroupsCount(); i++) {
            Group g = mTournament.getGroup(i);

            if (mTournament.getRound(roundId).getRankings(false).getGroupRanking() != null) {
                IndivRanking ranking = mTournament.getRound(roundId).getRankings(false).getGroupRanking().get(g);

                String complete_url = url + "/tournaments/" + tourId + "/rounds/" + roundId + "/rankings/groups/" + i;

                if (!error) {
                    error = synchronizeRanking(complete_url, ranking);
                }
            }
        }
        return error;
    }

    private boolean synchronizePoolRankings(String url, long tourId, int roundId) throws IOException {

        boolean error = false;

        for (int i = 0; i < mTournament.getPoolCount(); i++) {
            Pool p = mTournament.getPool(i);

            IndivRankingsSet ranking_set = mTournament.getRound(roundId).getRankings(false).getPoolIndivRankings().get(p);

            if (!error) {
                error = synchronizeIndivdualRankingSet(url, tourId, roundId, i, ranking_set);
            }
        }

        for (int i = 0; i < mTournament.getPoolCount(); i++) {
            Pool p = mTournament.getPool(i);

            TeamRankingsSet rankingSet = mTournament.getRound(roundId).getRankings(false).getPoolTeamRankings().get(p);

            if (!error) {
                error = synchronizeTeamRankingSet(url, tourId, roundId, i, rankingSet);
            }
        }
        return error;
    }

    private boolean synchronizeRankings(String url, long tourId, int roundId) throws IOException {

        Rankings rankings = mTournament.getRound(roundId).getRankings(false);

        boolean error = synchronizeIndivdualRankingSet(url, tourId, roundId, -1, mTournament.getRound(roundId).getRankings(false).getIndivRankingSet());

        if (!error) {
            error = synchronizeClanRankingSet(url, tourId, roundId);
        }

        if (!error) {
            error = synchronizeTeamRankingSet(url, tourId, roundId, -1, mTournament.getRound(roundId).getRankings(false).getTeamRankingSet());
        }

        if (!error) {
            error = synchronizeCategoryRankings(url, tourId, roundId);
        }

        if (!error) {
            error = synchronizeGroupRankings(url, tourId, roundId);
        }

        if (!error) {
            error = synchronizePoolRankings(url, tourId, roundId);
        }

        return error;
    }

    private boolean synchronizeRounds(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/rounds");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getRoundsCount() > i) {
                    if (dt.isAfter(mTournament.getRound(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                    if (dt.isBefore(mTournament.getRound(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                } else {
                    mTournament.addRound(new Round(i, mTournament));
                    toDownload = true;
                }
            }

            if (toUpload) {
                JSONObject obj2 = mTournament.getRound(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/rounds/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing rounds " + i + ": " + result);
                    error = true;
                }

                synchronizeMatchs(url, tourId, i);
                synchronizeRankings(url, tourId, i);
            }

            if (toDownload) {
                mTournament.getRound(i).updateFromJSON(obj);
                synchronizeMatchs(url, tourId, i);
                synchronizeRankings(url, tourId, i);
            }
        }

        int diff = mTournament.getRoundsCount() - array.length();
        for (int i = 0; i < diff; i++) {
            JSONObject obj2 = mTournament.getRound(array.length() + i).getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/rounds", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing rounds: " + result);
                error = true;
            }
        }
        return error;
    }

    private boolean synchronizeClans(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/clans");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getClansCount() > i) {
                    if (dt.isAfter(mTournament.getClan(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                    if (dt.isBefore(mTournament.getClan(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                } else {
                    mTournament.addClan(new Clan(obj.getString("name")));
                    toDownload = true;
                }
            }

            if (toUpload) {

                JSONObject obj2 = mTournament.getClan(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/clans/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing categories: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                mTournament.getClan(i).updateFromJSON(obj);
            }
        }

        int diff = mTournament.getClansCount() - array.length();
        for (int i = 0; i < diff; i++) {
            JSONObject obj2 = mTournament.getClan(array.length() + i).getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/categories", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                error = true;
            }
        }
        return error;
    }

    private boolean synchronizeCoachs(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/coachs");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getCoachsCount() > i) {
                    if (dt.isAfter(mTournament.getCoach(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                    if (dt.isBefore(mTournament.getCoach(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                } else {
                    mTournament.addCoach(new Coach(obj.getString("name")));
                    toDownload = true;
                }
            }

            if (toUpload) {

                JSONObject obj2 = mTournament.getCoach(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/coachs/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing coachs: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                mTournament.getCoach(i).updateFromJSON(obj);
            }
        }

        int diff = mTournament.getCoachsCount() - array.length();
        for (int i = 0; i < diff; i++) {
            JSONObject obj2 = mTournament.getCoach(array.length() + i).getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/coachs", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                error = true;
            }
        }
        return error;
    }

    private boolean synchronizeTeams(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/teams");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getTeamsCount() > i) {
                    if (dt.isAfter(mTournament.getTeam(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                    if (dt.isBefore(mTournament.getTeam(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                } else {
                    mTournament.addTeam(new Team(obj.getString("name")));
                    toDownload = true;
                }
            }

            if (toUpload) {

                JSONObject obj2 = mTournament.getTeam(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/teams/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing coachs: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                mTournament.getTeam(i).updateFromJSON(obj);
            }
        }

        int diff = mTournament.getTeamsCount() - array.length();
        for (int i = 0; i < diff; i++) {
            JSONObject obj2 = mTournament.getTeam(array.length() + i).getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/teams", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                error = true;
            }
        }
        return error;
    }

    private boolean synchronizeGroups(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/groups");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getGroupsCount() > i) {
                    if (dt.isAfter(mTournament.getGroup(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                    if (dt.isBefore(mTournament.getGroup(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                } else {
                    mTournament.addGroup(new Group(obj.getString("name")));
                    toDownload = true;
                }
            }

            if (toUpload) {

                JSONObject obj2 = mTournament.getGroup(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/groups/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                mTournament.getGroup(i).updateFromJSON(obj);
            }
        }

        int diff = mTournament.getGroupsCount() - array.length();
        for (int i = 0; i < diff; i++) {
            JSONObject obj2 = mTournament.getGroup(array.length() + i).getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/groups", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                error = true;
            }

        }

        if (!error) {
            // Synchronize group opposing points
            for (int i = 0; i < mTournament.getGroupsCount(); i++) {
                for (int j = 0; j < mTournament.getGroupsCount(); j++) {
                    if (i != j) {
                        error = synchronizeGroupOpposingPoints(url, tourId, i, j);
                        if (error) {
                            break;
                        }
                    }
                }
            }
        }

        return error;
    }

    private boolean synchronizeCriteria(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/params/criteria");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getParams().getCriteriaCount() > i) {
                    if (dt.isAfter(mTournament.getParams().getCriterion(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                    if (dt.isBefore(mTournament.getParams().getCriterion(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                } else {
                    mTournament.getParams().addCriteria(new Criterion("new_" + i));
                    toDownload = true;
                }
            }

            if (toUpload) {
                JSONObject obj2 = mTournament.getParams().getCriterion(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/params/criterion/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                mTournament.getParams().getCriterion(i).updateFromJSON(obj);
            }
        }

        int diff = mTournament.getParams().getCriteriaCount() - array.length();
        while (diff > 0) {
            JSONObject obj2 = mTournament.getParams().getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/params/criterion", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                error = true;
            }

            diff--;
        }
        return error;
    }

    private boolean synchronizeFormula(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/params/formulas");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getParams().getFormulaCount() > i) {
                    if (dt.isAfter(mTournament.getParams().getFormula(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                    if (dt.isBefore(mTournament.getParams().getFormula(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                } else {
                    mTournament.getParams().addFormula(new Formula("new_" + i));
                    toDownload = true;
                }
            }

            if (toUpload) {

                JSONObject obj2 = mTournament.getParams().getFormula(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/params/formula/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing formula: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                mTournament.getParams().getFormula(i).updateFromJSON(obj);
            }
        }

        int diff = mTournament.getParams().getFormulaCount() - array.length();
        while (diff > 0) {
            JSONObject obj2 = mTournament.getParams().getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/params/formula", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing formula: " + result);
                error = true;
            }

            diff--;
        }
        return error;
    }

    private boolean synchronizeTournament(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId);

        boolean error = false;

        JSONObject obj = new JSONObject(lineGet);
        boolean toUpload = false;
        boolean toDownload = false;
        Object lastUpdatedDate = obj.get("updateDateTime");
        if (lastUpdatedDate == JSONObject.NULL) {
            toUpload = true;
        } else {
            LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
            if (dt.isAfter(mTournament.getUpdateDateTime())) {
                toDownload = true;
            }
            if (dt.isBefore(mTournament.getUpdateDateTime())) {
                toUpload = true;
            }
        }

        // Check date 
        if (toUpload) {
            JSONObject obj2 = mTournament.getJSON();
            int result = methodPATCH(url + "/tournaments/" + mTournament.getTournament_id(), obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing tournament: " + result);
                error = true;
            }
        } else {

            if (toDownload) {
                mTournament.updateFromJSON(obj);
            }
        }

        if (!error) {
            error = synchronizeParams(url, tourId);
        }

        
        // Download Rosters
        // If needed update Rosters    
        if (!error) {
            error = synchronizeRosters(url, tourId);
        }

        // Download Groups
        // If needed update Groups
        if (!error) {
            error = synchronizeGroups(url, tourId);
        }
/*
        // Download Categories
        // If needed update Categories
        if (!error) {
            error = synchronizeCategories(url, tourId);
        }

        // Download Clans
        // If needed update Clans
        if (!error) {
            error = synchronizeClans(url, tourId);
        }

        // Download Coachs
        // If needed update Coachs
        if (!error) {
            error = synchronizeCoachs(url, tourId);
        }

        // Download Teams
        // If needed update Teams
        if (!error) {
            error = synchronizeTeams(url, tourId);
        }

        // Downloads Rounds
        // If needed update Rounds
        if (!error) {
            error = synchronizeRounds(url, tourId);
        }
*/
        return error;

    }

    private void jbtSyncActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbtSyncActionPerformed

        jbtOK.setEnabled(false);
        try {
            String url = mTournament.getURL();
            if (!url.startsWith("https://")) {
                if (url.startsWith("http://")) {
                    url = url.replace("http://", "https://");
                } else {
                    url = "https://" + url;
                }
            }
            url = "https://localhost:443";
            mTournament.setTournament_id(158916);

            synchronizeTournament(url, mTournament.getTournament_id());

        } catch (FileNotFoundException ex) {
            Logger.getLogger(JdgSynchronizeWithServer.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(JdgSynchronizeWithServer.class.getName()).log(Level.SEVERE, null, ex);
        }
        jbtOK.setEnabled(true);
    }//GEN-LAST:event_jbtSyncActionPerformed

    private void jtfTournamentIdActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jtfTournamentIdActionPerformed
        if (mTournament != null) {
            mTournament.setTournament_id(Long.parseLong(jtfTournamentId.getText()));
            update();
        }
    }//GEN-LAST:event_jtfTournamentIdActionPerformed

    private void jtfLoginActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jtfLoginActionPerformed
        if (mTournament != null) {
            mTournament.setLogin(jtfLogin.getText());

            update();
        }
    }//GEN-LAST:event_jtfLoginActionPerformed

    private void JpfPasswordActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_JpfPasswordActionPerformed
        if (mTournament != null) {
            mTournament.setPassword(new String(JpfPassword.getPassword()));
            update();
        }
    }//GEN-LAST:event_JpfPasswordActionPerformed

    private void jtfUrlActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jtfUrlActionPerformed
        if (mTournament != null) {
            mTournament.setURL(jtfUrl.getText());
            update();
        }
    }//GEN-LAST:event_jtfUrlActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPasswordField JpfPassword;
    private javax.swing.ButtonGroup bgAutoUpdate;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JButton jbtOK;
    private javax.swing.JButton jbtSync;
    private javax.swing.JCheckBox jcxAutomatic;
    private javax.swing.JRadioButton jrbEventUpdate;
    private javax.swing.JRadioButton jrbPeriodicUpdate;
    private javax.swing.JTextField jtfLogin;
    private javax.swing.JTextField jtfTournamentId;
    private javax.swing.JTextField jtfUrl;
    // End of variables declaration//GEN-END:variables
}
