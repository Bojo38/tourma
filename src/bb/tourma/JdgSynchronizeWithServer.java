/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package bb.tourma;

import bb.tourma.data.Category;
import bb.tourma.data.Clan;
import bb.tourma.data.Coach;
import bb.tourma.data.Criterion;
import bb.tourma.data.Formula;
import bb.tourma.data.Group;
import bb.tourma.data.GroupPoints;
import bb.tourma.data.RosterType;
import bb.tourma.data.Team;
import bb.tourma.data.Tournament;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.ProtocolException;
import java.net.URL;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.time.LocalDateTime;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import javax.swing.JOptionPane;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.net.HttpURLConnection;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.Set;
import org.json.JSONArray;
import org.json.JSONObject;
import org.json.JSONWriter;

/**
 *
 * @author WFMJ7631
 */
public class JdgSynchronizeWithServer extends javax.swing.JDialog {

    Tournament mTournament;

    /**
     * Creates new form JdgSynchronizeWithServer
     */
    public JdgSynchronizeWithServer(java.awt.Frame parent, boolean modal, final Tournament tour) {
        super(parent, modal);
        initComponents();

        mTournament = tour;

        this.update();
    }

    private void update() {
        this.JpfPassword.setText(mTournament.getPassword());
        this.jtfLogin.setText(mTournament.getLogin());
        this.jtfUrl.setText(mTournament.getURL());
        this.jtfTournamentId.setText(Long.toString(mTournament.getTournament_id()));

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        bgAutoUpdate = new javax.swing.ButtonGroup();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jtfTournamentId = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jtfLogin = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        JpfPassword = new javax.swing.JPasswordField();
        jLabel4 = new javax.swing.JLabel();
        jtfUrl = new javax.swing.JTextField();
        jPanel3 = new javax.swing.JPanel();
        jPanel4 = new javax.swing.JPanel();
        jbtSync = new javax.swing.JButton();
        jPanel5 = new javax.swing.JPanel();
        jrbPeriodicUpdate = new javax.swing.JRadioButton();
        jrbEventUpdate = new javax.swing.JRadioButton();
        jPanel6 = new javax.swing.JPanel();
        jcxAutomatic = new javax.swing.JCheckBox();
        jPanel2 = new javax.swing.JPanel();
        jbtOK = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        jPanel1.setLayout(new java.awt.GridLayout(5, 2));

        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("bb/tourma/languages/language"); // NOI18N
        jLabel1.setText(bundle.getString("TournamentID")); // NOI18N
        jPanel1.add(jLabel1);

        jtfTournamentId.setText("1234");
        jtfTournamentId.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jtfTournamentIdActionPerformed(evt);
            }
        });
        jPanel1.add(jtfTournamentId);

        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        jLabel2.setText(bundle.getString("login")); // NOI18N
        jPanel1.add(jLabel2);

        jtfLogin.setText("lord_bojo");
        jtfLogin.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jtfLoginActionPerformed(evt);
            }
        });
        jPanel1.add(jtfLogin);

        jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        jLabel3.setText(bundle.getString("password")); // NOI18N
        jPanel1.add(jLabel3);

        JpfPassword.setText("7539");
        JpfPassword.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                JpfPasswordActionPerformed(evt);
            }
        });
        jPanel1.add(JpfPassword);

        jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        jLabel4.setText(bundle.getString("URL")); // NOI18N
        jPanel1.add(jLabel4);

        jtfUrl.setText("http://192.168.1.100:443");
        jtfUrl.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jtfUrlActionPerformed(evt);
            }
        });
        jPanel1.add(jtfUrl);

        getContentPane().add(jPanel1, java.awt.BorderLayout.PAGE_START);

        jPanel3.setLayout(new java.awt.BorderLayout());

        jPanel4.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jbtSync.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bb/tourma/images/reload.png"))); // NOI18N
        jbtSync.setText(bundle.getString("Synchronize")); // NOI18N
        jbtSync.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbtSyncActionPerformed(evt);
            }
        });
        jPanel4.add(jbtSync);

        jPanel3.add(jPanel4, java.awt.BorderLayout.SOUTH);

        jPanel5.setBorder(javax.swing.BorderFactory.createTitledBorder(bundle.getString("Update Types"))); // NOI18N
        jPanel5.setEnabled(false);
        jPanel5.setLayout(new java.awt.GridLayout(1, 2));

        jrbPeriodicUpdate.setText(bundle.getString("Periodic Update")); // NOI18N
        jrbPeriodicUpdate.setToolTipText("Update every 5 minutes");
        jrbPeriodicUpdate.setEnabled(false);
        jPanel5.add(jrbPeriodicUpdate);

        jrbEventUpdate.setText(bundle.getString("EventUpdate")); // NOI18N
        jrbEventUpdate.setToolTipText("Update from PC after each local modification (enter match, change setting, generate round) and read from internet every minute.");
        jrbEventUpdate.setEnabled(false);
        jPanel5.add(jrbEventUpdate);

        jPanel3.add(jPanel5, java.awt.BorderLayout.CENTER);

        jcxAutomatic.setText(bundle.getString("AutomaticRefresh")); // NOI18N
        jcxAutomatic.setEnabled(false);
        jPanel6.add(jcxAutomatic);

        jPanel3.add(jPanel6, java.awt.BorderLayout.NORTH);

        getContentPane().add(jPanel3, java.awt.BorderLayout.CENTER);

        jbtOK.setText("OK");
        jbtOK.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jbtOKActionPerformed(evt);
            }
        });
        jPanel2.add(jbtOK);

        getContentPane().add(jPanel2, java.awt.BorderLayout.SOUTH);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jbtOKActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbtOKActionPerformed
        this.setVisible(false);
    }//GEN-LAST:event_jbtOKActionPerformed

    private SSLContext getSSLContext() {
        TrustManager[] trustAllCerts = new TrustManager[]{
            new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                    return null;
                }

                @Override
                public void checkClientTrusted(X509Certificate[] arg0, String arg1)
                        throws CertificateException {
                }

                @Override
                public void checkServerTrusted(X509Certificate[] arg0, String arg1)
                        throws CertificateException {
                }
            }
        };

        SSLContext sslContext = null;
        try {
            sslContext = SSLContext.getInstance("SSL");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        try {
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
        } catch (KeyManagementException e) {
            e.printStackTrace();
        }
        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());

        // Create all-trusting host name verifier
        HostnameVerifier validHosts = new HostnameVerifier() {
            @Override
            public boolean verify(String arg0, SSLSession arg1) {
                return true;
            }
        };
        // All hosts will be valid
        HttpsURLConnection.setDefaultHostnameVerifier(validHosts);

        return sslContext;
    }

    public static void allowMethods(String... methods) {
        try {
            Field methodsField = HttpURLConnection.class.getDeclaredField("methods");

            Field modifiersField = Field.class.getDeclaredField("modifiers");
            modifiersField.setAccessible(true);
            modifiersField.setInt(methodsField, methodsField.getModifiers() & ~Modifier.FINAL);

            methodsField.setAccessible(true);

            String[] oldMethods = (String[]) methodsField.get(null);
            Set<String> methodsSet = new LinkedHashSet<>(Arrays.asList(oldMethods));
            methodsSet.addAll(Arrays.asList(methods));
            String[] newMethods = methodsSet.toArray(new String[0]);

            methodsField.set(null/*static field*/, newMethods);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            throw new IllegalStateException(e);
        }
    }

    String methodGET(String url) throws IOException {
        String inline = "";

        SSLContext sslContext = getSSLContext();
        HttpsURLConnection connection = (HttpsURLConnection) new URL(url).openConnection();
        connection.setSSLSocketFactory(sslContext.getSocketFactory());

        connection.setRequestMethod("GET");
        connection.connect();
        //Getting the response code
        int responsecode = connection.getResponseCode();
        if (responsecode != 200) {
            JOptionPane.showMessageDialog(this, "HTTP error: " + responsecode, "Io Error", JOptionPane.ERROR_MESSAGE);
        } else {
            System.out.println("Response to request: " + url);
            Scanner sc = new Scanner(connection.getInputStream());

            while (sc.hasNext()) {
                inline += sc.nextLine();
            }
            System.out.println(inline);
            sc.close();
        }
        return inline;
    }

    public int methodPOST(String url, JSONObject object) throws IOException {
        int result = 0;

        SSLContext sslContext = getSSLContext();
        HttpsURLConnection connection = (HttpsURLConnection) new URL(url).openConnection();
        connection.setSSLSocketFactory(sslContext.getSocketFactory());

        connection.setRequestMethod("POST");
        connection.setRequestProperty("Content-Type", "application/json; utf-8");
        connection.setRequestProperty("Accept", "application/json");

        connection.setDoOutput(true);

        try (OutputStream os = connection.getOutputStream()) {
            String written = JSONWriter.valueToString(object);
            byte[] input = written.getBytes("utf-8");
            System.out.println(written);
            os.write(input, 0, input.length);
        }

        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
            System.out.println("Response to Patch: " + url);
            try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    System.out.println(line);
                }
            }
        } else {
            System.out.println(connection.getResponseCode());
        }

        connection.connect();
        return result;
    }

    public int methodPATCH(String url, JSONObject object) throws IOException {
        int result = 0;

        SSLContext sslContext = getSSLContext();
        HttpsURLConnection connection = (HttpsURLConnection) new URL(url).openConnection();
        connection.setSSLSocketFactory(sslContext.getSocketFactory());

        //connection.setRequestProperty("X-HTTP-Method-Override", "PATCH");
        connection.setRequestMethod("PATCH");
        connection.setRequestProperty("Content-Type", "application/json; utf-8");
        connection.setRequestProperty("Accept", "application/json");

        connection.setDoOutput(true);

        try (OutputStream os = connection.getOutputStream()) {
            String written = JSONWriter.valueToString(object);
            byte[] input = written.getBytes("utf-8");
            System.out.println(written);
            os.write(input, 0, input.length);
        }

        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
            System.out.println("Response to Patch: " + url);
            try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    System.out.println(line);
                }
            }
        } else {
            System.out.println(connection.getResponseCode());
        }

        connection.connect();
        return result;
    }

    private boolean synchronizeGroupOpposingPoints(String url, long tourId, int gid, int oid) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/groups/" + gid + "/" + oid);

        boolean error = false;

        Group group = mTournament.getGroup(gid);
        Group opp = mTournament.getGroup(oid);
        GroupPoints gp = group.getOpponentModificationPoints(opp);

        // Download Params
        JSONObject obj = new JSONObject(lineGet);
        boolean toUpload = false;
        boolean toDownload = false;
        Object lastUpdatedDate = obj.get("updateDateTime");
        if (lastUpdatedDate == JSONObject.NULL) {
            toUpload = true;
        } else {
            LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
            if (dt.isAfter(gp.getUpdateDateTime())) {
                toUpload = true;
            }
            if (dt.isBefore(gp.getUpdateDateTime())) {
                toDownload = true;
            }
        }

        // If needed update Params
        // Check date 
        if (toUpload) {
            JSONObject obj2 = gp.getJSON();
            int result = methodPATCH(url + "/tournaments/" + tourId + "/groups/" + gid + "/" + oid, obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing parameters: " + result);
                error = true;
            }

        } else {
            if (toDownload) {
                gp.updateFromJSON(obj);
            }

        }

        return error;
    }

    private boolean synchronizeParams(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/params");

        boolean error = false;

        // Download Params
        JSONObject obj = new JSONObject(lineGet);
        boolean toUpload = false;
        boolean toDownload = false;
        Object lastUpdatedDate = obj.get("updateDateTime");
        if (lastUpdatedDate == JSONObject.NULL) {
            toUpload = true;
        } else {
            LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
            if (dt.isAfter(mTournament.getParams().getUpdateDateTime())) {
                toUpload = true;
            }
            if (dt.isBefore(mTournament.getParams().getUpdateDateTime())) {
                toDownload = true;
            }
        }

        // If needed update Params
        // Check date 
        if (toUpload) {
            JSONObject obj2 = mTournament.getParams().getJSON();
            int result = methodPATCH(url + "/tournaments/" + tourId + "/params", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing parameters: " + result);
                error = true;
            }

        } else {
            if (toDownload) {
                mTournament.getParams().updateFromJSON(obj);
            }

        }

        if (!error) {
            error = synchronizeCriteria(url, tourId);
            if (!error) {
                error = synchronizeFormula(url, tourId);
            }
        }

        return error;
    }

    private boolean synchronizeRosters(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/rosters");

        boolean error = false;

        // Download Array of rosters
        JSONArray array = new JSONArray(lineGet);

        RosterType[] rts = (RosterType[]) mTournament.getRosterType().entrySet().toArray();

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");

            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getRosterType().size() > i) {
                    if (dt.isAfter(rts[i].getUpdateDateTime())) {
                        toUpload = true;
                    }
                    if (dt.isBefore(rts[i].getUpdateDateTime())) {
                        toDownload = true;
                    }
                } else {
                    mTournament.getRosterType().put(obj.getString("name"), new RosterType("new"));
                    toDownload = true;
                }
            }

            if (toUpload) {
                JSONObject obj2 = rts[i].getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/rosters/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing rosters: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                rts[i].updateFromJSON(obj);
            }
        }

        int diff = mTournament.getRosterType().size() - array.length();
        for (int i = 0; i < diff; i++) {
            JSONObject obj2 = rts[array.length() + i].getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/rosters", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing rosters: " + result);
                error = true;
            }
        }

        return error;
    }

    private boolean synchronizeCategories(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/categories");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getCategoriesCount() > i) {
                    if (dt.isAfter(mTournament.getCategory(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                    if (dt.isBefore(mTournament.getCategory(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                } else {
                    mTournament.addCategory(new Category(obj.getString("name")));
                    toDownload = true;
                }
            }

            if (toUpload) {

                JSONObject obj2 = mTournament.getCategory(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/categories/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing categories: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                mTournament.getCategory(i).updateFromJSON(obj);
            }
        }

        int diff = mTournament.getCategoriesCount() - array.length();
        for (int i = 0; i < diff; i++) {
            JSONObject obj2 = mTournament.getCategory(array.length() + i).getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/categories", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                error = true;
            }

        }

        return error;
    }
    
    private boolean synchronizeClans(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/clans");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getClansCount()> i) {
                    if (dt.isAfter(mTournament.getClan(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                    if (dt.isBefore(mTournament.getClan(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                } else {
                    mTournament.addClan(new Clan(obj.getString("name")));
                    toDownload = true;
                }
            }

            if (toUpload) {

                JSONObject obj2 = mTournament.getClan(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/clans/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing categories: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                mTournament.getClan(i).updateFromJSON(obj);
            }
        }

        int diff = mTournament.getClansCount()- array.length();
        for (int i = 0; i < diff; i++) {
            JSONObject obj2 = mTournament.getClan(array.length() + i).getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/categories", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                error = true;
            }
        }
        return error;
    }
    
    private boolean synchronizeCoachs(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/coachs");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getCoachsCount()> i) {
                    if (dt.isAfter(mTournament.getCoach(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                    if (dt.isBefore(mTournament.getCoach(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                } else {
                    mTournament.addCoach(new Coach(obj.getString("name")));
                    toDownload = true;
                }
            }

            if (toUpload) {

                JSONObject obj2 = mTournament.getCoach(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/coachs/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing coachs: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                mTournament.getCoach(i).updateFromJSON(obj);
            }
        }

        int diff = mTournament.getCoachsCount()- array.length();
        for (int i = 0; i < diff; i++) {
            JSONObject obj2 = mTournament.getCoach(array.length() + i).getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/coachs", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                error = true;
            }
        }
        return error;
    }
    
    private boolean synchronizeTeams(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/teams");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getTeamsCount()> i) {
                    if (dt.isAfter(mTournament.getTeam(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                    if (dt.isBefore(mTournament.getTeam(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                } else {
                    mTournament.addTeam(new Team(obj.getString("name")));
                    toDownload = true;
                }
            }

            if (toUpload) {

                JSONObject obj2 = mTournament.getTeam(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/teams/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing coachs: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                mTournament.getTeam(i).updateFromJSON(obj);
            }
        }

        int diff = mTournament.getTeamsCount()- array.length();
        for (int i = 0; i < diff; i++) {
            JSONObject obj2 = mTournament.getTeam(array.length() + i).getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/teams", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                error = true;
            }
        }
        return error;
    }

    private boolean synchronizeGroups(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/groups");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getGroupsCount() > i) {
                    if (dt.isAfter(mTournament.getGroup(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                    if (dt.isBefore(mTournament.getGroup(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                } else {
                    mTournament.addGroup(new Group(obj.getString("name")));
                    toDownload = true;
                }
            }

            if (toUpload) {

                JSONObject obj2 = mTournament.getGroup(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/group/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                mTournament.getGroup(i).updateFromJSON(obj);
            }
        }

        int diff = mTournament.getGroupsCount() - array.length();
        for (int i = 0; i < diff; i++) {
            JSONObject obj2 = mTournament.getGroup(array.length() + i).getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/group", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                error = true;
            }

        }

        if (!error) {
            // Synchronize group opposing points
            for (int i = 0; i < mTournament.getGroupsCount(); i++) {
                for (int j = 0; j < mTournament.getGroupsCount(); j++) {
                    if (i != j) {
                        error = synchronizeGroupOpposingPoints(url, tourId, i, j);
                        if (error) {
                            break;
                        }
                    }
                }
            }
        }

        return error;
    }

    private boolean synchronizeCriteria(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/params/criteria");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getParams().getCriteriaCount() > i) {
                    if (dt.isAfter(mTournament.getParams().getCriterion(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                    if (dt.isBefore(mTournament.getParams().getCriterion(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                } else {
                    mTournament.getParams().addCriteria(new Criterion("new_" + i));
                    toDownload = true;
                }
            }

            if (toUpload) {

                JSONObject obj2 = mTournament.getParams().getCriterion(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/params/criterion/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                mTournament.getParams().getCriterion(i).updateFromJSON(obj);
            }
        }

        int diff = mTournament.getParams().getCriteriaCount() - array.length();
        while (diff > 0) {
            JSONObject obj2 = mTournament.getParams().getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/params/criterion", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing criteria: " + result);
                error = true;
            }

            diff--;
        }
        return error;
    }

    private boolean synchronizeFormula(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId + "/params/formula");

        boolean error = false;
        JSONArray array = new JSONArray(lineGet);

        for (int i = 0; i < array.length(); i++) {
            JSONObject obj = array.getJSONObject(i);

            boolean toUpload = false;
            boolean toDownload = false;
            Object lastUpdatedDate = obj.get("updateDateTime");
            if (lastUpdatedDate == JSONObject.NULL) {
                toUpload = true;
            } else {
                LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
                if (mTournament.getParams().getFormulaCount() > i) {
                    if (dt.isAfter(mTournament.getParams().getFormula(i).getUpdateDateTime())) {
                        toUpload = true;
                    }
                    if (dt.isBefore(mTournament.getParams().getFormula(i).getUpdateDateTime())) {
                        toDownload = true;
                    }
                } else {
                    mTournament.getParams().addFormula(new Formula("new_" + i));
                    toDownload = true;
                }
            }

            if (toUpload) {

                JSONObject obj2 = mTournament.getParams().getFormula(i).getJSON();
                int result = methodPATCH(url + "/tournaments/" + tourId + "/params/formula/" + i, obj2);
                if (result != 0) {
                    JOptionPane.showMessageDialog(this, "Error detected while synchronizing formula: " + result);
                    error = true;
                }
            }

            if (toDownload) {
                mTournament.getParams().getFormula(i).updateFromJSON(obj);
            }
        }

        int diff = mTournament.getParams().getFormulaCount() - array.length();
        while (diff > 0) {
            JSONObject obj2 = mTournament.getParams().getJSON();
            int result = methodPOST(url + "/tournaments/" + tourId + "/params/formula", obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing formula: " + result);
                error = true;
            }

            diff--;
        }
        return error;
    }

    private void synchronizeTournament(String url, long tourId) throws IOException {
        String lineGet = methodGET(url + "/tournaments/" + tourId);

        boolean error = false;

        JSONObject obj = new JSONObject(lineGet);
        boolean toUpload = false;
        boolean toDownload = false;
        Object lastUpdatedDate = obj.get("updateDateTime");
        if (lastUpdatedDate == JSONObject.NULL) {
            toUpload = true;
        } else {
            LocalDateTime dt = LocalDateTime.parse((String) lastUpdatedDate);
            if (dt.isAfter(mTournament.getUpdateDateTime())) {
                toUpload = true;
            }
            if (dt.isBefore(mTournament.getUpdateDateTime())) {
                toDownload = true;
            }
        }

        // Check date 
        if (toUpload) {
            JSONObject obj2 = mTournament.getJSON();
            int result = methodPATCH(url + "/tournaments/" + mTournament.getTournament_id(), obj2);
            if (result != 0) {
                JOptionPane.showMessageDialog(this, "Error detected while synchronizing tournament: " + result);
                error = true;
            }
        } else {

            if (toDownload) {
                mTournament.updateFromJSON(obj);
            }
        }

        if (!error) {
            error = synchronizeParams(url, tourId);
        }

        // Download Rosters
        // If needed update Rosters    
        if (!error) {
            error = synchronizeRosters(url, tourId);
        }

        // Download Groups
        // If needed update Groups
        if (!error) {
            error = synchronizeGroups(url, tourId);
        }

        // Download Categories
        // If needed update Categories
        if (!error) {
            error = synchronizeCategories(url, tourId);
        }

        // Download Clans
        // If needed update Clans
        if (!error) {
            error = synchronizeClans(url, tourId);
        }

        // Download Coachs
        // If needed update Coachs
        if (!error) {
            error = synchronizeCoachs(url, tourId);
        }
        
        // Download Teams
        // If needed update Teams
        if (!error) {
            error = synchronizeTeams(url, tourId);
        }
        
        // Downloads Rounds
        // If needed update Rounds
        
            // Downloads Matchs
            // If needed update Matchs

            // Downloads Rankings ?
            // If needed update Ranking
    }

    private void jbtSyncActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jbtSyncActionPerformed

        try {
            String url = mTournament.getURL();
            if (!url.startsWith("https://")) {
                if (url.startsWith("http://")) {
                    url = url.replace("http://", "https://");
                } else {
                    url = "https://" + url;
                }
            }
            url = "https://localhost:443";
            mTournament.setTournament_id(62257);

            synchronizeTournament(url, mTournament.getTournament_id());

        } catch (FileNotFoundException ex) {
            Logger.getLogger(JdgSynchronizeWithServer.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(JdgSynchronizeWithServer.class.getName()).log(Level.SEVERE, null, ex);
        }

    }//GEN-LAST:event_jbtSyncActionPerformed

    private void jtfTournamentIdActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jtfTournamentIdActionPerformed
        if (mTournament != null) {
            mTournament.setTournament_id(Long.parseLong(jtfTournamentId.getText()));
            update();
        }
    }//GEN-LAST:event_jtfTournamentIdActionPerformed

    private void jtfLoginActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jtfLoginActionPerformed
        if (mTournament != null) {
            mTournament.setLogin(jtfLogin.getText());

            update();
        }
    }//GEN-LAST:event_jtfLoginActionPerformed

    private void JpfPasswordActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_JpfPasswordActionPerformed
        if (mTournament != null) {
            mTournament.setPassword(new String(JpfPassword.getPassword()));
            update();
        }
    }//GEN-LAST:event_JpfPasswordActionPerformed

    private void jtfUrlActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jtfUrlActionPerformed
        if (mTournament != null) {
            mTournament.setURL(jtfUrl.getText());
            update();
        }
    }//GEN-LAST:event_jtfUrlActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPasswordField JpfPassword;
    private javax.swing.ButtonGroup bgAutoUpdate;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JButton jbtOK;
    private javax.swing.JButton jbtSync;
    private javax.swing.JCheckBox jcxAutomatic;
    private javax.swing.JRadioButton jrbEventUpdate;
    private javax.swing.JRadioButton jrbPeriodicUpdate;
    private javax.swing.JTextField jtfLogin;
    private javax.swing.JTextField jtfTournamentId;
    private javax.swing.JTextField jtfUrl;
    // End of variables declaration//GEN-END:variables
}
